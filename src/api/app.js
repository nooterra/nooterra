import crypto from "node:crypto";

import { createStore } from "./store.js";
import { readJsonBody, readRawBody, sendError, sendJson, sendText } from "./http.js";
import { createId } from "../core/ids.js";
import { appendChainedEvent, createChainedEvent, verifyChainedEvents } from "../core/event-chain.js";
import { keyIdFromPublicKeyPem, sha256Hex, signHashHexEd25519, verifyHashHexEd25519 } from "../core/crypto.js";
import { listKnownEventTypes, requiredSignerKindForEventType, SIGNER_KIND } from "../core/event-policy.js";
import { canonicalJsonStringify, normalizeForCanonicalJson } from "../core/canonical-json.js";
import { computeToolProviderSignaturePayloadHashV1, verifyToolProviderSignatureV1 } from "../core/tool-provider-signature.js";
import { reduceJob } from "../core/job-reducer.js";
import { ledgerEntriesForJobEvent } from "../core/ledger-postings.js";
import { makeIdempotencyEndpoint, makeIdempotencyStoreKey, normalizePrincipalId } from "../core/idempotency.js";
import { authKeyId, authKeySecret, hashAuthKeySecret, normalizeAuthKeyStatus, normalizeScopes } from "../core/auth.js";
import { isWithinAccessWindow, validateAccessPlanIssuedPayload, validateAccessResultPayload, validateAccessRevokedPayload } from "../core/access.js";
import { validateSkillLicensedPayload, validateSkillUsedPayload } from "../core/skills.js";
import { validateIncidentDetectedPayload, validateIncidentReportedPayload } from "../core/incidents.js";
import { validateEvidenceCapturedPayload, validateEvidenceExpiredPayload, validateEvidenceViewedPayload } from "../core/evidence.js";
import { validateZoneCoverageReportedPayload } from "../core/zone-coverage.js";
import { validateProofEvaluatedPayload } from "../core/proof-events.js";
import { verifyZoneCoverageProofV1 } from "../core/proof-verifier.js";
import { computeZoneSetHash, validateZoneSetV1 } from "../core/zoneset.js";
import {
  computeClaimTotalCents,
  validateClaimApprovedPayload,
  validateClaimDeniedPayload,
  validateClaimOpenedPayload,
  validateClaimPaidPayload,
  validateClaimTriagedPayload,
  validateJobAdjustedPayload
} from "../core/claims.js";
import { reduceRobot } from "../core/robot-reducer.js";
import { reduceOperator } from "../core/operator-reducer.js";
import { validateRobotAvailabilitySetPayload, validateRobotStatusChangedPayload } from "../core/robots.js";
import {
  validateMaintenanceCompletedPayload,
  validateMaintenanceRequestedPayload,
  validateRobotQuarantineClearedPayload,
  validateRobotQuarantinedPayload,
  validateRobotUnhealthyPayload
} from "../core/robot-health.js";
import { validateOperatorShiftClosedPayload, validateOperatorShiftOpenedPayload } from "../core/operators.js";
import {
  ENV_TIER,
  validateBookedPayload,
  validateBookingWindowInput,
  validateReservedPayload,
  windowsOverlap as bookingWindowsOverlap
} from "../core/booking.js";
import { robotIsAvailableForWindow } from "../core/robots.js";
import { computeQuote } from "../core/pricing.js";
import { selectRobotForJob } from "../core/dispatch.js";
import {
  computeLivenessPolicy,
  validateJobExecutionAbortedPayload,
  validateJobExecutionCompletedPayload,
  validateJobExecutionResumedPayload,
  validateJobExecutionStartedPayload,
  validateJobExecutionStalledPayload,
  validateJobHeartbeatPayload
} from "../core/liveness.js";
import { validateJobRescheduledPayload } from "../core/rescheduling.js";
import { validateJobCancelledPayload } from "../core/cancellation.js";
import { normalizeZoneId } from "../core/zones.js";
import { computeSlaPolicy } from "../core/sla.js";
import { SLA_POLICY_TEMPLATE_CATALOG_VERSION, listSlaPolicyTemplates } from "../core/sla-policy-templates.js";
import { getPilotTemplate, listPilotTemplates } from "../core/pilot-templates.js";
import {
  AGENT_RUN_EVENT_SCHEMA_VERSION,
  AGENT_RUN_EVENT_TYPE,
  AGENT_RUN_STATUS,
  computeAgentRunVerification,
  reduceAgentRun,
  validateEvidenceAddedPayload,
  validateRunCompletedPayload,
  validateRunCreatedPayload,
  validateRunFailedPayload,
  validateRunHeartbeatPayload,
  validateRunStartedPayload
} from "../core/agent-runs.js";
import {
  AGENT_RUN_SETTLEMENT_DISPUTE_STATUS,
  AGENT_RUN_SETTLEMENT_DISPUTE_PRIORITY,
  AGENT_RUN_SETTLEMENT_DISPUTE_CHANNEL,
  AGENT_RUN_SETTLEMENT_DISPUTE_ESCALATION_LEVEL,
  AGENT_RUN_SETTLEMENT_DECISION_MODE,
  AGENT_RUN_SETTLEMENT_DECISION_STATUS,
  AGENT_RUN_SETTLEMENT_STATUS,
  createAgentRunSettlement,
  createAgentWallet,
  creditAgentWallet,
  ensureAgentWallet,
  lockAgentWalletEscrow,
  refundReleasedAgentRunSettlement,
  refundAgentWalletEscrow,
  releaseAgentWalletEscrowToPayee,
  resolveAgentRunSettlement,
  transferAgentWalletAvailable,
  patchAgentRunSettlementDisputeContext,
  updateAgentRunSettlementDecision,
  updateAgentRunSettlementDispute,
  validateAgentRunSettlementRequest
} from "../core/agent-wallets.js";
import { buildFundingHoldV1, FUNDING_HOLD_STATUS, resolveFundingHoldV1, validateFundingHoldV1 } from "../core/funding-hold.js";
import { buildSettlementAdjustmentV1, SETTLEMENT_ADJUSTMENT_KIND, validateSettlementAdjustmentV1 } from "../core/settlement-adjustment.js";
import {
  AGREEMENT_DELEGATION_SCHEMA_VERSION,
  buildAgreementDelegationV1,
  cascadeSettlementCheck,
  refundUnwindCheck,
  resolveAgreementDelegationV1,
  validateAgreementDelegationV1
} from "../core/agreement-delegation.js";
import {
  DISPUTE_OPEN_ENVELOPE_SCHEMA_VERSION,
  validateDisputeOpenEnvelopeV1
} from "../core/dispute-open-envelope.js";
import { buildSettldAgentCard } from "../core/agent-card.js";
import { buildX402SettlementTerms, parseX402PaymentRequired } from "../core/x402-gate.js";
import { createCircleReserveAdapter } from "../core/circle-reserve-adapter.js";
import { verifyX402ReversalCommandV1 } from "../core/x402-reversal-command.js";
import { verifyX402ProviderRefundDecisionV1 } from "../core/x402-provider-refund-decision.js";
import {
  REPUTATION_EVENT_KIND,
  REPUTATION_EVENT_SCHEMA_VERSION,
  buildReputationEventV1,
  validateReputationEventV1
} from "../core/reputation-event.js";
import {
  AGENT_REPUTATION_WINDOW,
  computeAgentReputation,
  computeAgentReputationV2
} from "../core/agent-reputation.js";
import { normalizeInteractionDirection } from "../core/interaction-directions.js";
import {
  validateDispatchConfirmedPayload,
  validateDispatchEvaluatedPayload,
  validateDispatchFailedPayload,
  validateDispatchRequestedPayload
} from "../core/dispatch-events.js";
import { validateOperatorCoverageReleasedPayload, validateOperatorCoverageReservedPayload } from "../core/operator-coverage.js";
import {
  validateAssistAcceptedPayload,
  validateAssistAssignedPayload,
  validateAssistDeclinedPayload,
  validateAssistQueuedPayload,
  validateAssistRequestedPayload,
  validateAssistTimeoutPayload
} from "../core/assist.js";
import { computeOperatorCostCents, validateOperatorCostRecordedPayload } from "../core/operator-cost.js";
import {
  SLA_BREACH_TYPE,
  SLA_CREDIT_TRIGGER_TYPE,
  validateSlaBreachDetectedPayload,
  validateSlaCreditIssuedPayload
} from "../core/sla-events.js";
import { buildAuditExport, buildEvidenceExport } from "../core/audit-export.js";
import { DEFAULT_TENANT_ID, makeScopedKey, normalizeTenantId, parseScopedKey } from "../core/tenancy.js";
import {
  COVERAGE_FEE_MODEL,
  CREDIT_FUNDING_MODEL,
  applyContractSlaOverrides,
  createDefaultContract,
  selectBestContract,
  validateContract
} from "../core/contracts.js";
import { computeMonthlyStatement, parseYearMonth, statementToCsv } from "../core/statements.js";
import { computeGlBatchBodyV1 } from "../core/gl-batch.js";
import { computeFinanceAccountMapHash, validateFinanceAccountMapV1 } from "../core/finance-account-map.js";
import { renderJournalCsvV1 } from "../core/journal-csv.js";
import { buildEvidenceDownloadUrl, verifyEvidenceDownload } from "../core/evidence-store.js";
import { computeHoldExposureV1 } from "../core/hold-exposure.js";
import {
  ESCROW_OPERATION_TYPE,
  applyEscrowOperation,
  createEscrowLedger,
  getEscrowLedgerBalance,
  upsertEscrowLedgerWalletBalances,
  walletAvailableAccountId,
  walletEscrowAccountId
} from "../core/escrow-ledger.js";
import {
  MONEY_RAIL_DIRECTION,
  MONEY_RAIL_OPERATION_STATE,
  MONEY_RAIL_PROVIDER_EVENT_TYPE,
  createStoreBackedMoneyRailAdapter,
  createMoneyRailAdapterRegistry
} from "../core/money-rail-adapters.js";
import { buildDeterministicZipStore, sha256HexBytes } from "../core/deterministic-zip.js";
import { buildFinancePackBundleV1 } from "../core/finance-pack-bundle.js";
import { buildMonthProofBundleV1 } from "../core/proof-bundle.js";
import {
  ARTIFACT_TYPE,
  buildMonthlyStatementV1,
  buildHeldExposureRollforwardV1,
  buildEscrowNetCloseV1,
  buildPartyStatementV1,
  buildPayoutInstructionV1,
  buildJournalCsvV1,
  buildGlBatchV1,
  buildFinancePackBundlePointerV1,
  computeArtifactHash,
  hmacSignArtifact,
  sliceEventsThroughChainHash
} from "../core/artifacts.js";
import { computeArtifactVerificationStatus } from "../core/artifact-verification-status.js";
import { buildPolicySnapshot, computePolicyHash } from "../core/policy.js";
import { MONTH_CLOSE_BASIS, makeMonthCloseStreamId, reduceMonthClose, validateMonthCloseRequestedPayload, validateMonthClosedPayload, validateMonthCloseReopenedPayload } from "../core/month-close.js";
import { MONTH_CLOSE_HOLD_POLICY, normalizeMonthCloseHoldPolicy } from "../core/month-close-hold-policy.js";
import {
  GOVERNANCE_STREAM_ID,
  validateServerSignerKeyRegisteredPayload,
  validateServerSignerKeyRevokedPayload,
  validateServerSignerKeyRotatedPayload,
  validateTenantPolicyUpdatedPayload
} from "../core/governance.js";
import { computePartyStatement, computePayoutAmountCentsForStatement, jobIdFromLedgerMemo, payoutKeyFor } from "../core/party-statements.js";
import { RISK_BASIS, computeRiskAssessment, validateRiskScoredPayload } from "../core/risk.js";
import { FINANCE_STREAM_ID, validateInsurerReimbursementRecordedPayload } from "../core/insurer-reimbursements.js";
import { ledgerEntriesForFinanceEvent } from "../core/ledger-postings-finance.js";
import {
  computeVerificationMethodHash,
  computeSettlementPolicyHash,
  evaluateSettlementPolicy,
  normalizeSettlementPolicy,
  normalizeVerificationMethod
} from "../core/settlement-policy.js";
import { evaluateSettlementVerifierExecution, resolveSettlementVerifierRef } from "../core/settlement-verifier.js";
import {
  SETTLEMENT_FINALITY_STATE,
  SETTLEMENT_KERNEL_VERIFICATION_CODE,
  buildSettlementDecisionRecord,
  buildSettlementReceipt,
  extractSettlementKernelArtifacts,
  verifySettlementKernelArtifacts
} from "../core/settlement-kernel.js";
import {
  buildSettldPayPayloadV1,
  computeSettldPayTokenSha256,
  mintSettldPayTokenV1,
  parseSettldPayTokenV1
} from "../core/settld-pay-token.js";
import {
  buildX402WalletIssuerDecisionPayloadV1,
  mintX402WalletIssuerDecisionTokenV1,
  verifyX402WalletIssuerDecisionTokenV1
} from "../core/x402-wallet-issuer-decision.js";
import { buildSettldPayKeysetV1 } from "../core/settld-keys.js";
import {
  buildMarketplaceOffer,
  buildMarketplaceAcceptance
} from "../core/marketplace-kernel.js";
import { computePaidToolManifestHashV1, normalizePaidToolManifestV1 } from "../core/paid-tool-manifest.js";
import { runProviderConformanceV1 } from "../core/provider-publish-conformance.js";
import { createArtifactWorker, deriveArtifactEnqueuesFromJobEvents } from "./workers/artifacts.js";
import { createDeliveryWorker } from "./workers/deliveries.js";
import { createProofWorker, deriveProofEvalEnqueuesFromJobEvents } from "./workers/proof.js";
import { processOutbox as processInMemoryOutbox } from "./outbox.js";
import { authenticateRequest, requireScope } from "./middleware/auth.js";
import { normalizeSignerKeyPurpose, normalizeSignerKeyStatus, SIGNER_KEY_PURPOSE, SIGNER_KEY_STATUS } from "../core/signer-keys.js";
import { getLogContext, logger, withLogContext } from "../core/log.js";
import { createMetrics } from "../core/metrics.js";
import { makeOpsAuditRecord } from "../core/ops-audit.js";
import { createSecretsProvider } from "../core/secrets.js";
import { checkUrlSafety, checkUrlSafetySync } from "../core/url-safety.js";
import { clampRetentionDays, computeExpiresAtIso } from "../core/retention.js";
import { clampQuota, isQuotaExceeded } from "../core/quotas.js";
import {
  BILLING_PLAN_ID,
  computeBillingEstimate,
  getBillingPlanCatalog,
  normalizeBillingPlanId,
  normalizeBillingPlanOverrides,
  resolveBillingPlan
} from "../core/billing-plans.js";
import { buildOpenApiSpec } from "./openapi.js";
import {
  FINANCE_RECONCILE_ADVISORY_LOCK_KEY,
  MONEY_RAIL_RECONCILE_ADVISORY_LOCK_KEY,
  RETENTION_CLEANUP_ADVISORY_LOCK_KEY
} from "../core/maintenance-locks.js";
import { compareProtocolVersions, parseProtocolVersion, resolveProtocolPolicy } from "../core/protocol.js";
import {
  CONTRACT_DOCUMENT_TYPE_V1,
  contractDocumentV1FromLegacyContract,
  hashContractDocumentV1,
  validateContractDocumentV1
} from "../core/contract-document.js";
import { CONTRACT_COMPILER_ID, compileBookingPolicySnapshot, compileContractPolicyTemplate } from "../core/contract-compiler.js";
import { reconcileGlBatchAgainstPartyStatements } from "../../packages/artifact-verify/src/index.js";

export function createApi({
  store = createStore(),
  now = () => new Date().toISOString(),
  opsTokens = null,
  opsToken = null,
  exportDestinations = null,
  ingestToken = null,
  deliveryMaxAttempts = 10,
  deliveryBackoffBaseMs = 1000,
  deliveryBackoffMaxMs = 60_000,
  deliveryRandom = Math.random,
  fetchFn = null,
  rateLimitRpm = null,
  rateLimitBurst = null,
  protocol = null,
  moneyRailMode = null,
  moneyRailProviderConfigs = null,
  moneyRailDefaultProviderId = null,
  billingPlanEnforcementEnabled = null,
  billingStripeWebhookSecret = null,
  billingStripeWebhookToleranceSeconds = null,
  billingStripeCheckoutBaseUrl = null,
  billingStripePortalBaseUrl = null,
  billingStripeApiBaseUrl = null,
  billingStripeSecretKey = null,
  billingStripePriceIdBuilder = null,
  billingStripePriceIdGrowth = null,
  billingStripePriceIdEnterprise = null,
  billingStripeCheckoutSuccessUrl = null,
  billingStripeCheckoutCancelUrl = null,
  billingStripePortalReturnUrl = null,
  billingStripeRetryMaxAttempts = null,
  billingStripeRetryBaseMs = null,
  billingStripeRetryMaxMs = null,
  billingStripeCircuitFailureThreshold = null,
  billingStripeCircuitOpenMs = null,
  billingStripeFetchFn = null,
  billingStripeSyncEnabled = null,
  billingStripeSyncIntervalSeconds = null,
  billingStripeSyncBatchSize = null,
  billingStripeSyncAuditScanLimit = null,
  billingStripeSyncMaxReplayAttempts = null,
  billingStripeSyncMinRetrySeconds = null,
  billingStripeSyncMaxRetrySeconds = null,
  billingStripeSyncReplayReasons = null,
  financeReconcileEnabled = null,
  financeReconcileIntervalSeconds = null,
  financeReconcileMaxTenants = null,
  financeReconcileMaxPeriodsPerTenant = null,
  moneyRailReconcileEnabled = null,
  moneyRailReconcileIntervalSeconds = null,
  moneyRailReconcileMaxTenants = null,
  moneyRailReconcileMaxPeriodsPerTenant = null,
  moneyRailReconcileMaxProvidersPerTenant = null,
  x402ReserveAdapter = null,
  x402RequireExternalReserve = null,
  x402ReserveMode = null,
  x402PilotKillSwitch = null,
  x402PilotAllowedProviderIds = null,
  x402PilotMaxAmountCents = null,
  x402PilotDailyLimitCents = null,
  settldPayTokenTtlSeconds = null,
  settldPayFallbackKeys = null,
  settldPayIssuer = null
} = {}) {
  const apiStartedAtMs = Date.now();
  const apiStartedAtIso = new Date(apiStartedAtMs).toISOString();

  const protocolPolicy = resolveProtocolPolicy(protocol ?? {});

  function decodePathPart(value) {
    // `url.pathname` preserves percent-encoding (ex: ":" becomes "%3A"). Our ops routes
    // parse by splitting on "/" and need to decode path params before using them as IDs.
    try {
      return decodeURIComponent(String(value ?? ""));
    } catch {
      return String(value ?? "");
    }
  }

  const serverSigner = { keyId: store.serverSigner.keyId, privateKeyPem: store.serverSigner.privateKeyPem };
  const OPS_SCOPES = Object.freeze({
    OPS_READ: "ops_read",
    OPS_WRITE: "ops_write",
    FINANCE_READ: "finance_read",
    FINANCE_WRITE: "finance_write",
    AUDIT_READ: "audit_read",
    GOVERNANCE_TENANT_READ: "governance_tenant_read",
    GOVERNANCE_TENANT_WRITE: "governance_tenant_write",
    GOVERNANCE_GLOBAL_READ: "governance_global_read",
    GOVERNANCE_GLOBAL_WRITE: "governance_global_write"
  });
  const ALL_OPS_SCOPES = new Set(Object.values(OPS_SCOPES));
  const DEFAULT_TENANT_BOOTSTRAP_API_KEY_SCOPES = Object.freeze([
    OPS_SCOPES.OPS_READ,
    OPS_SCOPES.OPS_WRITE,
    OPS_SCOPES.FINANCE_READ,
    OPS_SCOPES.FINANCE_WRITE,
    OPS_SCOPES.AUDIT_READ
  ]);

  const opsTokensRaw = opsTokens ?? (typeof process !== "undefined" ? (process.env.PROXY_OPS_TOKENS ?? null) : null);
  const legacyOpsTokenRaw = opsToken ?? (typeof process !== "undefined" ? (process.env.PROXY_OPS_TOKEN ?? null) : null);
  const rateLimitRpmRaw = rateLimitRpm ?? (typeof process !== "undefined" ? (process.env.PROXY_RATE_LIMIT_RPM ?? null) : null);
  const rateLimitBurstRaw = rateLimitBurst ?? (typeof process !== "undefined" ? (process.env.PROXY_RATE_LIMIT_BURST ?? null) : null);
  const rateLimitPerKeyRpmRaw = typeof process !== "undefined" ? process.env.PROXY_RATE_LIMIT_PER_KEY_RPM ?? null : null;
  const rateLimitPerKeyBurstRaw = typeof process !== "undefined" ? process.env.PROXY_RATE_LIMIT_PER_KEY_BURST ?? null : null;

  const evidenceSigningSecret =
    typeof process !== "undefined" && typeof process.env.PROXY_EVIDENCE_SIGNING_SECRET === "string" && process.env.PROXY_EVIDENCE_SIGNING_SECRET.trim() !== ""
      ? process.env.PROXY_EVIDENCE_SIGNING_SECRET.trim()
      : sha256Hex(store.serverSigner.privateKeyPem);

  const exportDestinationsRaw =
    exportDestinations ?? (typeof process !== "undefined" ? (process.env.PROXY_EXPORT_DESTINATIONS ?? null) : null);

  const rateLimitRpmValue = rateLimitRpmRaw && String(rateLimitRpmRaw).trim() !== "" ? Number(rateLimitRpmRaw) : 0;
  if (rateLimitRpmRaw && String(rateLimitRpmRaw).trim() !== "" && (!Number.isFinite(rateLimitRpmValue) || rateLimitRpmValue <= 0)) {
    throw new TypeError("PROXY_RATE_LIMIT_RPM must be a positive number");
  }
  const rateLimitBurstValue = rateLimitRpmValue
    ? rateLimitBurstRaw && String(rateLimitBurstRaw).trim() !== ""
      ? Number(rateLimitBurstRaw)
      : rateLimitRpmValue
    : 0;
  if (rateLimitRpmValue && (!Number.isFinite(rateLimitBurstValue) || rateLimitBurstValue <= 0)) {
    throw new TypeError("PROXY_RATE_LIMIT_BURST must be a positive number");
  }
  const rateBuckets = new Map(); // tenantId -> { tokens, lastMs }
  const rateRefillPerMs = rateLimitRpmValue ? rateLimitRpmValue / 60_000 : 0;
  const rateLimitPerKeyRpmValue =
    rateLimitPerKeyRpmRaw && String(rateLimitPerKeyRpmRaw).trim() !== "" ? Number(rateLimitPerKeyRpmRaw) : 0;
  if (
    rateLimitPerKeyRpmRaw &&
    String(rateLimitPerKeyRpmRaw).trim() !== "" &&
    (!Number.isFinite(rateLimitPerKeyRpmValue) || rateLimitPerKeyRpmValue <= 0)
  ) {
    throw new TypeError("PROXY_RATE_LIMIT_PER_KEY_RPM must be a positive number");
  }
  const rateLimitPerKeyBurstValue = rateLimitPerKeyRpmValue
    ? rateLimitPerKeyBurstRaw && String(rateLimitPerKeyBurstRaw).trim() !== ""
      ? Number(rateLimitPerKeyBurstRaw)
      : rateLimitPerKeyRpmValue
    : 0;
  if (rateLimitPerKeyRpmValue && (!Number.isFinite(rateLimitPerKeyBurstValue) || rateLimitPerKeyBurstValue <= 0)) {
    throw new TypeError("PROXY_RATE_LIMIT_PER_KEY_BURST must be a positive number");
  }
  const rateBucketsByApiKey = new Map(); // `${tenantId}\n${apiKeyId}` -> { tokens, lastMs }
  const ratePerKeyRefillPerMs = rateLimitPerKeyRpmValue ? rateLimitPerKeyRpmValue / 60_000 : 0;

  function setProtocolResponseHeaders(res) {
    try {
      res.setHeader("x-settld-protocol", protocolPolicy.current);
      res.setHeader("x-settld-supported-protocols", protocolPolicy.supported.join(","));
      if (protocolPolicy.buildId) res.setHeader("x-settld-build", String(protocolPolicy.buildId));
    } catch {
      // ignore
    }
  }

  function parseAndValidateRequestProtocol({ req, required }) {
    const header = req?.headers?.["x-settld-protocol"] ? String(req.headers["x-settld-protocol"]).trim() : "";
    if (!header) {
      if (required) {
        return { ok: false, statusCode: 400, code: "PROTOCOL_VERSION_REQUIRED", message: "x-settld-protocol is required" };
      }
      return { ok: true, protocol: protocolPolicy.current, assumed: true };
    }

    let p;
    try {
      p = parseProtocolVersion(header).raw;
    } catch (err) {
      return { ok: false, statusCode: 400, code: "INVALID_PROTOCOL_VERSION", message: err?.message ?? "invalid protocol" };
    }

    try {
      if (compareProtocolVersions(p, protocolPolicy.min) < 0) {
        return { ok: false, statusCode: 426, code: "PROTOCOL_TOO_OLD", message: "protocol too old", details: { min: protocolPolicy.min } };
      }
      if (compareProtocolVersions(p, protocolPolicy.max) > 0) {
        return { ok: false, statusCode: 400, code: "PROTOCOL_TOO_NEW", message: "protocol too new", details: { max: protocolPolicy.max } };
      }
    } catch (err) {
      return { ok: false, statusCode: 400, code: "INVALID_PROTOCOL_VERSION", message: err?.message ?? "invalid protocol" };
    }

    const dep = protocolPolicy.deprecations?.byVersion?.get?.(p) ?? null;
    if (dep?.cutoffAt) {
      const cutoffMs = Date.parse(dep.cutoffAt);
      const nowMs = Date.parse(nowIso());
      if (Number.isFinite(cutoffMs) && Number.isFinite(nowMs) && nowMs > cutoffMs) {
        return { ok: false, statusCode: 426, code: "PROTOCOL_DEPRECATED", message: "protocol deprecated", details: { cutoffAt: dep.cutoffAt } };
      }
    }

    return { ok: true, protocol: p, assumed: false };
  }

  function requireProtocolHeaderForWrite(req, res) {
    const check = parseAndValidateRequestProtocol({ req, required: protocolPolicy.requireHeader });
    if (!check.ok) {
      sendError(res, check.statusCode ?? 400, check.message ?? "invalid protocol", check.details ?? null, { code: check.code ?? "INVALID_PROTOCOL_VERSION" });
      return false;
    }
    return true;
  }

  function parseEventSchemaVersionFromBody(body) {
    if (!body || typeof body !== "object") return { ok: true, schemaVersion: 1, assumed: true };
    const raw = body?.schemaVersion ?? body?.schema_version ?? null;
    if (raw === null || raw === undefined || String(raw).trim() === "") return { ok: true, schemaVersion: 1, assumed: true };
    const n = Number(raw);
    if (!Number.isFinite(n) || !Number.isInteger(n)) {
      return { ok: false, statusCode: 400, code: "INVALID_EVENT_SCHEMA", message: "schemaVersion must be an integer" };
    }
    if (n !== 1) {
      return { ok: false, statusCode: 400, code: "UNSUPPORTED_EVENT_VERSION", message: "unsupported event schemaVersion", details: { supported: [1] } };
    }
    return { ok: true, schemaVersion: n, assumed: false };
  }

  function takeRateLimitToken({ tenantId }) {
    if (!rateLimitRpmValue) return { ok: true };
    const nowMs = Date.now();
    const key = normalizeTenant(tenantId);
    const existing = rateBuckets.get(key) ?? null;
    const lastMs = existing?.lastMs ?? nowMs;
    const elapsedMs = Math.max(0, nowMs - lastMs);
    const prevTokens =
      typeof existing?.tokens === "number" && Number.isFinite(existing.tokens) ? existing.tokens : rateLimitBurstValue;
    const refilled = Math.min(rateLimitBurstValue, prevTokens + elapsedMs * rateRefillPerMs);
    if (refilled < 1) {
      const waitMs = rateRefillPerMs > 0 ? Math.ceil((1 - refilled) / rateRefillPerMs) : 60_000;
      const retryAfterSeconds = Math.max(1, Math.ceil(waitMs / 1000));
      rateBuckets.set(key, { tokens: refilled, lastMs: nowMs });
      return { ok: false, retryAfterSeconds };
    }
    rateBuckets.set(key, { tokens: refilled - 1, lastMs: nowMs });
    return { ok: true };
  }

  function takeApiKeyRateLimitToken({ tenantId, apiKeyId }) {
    if (!rateLimitPerKeyRpmValue) return { ok: true };
    const normalizedApiKeyId = typeof apiKeyId === "string" ? apiKeyId.trim() : "";
    if (!normalizedApiKeyId) return { ok: true };

    const nowMs = Date.now();
    const key = `${normalizeTenant(tenantId)}\n${normalizedApiKeyId}`;
    const existing = rateBucketsByApiKey.get(key) ?? null;
    const lastMs = existing?.lastMs ?? nowMs;
    const elapsedMs = Math.max(0, nowMs - lastMs);
    const prevTokens =
      typeof existing?.tokens === "number" && Number.isFinite(existing.tokens) ? existing.tokens : rateLimitPerKeyBurstValue;
    const refilled = Math.min(rateLimitPerKeyBurstValue, prevTokens + elapsedMs * ratePerKeyRefillPerMs);
    if (refilled < 1) {
      const waitMs = ratePerKeyRefillPerMs > 0 ? Math.ceil((1 - refilled) / ratePerKeyRefillPerMs) : 60_000;
      const retryAfterSeconds = Math.max(1, Math.ceil(waitMs / 1000));
      rateBucketsByApiKey.set(key, { tokens: refilled, lastMs: nowMs });
      return { ok: false, retryAfterSeconds };
    }
    rateBucketsByApiKey.set(key, { tokens: refilled - 1, lastMs: nowMs });
    return { ok: true };
  }

  function parseExportDestinations(raw) {
    if (raw === null || raw === undefined) return new Map();
    const text = typeof raw === "string" ? raw.trim() : JSON.stringify(raw);
    if (!text) return new Map();
    let parsed;
    try {
      parsed = typeof raw === "string" ? JSON.parse(text) : raw;
    } catch (err) {
      throw new TypeError(`invalid PROXY_EXPORT_DESTINATIONS JSON: ${err?.message}`);
    }
    if (!parsed || typeof parsed !== "object" || Array.isArray(parsed)) throw new TypeError("export destinations must be a JSON object mapping tenantId -> destinations[]");
    const map = new Map();
    for (const [tenantIdRaw, list] of Object.entries(parsed)) {
      const tenantId = normalizeTenantId(tenantIdRaw);
      if (!Array.isArray(list)) throw new TypeError(`export destinations for ${tenantId} must be an array`);
      const normalized = [];
      for (const d of list) {
        if (!d || typeof d !== "object" || Array.isArray(d)) throw new TypeError("destination must be an object");
        const destinationId = d.destinationId ? String(d.destinationId) : null;
        const kind = d.kind ? String(d.kind) : "webhook";
        if (!destinationId) throw new TypeError("destination requires destinationId");
        const artifactTypes = d.artifactTypes ? (Array.isArray(d.artifactTypes) ? d.artifactTypes.map(String) : null) : null;
        if (kind === "webhook") {
          const url = d.url ? String(d.url) : null;
          const secretRef = d.secretRef ? String(d.secretRef) : d.credentialRef ? String(d.credentialRef) : null;
          const secret = d.secret ? String(d.secret) : null;
          if (!url || (!secretRef && !secret)) throw new TypeError("webhook destination requires url and (secretRef or secret)");
          if (
            secret &&
            !secretRef &&
            typeof process !== "undefined" &&
            process.env.NODE_ENV === "production" &&
            process.env.PROXY_ALLOW_INLINE_SECRETS !== "1"
          ) {
            throw new TypeError("inline webhook secrets are not allowed in production; use secretRef");
          }
          normalized.push({ destinationId, kind, url, secretRef: secretRef ?? null, secret: secretRef ? null : secret, artifactTypes });
          continue;
        }
        if (kind === "s3") {
          const endpoint = d.endpoint ? String(d.endpoint) : null;
          const region = d.region ? String(d.region) : "us-east-1";
          const bucket = d.bucket ? String(d.bucket) : null;
          const accessKeyIdRef = d.accessKeyIdRef ? String(d.accessKeyIdRef) : null;
          const secretAccessKeyRef = d.secretAccessKeyRef ? String(d.secretAccessKeyRef) : null;
          const accessKeyId = d.accessKeyId ? String(d.accessKeyId) : null;
          const secretAccessKey = d.secretAccessKey ? String(d.secretAccessKey) : null;
          const forcePathStyle = d.forcePathStyle === false ? false : true;
          const prefix = d.prefix ? String(d.prefix) : "";
          if (!endpoint || !bucket || (!accessKeyIdRef && !accessKeyId) || (!secretAccessKeyRef && !secretAccessKey)) {
            throw new TypeError("s3 destination requires endpoint, bucket, and (accessKeyIdRef or accessKeyId) and (secretAccessKeyRef or secretAccessKey)");
          }
          if (
            accessKeyId &&
            secretAccessKey &&
            !accessKeyIdRef &&
            !secretAccessKeyRef &&
            typeof process !== "undefined" &&
            process.env.NODE_ENV === "production" &&
            process.env.PROXY_ALLOW_INLINE_SECRETS !== "1"
          ) {
            throw new TypeError("inline s3 credentials are not allowed in production; use accessKeyIdRef/secretAccessKeyRef");
          }
          normalized.push({
            destinationId,
            kind,
            endpoint,
            region,
            bucket,
            accessKeyIdRef: accessKeyIdRef ?? null,
            secretAccessKeyRef: secretAccessKeyRef ?? null,
            accessKeyId: accessKeyIdRef ? null : accessKeyId,
            secretAccessKey: secretAccessKeyRef ? null : secretAccessKey,
            forcePathStyle,
            prefix,
            artifactTypes
          });
          continue;
        }
        throw new TypeError(`unsupported destination kind: ${kind}`);
      }
      map.set(tenantId, normalized);
    }
    return map;
  }

  const exportDestinationsByTenant = parseExportDestinations(exportDestinationsRaw);
  const listDestinationsForTenant = (tenantId) => exportDestinationsByTenant.get(normalizeTenantId(tenantId)) ?? [];

  const ingestTokenValue =
    ingestToken ?? (typeof process !== "undefined" ? (process.env.PROXY_INGEST_TOKEN ?? null) : null);

  function parseNonNegativeIntEnv(name, fallback) {
    if (typeof process === "undefined" || !process.env) return fallback;
    const raw = process.env[name] ?? null;
    if (raw === null || raw === undefined || String(raw).trim() === "") return fallback;
    const n = Number(raw);
    if (!Number.isSafeInteger(n) || n < 0) throw new TypeError(`${name} must be a non-negative safe integer`);
    return n;
  }

  const quotaPlatformMaxOpenJobs = parseNonNegativeIntEnv("PROXY_QUOTA_PLATFORM_MAX_OPEN_JOBS", 0);
  const quotaPlatformMaxPendingDeliveries = parseNonNegativeIntEnv("PROXY_QUOTA_PLATFORM_MAX_PENDING_DELIVERIES", 0);
  const quotaPlatformMaxIngestDlqDepth = parseNonNegativeIntEnv("PROXY_QUOTA_PLATFORM_MAX_INGEST_DLQ_DEPTH", 0);
  const quotaPlatformMaxEvidenceRefsPerJob = parseNonNegativeIntEnv("PROXY_QUOTA_PLATFORM_MAX_EVIDENCE_REFS_PER_JOB", 0);
  const quotaPlatformMaxArtifactsPerJobType = parseNonNegativeIntEnv("PROXY_QUOTA_PLATFORM_MAX_ARTIFACTS_PER_JOB_TYPE", 0);

  const ingestRecordsRetentionMaxDays = parseNonNegativeIntEnv("PROXY_RETENTION_INGEST_RECORDS_MAX_DAYS", 0);
  const outboxMaxAttempts = (() => {
    const raw = typeof process !== "undefined" ? (process.env.PROXY_OUTBOX_MAX_ATTEMPTS ?? null) : null;
    if (raw === null || raw === undefined || String(raw).trim() === "") return 25;
    const n = Number(raw);
    if (!Number.isSafeInteger(n) || n <= 0) throw new TypeError("PROXY_OUTBOX_MAX_ATTEMPTS must be a positive integer");
    return n;
  })();

  const retentionCleanupDefaultBatchSize = (() => {
    const n = parseNonNegativeIntEnv("PROXY_RETENTION_CLEANUP_BATCH_SIZE", 500);
    if (!Number.isSafeInteger(n) || n <= 0) throw new TypeError("PROXY_RETENTION_CLEANUP_BATCH_SIZE must be a positive safe integer");
    return n;
  })();

  const retentionCleanupDefaultMaxMillis = (() => {
    const n = parseNonNegativeIntEnv("PROXY_RETENTION_CLEANUP_MAX_MILLIS", 1500);
    if (!Number.isSafeInteger(n) || n <= 0) throw new TypeError("PROXY_RETENTION_CLEANUP_MAX_MILLIS must be a positive safe integer");
    return n;
  })();

  const retentionCleanupDefaultDryRun = typeof process !== "undefined" && process.env.PROXY_RETENTION_CLEANUP_DRY_RUN === "1";

  const evidenceContentTypeAllowlist = (() => {
    if (typeof process === "undefined" || !process.env) return null;
    const raw = process.env.PROXY_EVIDENCE_CONTENT_TYPE_ALLOWLIST ?? null;
    if (raw === null || raw === undefined || String(raw).trim() === "") return null;
    const list = String(raw)
      .split(",")
      .map((s) => s.trim())
      .filter(Boolean);
    if (list.length === 0) return null;
    return new Set(list);
  })();

  const evidenceRequireSizeBytes =
    typeof process !== "undefined" && typeof process.env.PROXY_EVIDENCE_REQUIRE_SIZE_BYTES === "string" && process.env.PROXY_EVIDENCE_REQUIRE_SIZE_BYTES === "1";

  const evidenceMaxSizeBytes = parseNonNegativeIntEnv("PROXY_EVIDENCE_MAX_SIZE_BYTES", 0);
  const effectiveBillingPlanEnforcementEnabled = (() => {
    const raw =
      billingPlanEnforcementEnabled ??
      (typeof process !== "undefined"
        ? process.env.PROXY_BILLING_PLAN_ENFORCEMENT_ENABLED ?? process.env.PROXY_BILLING_ENFORCEMENT_ENABLED
        : null);
    return parseBooleanLike(raw, false);
  })();
  const effectiveBillingStripeWebhookSecret =
    billingStripeWebhookSecret !== null && billingStripeWebhookSecret !== undefined
      ? String(billingStripeWebhookSecret).trim() || null
      : typeof process !== "undefined" && typeof process.env.PROXY_BILLING_STRIPE_WEBHOOK_SECRET === "string" && process.env.PROXY_BILLING_STRIPE_WEBHOOK_SECRET.trim() !== ""
        ? process.env.PROXY_BILLING_STRIPE_WEBHOOK_SECRET.trim()
        : null;
  const effectiveBillingStripeWebhookToleranceSeconds =
    billingStripeWebhookToleranceSeconds !== null && billingStripeWebhookToleranceSeconds !== undefined
      ? Number(billingStripeWebhookToleranceSeconds)
      : parseNonNegativeIntEnv("PROXY_BILLING_STRIPE_WEBHOOK_TOLERANCE_SECONDS", 300);
  const effectiveBillingStripeCheckoutBaseUrl =
    billingStripeCheckoutBaseUrl !== null && billingStripeCheckoutBaseUrl !== undefined
      ? String(billingStripeCheckoutBaseUrl).trim()
      : typeof process !== "undefined" && typeof process.env.PROXY_BILLING_STRIPE_CHECKOUT_BASE_URL === "string" && process.env.PROXY_BILLING_STRIPE_CHECKOUT_BASE_URL.trim() !== ""
        ? process.env.PROXY_BILLING_STRIPE_CHECKOUT_BASE_URL.trim()
        : "https://billing.stripe.local/checkout";
  const effectiveBillingStripePortalBaseUrl =
    billingStripePortalBaseUrl !== null && billingStripePortalBaseUrl !== undefined
      ? String(billingStripePortalBaseUrl).trim()
      : typeof process !== "undefined" && typeof process.env.PROXY_BILLING_STRIPE_PORTAL_BASE_URL === "string" && process.env.PROXY_BILLING_STRIPE_PORTAL_BASE_URL.trim() !== ""
        ? process.env.PROXY_BILLING_STRIPE_PORTAL_BASE_URL.trim()
        : "https://billing.stripe.local/portal";
  const effectiveBillingStripeApiBaseUrl =
    billingStripeApiBaseUrl !== null && billingStripeApiBaseUrl !== undefined
      ? String(billingStripeApiBaseUrl).trim().replace(/\/+$/, "")
      : typeof process !== "undefined" && typeof process.env.PROXY_BILLING_STRIPE_API_BASE_URL === "string" && process.env.PROXY_BILLING_STRIPE_API_BASE_URL.trim() !== ""
        ? String(process.env.PROXY_BILLING_STRIPE_API_BASE_URL).trim().replace(/\/+$/, "")
        : "https://api.stripe.com";
  const effectiveBillingStripeSecretKey =
    billingStripeSecretKey !== null && billingStripeSecretKey !== undefined
      ? String(billingStripeSecretKey).trim()
      : typeof process !== "undefined" && typeof process.env.PROXY_BILLING_STRIPE_SECRET_KEY === "string" && process.env.PROXY_BILLING_STRIPE_SECRET_KEY.trim() !== ""
        ? process.env.PROXY_BILLING_STRIPE_SECRET_KEY.trim()
        : "";
  const effectiveBillingStripePriceIdBuilder =
    billingStripePriceIdBuilder !== null && billingStripePriceIdBuilder !== undefined
      ? String(billingStripePriceIdBuilder).trim()
      : typeof process !== "undefined" && typeof process.env.PROXY_BILLING_STRIPE_PRICE_ID_BUILDER === "string" && process.env.PROXY_BILLING_STRIPE_PRICE_ID_BUILDER.trim() !== ""
        ? process.env.PROXY_BILLING_STRIPE_PRICE_ID_BUILDER.trim()
        : "";
  const effectiveBillingStripePriceIdGrowth =
    billingStripePriceIdGrowth !== null && billingStripePriceIdGrowth !== undefined
      ? String(billingStripePriceIdGrowth).trim()
      : typeof process !== "undefined" && typeof process.env.PROXY_BILLING_STRIPE_PRICE_ID_GROWTH === "string" && process.env.PROXY_BILLING_STRIPE_PRICE_ID_GROWTH.trim() !== ""
        ? process.env.PROXY_BILLING_STRIPE_PRICE_ID_GROWTH.trim()
        : "";
  const effectiveBillingStripePriceIdEnterprise =
    billingStripePriceIdEnterprise !== null && billingStripePriceIdEnterprise !== undefined
      ? String(billingStripePriceIdEnterprise).trim()
      : typeof process !== "undefined" && typeof process.env.PROXY_BILLING_STRIPE_PRICE_ID_ENTERPRISE === "string" && process.env.PROXY_BILLING_STRIPE_PRICE_ID_ENTERPRISE.trim() !== ""
        ? process.env.PROXY_BILLING_STRIPE_PRICE_ID_ENTERPRISE.trim()
        : "";
  const effectiveBillingStripeCheckoutSuccessUrl =
    billingStripeCheckoutSuccessUrl !== null && billingStripeCheckoutSuccessUrl !== undefined
      ? String(billingStripeCheckoutSuccessUrl).trim()
      : typeof process !== "undefined" && typeof process.env.PROXY_BILLING_STRIPE_CHECKOUT_SUCCESS_URL === "string" && process.env.PROXY_BILLING_STRIPE_CHECKOUT_SUCCESS_URL.trim() !== ""
        ? process.env.PROXY_BILLING_STRIPE_CHECKOUT_SUCCESS_URL.trim()
        : "";
  const effectiveBillingStripeCheckoutCancelUrl =
    billingStripeCheckoutCancelUrl !== null && billingStripeCheckoutCancelUrl !== undefined
      ? String(billingStripeCheckoutCancelUrl).trim()
      : typeof process !== "undefined" && typeof process.env.PROXY_BILLING_STRIPE_CHECKOUT_CANCEL_URL === "string" && process.env.PROXY_BILLING_STRIPE_CHECKOUT_CANCEL_URL.trim() !== ""
        ? process.env.PROXY_BILLING_STRIPE_CHECKOUT_CANCEL_URL.trim()
        : "";
  const effectiveBillingStripePortalReturnUrl =
    billingStripePortalReturnUrl !== null && billingStripePortalReturnUrl !== undefined
      ? String(billingStripePortalReturnUrl).trim()
      : typeof process !== "undefined" && typeof process.env.PROXY_BILLING_STRIPE_PORTAL_RETURN_URL === "string" && process.env.PROXY_BILLING_STRIPE_PORTAL_RETURN_URL.trim() !== ""
        ? process.env.PROXY_BILLING_STRIPE_PORTAL_RETURN_URL.trim()
        : "";
  const effectiveBillingStripeRetryMaxAttempts =
    billingStripeRetryMaxAttempts !== null && billingStripeRetryMaxAttempts !== undefined
      ? Number(billingStripeRetryMaxAttempts)
      : parseNonNegativeIntEnv("PROXY_BILLING_STRIPE_RETRY_MAX_ATTEMPTS", 3);
  if (!Number.isSafeInteger(effectiveBillingStripeRetryMaxAttempts) || effectiveBillingStripeRetryMaxAttempts <= 0) {
    throw new TypeError("PROXY_BILLING_STRIPE_RETRY_MAX_ATTEMPTS must be a positive safe integer");
  }
  const effectiveBillingStripeRetryBaseMs =
    billingStripeRetryBaseMs !== null && billingStripeRetryBaseMs !== undefined
      ? Number(billingStripeRetryBaseMs)
      : parseNonNegativeIntEnv("PROXY_BILLING_STRIPE_RETRY_BASE_MS", 200);
  if (!Number.isSafeInteger(effectiveBillingStripeRetryBaseMs) || effectiveBillingStripeRetryBaseMs < 0) {
    throw new TypeError("PROXY_BILLING_STRIPE_RETRY_BASE_MS must be a non-negative safe integer");
  }
  const effectiveBillingStripeRetryMaxMs =
    billingStripeRetryMaxMs !== null && billingStripeRetryMaxMs !== undefined
      ? Number(billingStripeRetryMaxMs)
      : parseNonNegativeIntEnv("PROXY_BILLING_STRIPE_RETRY_MAX_MS", 2000);
  if (!Number.isSafeInteger(effectiveBillingStripeRetryMaxMs) || effectiveBillingStripeRetryMaxMs <= 0) {
    throw new TypeError("PROXY_BILLING_STRIPE_RETRY_MAX_MS must be a positive safe integer");
  }
  const effectiveBillingStripeCircuitFailureThreshold =
    billingStripeCircuitFailureThreshold !== null && billingStripeCircuitFailureThreshold !== undefined
      ? Number(billingStripeCircuitFailureThreshold)
      : parseNonNegativeIntEnv("PROXY_BILLING_STRIPE_CIRCUIT_FAILURE_THRESHOLD", 3);
  if (!Number.isSafeInteger(effectiveBillingStripeCircuitFailureThreshold) || effectiveBillingStripeCircuitFailureThreshold <= 0) {
    throw new TypeError("PROXY_BILLING_STRIPE_CIRCUIT_FAILURE_THRESHOLD must be a positive safe integer");
  }
  const effectiveBillingStripeCircuitOpenMs =
    billingStripeCircuitOpenMs !== null && billingStripeCircuitOpenMs !== undefined
      ? Number(billingStripeCircuitOpenMs)
      : parseNonNegativeIntEnv("PROXY_BILLING_STRIPE_CIRCUIT_OPEN_MS", 30_000);
  if (!Number.isSafeInteger(effectiveBillingStripeCircuitOpenMs) || effectiveBillingStripeCircuitOpenMs <= 0) {
    throw new TypeError("PROXY_BILLING_STRIPE_CIRCUIT_OPEN_MS must be a positive safe integer");
  }
  const effectiveBillingStripeFetchFn = typeof billingStripeFetchFn === "function" ? billingStripeFetchFn : null;
  const effectiveBillingStripeSyncEnabled =
    billingStripeSyncEnabled !== null && billingStripeSyncEnabled !== undefined
      ? billingStripeSyncEnabled === true
      : typeof process !== "undefined" && process.env.PROXY_BILLING_STRIPE_SYNC_ENABLED !== undefined
        ? String(process.env.PROXY_BILLING_STRIPE_SYNC_ENABLED) === "1"
        : true;
  const effectiveBillingStripeSyncIntervalSeconds =
    billingStripeSyncIntervalSeconds !== null && billingStripeSyncIntervalSeconds !== undefined
      ? Number(billingStripeSyncIntervalSeconds)
      : parseNonNegativeIntEnv("PROXY_BILLING_STRIPE_SYNC_INTERVAL_SECONDS", 60);
  if (!Number.isSafeInteger(effectiveBillingStripeSyncIntervalSeconds) || effectiveBillingStripeSyncIntervalSeconds < 0) {
    throw new TypeError("PROXY_BILLING_STRIPE_SYNC_INTERVAL_SECONDS must be a non-negative safe integer");
  }
  const effectiveBillingStripeSyncBatchSize =
    billingStripeSyncBatchSize !== null && billingStripeSyncBatchSize !== undefined
      ? Number(billingStripeSyncBatchSize)
      : parseNonNegativeIntEnv("PROXY_BILLING_STRIPE_SYNC_BATCH_SIZE", 50);
  if (!Number.isSafeInteger(effectiveBillingStripeSyncBatchSize) || effectiveBillingStripeSyncBatchSize <= 0) {
    throw new TypeError("PROXY_BILLING_STRIPE_SYNC_BATCH_SIZE must be a positive safe integer");
  }
  const effectiveBillingStripeSyncAuditScanLimit =
    billingStripeSyncAuditScanLimit !== null && billingStripeSyncAuditScanLimit !== undefined
      ? Number(billingStripeSyncAuditScanLimit)
      : parseNonNegativeIntEnv("PROXY_BILLING_STRIPE_SYNC_AUDIT_SCAN_LIMIT", 1000);
  if (!Number.isSafeInteger(effectiveBillingStripeSyncAuditScanLimit) || effectiveBillingStripeSyncAuditScanLimit <= 0) {
    throw new TypeError("PROXY_BILLING_STRIPE_SYNC_AUDIT_SCAN_LIMIT must be a positive safe integer");
  }
  const effectiveBillingStripeSyncMaxReplayAttempts =
    billingStripeSyncMaxReplayAttempts !== null && billingStripeSyncMaxReplayAttempts !== undefined
      ? Number(billingStripeSyncMaxReplayAttempts)
      : parseNonNegativeIntEnv("PROXY_BILLING_STRIPE_SYNC_MAX_REPLAY_ATTEMPTS", 5);
  if (!Number.isSafeInteger(effectiveBillingStripeSyncMaxReplayAttempts) || effectiveBillingStripeSyncMaxReplayAttempts <= 0) {
    throw new TypeError("PROXY_BILLING_STRIPE_SYNC_MAX_REPLAY_ATTEMPTS must be a positive safe integer");
  }
  const effectiveBillingStripeSyncMinRetrySeconds =
    billingStripeSyncMinRetrySeconds !== null && billingStripeSyncMinRetrySeconds !== undefined
      ? Number(billingStripeSyncMinRetrySeconds)
      : parseNonNegativeIntEnv("PROXY_BILLING_STRIPE_SYNC_MIN_RETRY_SECONDS", 60);
  if (!Number.isSafeInteger(effectiveBillingStripeSyncMinRetrySeconds) || effectiveBillingStripeSyncMinRetrySeconds < 0) {
    throw new TypeError("PROXY_BILLING_STRIPE_SYNC_MIN_RETRY_SECONDS must be a non-negative safe integer");
  }
  const effectiveBillingStripeSyncMaxRetrySeconds =
    billingStripeSyncMaxRetrySeconds !== null && billingStripeSyncMaxRetrySeconds !== undefined
      ? Number(billingStripeSyncMaxRetrySeconds)
      : parseNonNegativeIntEnv("PROXY_BILLING_STRIPE_SYNC_MAX_RETRY_SECONDS", 3600);
  if (!Number.isSafeInteger(effectiveBillingStripeSyncMaxRetrySeconds) || effectiveBillingStripeSyncMaxRetrySeconds <= 0) {
    throw new TypeError("PROXY_BILLING_STRIPE_SYNC_MAX_RETRY_SECONDS must be a positive safe integer");
  }
  const effectiveBillingStripeSyncReplayReasons = (() => {
    const raw =
      billingStripeSyncReplayReasons !== null && billingStripeSyncReplayReasons !== undefined
        ? billingStripeSyncReplayReasons
        : typeof process !== "undefined" && typeof process.env.PROXY_BILLING_STRIPE_SYNC_REPLAY_REASONS === "string"
          ? process.env.PROXY_BILLING_STRIPE_SYNC_REPLAY_REASONS
          : "apply_failed,reconcile_apply_failed,dead_letter_replay_apply_failed";
    const list = Array.isArray(raw)
      ? raw
      : String(raw)
          .split(",")
          .map((value) => value.trim())
          .filter(Boolean);
    const set = new Set();
    for (const reason of list) {
      set.add(String(reason));
    }
    if (set.size === 0) {
      set.add("apply_failed");
      set.add("reconcile_apply_failed");
      set.add("dead_letter_replay_apply_failed");
    }
    return set;
  })();
  const effectiveFinanceReconcileEnabled =
    financeReconcileEnabled !== null && financeReconcileEnabled !== undefined
      ? financeReconcileEnabled === true
      : typeof process !== "undefined" && typeof process.env.PROXY_FINANCE_RECONCILE_ENABLED === "string"
        ? process.env.PROXY_FINANCE_RECONCILE_ENABLED !== "0"
        : true;
  const effectiveFinanceReconcileIntervalSeconds =
    financeReconcileIntervalSeconds !== null && financeReconcileIntervalSeconds !== undefined
      ? Number(financeReconcileIntervalSeconds)
      : parseNonNegativeIntEnv("PROXY_FINANCE_RECONCILE_INTERVAL_SECONDS", 300);
  if (!Number.isSafeInteger(effectiveFinanceReconcileIntervalSeconds) || effectiveFinanceReconcileIntervalSeconds < 0) {
    throw new TypeError("PROXY_FINANCE_RECONCILE_INTERVAL_SECONDS must be a non-negative safe integer");
  }
  const effectiveFinanceReconcileMaxTenants =
    financeReconcileMaxTenants !== null && financeReconcileMaxTenants !== undefined
      ? Number(financeReconcileMaxTenants)
      : parseNonNegativeIntEnv("PROXY_FINANCE_RECONCILE_MAX_TENANTS", 50);
  if (!Number.isSafeInteger(effectiveFinanceReconcileMaxTenants) || effectiveFinanceReconcileMaxTenants <= 0) {
    throw new TypeError("PROXY_FINANCE_RECONCILE_MAX_TENANTS must be a positive safe integer");
  }
  const effectiveFinanceReconcileMaxPeriodsPerTenant =
    financeReconcileMaxPeriodsPerTenant !== null && financeReconcileMaxPeriodsPerTenant !== undefined
      ? Number(financeReconcileMaxPeriodsPerTenant)
      : parseNonNegativeIntEnv("PROXY_FINANCE_RECONCILE_MAX_PERIODS_PER_TENANT", 2);
  if (!Number.isSafeInteger(effectiveFinanceReconcileMaxPeriodsPerTenant) || effectiveFinanceReconcileMaxPeriodsPerTenant <= 0) {
    throw new TypeError("PROXY_FINANCE_RECONCILE_MAX_PERIODS_PER_TENANT must be a positive safe integer");
  }
  const effectiveMoneyRailReconcileEnabled =
    moneyRailReconcileEnabled !== null && moneyRailReconcileEnabled !== undefined
      ? moneyRailReconcileEnabled === true
      : typeof process !== "undefined" && typeof process.env.PROXY_MONEY_RAIL_RECONCILE_ENABLED === "string"
        ? process.env.PROXY_MONEY_RAIL_RECONCILE_ENABLED !== "0"
        : true;
  const effectiveMoneyRailReconcileIntervalSeconds =
    moneyRailReconcileIntervalSeconds !== null && moneyRailReconcileIntervalSeconds !== undefined
      ? Number(moneyRailReconcileIntervalSeconds)
      : parseNonNegativeIntEnv("PROXY_MONEY_RAIL_RECONCILE_INTERVAL_SECONDS", 300);
  if (!Number.isSafeInteger(effectiveMoneyRailReconcileIntervalSeconds) || effectiveMoneyRailReconcileIntervalSeconds < 0) {
    throw new TypeError("PROXY_MONEY_RAIL_RECONCILE_INTERVAL_SECONDS must be a non-negative safe integer");
  }
  const effectiveMoneyRailReconcileMaxTenants =
    moneyRailReconcileMaxTenants !== null && moneyRailReconcileMaxTenants !== undefined
      ? Number(moneyRailReconcileMaxTenants)
      : parseNonNegativeIntEnv("PROXY_MONEY_RAIL_RECONCILE_MAX_TENANTS", 50);
  if (!Number.isSafeInteger(effectiveMoneyRailReconcileMaxTenants) || effectiveMoneyRailReconcileMaxTenants <= 0) {
    throw new TypeError("PROXY_MONEY_RAIL_RECONCILE_MAX_TENANTS must be a positive safe integer");
  }
  const effectiveMoneyRailReconcileMaxPeriodsPerTenant =
    moneyRailReconcileMaxPeriodsPerTenant !== null && moneyRailReconcileMaxPeriodsPerTenant !== undefined
      ? Number(moneyRailReconcileMaxPeriodsPerTenant)
      : parseNonNegativeIntEnv("PROXY_MONEY_RAIL_RECONCILE_MAX_PERIODS_PER_TENANT", 2);
  if (!Number.isSafeInteger(effectiveMoneyRailReconcileMaxPeriodsPerTenant) || effectiveMoneyRailReconcileMaxPeriodsPerTenant <= 0) {
    throw new TypeError("PROXY_MONEY_RAIL_RECONCILE_MAX_PERIODS_PER_TENANT must be a positive safe integer");
  }
  const effectiveMoneyRailReconcileMaxProvidersPerTenant =
    moneyRailReconcileMaxProvidersPerTenant !== null && moneyRailReconcileMaxProvidersPerTenant !== undefined
      ? Number(moneyRailReconcileMaxProvidersPerTenant)
      : parseNonNegativeIntEnv("PROXY_MONEY_RAIL_RECONCILE_MAX_PROVIDERS_PER_TENANT", 10);
  if (!Number.isSafeInteger(effectiveMoneyRailReconcileMaxProvidersPerTenant) || effectiveMoneyRailReconcileMaxProvidersPerTenant <= 0) {
    throw new TypeError("PROXY_MONEY_RAIL_RECONCILE_MAX_PROVIDERS_PER_TENANT must be a positive safe integer");
  }
  const billingStripeSyncState = {
    inFlight: false,
    lastRunAt: null,
    lastSuccessAt: null,
    lastResult: null,
    nextEligibleAtMs: 0
  };
  const financeReconcileState = {
    inFlight: false,
    lastRunAt: null,
    lastSuccessAt: null,
    lastResult: null,
    nextEligibleAtMs: 0
  };
  const moneyRailReconcileState = {
    inFlight: false,
    lastRunAt: null,
    lastSuccessAt: null,
    lastResult: null,
    nextEligibleAtMs: 0
  };

  function parseOpsTokens(raw) {
    if (raw === null || raw === undefined) return new Map();
    const text = String(raw).trim();
    if (!text) return new Map();

    const map = new Map();
    const entries = text
      .split(";")
      .map((s) => s.trim())
      .filter(Boolean);
    for (const entry of entries) {
      const [tokenRaw, scopesRaw] = entry.split(":");
      const token = tokenRaw ? tokenRaw.trim() : "";
      if (!token) continue;
      const scopes = new Set();
      const scopesList = scopesRaw
        ? scopesRaw
            .split(",")
            .map((s) => s.trim())
            .filter(Boolean)
        : [];
      for (const s of scopesList) {
        if (!ALL_OPS_SCOPES.has(s)) throw new TypeError(`unknown ops scope: ${s}`);
        scopes.add(s);
      }
      map.set(token, scopes);
    }
    return map;
  }

  let opsTokenScopes = parseOpsTokens(opsTokensRaw);
  const normalizedLegacyOpsToken = typeof legacyOpsTokenRaw === "string" ? legacyOpsTokenRaw.trim() : "";
  if (opsTokenScopes.size === 0 && normalizedLegacyOpsToken) {
    // Back-compat: a single ops token grants full access.
    opsTokenScopes = new Map([[normalizedLegacyOpsToken, new Set(ALL_OPS_SCOPES)]]);
  }

  function nowIso() {
    const value = typeof now === "function" ? now() : new Date().toISOString();
    const t = Date.parse(value);
    if (!Number.isFinite(t)) throw new TypeError("now() must return an ISO date string");
    return value;
  }

  function parseBooleanLike(value, fallback = false) {
    if (value === null || value === undefined || String(value).trim() === "") return fallback;
    const normalized = String(value).trim().toLowerCase();
    if (normalized === "1" || normalized === "true" || normalized === "yes" || normalized === "on") return true;
    if (normalized === "0" || normalized === "false" || normalized === "no" || normalized === "off") return false;
    throw new TypeError("boolean-like value must be true|false");
  }

  function normalizeX402PilotAllowedProviderIdsInput(value, { fieldName = "X402_PILOT_ALLOWED_PROVIDER_IDS" } = {}) {
    if (value === null || value === undefined || String(value).trim() === "") return null;
    let parsed = value;
    if (typeof parsed === "string") {
      const trimmed = parsed.trim();
      if (!trimmed) return null;
      if (trimmed.startsWith("[")) {
        try {
          parsed = JSON.parse(trimmed);
        } catch (err) {
          throw new TypeError(`${fieldName} must be valid JSON array or comma-delimited string: ${err?.message ?? String(err ?? "")}`);
        }
      } else {
        parsed = trimmed
          .split(",")
          .map((entry) => String(entry ?? "").trim())
          .filter(Boolean);
      }
    }
    if (!Array.isArray(parsed)) {
      throw new TypeError(`${fieldName} must be an array, JSON array string, or comma-delimited string`);
    }
    return normalizeMoneyRailAllowedProviderIds(parsed, { fieldName });
  }

  function isProductionLikeRuntimeEnv() {
    const nodeEnv = typeof process !== "undefined" ? String(process.env.NODE_ENV ?? "").trim().toLowerCase() : "";
    if (nodeEnv === "production") return true;
    const settldEnv = typeof process !== "undefined" ? String(process.env.SETTLD_ENV ?? "").trim().toLowerCase() : "";
    if (settldEnv === "production" || settldEnv === "prod") return true;
    const railwayEnv =
      typeof process !== "undefined" ? String(process.env.RAILWAY_ENVIRONMENT_NAME ?? "").trim().toLowerCase() : "";
    if (railwayEnv === "production" || railwayEnv === "prod") return true;
    return false;
  }

  function normalizeSettldPayFallbackKeysInput(raw) {
    if (raw === null || raw === undefined || raw === "") return [];
    let parsed = raw;
    if (typeof parsed === "string") {
      try {
        parsed = JSON.parse(parsed);
      } catch (err) {
        throw new TypeError(`invalid SETTLD_PAY_FALLBACK_KEYS JSON: ${err?.message ?? String(err ?? "")}`);
      }
    }
    const entries = Array.isArray(parsed) ? parsed : [parsed];
    const out = [];
    for (const entry of entries) {
      if (!entry || typeof entry !== "object" || Array.isArray(entry)) continue;
      const publicKeyPem = typeof entry.publicKeyPem === "string" && entry.publicKeyPem.trim() !== "" ? entry.publicKeyPem : null;
      if (!publicKeyPem) continue;
      const keyId = typeof entry.keyId === "string" && entry.keyId.trim() !== "" ? entry.keyId.trim() : null;
      out.push({ publicKeyPem, keyId });
    }
    return out;
  }

  function mergeSettldPayFallbackKeys(...lists) {
    const out = [];
    const seen = new Set();
    for (const list of lists) {
      const rows = Array.isArray(list) ? list : [];
      for (const row of rows) {
        if (!row || typeof row !== "object" || Array.isArray(row)) continue;
        const publicKeyPem = typeof row.publicKeyPem === "string" ? row.publicKeyPem : "";
        if (!publicKeyPem.trim()) continue;
        const derivedKeyId = keyIdFromPublicKeyPem(publicKeyPem);
        if (seen.has(derivedKeyId)) continue;
        seen.add(derivedKeyId);
        const keyId = typeof row.keyId === "string" && row.keyId.trim() !== "" ? row.keyId.trim() : derivedKeyId;
        out.push({ publicKeyPem, keyId });
      }
    }
    return out;
  }

  // Keep in-memory derived subsystems (deliveries/correlations) time-consistent in tests.
  if (store && typeof store === "object" && typeof store.nowIso === "function") {
    store.nowIso = nowIso;
  }

  const settldPayIssuerValue =
    typeof settldPayIssuer === "string" && settldPayIssuer.trim() !== ""
      ? settldPayIssuer.trim()
      : typeof process !== "undefined" && typeof process.env.SETTLD_PAY_ISSUER === "string" && process.env.SETTLD_PAY_ISSUER.trim() !== ""
        ? process.env.SETTLD_PAY_ISSUER.trim()
        : "settld";
  const settldPayTokenTtlSecondsValue = (() => {
    const raw =
      settldPayTokenTtlSeconds ??
      (typeof process !== "undefined" ? (process.env.SETTLD_PAY_TOKEN_TTL_SECONDS ?? null) : null) ??
      300;
    const n = Number(raw);
    if (!Number.isSafeInteger(n) || n <= 0 || n > 3600) throw new TypeError("SETTLD_PAY_TOKEN_TTL_SECONDS must be an integer within 1..3600");
    return n;
  })();
  const settldPayFallbackKeysValue = (() => {
    const fromStore = normalizeSettldPayFallbackKeysInput(store?.settldPayFallbackKeys ?? null);
    const explicit = normalizeSettldPayFallbackKeysInput(settldPayFallbackKeys);
    if (explicit.length > 0) return mergeSettldPayFallbackKeys(fromStore, explicit);
    const fromEnvJson =
      typeof process !== "undefined" ? normalizeSettldPayFallbackKeysInput(process.env.SETTLD_PAY_FALLBACK_KEYS ?? null) : [];
    if (fromEnvJson.length > 0) return mergeSettldPayFallbackKeys(fromStore, fromEnvJson);
    const singlePem =
      typeof process !== "undefined" && typeof process.env.SETTLD_PAY_FALLBACK_PUBLIC_KEY_PEM === "string"
        ? process.env.SETTLD_PAY_FALLBACK_PUBLIC_KEY_PEM.trim()
        : "";
    if (!singlePem) return fromStore;
    const singleKid =
      typeof process !== "undefined" && typeof process.env.SETTLD_PAY_FALLBACK_KEY_ID === "string"
        ? process.env.SETTLD_PAY_FALLBACK_KEY_ID.trim()
        : "";
    return mergeSettldPayFallbackKeys(fromStore, [{ publicKeyPem: singlePem, keyId: singleKid || null }]);
  })();
  const productionLikeEnv = isProductionLikeRuntimeEnv();
  const x402RequireExternalReserveValue = (() => {
    const raw =
      x402RequireExternalReserve ??
      (typeof process !== "undefined" ? process.env.X402_REQUIRE_EXTERNAL_RESERVE : null);
    return parseBooleanLike(raw, productionLikeEnv);
  })();
  const x402ReserveModeValue = (() => {
    const raw =
      x402ReserveMode ??
      (typeof process !== "undefined" ? process.env.X402_CIRCLE_RESERVE_MODE : null);
    if (raw === null || raw === undefined || String(raw).trim() === "") return productionLikeEnv ? "production" : "stub";
    return String(raw).trim();
  })();
  const x402PilotKillSwitchValue = (() => {
    const raw =
      x402PilotKillSwitch ??
      (typeof process !== "undefined" ? process.env.X402_PILOT_KILL_SWITCH : null);
    return parseBooleanLike(raw, false);
  })();
  const x402PilotAllowedProviderIdsValue = (() => {
    const raw =
      x402PilotAllowedProviderIds ??
      (typeof process !== "undefined" ? process.env.X402_PILOT_ALLOWED_PROVIDER_IDS : null);
    return normalizeX402PilotAllowedProviderIdsInput(raw, { fieldName: "X402_PILOT_ALLOWED_PROVIDER_IDS" });
  })();
  const x402PilotMaxAmountCentsValue = (() => {
    const raw =
      x402PilotMaxAmountCents ??
      (typeof process !== "undefined" ? process.env.X402_PILOT_MAX_AMOUNT_CENTS : null);
    return normalizeOptionalNonNegativeSafeInt(raw, { fieldName: "X402_PILOT_MAX_AMOUNT_CENTS", allowNull: true });
  })();
  const x402PilotDailyLimitCentsValue = (() => {
    const raw =
      x402PilotDailyLimitCents ??
      (typeof process !== "undefined" ? process.env.X402_PILOT_DAILY_LIMIT_CENTS : null);
    return normalizeOptionalNonNegativeSafeInt(raw, { fieldName: "X402_PILOT_DAILY_LIMIT_CENTS", allowNull: true });
  })();
  const x402QuoteTtlSecondsValue = (() => {
    const raw = typeof process !== "undefined" ? process.env.X402_QUOTE_TTL_SECONDS : null;
    if (raw === null || raw === undefined || String(raw).trim() === "") return 300;
    const n = Number(raw);
    if (!Number.isSafeInteger(n) || n <= 0 || n > 3600) {
      throw new TypeError("X402_QUOTE_TTL_SECONDS must be an integer within 1..3600");
    }
    return n;
  })();
  const circleReserveAdapter = x402ReserveAdapter ?? createCircleReserveAdapter({ mode: x402ReserveModeValue, now: nowIso });

  function computeX402DailyAuthorizedExposureCents({ tenantId, dayKey, excludeGateId = null, sponsorWalletRef = null } = {}) {
    if (!dayKey || !(store?.x402Gates instanceof Map)) return 0;
    const normalizedTenantId = normalizeTenantId(tenantId ?? DEFAULT_TENANT_ID);
    const sponsorWalletFilter =
      typeof sponsorWalletRef === "string" && sponsorWalletRef.trim() !== "" ? sponsorWalletRef.trim() : null;
    let total = 0;
    for (const row of store.x402Gates.values()) {
      if (!row || typeof row !== "object") continue;
      if (normalizeTenantId(row.tenantId ?? DEFAULT_TENANT_ID) !== normalizedTenantId) continue;
      const rowGateId = typeof row.gateId === "string" ? row.gateId : "";
      if (excludeGateId && rowGateId === excludeGateId) continue;
      if (sponsorWalletFilter) {
        const rowSponsorWalletRef =
          row?.agentPassport && typeof row.agentPassport === "object" && !Array.isArray(row.agentPassport)
            ? typeof row.agentPassport.sponsorWalletRef === "string" && row.agentPassport.sponsorWalletRef.trim() !== ""
              ? row.agentPassport.sponsorWalletRef.trim()
              : null
            : null;
        if (rowSponsorWalletRef !== sponsorWalletFilter) continue;
      }

      const authorization = row.authorization && typeof row.authorization === "object" && !Array.isArray(row.authorization) ? row.authorization : null;
      if (!authorization) continue;
      const authStatus = String(authorization.status ?? "").toLowerCase();
      if (authStatus !== "reserved" && authStatus !== "settled") continue;
      const reserve = authorization.reserve && typeof authorization.reserve === "object" && !Array.isArray(authorization.reserve)
        ? authorization.reserve
        : null;
      const reserveStatus = String(reserve?.status ?? "").toLowerCase();
      if (reserveStatus !== "reserved" && reserveStatus !== "settled" && reserveStatus !== "voided") continue;
      const reserveId = typeof reserve?.reserveId === "string" ? reserve.reserveId.trim() : "";
      if (!reserveId) continue;
      const reserveAtRaw =
        (typeof reserve?.reservedAt === "string" && reserve.reservedAt.trim() !== "" ? reserve.reservedAt : null) ??
        (typeof authorization?.updatedAt === "string" && authorization.updatedAt.trim() !== "" ? authorization.updatedAt : null) ??
        (typeof row?.updatedAt === "string" && row.updatedAt.trim() !== "" ? row.updatedAt : null);
      if (!reserveAtRaw) continue;
      const reserveAtMs = Date.parse(reserveAtRaw);
      if (!Number.isFinite(reserveAtMs)) continue;
      if (new Date(reserveAtMs).toISOString().slice(0, 10) !== dayKey) continue;

      const amountCents = Number(row?.terms?.amountCents ?? authorization?.walletEscrow?.amountCents ?? 0);
      if (!Number.isSafeInteger(amountCents) || amountCents <= 0) continue;
      total += amountCents;
      if (!Number.isSafeInteger(total)) throw new Error("x402 daily authorized exposure overflow");
    }
    return total;
  }

  function buildSettldPayKeyset() {
    return buildSettldPayKeysetV1({
      activeKey: {
        keyId: store.serverSigner.keyId,
        publicKeyPem: store.serverSigner.publicKeyPem
      },
      fallbackKeys: settldPayFallbackKeysValue,
      refreshedAt: nowIso()
    });
  }

  const CANONICAL_MONEY_RAIL_PROVIDER_EVENT_TYPES = new Set(Object.values(MONEY_RAIL_PROVIDER_EVENT_TYPE));

  function normalizeMoneyRailModeValue(value, { fieldName = "moneyRailMode" } = {}) {
    const normalized = String(value ?? "").trim().toLowerCase();
    if (normalized === "" || normalized === "sandbox" || normalized === "stub" || normalized === "test") return "sandbox";
    if (normalized === "production" || normalized === "prod") return "production";
    throw new TypeError(`${fieldName} must be sandbox|production`);
  }

  function normalizeMoneyRailProviderConfigsInput(rawValue, { fallbackMode = "sandbox" } = {}) {
    let parsed = rawValue;
    if (parsed === null || parsed === undefined || parsed === "") return [];
    if (typeof parsed === "string") {
      try {
        parsed = JSON.parse(parsed);
      } catch (err) {
        throw new TypeError(`PROXY_MONEY_RAIL_PROVIDERS must be valid JSON: ${err?.message}`);
      }
    }
    let entries = [];
    if (Array.isArray(parsed)) {
      entries = parsed;
    } else if (parsed && typeof parsed === "object") {
      entries = Object.entries(parsed).map(([providerId, config]) => ({
        providerId,
        ...(config && typeof config === "object" && !Array.isArray(config) ? config : {})
      }));
    } else {
      throw new TypeError("PROXY_MONEY_RAIL_PROVIDERS must be an array or object");
    }

    const seenProviderIds = new Set();
    const normalizedEntries = [];
    for (let index = 0; index < entries.length; index += 1) {
      const item = entries[index];
      if (!item || typeof item !== "object" || Array.isArray(item)) {
        throw new TypeError(`money rail provider config at index ${index} must be an object`);
      }
      const providerId = typeof item.providerId === "string" && item.providerId.trim() !== "" ? item.providerId.trim() : null;
      if (!providerId) throw new TypeError(`money rail provider config at index ${index} requires providerId`);
      if (seenProviderIds.has(providerId)) throw new TypeError(`duplicate money rail providerId: ${providerId}`);
      seenProviderIds.add(providerId);

      const providerMode = normalizeMoneyRailModeValue(item.mode ?? fallbackMode, {
        fieldName: `money rail provider ${providerId}.mode`
      });
      const allowPayout = item.allowPayout !== false;
      const allowCollection = item.allowCollection !== false;
      const webhookSecret =
        typeof item.webhookSecret === "string" && item.webhookSecret.trim() !== "" ? item.webhookSecret.trim() : null;
      const requireSignedIngest = item.requireSignedIngest === true || webhookSecret !== null;
      const webhookSignatureToleranceSecondsRaw =
        item.webhookSignatureToleranceSeconds === null || item.webhookSignatureToleranceSeconds === undefined
          ? 300
          : Number(item.webhookSignatureToleranceSeconds);
      if (!Number.isSafeInteger(webhookSignatureToleranceSecondsRaw) || webhookSignatureToleranceSecondsRaw <= 0) {
        throw new TypeError(`money rail provider ${providerId}.webhookSignatureToleranceSeconds must be a positive safe integer`);
      }

      const statusMap = new Map();
      for (const canonicalType of CANONICAL_MONEY_RAIL_PROVIDER_EVENT_TYPES) statusMap.set(canonicalType, canonicalType);
      const statusMapInput =
        item.providerStatusMap && typeof item.providerStatusMap === "object" && !Array.isArray(item.providerStatusMap)
          ? item.providerStatusMap
          : {};
      for (const [providerStatusRaw, eventTypeRaw] of Object.entries(statusMapInput)) {
        const providerStatus = String(providerStatusRaw ?? "").trim().toLowerCase();
        if (!providerStatus) throw new TypeError(`providerStatusMap keys for ${providerId} must be non-empty strings`);
        const eventType = String(eventTypeRaw ?? "").trim().toLowerCase();
        if (!CANONICAL_MONEY_RAIL_PROVIDER_EVENT_TYPES.has(eventType)) {
          throw new TypeError(
            `providerStatusMap.${providerStatus} for ${providerId} must map to ${Array.from(CANONICAL_MONEY_RAIL_PROVIDER_EVENT_TYPES).join("|")}`
          );
        }
        statusMap.set(providerStatus, eventType);
      }

      normalizedEntries.push({
        providerId,
        mode: providerMode,
        allowPayout,
        allowCollection,
        providerStatusMap: statusMap,
        webhookSecret,
        requireSignedIngest,
        webhookSignatureToleranceSeconds: webhookSignatureToleranceSecondsRaw
      });
    }
    return normalizedEntries;
  }

  function normalizeMoneyRailProviderStatusValue(value) {
    if (value === null || value === undefined) return null;
    const normalized = String(value).trim().toLowerCase();
    return normalized || null;
  }

  function parseMoneyRailProviderSignatureHeader(value) {
    if (value === null || value === undefined || String(value).trim() === "") {
      throw new TypeError("x-proxy-provider-signature header is required");
    }
    const input = String(value);
    let timestamp = null;
    const signatures = [];
    for (const part of input.split(",")) {
      const [rawKey, rawVal] = part.split("=");
      const key = String(rawKey ?? "").trim().toLowerCase();
      const val = String(rawVal ?? "").trim();
      if (!key || !val) continue;
      if (key === "t") {
        const n = Number(val);
        if (!Number.isSafeInteger(n) || n <= 0) throw new TypeError("provider signature timestamp is invalid");
        timestamp = n;
      } else if (key === "v1") {
        signatures.push(val.toLowerCase());
      }
    }
    if (!Number.isSafeInteger(timestamp) || timestamp <= 0) throw new TypeError("provider signature missing timestamp");
    if (!signatures.length) throw new TypeError("provider signature missing v1 digest");
    return { timestamp, signatures };
  }

  function verifyMoneyRailProviderSignature({
    signatureHeader,
    rawBody,
    secret,
    toleranceSeconds = 300,
    nowAt = null
  } = {}) {
    if (typeof secret !== "string" || secret.trim() === "") throw new TypeError("provider webhook secret is required");
    const { timestamp, signatures } = parseMoneyRailProviderSignatureHeader(signatureHeader);
    const payload = `${timestamp}.${String(rawBody ?? "")}`;
    const expected = crypto.createHmac("sha256", secret).update(payload, "utf8").digest("hex");
    let matched = false;
    for (const candidate of signatures) {
      if (typeof candidate !== "string" || !candidate) continue;
      if (candidate.length !== expected.length) continue;
      if (crypto.timingSafeEqual(Buffer.from(candidate, "utf8"), Buffer.from(expected, "utf8"))) {
        matched = true;
        break;
      }
    }
    if (!matched) throw new TypeError("provider signature digest mismatch");

    const tolerance = Number(toleranceSeconds);
    if (Number.isSafeInteger(tolerance) && tolerance > 0) {
      const nowMs = Date.parse(nowAt ?? nowIso());
      if (Number.isFinite(nowMs)) {
        const delta = Math.abs(Math.floor(nowMs / 1000) - timestamp);
        if (delta > tolerance) throw new TypeError("provider signature timestamp outside tolerance window");
      }
    }
  }

  const moneyRailModeRaw =
    moneyRailMode ?? (typeof process !== "undefined" && process.env.PROXY_MONEY_RAIL_MODE ? process.env.PROXY_MONEY_RAIL_MODE : null);
  const effectiveMoneyRailMode = normalizeMoneyRailModeValue(moneyRailModeRaw ?? "sandbox");
  const moneyRailProviderConfigsRaw =
    moneyRailProviderConfigs ??
    (typeof process !== "undefined" && typeof process.env.PROXY_MONEY_RAIL_PROVIDERS === "string" ? process.env.PROXY_MONEY_RAIL_PROVIDERS : null);
  const parsedMoneyRailProviderConfigs = normalizeMoneyRailProviderConfigsInput(moneyRailProviderConfigsRaw, {
    fallbackMode: effectiveMoneyRailMode
  });
  if (effectiveMoneyRailMode === "production" && parsedMoneyRailProviderConfigs.length === 0) {
    throw new TypeError("production money rail mode requires configured providers");
  }

  const defaultMoneyRailProviderId =
    typeof moneyRailDefaultProviderId === "string" && moneyRailDefaultProviderId.trim() !== ""
      ? moneyRailDefaultProviderId.trim()
      : typeof process !== "undefined" && typeof process.env.PROXY_MONEY_RAIL_PROVIDER_ID === "string" && process.env.PROXY_MONEY_RAIL_PROVIDER_ID.trim() !== ""
        ? process.env.PROXY_MONEY_RAIL_PROVIDER_ID.trim()
        : parsedMoneyRailProviderConfigs[0]?.providerId ?? "stub_default";

  const fallbackProviderStatusMap = new Map();
  for (const canonicalType of CANONICAL_MONEY_RAIL_PROVIDER_EVENT_TYPES) fallbackProviderStatusMap.set(canonicalType, canonicalType);
  const moneyRailProviderConfigById = new Map(
    parsedMoneyRailProviderConfigs.map((config) => [
      config.providerId,
      {
        providerId: config.providerId,
        mode: config.mode,
        allowPayout: config.allowPayout,
        allowCollection: config.allowCollection,
        providerStatusMap: new Map(config.providerStatusMap),
        webhookSecret: config.webhookSecret ?? null,
        requireSignedIngest: config.requireSignedIngest === true,
        webhookSignatureToleranceSeconds: Number.isSafeInteger(config.webhookSignatureToleranceSeconds)
          ? config.webhookSignatureToleranceSeconds
          : 300
      }
    ])
  );
  if (!moneyRailProviderConfigById.has(defaultMoneyRailProviderId)) {
    if (effectiveMoneyRailMode === "production") {
      throw new TypeError("default production money rail provider must be configured");
    }
    moneyRailProviderConfigById.set(defaultMoneyRailProviderId, {
      providerId: defaultMoneyRailProviderId,
      mode: effectiveMoneyRailMode,
      allowPayout: true,
      allowCollection: true,
      providerStatusMap: new Map(fallbackProviderStatusMap),
      webhookSecret: null,
      requireSignedIngest: false,
      webhookSignatureToleranceSeconds: 300
    });
  }
  if (effectiveMoneyRailMode === "production" && String(defaultMoneyRailProviderId).toLowerCase().startsWith("stub")) {
    throw new TypeError("production money rail mode cannot use a stub provider");
  }

  const moneyRailAdapters = createMoneyRailAdapterRegistry({
    adapters: Array.from(moneyRailProviderConfigById.values()).map((config) =>
      createStoreBackedMoneyRailAdapter({ providerId: config.providerId, store, now: nowIso })
    )
  });

  try {
    if (!store.moneyRailAdapters || typeof store.moneyRailAdapters !== "object") {
      store.moneyRailAdapters = moneyRailAdapters;
    }
  } catch {
    // ignore
  }

  const metrics = store?.metrics && typeof store.metrics.incCounter === "function" ? store.metrics : createMetrics();
  try {
    store.metrics = metrics;
  } catch {}

  const secrets = store?.secrets && typeof store.secrets.getSecret === "function" ? store.secrets : createSecretsProvider();
  try {
    store.secrets = secrets;
  } catch {}

  function metricInc(name, labels, value = 1) {
    try {
      metrics.incCounter(name, labels, value);
    } catch {}
  }

  function metricGauge(name, labels, value) {
    try {
      metrics.setGauge(name, labels, value);
    } catch {}
  }

  const knownOutboxKindsForGauge = new Set();
  const knownDeliveryDlqDestinationsForGauge = new Set();

  async function refreshOutboxPendingGauges() {
    const counts = new Map();

    if (store?.kind === "pg" && store?.pg?.pool) {
      try {
        const res = await store.pg.pool.query("SELECT topic, COUNT(*)::bigint AS count FROM outbox WHERE processed_at IS NULL GROUP BY topic");
        for (const row of res.rows) {
          const kind = row?.topic ? String(row.topic) : null;
          if (!kind) continue;
          const n = Number(row.count);
          counts.set(kind, Number.isFinite(n) ? n : 0);
        }
      } catch {
        // ignore
      }
    } else if (Array.isArray(store?.outbox)) {
      const cursor = Number.isSafeInteger(store?.outboxCursor) ? store.outboxCursor : 0;
      for (let i = cursor; i < store.outbox.length; i += 1) {
        const msg = store.outbox[i];
        const kind = msg?.type ? String(msg.type) : null;
        if (!kind) continue;
        counts.set(kind, (counts.get(kind) ?? 0) + 1);
      }
    }

    for (const kind of counts.keys()) knownOutboxKindsForGauge.add(kind);
    for (const kind of knownOutboxKindsForGauge) metricGauge("outbox_pending_gauge", { kind }, 0);
    for (const [kind, count] of counts.entries()) metricGauge("outbox_pending_gauge", { kind }, count);
  }

  function parseTopReasonCodesFromMetrics({ metricPrefix, snapshot, topN = 10 } = {}) {
    const out = new Map(); // reason -> count
    if (!snapshot || typeof snapshot !== "object") return [];
    const counters = snapshot.counters ?? {};
    if (!counters || typeof counters !== "object") return [];
    for (const [k, vRaw] of Object.entries(counters)) {
      if (typeof k !== "string" || !k.startsWith(`${metricPrefix}|`)) continue;
      const idx = k.indexOf("reason=");
      if (idx === -1) continue;
      const reason = k.slice(idx + "reason=".length).trim();
      if (!reason) continue;
      const v = Number(vRaw);
      if (!Number.isFinite(v) || v <= 0) continue;
      out.set(reason, (out.get(reason) ?? 0) + v);
    }
    const rows = Array.from(out.entries()).map(([reason, count]) => ({ reason, count }));
    rows.sort((a, b) => b.count - a.count || a.reason.localeCompare(b.reason));
    return rows.slice(0, Math.max(0, Math.min(50, Number(topN) || 0)));
  }

  async function computeOpsBacklogSummary({ tenantId, includeOutbox = true } = {}) {
    const outboxByKind = includeOutbox ? {} : null;
    let deliveriesPending = 0;
    let deliveriesFailed = 0;
    let ingestRejected = 0;
    const deliveryDlqTopDestinations = [];

    if (store?.kind === "pg" && store?.pg?.pool) {
      if (includeOutbox) {
        try {
          const res = await store.pg.pool.query("SELECT topic, COUNT(*)::bigint AS count FROM outbox WHERE processed_at IS NULL GROUP BY topic");
          for (const row of res.rows ?? []) {
            const kind = row?.topic ? String(row.topic) : null;
            if (!kind) continue;
            const n = Number(row?.count ?? 0);
            outboxByKind[kind] = Number.isFinite(n) ? n : 0;
          }
        } catch {}
      }

      try {
        const res = await store.pg.pool.query(
          "SELECT state, COUNT(*)::bigint AS count FROM deliveries WHERE tenant_id = $1 AND state IN ('pending','failed') GROUP BY state",
          [tenantId]
        );
        for (const row of res.rows ?? []) {
          const state = row?.state ? String(row.state) : "";
          const n = Number(row?.count ?? 0);
          const count = Number.isFinite(n) ? n : 0;
          if (state === "pending") deliveriesPending = count;
          if (state === "failed") deliveriesFailed = count;
        }
      } catch {}

      // DLQ visibility: top destinations by failed delivery count (bounded to avoid high-cardinality).
      try {
        const res = await store.pg.pool.query(
          `
            SELECT destination_id, COUNT(*)::bigint AS count
            FROM deliveries
            WHERE tenant_id = $1 AND state = 'failed'
            GROUP BY destination_id
            ORDER BY COUNT(*) DESC, destination_id ASC
            LIMIT 10
          `,
          [tenantId]
        );
        for (const row of res.rows ?? []) {
          const destinationId = row?.destination_id ? String(row.destination_id) : null;
          if (!destinationId) continue;
          const n = Number(row?.count ?? 0);
          deliveryDlqTopDestinations.push({ destinationId, count: Number.isFinite(n) ? n : 0 });
        }
      } catch {}

      try {
        const res = await store.pg.pool.query("SELECT COUNT(*)::bigint AS count FROM ingest_records WHERE tenant_id = $1 AND status = 'rejected'", [tenantId]);
        const n = Number(res.rows?.[0]?.count ?? 0);
        ingestRejected = Number.isFinite(n) ? n : 0;
      } catch {}
    } else {
      if (includeOutbox) {
        const counts = new Map();
        const cursor = Number.isSafeInteger(store?.outboxCursor) ? store.outboxCursor : 0;
        for (let i = cursor; i < (store?.outbox?.length ?? 0); i += 1) {
          const msg = store.outbox[i];
          const kind = msg?.type ? String(msg.type) : null;
          if (!kind) continue;
          counts.set(kind, (counts.get(kind) ?? 0) + 1);
        }
        for (const [kind, count] of counts.entries()) outboxByKind[kind] = count;
      }

      if (store?.deliveries instanceof Map) {
        const byDestination = new Map();
        for (const d of store.deliveries.values()) {
          if (!d || typeof d !== "object") continue;
          const state = d.state ?? null;
          if (state === "pending") deliveriesPending += 1;
          if (state === "failed") {
            deliveriesFailed += 1;
            const destId = d.destinationId ? String(d.destinationId) : null;
            if (destId) byDestination.set(destId, (byDestination.get(destId) ?? 0) + 1);
          }
        }
        const rows = Array.from(byDestination.entries()).map(([destinationId, count]) => ({ destinationId, count }));
        rows.sort((a, b) => b.count - a.count || a.destinationId.localeCompare(b.destinationId));
        deliveryDlqTopDestinations.push(...rows.slice(0, 10));
      }

      if (store?.ingestRecords instanceof Map) {
        for (const r of store.ingestRecords.values()) {
          if (r?.status === "rejected") ingestRejected += 1;
        }
      }
    }

    return {
      outboxByKind: includeOutbox ? outboxByKind : null,
      deliveriesPending,
      deliveriesFailed,
      ingestRejected,
      deliveryDlqTopDestinations
    };
  }

  const COMMAND_CENTER_ALERT_ARTIFACT_TYPE = "CommandCenterAlert.v1";
  const RECONCILE_REPORT_ARTIFACT_TYPE = "ReconcileReport.v1";
  const MONEY_RAIL_RECONCILE_REPORT_ARTIFACT_TYPE = "MoneyRailReconcileReport.v1";
  const BILLING_PERIOD_CLOSE_ARTIFACT_TYPE = "BillingPeriodClose.v1";
  const BILLING_STRIPE_CHECKOUT_SESSION_SCHEMA = "BillingStripeCheckoutSession.v1";
  const BILLING_STRIPE_PORTAL_SESSION_SCHEMA = "BillingStripePortalSession.v1";
  const COMMAND_CENTER_ALERT_DEFAULT_THRESHOLDS = Object.freeze({
    httpClientErrorRateThresholdPct: 1,
    httpServerErrorRateThresholdPct: 1,
    deliveryDlqThreshold: 1,
    disputeOverSlaThreshold: 1,
    determinismRejectThreshold: 1,
    kernelVerificationErrorThreshold: 1
  });

  function parseBooleanQueryValue(raw, { defaultValue = false, name = "query parameter" } = {}) {
    if (raw === null || raw === undefined || String(raw).trim() === "") return Boolean(defaultValue);
    const value = String(raw).trim().toLowerCase();
    if (value === "1" || value === "true" || value === "yes") return true;
    if (value === "0" || value === "false" || value === "no") return false;
    throw new TypeError(`${name} must be boolean`);
  }

  function parseThresholdIntegerQueryValue(raw, { defaultValue = 0, min = 0, max = null, name = "query parameter" } = {}) {
    if (raw === null || raw === undefined || String(raw).trim() === "") return Number(defaultValue);
    const value = Number(raw);
    if (!Number.isSafeInteger(value)) throw new TypeError(`${name} must be an integer`);
    if (value < min) throw new TypeError(`${name} must be >= ${min}`);
    if (Number.isFinite(max) && value > max) throw new TypeError(`${name} must be <= ${max}`);
    return value;
  }

  function parseThresholdNumberQueryValue(raw, { defaultValue = 0, min = 0, max = null, name = "query parameter" } = {}) {
    if (raw === null || raw === undefined || String(raw).trim() === "") return Number(defaultValue);
    const value = Number(raw);
    if (!Number.isFinite(value)) throw new TypeError(`${name} must be numeric`);
    if (value < min) throw new TypeError(`${name} must be >= ${min}`);
    if (Number.isFinite(max) && value > max) throw new TypeError(`${name} must be <= ${max}`);
    return value;
  }

  function evaluateNetworkCommandCenterAlerts({ commandCenter, thresholds } = {}) {
    const summary =
      commandCenter && typeof commandCenter === "object" && !Array.isArray(commandCenter) ? commandCenter : {};
    const effectiveThresholds =
      thresholds && typeof thresholds === "object" && !Array.isArray(thresholds)
        ? thresholds
        : COMMAND_CENTER_ALERT_DEFAULT_THRESHOLDS;
    const alerts = [];

    const pushAlert = ({ alertType, severity, metric, currentValue, threshold, comparator = ">=", message = null, dimensions = null }) => {
      const normalizedDimensions =
        dimensions && typeof dimensions === "object" && !Array.isArray(dimensions)
          ? normalizeForCanonicalJson(dimensions, { path: "$.dimensions" })
          : null;
      const payload = {
        schemaVersion: COMMAND_CENTER_ALERT_ARTIFACT_TYPE,
        alertType: String(alertType),
        severity: String(severity),
        metric: String(metric),
        comparator: String(comparator),
        currentValue: Number(currentValue),
        threshold: Number(threshold),
        message: typeof message === "string" && message.trim() !== "" ? message.trim() : `${metric} ${comparator} ${threshold}`
      };
      if (normalizedDimensions) payload.dimensions = normalizedDimensions;
      alerts.push(normalizeForCanonicalJson(payload, { path: "$" }));
    };

    const httpClientErrorRatePct = Number(summary?.reliability?.httpClientErrorRatePct ?? 0);
    const httpServerErrorRatePct = Number(summary?.reliability?.httpServerErrorRatePct ?? 0);
    const deliveriesFailed = Number(summary?.reliability?.backlog?.deliveriesFailed ?? 0);
    const disputeOverSlaCount = Number(summary?.disputes?.overSlaCount ?? 0);
    const disputeSlaHours = Number(summary?.disputes?.slaHours ?? 24);
    const overSlaCases = Array.isArray(summary?.disputes?.overSlaCases) ? summary.disputes.overSlaCases : [];
    const determinismSensitiveRejects = Number(summary?.determinism?.determinismSensitiveRejects ?? 0);
    const kernelVerificationErrorCount = Number(summary?.settlement?.kernelVerificationErrorCount ?? 0);
    const kernelVerificationErrorCountsByCode = Array.isArray(summary?.settlement?.kernelVerificationErrorCountsByCode)
      ? summary.settlement.kernelVerificationErrorCountsByCode
      : [];

    if (httpClientErrorRatePct >= Number(effectiveThresholds.httpClientErrorRateThresholdPct)) {
      pushAlert({
        alertType: "http_client_error_rate_high",
        severity: "high",
        metric: "reliability.httpClientErrorRatePct",
        currentValue: httpClientErrorRatePct,
        threshold: Number(effectiveThresholds.httpClientErrorRateThresholdPct)
      });
    }
    if (httpServerErrorRatePct >= Number(effectiveThresholds.httpServerErrorRateThresholdPct)) {
      pushAlert({
        alertType: "http_server_error_rate_high",
        severity: "critical",
        metric: "reliability.httpServerErrorRatePct",
        currentValue: httpServerErrorRatePct,
        threshold: Number(effectiveThresholds.httpServerErrorRateThresholdPct)
      });
    }
    if (deliveriesFailed >= Number(effectiveThresholds.deliveryDlqThreshold)) {
      pushAlert({
        alertType: "delivery_dlq_backlog_high",
        severity: "high",
        metric: "reliability.backlog.deliveriesFailed",
        currentValue: deliveriesFailed,
        threshold: Number(effectiveThresholds.deliveryDlqThreshold)
      });
    }
    if (disputeOverSlaCount >= Number(effectiveThresholds.disputeOverSlaThreshold)) {
      pushAlert({
        alertType: "disputes_over_sla_high",
        severity: "high",
        metric: "disputes.overSlaCount",
        currentValue: disputeOverSlaCount,
        threshold: Number(effectiveThresholds.disputeOverSlaThreshold)
      });
    }
    const disputeSlaSeconds =
      Number.isFinite(disputeSlaHours) && disputeSlaHours > 0 ? Math.round(disputeSlaHours * 60 * 60) : 24 * 60 * 60;
    for (const overSlaCase of overSlaCases.slice(0, 25)) {
      const caseId = typeof overSlaCase?.caseId === "string" && overSlaCase.caseId.trim() !== "" ? overSlaCase.caseId.trim() : null;
      if (!caseId) continue;
      const ageSecondsRaw = Number(overSlaCase?.ageSeconds);
      const ageSeconds = Number.isFinite(ageSecondsRaw) && ageSecondsRaw >= 0 ? Math.round(ageSecondsRaw) : disputeSlaSeconds + 1;
      pushAlert({
        alertType: "dispute_case_over_sla",
        severity: "high",
        metric: "disputes.overSlaCase.ageSeconds",
        comparator: ">",
        currentValue: ageSeconds,
        threshold: disputeSlaSeconds,
        message: `dispute case ${caseId} over SLA`,
        dimensions: {
          caseId,
          runId: overSlaCase?.runId ?? null,
          disputeId: overSlaCase?.disputeId ?? null,
          priority: overSlaCase?.priority ?? null,
          status: overSlaCase?.status ?? null
        }
      });
    }
    if (determinismSensitiveRejects >= Number(effectiveThresholds.determinismRejectThreshold)) {
      pushAlert({
        alertType: "determinism_sensitive_rejects_high",
        severity: "critical",
        metric: "determinism.determinismSensitiveRejects",
        currentValue: determinismSensitiveRejects,
        threshold: Number(effectiveThresholds.determinismRejectThreshold)
      });
    }
    if (kernelVerificationErrorCount >= Number(effectiveThresholds.kernelVerificationErrorThreshold)) {
      pushAlert({
        alertType: "settlement_kernel_verification_errors_high",
        severity: "critical",
        metric: "settlement.kernelVerificationErrorCount",
        currentValue: kernelVerificationErrorCount,
        threshold: Number(effectiveThresholds.kernelVerificationErrorThreshold)
      });
    }
    for (const codeRow of kernelVerificationErrorCountsByCode.slice(0, 25)) {
      const code = typeof codeRow?.code === "string" && codeRow.code.trim() !== "" ? codeRow.code.trim() : null;
      if (!code) continue;
      const count = Number(codeRow?.count ?? 0);
      if (!Number.isFinite(count) || count < Number(effectiveThresholds.kernelVerificationErrorThreshold)) continue;
      pushAlert({
        alertType: "settlement_kernel_verification_error_code",
        severity: "critical",
        metric: `settlement.kernelVerificationErrorCountsByCode.${code}`,
        currentValue: Math.round(count),
        threshold: Number(effectiveThresholds.kernelVerificationErrorThreshold),
        message: `settlement kernel verification errors for code ${code}`,
        dimensions: { code }
      });
    }

    return alerts;
  }

  async function emitCommandCenterAlertArtifacts({ tenantId, commandCenter, thresholds, alerts } = {}) {
    if (!Array.isArray(alerts) || alerts.length === 0) return [];
    if (typeof store.putArtifact !== "function" || typeof store.createDelivery !== "function") return [];

    const t = normalizeTenant(tenantId);
    const generatedAt =
      commandCenter && typeof commandCenter.generatedAt === "string" && Number.isFinite(Date.parse(commandCenter.generatedAt))
        ? commandCenter.generatedAt
        : nowIso();
    const generatedAtMs = Date.parse(generatedAt);
    const bucketMs = Number.isFinite(generatedAtMs) ? Math.floor(generatedAtMs / (15 * 60 * 1000)) * (15 * 60 * 1000) : Date.now();
    const bucketStartAt = new Date(bucketMs).toISOString();

    const destinations = listDestinationsForTenant(t).filter((destination) => {
      const allowed = Array.isArray(destination?.artifactTypes) && destination.artifactTypes.length ? destination.artifactTypes : null;
      return !allowed || allowed.includes(COMMAND_CENTER_ALERT_ARTIFACT_TYPE);
    });

    const emitted = [];
    for (const alert of alerts) {
      const identityHash = sha256Hex(
        canonicalJsonStringify(
          normalizeForCanonicalJson(
            {
              tenantId: t,
              alertType: alert?.alertType ?? null,
              severity: alert?.severity ?? null,
              metric: alert?.metric ?? null,
              threshold: alert?.threshold ?? null,
              currentValue: alert?.currentValue ?? null,
              dimensions: alert?.dimensions ?? null,
              bucketStartAt
            },
            { path: "$" }
          )
        )
      );
      const artifactId = `cc_alert_${String(alert?.alertType ?? "alert").replaceAll(/[^a-zA-Z0-9_-]/g, "_")}_${identityHash.slice(0, 24)}`;
      const artifactBody = normalizeForCanonicalJson(
        {
          schemaVersion: COMMAND_CENTER_ALERT_ARTIFACT_TYPE,
          artifactType: COMMAND_CENTER_ALERT_ARTIFACT_TYPE,
          artifactId,
          tenantId: t,
          generatedAt,
          bucketStartAt,
          thresholds: thresholds ?? COMMAND_CENTER_ALERT_DEFAULT_THRESHOLDS,
          alert: alert ?? null,
          commandCenter: commandCenter ?? null
        },
        { path: "$" }
      );
      const artifactHash = computeArtifactHash(artifactBody);
      const artifact = { ...artifactBody, artifactHash };
      let storedArtifact = artifact;
      try {
        await store.putArtifact({ tenantId: t, artifact });
      } catch (err) {
        if (err?.code !== "ARTIFACT_HASH_MISMATCH") throw err;
        if (typeof store.getArtifact !== "function") throw err;
        const existing = await store.getArtifact({ tenantId: t, artifactId });
        if (!existing || typeof existing?.artifactHash !== "string" || existing.artifactHash.trim() === "") throw err;
        storedArtifact = existing;
      }

      let deliveriesCreated = 0;
      for (const destination of destinations) {
        const resolvedArtifactHash = String(storedArtifact.artifactHash);
        const dedupeKey = `${t}:${destination.destinationId}:${COMMAND_CENTER_ALERT_ARTIFACT_TYPE}:${artifactId}:${resolvedArtifactHash}`;
        const scopeKey = `command_center_alert:${String(alert?.alertType ?? "alert")}`;
        const orderSeq = bucketMs;
        const priority = 95;
        const orderKey = `${scopeKey}\n${String(orderSeq)}\n${String(priority)}\n${artifactId}`;
        try {
          await store.createDelivery({
            tenantId: t,
            delivery: {
              destinationId: destination.destinationId,
              artifactType: COMMAND_CENTER_ALERT_ARTIFACT_TYPE,
              artifactId,
              artifactHash: resolvedArtifactHash,
              dedupeKey,
              scopeKey,
              orderSeq,
              priority,
              orderKey
            }
          });
          deliveriesCreated += 1;
        } catch (err) {
          if (err?.code === "DELIVERY_DEDUPE_CONFLICT") continue;
          throw err;
        }
      }

      emitted.push({
        alertType: String(alert?.alertType ?? "alert"),
        severity: String(alert?.severity ?? "high"),
        artifactId,
        artifactHash: String(storedArtifact.artifactHash),
        deliveriesCreated
      });
    }
    return emitted;
  }

  function readMetricLabelValue(metricKey, label) {
    if (typeof metricKey !== "string" || typeof label !== "string" || !label) return null;
    const prefix = `${label}=`;
    const parts = metricKey.split("|");
    for (const part of parts) {
      if (typeof part === "string" && part.startsWith(prefix)) return part.slice(prefix.length);
    }
    return null;
  }

  async function listAgentRunsForTenant({ tenantId } = {}) {
    const t = normalizeTenant(tenantId);
    if (typeof store.listAgentRuns === "function") {
      const pageSize = 1000;
      const out = [];
      let offset = 0;
      let page = 0;
      while (page < 200) {
        page += 1;
        const batch = await store.listAgentRuns({ tenantId: t, agentId: null, status: null, limit: pageSize, offset });
        if (!Array.isArray(batch) || batch.length === 0) break;
        out.push(...batch);
        if (batch.length < pageSize) break;
        offset += batch.length;
      }
      return out;
    }
    return listAgentRuns({ tenantId: t, agentId: null, status: null });
  }

  async function computeNetworkCommandCenterSummary({
    tenantId,
    transactionFeeBps = 100,
    windowHours = 24,
    disputeSlaHours = 24
  } = {}) {
    const t = normalizeTenant(tenantId);
    const nowAt = nowIso();
    const nowMs = Date.parse(nowAt);
    const safeWindowHours = Number.isSafeInteger(Number(windowHours)) && Number(windowHours) > 0 ? Number(windowHours) : 24;
    const safeDisputeSlaHours =
      Number.isSafeInteger(Number(disputeSlaHours)) && Number(disputeSlaHours) > 0 ? Number(disputeSlaHours) : 24;
    const safeTransactionFeeBps =
      Number.isSafeInteger(Number(transactionFeeBps)) && Number(transactionFeeBps) >= 0 && Number(transactionFeeBps) <= 5000
        ? Number(transactionFeeBps)
        : 100;
    const windowStartMs = Number.isFinite(nowMs) ? nowMs - safeWindowHours * 60 * 60 * 1000 : Number.NaN;

    const backlog = await computeOpsBacklogSummary({ tenantId: t, includeOutbox: true });
    const snapshot = (() => {
      try {
        return metrics.snapshot();
      } catch {
        return null;
      }
    })();

    let httpTotal = 0;
    let http4xx = 0;
    let http5xx = 0;
    if (snapshot && typeof snapshot === "object" && snapshot.counters && typeof snapshot.counters === "object") {
      for (const [metricKey, rawValue] of Object.entries(snapshot.counters)) {
        if (typeof metricKey !== "string" || !metricKey.startsWith("http_requests_total|")) continue;
        const value = Number(rawValue);
        if (!Number.isFinite(value) || value <= 0) continue;
        httpTotal += value;
        const statusRaw = readMetricLabelValue(metricKey, "status");
        const status = Number(statusRaw);
        if (Number.isFinite(status) && status >= 500) http5xx += value;
        else if (Number.isFinite(status) && status >= 400) http4xx += value;
      }
    }

    const appendRejectedTopReasons = parseTopReasonCodesFromMetrics({
      metricPrefix: "append_rejected_total",
      snapshot,
      topN: 10
    });
    const ingestRejectedTopReasons = parseTopReasonCodesFromMetrics({
      metricPrefix: "ingest_rejected_total",
      snapshot,
      topN: 10
    });
    const determinismSensitiveRejects = appendRejectedTopReasons.reduce((sum, row) => {
      const reason = String(row?.reason ?? "");
      const count = Number(row?.count ?? 0);
      if (!Number.isFinite(count) || count <= 0) return sum;
      if (/chain|payload.?hash|signature/i.test(reason)) return sum + count;
      return sum;
    }, 0);

    const runs = await listAgentRunsForTenant({ tenantId: t });
    const settlements = await listAgentRunSettlementsForRuns({ tenantId: t, runs });

    let resolvedCountInWindow = 0;
    let releasedAmountCentsInWindow = 0;
    let refundedAmountCentsInWindow = 0;
    let settlementAmountCentsInWindow = 0;
    let lockedCount = 0;
    let disputeOpenCount = 0;
    let disputeOpenedInWindow = 0;
    let disputeClosedInWindow = 0;
    let disputeOldestOpenAgeSeconds = 0;
    let disputeOverSlaCount = 0;
    let disputeExpiredWindowOpenCount = 0;
    let estimatedTransactionFeesCentsInWindow = 0;
    let kernelVerificationErrorCount = 0;
    const kernelVerificationErrorCounts = new Map();
    const settlementPriorityByRunId = new Map();

    for (const settlement of settlements) {
      if (!settlement || typeof settlement !== "object") continue;
      const settlementRunId = typeof settlement?.runId === "string" && settlement.runId.trim() !== "" ? settlement.runId.trim() : null;
      if (settlementRunId && !settlementPriorityByRunId.has(settlementRunId)) {
        settlementPriorityByRunId.set(
          settlementRunId,
          normalizeArbitrationCasePriority(settlement?.disputeContext?.priority, {
            fieldName: "settlement.disputeContext.priority",
            allowNull: true
          })
        );
      }
      const status = String(settlement.status ?? "").toLowerCase();
      if (status === AGENT_RUN_SETTLEMENT_STATUS.LOCKED) lockedCount += 1;

      const resolvedAtMs = settlement?.resolvedAt ? Date.parse(String(settlement.resolvedAt)) : Number.NaN;
      const inWindow = Number.isFinite(windowStartMs) && Number.isFinite(resolvedAtMs) && resolvedAtMs >= windowStartMs && resolvedAtMs <= nowMs;
      if (inWindow) {
        resolvedCountInWindow += 1;
        const released = Number(settlement.releasedAmountCents ?? 0);
        const refunded = Number(settlement.refundedAmountCents ?? 0);
        const amount = Number(settlement.amountCents ?? 0);
        if (Number.isFinite(released)) releasedAmountCentsInWindow += released;
        if (Number.isFinite(refunded)) refundedAmountCentsInWindow += refunded;
        if (Number.isFinite(amount)) settlementAmountCentsInWindow += amount;
        if (Number.isFinite(released) && safeTransactionFeeBps > 0) {
          estimatedTransactionFeesCentsInWindow += Math.floor((released * safeTransactionFeeBps) / 10000);
        }
      }

      const disputeStatus = String(settlement.disputeStatus ?? "").toLowerCase();
      const disputeOpenedAtMs = settlement?.disputeOpenedAt ? Date.parse(String(settlement.disputeOpenedAt)) : Number.NaN;
      const disputeClosedAtMs = settlement?.disputeClosedAt ? Date.parse(String(settlement.disputeClosedAt)) : Number.NaN;
      const disputeWindowEndsAtMs = settlement?.disputeWindowEndsAt ? Date.parse(String(settlement.disputeWindowEndsAt)) : Number.NaN;

      if (disputeStatus === AGENT_RUN_SETTLEMENT_DISPUTE_STATUS.OPEN) {
        disputeOpenCount += 1;
        const ageSeconds =
          Number.isFinite(disputeOpenedAtMs) && Number.isFinite(nowMs) ? Math.max(0, Math.floor((nowMs - disputeOpenedAtMs) / 1000)) : 0;
        if (ageSeconds > disputeOldestOpenAgeSeconds) disputeOldestOpenAgeSeconds = ageSeconds;
        if (ageSeconds > safeDisputeSlaHours * 60 * 60) disputeOverSlaCount += 1;
        if (Number.isFinite(disputeWindowEndsAtMs) && Number.isFinite(nowMs) && nowMs > disputeWindowEndsAtMs) {
          disputeExpiredWindowOpenCount += 1;
        }
      }
      if (Number.isFinite(windowStartMs) && Number.isFinite(disputeOpenedAtMs) && disputeOpenedAtMs >= windowStartMs && disputeOpenedAtMs <= nowMs) {
        disputeOpenedInWindow += 1;
      }
      if (Number.isFinite(windowStartMs) && Number.isFinite(disputeClosedAtMs) && disputeClosedAtMs >= windowStartMs && disputeClosedAtMs <= nowMs) {
        disputeClosedInWindow += 1;
      }

      const kernelVerification = verifySettlementKernelArtifacts({
        settlement,
        runId: settlementRunId ?? null
      });
      if (!kernelVerification?.valid) {
        const codes = Array.isArray(kernelVerification?.errors) ? kernelVerification.errors : [];
        for (const codeRaw of codes) {
          if (typeof codeRaw !== "string" || codeRaw.trim() === "") continue;
          const code = codeRaw.trim();
          kernelVerificationErrorCount += 1;
          kernelVerificationErrorCounts.set(code, (kernelVerificationErrorCounts.get(code) ?? 0) + 1);
        }
      }
    }

    const kernelVerificationErrorCountsByCode = Array.from(kernelVerificationErrorCounts.entries())
      .map(([code, count]) => ({
        code,
        count
      }))
      .sort((left, right) => {
        if (right.count !== left.count) return right.count - left.count;
        return String(left.code ?? "").localeCompare(String(right.code ?? ""));
      });

    const arbitrationOverSlaCases = [];
    try {
      const arbitrationCases = await listArbitrationCaseRecordsAll({ tenantId: t, pageSize: 1000 });
      for (const arbitrationCase of arbitrationCases) {
        if (!arbitrationCase || typeof arbitrationCase !== "object" || Array.isArray(arbitrationCase)) continue;
        try {
          const caseStatus = normalizeArbitrationCaseStatus(arbitrationCase.status ?? ARBITRATION_CASE_STATUS.OPEN, {
            fieldName: "arbitrationCase.status"
          });
          if (caseStatus === ARBITRATION_CASE_STATUS.CLOSED) continue;
          const openedAt = typeof arbitrationCase?.openedAt === "string" && arbitrationCase.openedAt.trim() !== ""
            ? arbitrationCase.openedAt.trim()
            : null;
          const openedAtMs = openedAt && Number.isFinite(Date.parse(openedAt)) ? Date.parse(openedAt) : Number.NaN;
          if (!Number.isFinite(openedAtMs) || !Number.isFinite(nowMs)) continue;
          const dueAtMs = openedAtMs + safeDisputeSlaHours * 60 * 60 * 1000;
          if (nowMs <= dueAtMs) continue;

          const runId = typeof arbitrationCase?.runId === "string" && arbitrationCase.runId.trim() !== "" ? arbitrationCase.runId.trim() : null;
          const disputePriority =
            normalizeArbitrationCasePriority(arbitrationCase?.priority, {
              fieldName: "arbitrationCase.priority",
              allowNull: true
            }) ??
            (runId && settlementPriorityByRunId.has(runId)
              ? settlementPriorityByRunId.get(runId) ?? null
              : null);

          arbitrationOverSlaCases.push({
            caseId: arbitrationCase.caseId ?? null,
            runId,
            disputeId: arbitrationCase.disputeId ?? null,
            status: caseStatus,
            arbiterAgentId: arbitrationCase.arbiterAgentId ?? null,
            openedAt,
            dueAt: new Date(dueAtMs).toISOString(),
            ageSeconds: Math.max(0, Math.floor((nowMs - openedAtMs) / 1000)),
            ageHours: Number(((nowMs - openedAtMs) / (60 * 60 * 1000)).toFixed(2)),
            priority: disputePriority
          });
        } catch {
          continue;
        }
      }
      arbitrationOverSlaCases.sort((left, right) => {
        const leftAge = Number(left?.ageSeconds ?? 0);
        const rightAge = Number(right?.ageSeconds ?? 0);
        if (leftAge !== rightAge) return rightAge - leftAge;
        return String(left?.caseId ?? "").localeCompare(String(right?.caseId ?? ""));
      });
    } catch {
      // Arbitration case SLA detail is best-effort.
    }

    let totalAgents = 0;
    let activeAgents = 0;
    let trustSampledAgents = 0;
    let trustScoreTotal = 0;
    try {
      const identities = typeof store.listAgentIdentities === "function"
        ? await store.listAgentIdentities({ tenantId: t, status: null, limit: 5000, offset: 0 })
        : listAgentIdentities({ tenantId: t, status: null });
      totalAgents = Array.isArray(identities) ? identities.length : 0;
      const active = (Array.isArray(identities) ? identities : []).filter(
        (identity) => String(identity?.status ?? "active").toLowerCase() === "active"
      );
      activeAgents = active.length;
      const trustCandidates = active.slice(0, 100);
      for (const identity of trustCandidates) {
        const agentId = typeof identity?.agentId === "string" ? identity.agentId : null;
        if (!agentId) continue;
        const reputation = await computeAgentReputationSnapshotVersioned({
          tenantId: t,
          agentId,
          at: nowAt,
          reputationVersion: "v2",
          reputationWindow: AGENT_REPUTATION_WINDOW.THIRTY_DAYS
        });
        const trustScore = Number(reputation?.trustScore ?? Number.NaN);
        if (!Number.isFinite(trustScore)) continue;
        trustSampledAgents += 1;
        trustScoreTotal += trustScore;
      }
    } catch {
      // trust summary is best-effort.
    }

    let currentPlatformRevenueCents = null;
    try {
      if (store?.ledger?.balances instanceof Map) {
        const raw = Number(store.ledger.balances.get("acct_platform_revenue"));
        if (Number.isFinite(raw)) {
          const rounded = Math.round(-raw);
          currentPlatformRevenueCents = Object.is(rounded, -0) ? 0 : rounded;
        }
      }
    } catch {
      // best-effort for non-ledger stores.
    }

    return {
      generatedAt: nowAt,
      freshness: {
        maxAgeSeconds: 15 * 60,
        generatedWithinSla: true
      },
      reliability: {
        httpRequestsTotal: Math.round(httpTotal),
        http4xxTotal: Math.round(http4xx),
        http5xxTotal: Math.round(http5xx),
        httpClientErrorRatePct: httpTotal > 0 ? Number(((http4xx / httpTotal) * 100).toFixed(2)) : 0,
        httpServerErrorRatePct: httpTotal > 0 ? Number(((http5xx / httpTotal) * 100).toFixed(2)) : 0,
        backlog
      },
      determinism: {
        appendRejectedTopReasons,
        ingestRejectedTopReasons,
        determinismSensitiveRejects: Math.round(determinismSensitiveRejects)
      },
      settlement: {
        windowHours: safeWindowHours,
        resolvedCount: resolvedCountInWindow,
        lockedCount,
        settlementAmountCents: settlementAmountCentsInWindow,
        releasedAmountCents: releasedAmountCentsInWindow,
        refundedAmountCents: refundedAmountCentsInWindow,
        kernelVerificationErrorCount: Math.round(kernelVerificationErrorCount),
        kernelVerificationErrorCountsByCode
      },
      disputes: {
        slaHours: safeDisputeSlaHours,
        openCount: disputeOpenCount,
        openedCountInWindow: disputeOpenedInWindow,
        closedCountInWindow: disputeClosedInWindow,
        oldestOpenAgeSeconds: disputeOldestOpenAgeSeconds,
        overSlaCount: disputeOverSlaCount,
        expiredWindowOpenCount: disputeExpiredWindowOpenCount,
        arbitrationOverSlaCount: arbitrationOverSlaCases.length,
        overSlaCases: arbitrationOverSlaCases.slice(0, 50)
      },
      revenue: {
        transactionFeeBps: safeTransactionFeeBps,
        estimatedTransactionFeesCentsInWindow,
        currentPlatformRevenueCents
      },
      trust: {
        totalAgents,
        activeAgents,
        sampledAgents: trustSampledAgents,
        averageTrustScore: trustSampledAgents > 0 ? Number((trustScoreTotal / trustSampledAgents).toFixed(2)) : null
      }
    };
  }

  async function fetchMaintenanceRetentionRunInfo({ tenantId }) {
    if (typeof store.listOpsAudit !== "function") return { last: null, lastOk: null };
    try {
      const records = await store.listOpsAudit({ tenantId, limit: 200, offset: 0 });
      let last = null;
      let lastOk = null;
      for (const r of records ?? []) {
        if (!r || typeof r !== "object") continue;
        if (r.action !== "MAINTENANCE_RETENTION_RUN") continue;
        if (!last) last = r;
        const outcome = r?.details?.outcome ?? null;
        if (!lastOk && outcome === "ok") lastOk = r;
        if (last && lastOk) break;
      }
      return { last, lastOk };
    } catch {
      return { last: null, lastOk: null };
    }
  }

  async function fetchMaintenanceFinanceReconcileRunInfo({ tenantId }) {
    if (typeof store.listOpsAudit !== "function") return { last: null, lastOk: null };
    try {
      const records = await store.listOpsAudit({ tenantId, limit: 200, offset: 0 });
      let last = null;
      let lastOk = null;
      for (const r of records ?? []) {
        if (!r || typeof r !== "object") continue;
        if (r.action !== "MAINTENANCE_FINANCE_RECONCILE_RUN") continue;
        if (!last) last = r;
        const outcome = r?.details?.outcome ?? null;
        if (!lastOk && outcome === "ok") lastOk = r;
        if (last && lastOk) break;
      }
      return { last, lastOk };
    } catch {
      return { last: null, lastOk: null };
    }
  }

  async function fetchMaintenanceMoneyRailReconcileRunInfo({ tenantId }) {
    if (typeof store.listOpsAudit !== "function") return { last: null, lastOk: null };
    try {
      const records = await store.listOpsAudit({ tenantId, limit: 200, offset: 0 });
      let last = null;
      let lastOk = null;
      for (const r of records ?? []) {
        if (!r || typeof r !== "object") continue;
        if (r.action !== "MAINTENANCE_MONEY_RAIL_RECONCILE_RUN") continue;
        if (!last) last = r;
        const outcome = r?.details?.outcome ?? null;
        if (!lastOk && outcome === "ok") lastOk = r;
        if (last && lastOk) break;
      }
      return { last, lastOk };
    } catch {
      return { last: null, lastOk: null };
    }
  }

	  async function refreshAlertGauges({ tenantId }) {
	    await refreshOutboxPendingGauges();

	    const backlog = await computeOpsBacklogSummary({ tenantId, includeOutbox: true });
	    metricGauge("deliveries_pending_gauge", { state: "pending" }, Number(backlog?.deliveriesPending ?? 0));
	    metricGauge("deliveries_pending_gauge", { state: "failed" }, Number(backlog?.deliveriesFailed ?? 0));
	    metricGauge("ingest_rejected_gauge", null, Number(backlog?.ingestRejected ?? 0));
	    metricGauge("delivery_dlq_pending_total_gauge", null, Number(backlog?.deliveriesFailed ?? 0));
    metricGauge("worker_deliveries_pending_total_gauge", null, Number(backlog?.deliveriesPending ?? 0));
    const outboxByKindForGauge =
      backlog?.outboxByKind && typeof backlog.outboxByKind === "object" && !Array.isArray(backlog.outboxByKind)
        ? backlog.outboxByKind
        : null;
    const outboxPendingTotal = outboxByKindForGauge
      ? Object.values(outboxByKindForGauge).reduce((sum, raw) => {
          const n = Number(raw);
          return sum + (Number.isFinite(n) ? n : 0);
        }, 0)
      : 0;
    metricGauge("worker_outbox_pending_total_gauge", null, outboxPendingTotal);

    const topDlq = Array.isArray(backlog?.deliveryDlqTopDestinations) ? backlog.deliveryDlqTopDestinations : [];
    for (const row of topDlq) {
      if (!row?.destinationId) continue;
      knownDeliveryDlqDestinationsForGauge.add(String(row.destinationId));
    }
    for (const destinationId of knownDeliveryDlqDestinationsForGauge) {
      metricGauge("delivery_dlq_pending_by_destination_gauge", { destinationId }, 0);
    }
	    for (const row of topDlq) {
	      const destinationId = row?.destinationId ? String(row.destinationId) : null;
	      if (!destinationId) continue;
	      const n = Number(row?.count ?? 0);
	      metricGauge("delivery_dlq_pending_by_destination_gauge", { destinationId }, Number.isFinite(n) ? n : 0);
	    }

    try {
      const commandCenter = await computeNetworkCommandCenterSummary({
        tenantId,
        windowHours: 24,
        disputeSlaHours: 24
      });
      metricGauge("replay_mismatch_gauge", null, Number(commandCenter?.settlement?.kernelVerificationErrorCount ?? 0));
      metricGauge("disputes_open_gauge", null, Number(commandCenter?.disputes?.openCount ?? 0));
      metricGauge("disputes_over_sla_gauge", null, Number(commandCenter?.disputes?.overSlaCount ?? 0));
      metricGauge(
        "disputes_expired_window_open_gauge",
        null,
        Number(commandCenter?.disputes?.expiredWindowOpenCount ?? 0)
      );
      metricGauge("arbitration_over_sla_gauge", null, Number(commandCenter?.disputes?.arbitrationOverSlaCount ?? 0));
    } catch {
      // best-effort telemetry for ops alerting.
    }

    const retentionInfo = await fetchMaintenanceRetentionRunInfo({ tenantId });
    const last = retentionInfo?.last ?? null;
    const lastOk = retentionInfo?.lastOk ?? null;

    const lastRunAtMs = last?.at ? Date.parse(String(last.at)) : NaN;
    const lastOkAtMs = lastOk?.at ? Date.parse(String(lastOk.at)) : NaN;
    metricGauge("maintenance_last_run_unixtime", { kind: "retention_cleanup" }, Number.isFinite(lastRunAtMs) ? Math.floor(lastRunAtMs / 1000) : 0);
    metricGauge("maintenance_last_success_unixtime", { kind: "retention_cleanup" }, Number.isFinite(lastOkAtMs) ? Math.floor(lastOkAtMs / 1000) : 0);

	    const outcome = last?.details?.outcome ?? null;
	    metricGauge("maintenance_last_run_ok_gauge", { kind: "retention_cleanup" }, outcome === "ok" ? 1 : 0);

    const financeReconcileInfo = await fetchMaintenanceFinanceReconcileRunInfo({ tenantId });
    const lastFinance = financeReconcileInfo?.last ?? null;
    const lastFinanceOk = financeReconcileInfo?.lastOk ?? null;
    const financeLastRunAt = store?.__financeReconcileLastRunAt ?? lastFinance?.at ?? null;
    const financeLastSuccessAt = store?.__financeReconcileLastSuccessAt ?? lastFinanceOk?.at ?? null;
    const financeLastRunAtMs = financeLastRunAt ? Date.parse(String(financeLastRunAt)) : Number.NaN;
    const financeLastOkAtMs = financeLastSuccessAt ? Date.parse(String(financeLastSuccessAt)) : Number.NaN;
    metricGauge("maintenance_last_run_unixtime", { kind: "finance_reconcile" }, Number.isFinite(financeLastRunAtMs) ? Math.floor(financeLastRunAtMs / 1000) : 0);
    metricGauge(
      "maintenance_last_success_unixtime",
      { kind: "finance_reconcile" },
      Number.isFinite(financeLastOkAtMs) ? Math.floor(financeLastOkAtMs / 1000) : 0
    );
    const financeOutcome =
      lastFinance?.details?.outcome ??
      (store?.__financeReconcileLastResult && typeof store.__financeReconcileLastResult === "object"
        ? store.__financeReconcileLastResult.ok === true
          ? "ok"
          : "error"
        : null);
    metricGauge("maintenance_last_run_ok_gauge", { kind: "finance_reconcile" }, financeOutcome === "ok" ? 1 : 0);

    const moneyRailReconcileInfo = await fetchMaintenanceMoneyRailReconcileRunInfo({ tenantId });
    const lastMoneyRail = moneyRailReconcileInfo?.last ?? null;
    const lastMoneyRailOk = moneyRailReconcileInfo?.lastOk ?? null;
    const moneyRailLastRunAt = store?.__moneyRailReconcileLastRunAt ?? lastMoneyRail?.at ?? null;
    const moneyRailLastSuccessAt = store?.__moneyRailReconcileLastSuccessAt ?? lastMoneyRailOk?.at ?? null;
    const moneyRailLastRunAtMs = moneyRailLastRunAt ? Date.parse(String(moneyRailLastRunAt)) : Number.NaN;
    const moneyRailLastOkAtMs = moneyRailLastSuccessAt ? Date.parse(String(moneyRailLastSuccessAt)) : Number.NaN;
    metricGauge(
      "maintenance_last_run_unixtime",
      { kind: "money_rails_reconcile" },
      Number.isFinite(moneyRailLastRunAtMs) ? Math.floor(moneyRailLastRunAtMs / 1000) : 0
    );
    metricGauge(
      "maintenance_last_success_unixtime",
      { kind: "money_rails_reconcile" },
      Number.isFinite(moneyRailLastOkAtMs) ? Math.floor(moneyRailLastOkAtMs / 1000) : 0
    );
    const moneyRailOutcome =
      lastMoneyRail?.details?.outcome ??
      (store?.__moneyRailReconcileLastResult && typeof store.__moneyRailReconcileLastResult === "object"
        ? store.__moneyRailReconcileLastResult.ok === true
          ? "ok"
          : "error"
        : null);
    metricGauge("maintenance_last_run_ok_gauge", { kind: "money_rails_reconcile" }, moneyRailOutcome === "ok" ? 1 : 0);

	    // Settlement holds: finance-operability gauges (count + aging distribution).
	    try {
	      const nowAt = nowIso();
	      const nowMs = Date.parse(nowAt);
	      let heldCount = 0;
	      let oldestAgeSeconds = 0;
        let holdsOver24Hours = 0;

	      const ages = [];
	      for (const job of listJobs({ tenantId })) {
	        const hold = job?.settlementHold ?? null;
	        if (!hold || typeof hold !== "object") continue;
	        const status = typeof hold.status === "string" ? hold.status.toUpperCase() : "";
	        if (status !== "HELD") continue;
	        heldCount += 1;
	        const heldAt = hold.heldAt ?? null;
	        const heldAtMs = heldAt ? Date.parse(String(heldAt)) : NaN;
	        const ageSeconds = Number.isFinite(nowMs) && Number.isFinite(heldAtMs) ? Math.max(0, Math.floor((nowMs - heldAtMs) / 1000)) : 0;
	        ages.push(ageSeconds);
	        if (ageSeconds > oldestAgeSeconds) oldestAgeSeconds = ageSeconds;
          if (ageSeconds > 24 * 60 * 60) holdsOver24Hours += 1;
	      }

	      metricGauge("settlement_holds_open_gauge", { status: "HELD" }, heldCount);
	      metricGauge("settlement_hold_oldest_age_seconds_gauge", null, oldestAgeSeconds);
        metricGauge("settlement_holds_over_24h_gauge", null, holdsOver24Hours);

	      // Use Prom-style bucket gauges for a snapshot distribution of open holds.
	      const buckets = [3600, 6 * 3600, 24 * 3600, 7 * 24 * 3600, 30 * 24 * 3600];
	      ages.sort((a, b) => a - b);
	      let idx = 0;
	      for (const b of buckets) {
	        while (idx < ages.length && ages[idx] <= b) idx += 1;
	        metricGauge("settlement_hold_age_seconds_bucket", { le: String(b) }, idx);
	      }
	      metricGauge("settlement_hold_age_seconds_bucket", { le: "+Inf" }, ages.length);
	    } catch {
	      // ignore
	    }
	  }

  function inferIngestReasonCode(reason) {
    const msg = typeof reason === "string" ? reason.trim() : "";
    if (!msg) return "UNKNOWN";
    const lower = msg.toLowerCase();

    if (lower === "event.at is too far in the future") return "FUTURE_TIMESTAMP";
    if (lower === "too many events in request") return "INGEST_MAX_EVENTS_EXCEEDED";
    if (lower === "tenant quota exceeded") return "TENANT_QUOTA_EXCEEDED";
    if (lower.includes("signature policy rejected")) return "SIGNATURE_POLICY";
    if (lower.includes("event chain verification failed")) return "CHAIN_BREAK";
    if (lower.includes("job transition rejected") || lower.includes("transition")) return "TRANSITION_ILLEGAL";
    if (lower.startsWith("unsupported signerkind=")) return "SIGNATURE_POLICY";
    if (lower === "ingest cannot spoof robot/operator actors") return "SIGNATURE_POLICY";
    if (lower.includes(" is required") || lower.startsWith("invalid ") || lower.includes("must be")) return "SCHEMA_INVALID";

    return "EVENT_REJECTED";
  }

  async function commitTx(ops, { audit = null } = {}) {
    if (!Array.isArray(ops) || ops.length === 0) throw new TypeError("commitTx requires non-empty ops[]");
    const ctx = getLogContext() ?? {};
    const requestId = ctx?.requestId ?? null;
    const derivedOutbox = [];
    for (const op of ops) {
      if (!op || typeof op !== "object") continue;
      if (op.kind === "JOB_EVENTS_APPENDED") {
        try {
          derivedOutbox.push(...deriveArtifactEnqueuesFromJobEvents({ tenantId: op.tenantId ?? DEFAULT_TENANT_ID, jobId: op.jobId, events: op.events ?? [] }));
        } catch {
          // Ignore: artifact triggers are best-effort; core semantics are in the job stream.
        }
        try {
          derivedOutbox.push(...deriveProofEvalEnqueuesFromJobEvents({ tenantId: op.tenantId ?? DEFAULT_TENANT_ID, jobId: op.jobId, events: op.events ?? [] }));
        } catch {
          // Ignore: proof triggers are best-effort; proof events are derived and idempotent.
        }
      }
    }

    function attachRequestId(record) {
      if (!requestId) return record;
      if (!record || typeof record !== "object" || Array.isArray(record)) return record;
      if (record.requestId) return record;
      return { ...record, requestId };
    }

    const normalizedOps = [];
    for (const op of ops) {
      if (!op || typeof op !== "object") continue;
      if (op.kind === "OUTBOX_ENQUEUE" && Array.isArray(op.messages)) {
        normalizedOps.push({ ...op, messages: op.messages.map(attachRequestId) });
        continue;
      }
      if (op.kind === "INGEST_RECORDS_PUT" && Array.isArray(op.records)) {
        normalizedOps.push({ ...op, records: op.records.map(attachRequestId) });
        continue;
      }
      normalizedOps.push(op);
    }

    const derived = derivedOutbox.map(attachRequestId);
    const augmented = derived.length ? [...normalizedOps, { kind: "OUTBOX_ENQUEUE", messages: derived }] : normalizedOps;

    const ctxPath = typeof ctx?.path === "string" ? ctx.path : "";
    const ctxMethod = typeof ctx?.method === "string" ? String(ctx.method).toUpperCase() : "";
    const isOpsWrite = ctxPath.startsWith("/ops") && ctxMethod !== "GET" && ctxMethod !== "HEAD" && ctxMethod !== "";
    if (!audit && isOpsWrite) {
      const tenantIdFromOps = ops.find((op) => op && typeof op === "object" && typeof op.tenantId === "string" && op.tenantId.trim())?.tenantId ?? DEFAULT_TENANT_ID;
      const tenantId = normalizeTenantId(typeof ctx?.tenantId === "string" ? ctx.tenantId : tenantIdFromOps);
      const actorKeyId = typeof ctx?.actorKeyId === "string" && ctx.actorKeyId.trim() ? ctx.actorKeyId : null;
      const actorPrincipalId = typeof ctx?.principalId === "string" && ctx.principalId.trim() ? ctx.principalId : null;
      const details = normalizeForCanonicalJson({
        method: ctxMethod,
        path: ctxPath,
        route: typeof ctx?.route === "string" ? ctx.route : null,
        opKinds: Array.isArray(ops) ? ops.map((op) => op?.kind).filter(Boolean) : []
      });
      audit = {
        tenantId,
        actorKeyId,
        actorPrincipalId,
        requestId: typeof requestId === "string" ? requestId : null,
        action: "OPS_HTTP_WRITE",
        targetType: null,
        targetId: null,
        at: nowIso(),
        detailsHash: sha256Hex(canonicalJsonStringify(details)),
        details
      };
    }

    try {
      await store.commitTx({ at: nowIso(), ops: augmented, audit: audit ? attachRequestId(audit) : null });
    } catch (err) {
      if (err?.code === "PREV_CHAIN_HASH_MISMATCH") {
        err.statusCode = 409;
        err.message = "event append conflict";
      }
      throw err;
    }
  }

  async function listAllLedgerEntriesForTenant({ tenantId, memoPrefix = null, maxEntries = 50_000 } = {}) {
    tenantId = normalizeTenant(tenantId);
    if (memoPrefix !== null && (typeof memoPrefix !== "string" || memoPrefix.trim() === "")) throw new TypeError("memoPrefix must be null or a non-empty string");
    if (!Number.isSafeInteger(maxEntries) || maxEntries <= 0) throw new TypeError("maxEntries must be a positive safe integer");

    const ledger = typeof store.getLedger === "function" ? store.getLedger(tenantId) : store.ledger;
    if (typeof store.listLedgerEntries !== "function") {
      const all = Array.isArray(ledger?.entries) ? ledger.entries : [];
      const filtered = memoPrefix ? all.filter((e) => typeof e?.memo === "string" && e.memo.startsWith(memoPrefix)) : all;
      return filtered.slice(0, maxEntries);
    }

    const entries = [];
    const pageSize = 5000;
    let offset = 0;
    while (entries.length < maxEntries) {
      // listLedgerEntries may be sync (memory) or async (pg). await handles both.
      // Note: ordering is not guaranteed; statements compute balances by filtering entry.at.
      // eslint-disable-next-line no-await-in-loop
      const batch = await store.listLedgerEntries({ tenantId, memoPrefix, limit: pageSize, offset });
      if (!Array.isArray(batch) || batch.length === 0) break;
      entries.push(...batch);
      if (batch.length < pageSize) break;
      offset += batch.length;
    }
    return entries;
  }

  async function listAllLedgerAllocationsForTenant({ tenantId, maxEntries = 50_000 } = {}) {
    tenantId = normalizeTenant(tenantId);
    if (!Number.isSafeInteger(maxEntries) || maxEntries <= 0) throw new TypeError("maxEntries must be a positive safe integer");

    if (typeof store.listLedgerAllocations !== "function") {
      const all = store.ledgerAllocations instanceof Map ? Array.from(store.ledgerAllocations.values()) : [];
      return all.filter((a) => normalizeTenantId(a?.tenantId ?? DEFAULT_TENANT_ID) === tenantId).slice(0, maxEntries);
    }

    const allocations = [];
    const pageSize = 5000;
    let offset = 0;
    while (allocations.length < maxEntries) {
      // listLedgerAllocations may be sync (memory) or async (pg). await handles both.
      // eslint-disable-next-line no-await-in-loop
      const batch = await store.listLedgerAllocations({ tenantId, limit: pageSize, offset });
      if (!Array.isArray(batch) || batch.length === 0) break;
      allocations.push(...batch);
      if (batch.length < pageSize) break;
      offset += batch.length;
    }
    return allocations;
  }

  function normalizeTenant(tenantId) {
    return normalizeTenantId(tenantId, { defaultTenantId: DEFAULT_TENANT_ID });
  }

  function jobStoreKey(tenantId, jobId) {
    return makeScopedKey({ tenantId: normalizeTenant(tenantId), id: jobId });
  }

  function robotStoreKey(tenantId, robotId) {
    return makeScopedKey({ tenantId: normalizeTenant(tenantId), id: robotId });
  }

  function operatorStoreKey(tenantId, operatorId) {
    return makeScopedKey({ tenantId: normalizeTenant(tenantId), id: operatorId });
  }

  function runStoreKey(tenantId, runId) {
    return makeScopedKey({ tenantId: normalizeTenant(tenantId), id: runId });
  }

  function rfqStoreKey(tenantId, rfqId) {
    return makeScopedKey({ tenantId: normalizeTenant(tenantId), id: rfqId });
  }

  function capabilityListingStoreKey(tenantId, listingId) {
    return makeScopedKey({ tenantId: normalizeTenant(tenantId), id: listingId });
  }

  function providerPublicationStoreKey(tenantId, providerId) {
    return makeScopedKey({ tenantId: normalizeTenant(tenantId), id: providerId });
  }

  function monthStoreKey(tenantId, monthId) {
    return makeScopedKey({ tenantId: normalizeTenant(tenantId), id: monthId });
  }

  function getMoneyRailAdapter(providerId) {
    const normalizedProviderId = typeof providerId === "string" && providerId.trim() !== "" ? providerId.trim() : defaultMoneyRailProviderId;
    return moneyRailAdapters.get(normalizedProviderId) ?? null;
  }

  function getMoneyRailProviderConfig(providerId) {
    const normalizedProviderId = typeof providerId === "string" && providerId.trim() !== "" ? providerId.trim() : defaultMoneyRailProviderId;
    return moneyRailProviderConfigById.get(normalizedProviderId) ?? null;
  }

  function resolveMoneyRailProviderEventType({ providerId, eventType, providerStatus } = {}) {
    const config = getMoneyRailProviderConfig(providerId);
    if (!config) throw new TypeError("unknown money rail provider");

    const normalizedEventType =
      typeof eventType === "string" && eventType.trim() !== "" ? String(eventType).trim().toLowerCase() : null;
    if (normalizedEventType && !CANONICAL_MONEY_RAIL_PROVIDER_EVENT_TYPES.has(normalizedEventType)) {
      throw new TypeError(
        `eventType must be one of: ${Array.from(CANONICAL_MONEY_RAIL_PROVIDER_EVENT_TYPES).join("|")}`
      );
    }

    const normalizedProviderStatus = normalizeMoneyRailProviderStatusValue(providerStatus);
    const mappedEventType = normalizedProviderStatus ? config.providerStatusMap.get(normalizedProviderStatus) ?? null : null;

    if (normalizedEventType && normalizedProviderStatus && mappedEventType && normalizedEventType !== mappedEventType) {
      throw new TypeError("eventType does not match providerStatus mapping");
    }
    if (normalizedEventType) return normalizedEventType;
    if (mappedEventType) return mappedEventType;
    if (normalizedProviderStatus) throw new TypeError(`unmapped providerStatus: ${normalizedProviderStatus}`);
    throw new TypeError("eventType or providerStatus is required");
  }

  function mapStripeWebhookEventTypeToMoneyRailEventType({ eventType, objectStatus = null, objectReversed = null } = {}) {
    const normalizedType = normalizeNonEmptyStringOrNull(eventType)?.toLowerCase() ?? null;
    const normalizedStatus = normalizeNonEmptyStringOrNull(objectStatus)?.toLowerCase() ?? null;
    if (!normalizedType) return null;

    if (normalizedType === "transfer.paid") return MONEY_RAIL_PROVIDER_EVENT_TYPE.CONFIRMED;
    if (normalizedType === "transfer.failed") return MONEY_RAIL_PROVIDER_EVENT_TYPE.FAILED;
    if (normalizedType === "transfer.reversed" || normalizedType === "transfer.refunded") {
      return MONEY_RAIL_PROVIDER_EVENT_TYPE.REVERSED;
    }
    if (normalizedType === "transfer.canceled" || normalizedType === "transfer.cancelled") {
      return MONEY_RAIL_PROVIDER_EVENT_TYPE.CANCELLED;
    }
    if (normalizedType === "transfer.created" || normalizedType === "transfer.pending") {
      return MONEY_RAIL_PROVIDER_EVENT_TYPE.SUBMITTED;
    }
    if (normalizedType === "transfer.updated") {
      if (objectReversed === true) return MONEY_RAIL_PROVIDER_EVENT_TYPE.REVERSED;
      if (normalizedStatus === "paid") return MONEY_RAIL_PROVIDER_EVENT_TYPE.CONFIRMED;
      if (normalizedStatus === "failed") return MONEY_RAIL_PROVIDER_EVENT_TYPE.FAILED;
      if (normalizedStatus === "canceled" || normalizedStatus === "cancelled") return MONEY_RAIL_PROVIDER_EVENT_TYPE.CANCELLED;
      return MONEY_RAIL_PROVIDER_EVENT_TYPE.SUBMITTED;
    }
    if (normalizedType === "payout.paid") return MONEY_RAIL_PROVIDER_EVENT_TYPE.CONFIRMED;
    if (normalizedType === "payout.failed") return MONEY_RAIL_PROVIDER_EVENT_TYPE.FAILED;
    if (normalizedType === "payout.canceled" || normalizedType === "payout.cancelled") {
      return MONEY_RAIL_PROVIDER_EVENT_TYPE.CANCELLED;
    }
    return null;
  }

  function extractStripeMoneyRailWebhookHints(value) {
    if (!value || typeof value !== "object" || Array.isArray(value)) return null;
    const root = value;
    const eventType = normalizeNonEmptyStringOrNull(root.type);
    const eventId = normalizeNonEmptyStringOrNull(root.id);
    const object =
      root?.data && typeof root.data === "object" && !Array.isArray(root.data) && root.data.object && typeof root.data.object === "object" && !Array.isArray(root.data.object)
        ? root.data.object
        : root?.object && typeof root.object === "object" && !Array.isArray(root.object)
          ? root.object
          : null;
    const metadata =
      object?.metadata && typeof object.metadata === "object" && !Array.isArray(object.metadata) ? object.metadata : null;

    const operationId =
      normalizeNonEmptyStringOrNull(root.operationId) ??
      normalizeNonEmptyStringOrNull(object?.operationId) ??
      normalizeNonEmptyStringOrNull(metadata?.settld_operation_id) ??
      normalizeNonEmptyStringOrNull(metadata?.operation_id);
    const payoutKey =
      normalizeNonEmptyStringOrNull(root?.payoutKey) ??
      normalizeNonEmptyStringOrNull(object?.payoutKey) ??
      normalizeNonEmptyStringOrNull(metadata?.settld_payout_key);
    const providerRef =
      normalizeNonEmptyStringOrNull(root.providerRef) ??
      normalizeNonEmptyStringOrNull(object?.providerRef) ??
      normalizeNonEmptyStringOrNull(object?.id);
    const providerStatus =
      normalizeMoneyRailProviderStatusValue(root.providerStatus) ??
      normalizeMoneyRailProviderStatusValue(object?.status);
    const mappedEventType = mapStripeWebhookEventTypeToMoneyRailEventType({
      eventType,
      objectStatus: providerStatus,
      objectReversed: object?.reversed === true
    });

    let occurredAt = null;
    if (Number.isSafeInteger(Number(root?.created))) {
      occurredAt = new Date(Number(root.created) * 1000).toISOString();
    } else if (typeof root?.created === "string" && root.created.trim() !== "" && Number.isFinite(Date.parse(root.created))) {
      occurredAt = new Date(Date.parse(root.created)).toISOString();
    }

    return {
      eventId,
      eventType,
      mappedEventType,
      providerStatus,
      operationId,
      payoutKey,
      providerRef,
      at: occurredAt,
      rawEvent: root
    };
  }

  async function resolveMoneyRailOperationIdFromStripeHints({ tenantId, adapter, hints } = {}) {
    if (!hints || typeof hints !== "object") return null;
    const directCandidates = [];
    if (hints.operationId) directCandidates.push(hints.operationId);
    if (hints.payoutKey) directCandidates.push(`mop_${hints.payoutKey}`);
    for (const candidate of directCandidates) {
      try {
        // eslint-disable-next-line no-await-in-loop
        const operation = await adapter.status({ tenantId, operationId: candidate });
        if (operation) return candidate;
      } catch {
        // ignore and continue to next candidate
      }
    }
    if (typeof adapter.listOperations !== "function") return null;
    const operations = await adapter.listOperations({ tenantId });
    const matches = operations.filter((operation) => {
      if (!operation || typeof operation !== "object") return false;
      if (hints.providerRef && normalizeNonEmptyStringOrNull(operation.providerRef) === hints.providerRef) return true;
      if (hints.payoutKey && extractPayoutKeyFromMoneyRailOperation(operation) === hints.payoutKey) return true;
      return false;
    });
    if (matches.length === 1) {
      return normalizeNonEmptyStringOrNull(matches[0]?.operationId);
    }
    return null;
  }

  function extractPayoutKeyFromMoneyRailOperation(operation) {
    if (!operation || typeof operation !== "object") return null;
    const metadataPayoutKey =
      typeof operation?.metadata?.payoutKey === "string" && operation.metadata.payoutKey.trim() !== ""
        ? operation.metadata.payoutKey.trim()
        : null;
    if (metadataPayoutKey) return metadataPayoutKey;
    if (typeof operation?.idempotencyKey === "string" && operation.idempotencyKey.trim() !== "") return operation.idempotencyKey.trim();
    if (typeof operation?.operationId === "string" && operation.operationId.startsWith("mop_")) return operation.operationId.slice(4);
    return null;
  }

  function payoutKeyMatchesPeriod({ payoutKey, period }) {
    if (typeof payoutKey !== "string" || payoutKey.trim() === "") return false;
    if (typeof period !== "string" || period.trim() === "") return false;
    return payoutKey.includes(`:period:${period}:`);
  }

  async function computeEscrowNetCloseReport({ tenantId, period }) {
    if (typeof store.listArtifacts !== "function") {
      const err = new Error("artifacts not supported for this store");
      err.statusCode = 501;
      throw err;
    }

    let bounds;
    try {
      bounds = parseYearMonth(period);
    } catch (err) {
      const wrapped = new Error(err?.message ?? "invalid period");
      wrapped.statusCode = 400;
      throw wrapped;
    }
    const startMs = Date.parse(bounds.startAt);
    const endMs = Date.parse(bounds.endAt);

    const monthId = makeMonthCloseStreamId({ month: period, basis: MONTH_CLOSE_BASIS.SETTLED_AT });
    let monthEvents = getMonthEvents(tenantId, monthId);
    if (!monthEvents.length && typeof store.listAggregateEvents === "function") {
      try {
        monthEvents = await store.listAggregateEvents({ tenantId, aggregateType: "month", aggregateId: monthId });
      } catch {
        monthEvents = [];
      }
    }
    if (!monthEvents.length) {
      const err = new Error("month close not found");
      err.statusCode = 409;
      throw err;
    }
    const monthClose = reduceMonthClose(monthEvents);
    if (!monthClose || monthClose.status !== "CLOSED") {
      const err = new Error("month is not closed");
      err.statusCode = 409;
      throw err;
    }

    const artifacts = await store.listArtifacts({ tenantId });
    const heldCandidates = artifacts
      .filter((artifact) => artifact?.artifactType === ARTIFACT_TYPE.HELD_EXPOSURE_ROLLFORWARD_V1 && String(artifact?.period ?? "") === String(period))
      .sort((a, b) => String(a?.generatedAt ?? a?.artifactId ?? "").localeCompare(String(b?.generatedAt ?? b?.artifactId ?? "")));
    const heldRollforwardArtifact = heldCandidates.length ? heldCandidates[heldCandidates.length - 1] : null;

    function sumHeldBucketNetCents(bucket) {
      const byCurrency = bucket && typeof bucket === "object" ? bucket.byCurrency : null;
      if (!byCurrency || typeof byCurrency !== "object") return 0;
      let total = 0;
      for (const row of Object.values(byCurrency)) {
        if (!row || typeof row !== "object") continue;
        if (!Number.isSafeInteger(row.amountNetCents)) continue;
        total += row.amountNetCents;
      }
      return total;
    }

    const rollforwardBuckets = heldRollforwardArtifact?.rollforward?.buckets ?? null;
    const heldRollforwardNet = rollforwardBuckets
      ? {
          openingHeldCents: sumHeldBucketNetCents(rollforwardBuckets.opening),
          newLocksCents: sumHeldBucketNetCents(rollforwardBuckets.newHolds),
          releasesCents: sumHeldBucketNetCents(rollforwardBuckets.released),
          forfeitsCents: sumHeldBucketNetCents(rollforwardBuckets.forfeited),
          endingHeldCents: sumHeldBucketNetCents(rollforwardBuckets.ending)
        }
      : null;

    const ledgerEntries = await listAllLedgerEntriesForTenant({ tenantId });
    ledgerEntries.sort((a, b) => {
      const aMs = Date.parse(String(a?.at ?? ""));
      const bMs = Date.parse(String(b?.at ?? ""));
      if (Number.isFinite(aMs) && Number.isFinite(bMs) && aMs !== bMs) return aMs - bMs;
      return String(a?.id ?? "").localeCompare(String(b?.id ?? ""));
    });

    const ledgerEscrow = {
      openingHeldCents: 0,
      newLocksCents: 0,
      releasesCents: 0,
      forfeitsCents: 0,
      unknownPositiveAdjustmentsCents: 0,
      unknownNegativeAdjustmentsCents: 0,
      endingHeldCents: 0,
      escrowPostingCount: 0
    };
    let totalWindowEscrowDeltaCents = 0;

    for (const entry of ledgerEntries) {
      if (!entry || typeof entry !== "object") continue;
      const atMs = Date.parse(String(entry?.at ?? ""));
      if (!Number.isFinite(atMs)) continue;
      const memo = String(entry?.memo ?? "").toLowerCase();
      const postings = Array.isArray(entry?.postings) ? entry.postings : [];
      for (const posting of postings) {
        if (!posting || typeof posting !== "object") continue;
        const accountId = typeof posting?.accountId === "string" ? posting.accountId : "";
        if (!accountId.endsWith(":escrow_locked")) continue;
        if (!Number.isSafeInteger(posting.amountCents)) continue;
        const amountCents = posting.amountCents;
        if (atMs < startMs) {
          ledgerEscrow.openingHeldCents += amountCents;
          continue;
        }
        if (atMs >= endMs) continue;

        ledgerEscrow.escrowPostingCount += 1;
        totalWindowEscrowDeltaCents += amountCents;

        if (amountCents > 0) {
          if (memo.includes("escrow:hold:")) ledgerEscrow.newLocksCents += amountCents;
          else ledgerEscrow.unknownPositiveAdjustmentsCents += amountCents;
          continue;
        }

        if (amountCents < 0) {
          const debitCents = -amountCents;
          if (memo.includes("escrow:release:")) ledgerEscrow.releasesCents += debitCents;
          else if (memo.includes("escrow:forfeit:")) ledgerEscrow.forfeitsCents += debitCents;
          else ledgerEscrow.unknownNegativeAdjustmentsCents += debitCents;
        }
      }
    }

    const actualEndingHeldCents = ledgerEscrow.openingHeldCents + totalWindowEscrowDeltaCents;
    const computedEndingHeldCents =
      ledgerEscrow.openingHeldCents +
      ledgerEscrow.newLocksCents -
      ledgerEscrow.releasesCents -
      ledgerEscrow.forfeitsCents +
      ledgerEscrow.unknownPositiveAdjustmentsCents -
      ledgerEscrow.unknownNegativeAdjustmentsCents;
    ledgerEscrow.endingHeldCents = actualEndingHeldCents;

    const ledgerConserved = computedEndingHeldCents === actualEndingHeldCents;
    const heldRollforwardConserved = heldRollforwardNet
      ? heldRollforwardNet.openingHeldCents + heldRollforwardNet.newLocksCents - heldRollforwardNet.releasesCents - heldRollforwardNet.forfeitsCents ===
        heldRollforwardNet.endingHeldCents
      : false;
    const heldRollforwardMatchesLedger = heldRollforwardNet
      ? heldRollforwardNet.openingHeldCents === ledgerEscrow.openingHeldCents &&
        heldRollforwardNet.newLocksCents === ledgerEscrow.newLocksCents &&
        heldRollforwardNet.releasesCents === ledgerEscrow.releasesCents &&
        heldRollforwardNet.forfeitsCents === ledgerEscrow.forfeitsCents &&
        heldRollforwardNet.endingHeldCents === ledgerEscrow.endingHeldCents
      : false;

    const mismatchCodes = [];
    if (!heldRollforwardArtifact) mismatchCodes.push("HELD_ROLLFORWARD_MISSING");
    if (!ledgerConserved) mismatchCodes.push("LEDGER_ESCROW_ROLLFORWARD_INVALID");
    if (heldRollforwardArtifact && !heldRollforwardConserved) mismatchCodes.push("HELD_ROLLFORWARD_INVALID");
    if (heldRollforwardArtifact && !heldRollforwardMatchesLedger) mismatchCodes.push("HELD_ROLLFORWARD_LEDGER_MISMATCH");
    if (ledgerEscrow.unknownPositiveAdjustmentsCents !== 0 || ledgerEscrow.unknownNegativeAdjustmentsCents !== 0) {
      mismatchCodes.push("LEDGER_UNCLASSIFIED_ESCROW_ADJUSTMENT");
    }

    const snapshot = {
      schemaVersion: "EscrowNetCloseSnapshot.v1",
      period,
      basis: monthClose?.basis ?? MONTH_CLOSE_BASIS.SETTLED_AT,
      window: {
        startAt: bounds.startAt,
        endAt: bounds.endAt
      },
      ledgerEscrow,
      heldRollforward: heldRollforwardNet,
      invariants: {
        ledgerConserved,
        heldRollforwardConserved,
        heldRollforwardMatchesLedger,
        computedEndingHeldCents,
        actualEndingHeldCents
      },
      mismatchCodes
    };

    return {
      period,
      basis: monthClose?.basis ?? MONTH_CLOSE_BASIS.SETTLED_AT,
      status: mismatchCodes.length ? "fail" : "pass",
      mismatchCodes,
      snapshot,
      evidence: {
        monthCloseEventId: monthClose?.lastEventId ?? null,
        monthCloseChainHash: monthClose?.lastChainHash ?? null,
        heldRollforwardArtifactId: heldRollforwardArtifact?.artifactId ?? null,
        heldRollforwardArtifactHash: heldRollforwardArtifact?.artifactHash ?? null
      },
      monthEvents,
      monthClose
    };
  }

  async function persistEscrowNetCloseArtifact({ tenantId, report }) {
    if (typeof store.putArtifact !== "function") {
      const err = new Error("artifact persistence not supported for this store");
      err.statusCode = 501;
      throw err;
    }
    const generatedAt = nowIso();
    const snapshotHash = sha256HexBytes(new TextEncoder().encode(`${canonicalJsonStringify(report.snapshot)}\n`));
    const artifactId = `escrow_net_close_${String(report.period).replaceAll(/[^0-9a-zA-Z_-]/g, "_")}_${snapshotHash.slice(0, 24)}`;
    const artifactBody = buildEscrowNetCloseV1({
      tenantId,
      period: report.period,
      basis: report.basis,
      snapshot: report.snapshot,
      events: report.monthEvents,
      artifactId,
      generatedAt
    });
    const artifactCore = {
      ...artifactBody,
      sourceEventId: report?.monthClose?.lastEventId ?? null,
      atChainHash: report?.monthClose?.lastChainHash ?? artifactBody?.eventProof?.lastChainHash ?? null
    };
    const artifactHash = computeArtifactHash(artifactCore);
    const artifact = { ...artifactCore, artifactHash };
    let storedArtifact = artifact;
    try {
      await store.putArtifact({ tenantId, artifact });
    } catch (err) {
      if (err?.code !== "ARTIFACT_HASH_MISMATCH") throw err;
      if (typeof store.getArtifact !== "function") throw err;
      const existing = await store.getArtifact({ tenantId, artifactId });
      if (!existing || typeof existing?.artifactHash !== "string" || existing.artifactHash.trim() === "") throw err;
      storedArtifact = existing;
    }

    let deliveriesCreated = 0;
    if (typeof store.createDelivery === "function") {
      const destinations = listDestinationsForTenant(tenantId).filter((destination) => {
        const allowed = Array.isArray(destination?.artifactTypes) && destination.artifactTypes.length ? destination.artifactTypes : null;
        return !allowed || allowed.includes(ARTIFACT_TYPE.ESCROW_NET_CLOSE_V1);
      });
      for (const destination of destinations) {
        const dedupeKey =
          `${tenantId}:${destination.destinationId}:${ARTIFACT_TYPE.ESCROW_NET_CLOSE_V1}:${artifactId}:${String(storedArtifact.artifactHash)}`;
        const scopeKey = `escrow_net_close:period:${report.period}`;
        const orderSeq = Date.parse(generatedAt);
        const priority = 97;
        const orderKey = `${scopeKey}\n${String(orderSeq)}\n${String(priority)}\n${artifactId}`;
        try {
          await store.createDelivery({
            tenantId,
            delivery: {
              destinationId: destination.destinationId,
              artifactType: ARTIFACT_TYPE.ESCROW_NET_CLOSE_V1,
              artifactId,
              artifactHash: String(storedArtifact.artifactHash),
              dedupeKey,
              scopeKey,
              orderSeq,
              priority,
              orderKey
            }
          });
          deliveriesCreated += 1;
        } catch (err) {
          if (err?.code === "DELIVERY_DEDUPE_CONFLICT") continue;
          throw err;
        }
      }
    }

    return {
      artifactId,
      artifactHash: String(storedArtifact.artifactHash),
      deliveriesCreated
    };
  }

  function syncEscrowLedgerWalletSnapshot({ ledgerState, tenantId, wallet }) {
    if (!wallet || typeof wallet !== "object") return;
    const walletId = typeof wallet.walletId === "string" && wallet.walletId.trim() !== "" ? wallet.walletId.trim() : `wallet_${String(wallet.agentId ?? "")}`;
    if (!walletId || walletId === "wallet_") return;
    upsertEscrowLedgerWalletBalances({
      state: ledgerState,
      tenantId: normalizeTenant(tenantId),
      walletId,
      availableCents: Number(wallet.availableCents ?? 0),
      escrowLockedCents: Number(wallet.escrowLockedCents ?? 0)
    });
  }

  function assertEscrowLedgerMatchesWallet({ ledgerState, tenantId, wallet, contextLabel }) {
    if (!wallet || typeof wallet !== "object") return;
    const walletId = typeof wallet.walletId === "string" && wallet.walletId.trim() !== "" ? wallet.walletId.trim() : `wallet_${String(wallet.agentId ?? "")}`;
    if (!walletId || walletId === "wallet_") return;
    const accountAvailable = walletAvailableAccountId({ tenantId: normalizeTenant(tenantId), walletId });
    const accountEscrow = walletEscrowAccountId({ tenantId: normalizeTenant(tenantId), walletId });
    const ledgerAvailable = getEscrowLedgerBalance({ state: ledgerState, accountId: accountAvailable });
    const ledgerEscrowLocked = getEscrowLedgerBalance({ state: ledgerState, accountId: accountEscrow });
    const walletAvailable = Number(wallet.availableCents ?? 0);
    const walletEscrowLocked = Number(wallet.escrowLockedCents ?? 0);
    if (ledgerAvailable !== walletAvailable || ledgerEscrowLocked !== walletEscrowLocked) {
      const err = new Error(`escrow ledger projection mismatch (${contextLabel})`);
      err.code = "ESCROW_LEDGER_MISMATCH";
      err.details = {
        walletId,
        contextLabel,
        ledgerAvailable,
        ledgerEscrowLocked,
        walletAvailable,
        walletEscrowLocked
      };
      throw err;
    }
  }

  function projectEscrowLedgerOperation({
    tenantId,
    settlement,
    operationId,
    type,
    amountCents,
    at,
    payerWalletBefore = null,
    payerWalletAfter = null,
    payeeWalletBefore = null,
    payeeWalletAfter = null,
    memo = null
  }) {
    const cents = Number(amountCents ?? 0);
    if (!Number.isSafeInteger(cents) || cents <= 0) return null;
    const normalizedCurrency = typeof settlement?.currency === "string" && settlement.currency.trim() !== "" ? settlement.currency.trim() : "USD";
    const ledgerState = createEscrowLedger({ currency: normalizedCurrency });
    syncEscrowLedgerWalletSnapshot({ ledgerState, tenantId, wallet: payerWalletBefore ?? payerWalletAfter });
    if (type === ESCROW_OPERATION_TYPE.RELEASE) {
      syncEscrowLedgerWalletSnapshot({ ledgerState, tenantId, wallet: payeeWalletBefore ?? payeeWalletAfter });
    }
    const input = {
      operationId,
      tenantId: normalizeTenant(tenantId),
      type,
      payerWalletId: (payerWalletAfter ?? payerWalletBefore)?.walletId ?? `wallet_${String(settlement?.payerAgentId ?? "")}`,
      payeeWalletId:
        type === ESCROW_OPERATION_TYPE.RELEASE
          ? (payeeWalletAfter ?? payeeWalletBefore)?.walletId ?? `wallet_${String(settlement?.agentId ?? "")}`
          : null,
      amountCents: cents,
      at,
      memo
    };
    const applied = applyEscrowOperation({ state: ledgerState, input });
    assertEscrowLedgerMatchesWallet({
      ledgerState,
      tenantId,
      wallet: payerWalletAfter ?? payerWalletBefore,
      contextLabel: `${String(type)}:payer`
    });
    if (type === ESCROW_OPERATION_TYPE.RELEASE) {
      assertEscrowLedgerMatchesWallet({
        ledgerState,
        tenantId,
        wallet: payeeWalletAfter ?? payeeWalletBefore,
        contextLabel: `${String(type)}:payee`
      });
    }
    return applied?.operation ?? null;
  }

  function getTenantConfig(tenantId) {
    const normalized = normalizeTenant(tenantId);
    if (typeof store.getConfig === "function") return store.getConfig(normalized);
    return store.config;
  }

  async function getTenantBillingConfig(tenantId) {
    const cfg = getTenantConfig(tenantId) ?? {};
    const fallback = cfg?.billing && typeof cfg.billing === "object" && !Array.isArray(cfg.billing) ? cfg.billing : {};
    if (typeof store.getTenantBillingConfig !== "function") {
      const subscriptionPlanId = resolveActiveSubscriptionPlanId(fallback);
      if (subscriptionPlanId) {
        const configuredPlanId = normalizeBillingPlanId(fallback.plan ?? BILLING_PLAN_ID.FREE, {
          allowNull: false,
          defaultPlan: BILLING_PLAN_ID.FREE
        });
        if (configuredPlanId !== subscriptionPlanId) {
          const synced = { ...fallback, plan: subscriptionPlanId };
          cfg.billing = synced;
          return synced;
        }
      }
      return fallback;
    }
    try {
      const persisted = await store.getTenantBillingConfig({ tenantId: normalizeTenant(tenantId) });
      if (persisted && typeof persisted === "object" && !Array.isArray(persisted)) {
        const subscriptionPlanId = resolveActiveSubscriptionPlanId(persisted);
        if (subscriptionPlanId) {
          const configuredPlanId = normalizeBillingPlanId(persisted.plan ?? BILLING_PLAN_ID.FREE, {
            allowNull: false,
            defaultPlan: BILLING_PLAN_ID.FREE
          });
          if (configuredPlanId !== subscriptionPlanId) {
            const synced = { ...persisted, plan: subscriptionPlanId };
            cfg.billing = synced;
            try {
              await store.putTenantBillingConfig({ tenantId: normalizeTenant(tenantId), billing: synced });
            } catch {
              // Keep serving effective config even if persistence is temporarily unavailable.
            }
            return synced;
          }
        }
        cfg.billing = persisted;
        return persisted;
      }
    } catch {
      // Fall back to in-memory config when store-specific read fails.
    }
    return fallback;
  }

  async function putTenantBillingConfig(tenantId, billing) {
    if (!billing || typeof billing !== "object" || Array.isArray(billing)) {
      throw new TypeError("billing config is required");
    }
    const cfg = getTenantConfig(tenantId);
    if (cfg && typeof cfg === "object") cfg.billing = billing;
    if (typeof store.putTenantBillingConfig === "function") {
      await store.putTenantBillingConfig({ tenantId: normalizeTenant(tenantId), billing });
      return;
    }
    if (!cfg || typeof cfg !== "object") throw new TypeError("tenant config unavailable");
  }

  function countOpenJobsForTenant(tenantId) {
    const t = normalizeTenant(tenantId);
    let count = 0;
    for (const job of store.jobs.values()) {
      if (!job?.id) continue;
      if (normalizeTenant(job.tenantId ?? DEFAULT_TENANT_ID) !== t) continue;
      const status = job.status ?? null;
      if (status === "ABORTED" || status === "SETTLED") continue;
      count += 1;
    }
    return count;
  }

  function getJobZoneId(job) {
    return normalizeZoneId(job?.booking?.zoneId ?? job?.constraints?.zoneId);
  }

  function getRobotZoneId(robot) {
    return normalizeZoneId(robot?.currentZoneId ?? robot?.homeZoneId);
  }

  function robotHasOverlappingReservation({ tenantId, robotId, window, ignoreJobId = null } = {}) {
    const t = normalizeTenant(tenantId);
    for (const other of store.jobs.values()) {
      if (!other?.id || other.id === ignoreJobId) continue;
      const otherTenant = normalizeTenant(other.tenantId ?? DEFAULT_TENANT_ID);
      if (otherTenant !== t) continue;
      const resv = other.reservation;
      if (!resv || resv.robotId !== robotId) continue;
      if (other.status === "ABORTED" || other.status === "SETTLED") continue;
      if (bookingWindowsOverlap(resv, window)) return true;
    }
    return false;
  }

  function countOperatorCoverageOverlaps({ tenantId, operatorId, window, ignoreJobId = null } = {}) {
    const t = normalizeTenant(tenantId);
    let count = 0;
    for (const other of store.jobs.values()) {
      if (!other?.id || other.id === ignoreJobId) continue;
      const otherTenant = normalizeTenant(other.tenantId ?? DEFAULT_TENANT_ID);
      if (otherTenant !== t) continue;
      if (other.status === "ABORTED" || other.status === "SETTLED") continue;
      const cov = other.operatorCoverage;
      if (!cov || cov.status !== "reserved") continue;
      if (cov.operatorId !== operatorId) continue;
      if (bookingWindowsOverlap({ startAt: cov.startAt, endAt: cov.endAt }, window)) count += 1;
    }
    return count;
  }

  function listAvailableOperators({ tenantId, zoneId, window, ignoreJobId = null } = {}) {
    const t = normalizeTenant(tenantId);
    const z = normalizeZoneId(zoneId);
    const candidates = [];
    for (const op of store.operators.values()) {
      if (!op?.id) continue;
      const opTenant = normalizeTenant(op.tenantId ?? DEFAULT_TENANT_ID);
      if (opTenant !== t) continue;
      if (op.shift?.status !== "open") continue;
      const opZoneId = normalizeZoneId(op.shift?.zoneId);
      if (opZoneId !== z) continue;
      const maxConcurrentJobs = op.shift?.maxConcurrentJobs ?? 1;
      const used = countOperatorCoverageOverlaps({ tenantId: t, operatorId: op.id, window, ignoreJobId });
      if (used >= maxConcurrentJobs) continue;
      candidates.push(op);
    }
    candidates.sort((a, b) => a.id.localeCompare(b.id));
    return candidates;
  }

  function listAvailableRobots({ tenantId, zoneId, window, ignoreJobId = null } = {}) {
    const t = normalizeTenant(tenantId);
    const z = normalizeZoneId(zoneId);
    const robots = [];
    for (const robot of store.robots.values()) {
      if (!robot?.id) continue;
      const robotTenant = normalizeTenant(robot.tenantId ?? DEFAULT_TENANT_ID);
      if (robotTenant !== t) continue;
      if (robot.status && robot.status !== "active") continue;
      if (getRobotZoneId(robot) !== z) continue;
      if (!robotIsAvailableForWindow(robot, window)) continue;
      if (robotHasOverlappingReservation({ tenantId: t, robotId: robot.id, window, ignoreJobId })) continue;
      robots.push(robot);
    }
    robots.sort((a, b) => a.id.localeCompare(b.id));
    return robots;
  }

  function getPendingDispatchRequestEvent(events) {
    if (!Array.isArray(events)) throw new TypeError("events must be an array");
    let lastRequestIndex = -1;
    for (let i = events.length - 1; i >= 0; i -= 1) {
      const e = events[i];
      if (e?.type === "DISPATCH_REQUESTED") {
        lastRequestIndex = i;
        break;
      }
    }
    if (lastRequestIndex === -1) return null;

    for (let i = lastRequestIndex + 1; i < events.length; i += 1) {
      const e = events[i];
      if (e?.type === "DISPATCH_CONFIRMED" || e?.type === "DISPATCH_FAILED") return null;
    }

    return events[lastRequestIndex];
  }

	  async function tickDispatch({ maxMessages = 100 } = {}) {
	    if (!Number.isSafeInteger(maxMessages) || maxMessages <= 0) throw new TypeError("maxMessages must be a positive safe integer");
	    if (!Number.isSafeInteger(store.dispatchCursor) || store.dispatchCursor < 0) store.dispatchCursor = 0;

	    const processed = [];
	    const isRobotReservationOverlapError = (err) => {
	      return err?.code === "23P01" || err?.constraint === "robot_reservations_no_overlap";
	    };
	    const isPrevChainMismatchError = (err) => {
	      return err?.code === "PREV_CHAIN_HASH_MISMATCH";
	    };
	    const handleDispatchRequestedMessage = async (message) => {
      if (!message || typeof message !== "object") return null;
      if (message.type !== "DISPATCH_REQUESTED") return null;

      const tenantId = normalizeTenant(message.tenantId ?? DEFAULT_TENANT_ID);

      const jobId = message.jobId;
      if (typeof jobId !== "string" || jobId.trim() === "") return null;

      const existing = getJobEvents(tenantId, jobId);
      if (existing.length === 0) return null;

      const jobBefore = reduceJob(existing);
      if (!jobBefore) return null;
      if (normalizeTenant(jobBefore.tenantId ?? DEFAULT_TENANT_ID) !== tenantId) return null;

      const pendingRequest = getPendingDispatchRequestEvent(existing);
      if (!pendingRequest) return null;
      if (typeof message.sourceEventId === "string" && message.sourceEventId.trim() !== "" && pendingRequest.id !== message.sourceEventId) {
        return null;
      }

      // Idempotency: only dispatch BOOKED jobs that are not already reserved.
      if (jobBefore.status !== "BOOKED") return null;
      if (!jobBefore.booking) return null;
      if (jobBefore.reservation) return null;

      const zoneId = getJobZoneId(jobBefore);
      const window = { startAt: jobBefore.booking.startAt, endAt: jobBefore.booking.endAt };
      const requiresOperatorCoverage = jobBefore.booking.requiresOperatorCoverage === true;

      const robots = listAvailableRobots({ tenantId, zoneId, window, ignoreJobId: jobId });
      const robotCandidates = robots
        .map((r) => ({ robotId: r.id, score: typeof r.trustScore === "number" ? r.trustScore : 0, reasons: ["available"], rejected: false }))
        .sort((a, b) => {
          if (b.score !== a.score) return b.score - a.score;
          return a.robotId.localeCompare(b.robotId);
        });

      const operators = requiresOperatorCoverage ? listAvailableOperators({ tenantId, zoneId, window, ignoreJobId: jobId }) : [];

      const evaluatedAt = nowIso();
      const evalPayload = {
        jobId,
        evaluatedAt,
        window,
        zoneId,
        requiresOperatorCoverage,
        candidates: robotCandidates.slice(0, 10),
        selected: null
      };

      if (robotCandidates.length === 0) {
        const failAt = nowIso();
        const failPayload = { jobId, failedAt: failAt, reason: "NO_ROBOTS", details: { zoneId } };

        const evalDraft = createChainedEvent({
          streamId: jobId,
          type: "DISPATCH_EVALUATED",
          at: evaluatedAt,
          actor: { type: "dispatch", id: "dispatch_v1" },
          payload: evalPayload
        });
        const eventsAfterEval = appendChainedEvent({ events: existing, event: evalDraft, signer: serverSigner });
        const evalEvent = eventsAfterEval[eventsAfterEval.length - 1];

        const failDraft = createChainedEvent({
          streamId: jobId,
          type: "DISPATCH_FAILED",
          at: failAt,
          actor: { type: "dispatch", id: "dispatch_v1" },
          payload: failPayload
        });
        const nextEvents = appendChainedEvent({ events: eventsAfterEval, event: failDraft, signer: serverSigner });
        const failEvent = nextEvents[nextEvents.length - 1];

        try {
          validateDomainEvent({ jobBefore, event: evalEvent, eventsBefore: existing });
          const jobAfterEval = reduceJob(eventsAfterEval);
          validateDomainEvent({ jobBefore: jobAfterEval, event: failEvent, eventsBefore: eventsAfterEval });
        } catch {
          return null;
        }

        await commitTx([
          { kind: "JOB_EVENTS_APPENDED", tenantId, jobId, events: [evalEvent, failEvent] },
          {
            kind: "OUTBOX_ENQUEUE",
            messages: [
              {
                type: "NOTIFY_OPS_DISPATCH_FAILED",
                tenantId,
                jobId,
                at: failAt,
                reason: "NO_ROBOTS",
                zoneId,
                window,
                sourceEventId: failEvent.id
              }
            ]
          }
        ]);
        return { jobId, status: "failed", reason: "NO_ROBOTS" };
      }

      if (requiresOperatorCoverage && operators.length === 0) {
        const failAt = nowIso();
        const failPayload = { jobId, failedAt: failAt, reason: "NO_OPERATORS", details: { zoneId } };

        const evalDraft = createChainedEvent({
          streamId: jobId,
          type: "DISPATCH_EVALUATED",
          at: evaluatedAt,
          actor: { type: "dispatch", id: "dispatch_v1" },
          payload: evalPayload
        });
        const eventsAfterEval = appendChainedEvent({ events: existing, event: evalDraft, signer: serverSigner });
        const evalEvent = eventsAfterEval[eventsAfterEval.length - 1];

        const failDraft = createChainedEvent({
          streamId: jobId,
          type: "DISPATCH_FAILED",
          at: failAt,
          actor: { type: "dispatch", id: "dispatch_v1" },
          payload: failPayload
        });
        const nextEvents = appendChainedEvent({ events: eventsAfterEval, event: failDraft, signer: serverSigner });
        const failEvent = nextEvents[nextEvents.length - 1];

        try {
          validateDomainEvent({ jobBefore, event: evalEvent, eventsBefore: existing });
          const jobAfterEval = reduceJob(eventsAfterEval);
          validateDomainEvent({ jobBefore: jobAfterEval, event: failEvent, eventsBefore: eventsAfterEval });
        } catch {
          return null;
        }

        await commitTx([
          { kind: "JOB_EVENTS_APPENDED", tenantId, jobId, events: [evalEvent, failEvent] },
          {
            kind: "OUTBOX_ENQUEUE",
            messages: [
              {
                type: "NOTIFY_OPS_DISPATCH_FAILED",
                tenantId,
                jobId,
                at: failAt,
                reason: "NO_OPERATORS",
                zoneId,
                window,
                sourceEventId: failEvent.id
              }
            ]
          }
        ]);
        return { jobId, status: "failed", reason: "NO_OPERATORS" };
      }

      for (const cand of robotCandidates) {
        const selectedRobotId = cand.robotId;
        const selectedOperator = requiresOperatorCoverage ? operators[0] : null;

        const evalDraft = createChainedEvent({
          streamId: jobId,
          type: "DISPATCH_EVALUATED",
          at: evaluatedAt,
          actor: { type: "dispatch", id: "dispatch_v1" },
          payload: { ...evalPayload, selected: { robotId: selectedRobotId, operatorId: selectedOperator?.id ?? null } }
        });
        let events = appendChainedEvent({ events: existing, event: evalDraft, signer: serverSigner });
        const evalEvent = events[events.length - 1];

	        const matchDraft = createChainedEvent({
	          streamId: jobId,
	          type: "MATCHED",
	          at: nowIso(),
	          actor: { type: "dispatch", id: "dispatch_v1" },
	          payload: {
	            robotId: selectedRobotId,
	            score: cand.score,
	            algorithm: "trustScore_v2",
	            operatorContractHash: jobBefore.booking?.customerContractHash ?? null,
	            operatorPolicyHash: jobBefore.booking?.policyHash ?? null,
	            operatorCompilerId: jobBefore.booking?.customerCompilerId ?? null
	          }
	        });
        events = appendChainedEvent({ events, event: matchDraft, signer: serverSigner });
        const matchEvent = events[events.length - 1];
        const jobAfterMatch = reduceJob(events);

        const reservationPayload = {
          robotId: selectedRobotId,
          startAt: window.startAt,
          endAt: window.endAt,
          reservationId: createId("rsv"),
          reservedUntil: window.startAt
        };
        const reserveDraft = createChainedEvent({
          streamId: jobId,
          type: "RESERVED",
          at: nowIso(),
          actor: { type: "dispatch", id: "dispatch_v1" },
          payload: reservationPayload
        });
        events = appendChainedEvent({ events, event: reserveDraft, signer: serverSigner });
        const reservedEvent = events[events.length - 1];
        const jobAfterReserve = reduceJob(events);

        let coverageEvent = null;
        if (requiresOperatorCoverage) {
          const coveragePayload = {
            jobId,
            operatorId: selectedOperator.id,
            startAt: window.startAt,
            endAt: window.endAt,
            reservationId: createId("opcov"),
            zoneId
          };
          const coverageDraft = createChainedEvent({
            streamId: jobId,
            type: "OPERATOR_COVERAGE_RESERVED",
            at: nowIso(),
            actor: { type: "dispatch", id: "dispatch_v1" },
            payload: coveragePayload
          });
          events = appendChainedEvent({ events, event: coverageDraft, signer: serverSigner });
          coverageEvent = events[events.length - 1];
        }

        const confirmedAt = nowIso();
        const confirmedDraft = createChainedEvent({
          streamId: jobId,
          type: "DISPATCH_CONFIRMED",
          at: confirmedAt,
          actor: { type: "dispatch", id: "dispatch_v1" },
          payload: { jobId, confirmedAt }
        });
        events = appendChainedEvent({ events, event: confirmedDraft, signer: serverSigner });
        const confirmedEvent = events[events.length - 1];

        try {
          validateDomainEvent({ jobBefore, event: evalEvent, eventsBefore: existing });
          const jobAfterEval = reduceJob([...existing, evalEvent]);
          validateDomainEvent({ jobBefore: jobAfterEval, event: matchEvent, eventsBefore: [...existing, evalEvent] });
          validateDomainEvent({ jobBefore: jobAfterMatch, event: reservedEvent, eventsBefore: [...existing, evalEvent, matchEvent] });
          if (coverageEvent) {
            validateDomainEvent({ jobBefore: jobAfterReserve, event: coverageEvent, eventsBefore: [...existing, evalEvent, matchEvent, reservedEvent] });
          }
          const jobForConfirm = reduceJob(
            coverageEvent ? [...existing, evalEvent, matchEvent, reservedEvent, coverageEvent] : [...existing, evalEvent, matchEvent, reservedEvent]
          );
          validateDomainEvent({
            jobBefore: jobForConfirm,
            event: confirmedEvent,
            eventsBefore: coverageEvent ? [...existing, evalEvent, matchEvent, reservedEvent, coverageEvent] : [...existing, evalEvent, matchEvent, reservedEvent]
          });
        } catch {
          continue;
        }

        const jobAfter = reduceJob(events);
        const appendedEvents = [evalEvent, matchEvent, reservedEvent, ...(coverageEvent ? [coverageEvent] : []), confirmedEvent];
        const outboxMessages = [];
        if (jobBefore.status !== jobAfter.status) {
          outboxMessages.push({ type: "JOB_STATUS_CHANGED", tenantId, jobId, fromStatus: jobBefore.status, toStatus: jobAfter.status, at: confirmedAt });
        }

        const ops = [{ kind: "JOB_EVENTS_APPENDED", tenantId, jobId, events: appendedEvents }];
        if (outboxMessages.length) ops.push({ kind: "OUTBOX_ENQUEUE", messages: outboxMessages });

        try {
          await commitTx(ops);
        } catch (err) {
          if (isRobotReservationOverlapError(err)) {
            continue;
          }
          throw err;
        }

        return { jobId, status: "dispatched", robotId: selectedRobotId, operatorId: selectedOperator?.id ?? null };
      }

      const failAt = nowIso();
      const failPayload = { jobId, failedAt: failAt, reason: "CONFLICT", details: { zoneId } };

      const evalDraft = createChainedEvent({
        streamId: jobId,
        type: "DISPATCH_EVALUATED",
        at: evaluatedAt,
        actor: { type: "dispatch", id: "dispatch_v1" },
        payload: evalPayload
      });
      const eventsAfterEval = appendChainedEvent({ events: existing, event: evalDraft, signer: serverSigner });
      const evalEvent = eventsAfterEval[eventsAfterEval.length - 1];

      const failDraft = createChainedEvent({
        streamId: jobId,
        type: "DISPATCH_FAILED",
        at: failAt,
        actor: { type: "dispatch", id: "dispatch_v1" },
        payload: failPayload
      });
      const nextEvents = appendChainedEvent({ events: eventsAfterEval, event: failDraft, signer: serverSigner });
      const failEvent = nextEvents[nextEvents.length - 1];

      try {
        validateDomainEvent({ jobBefore, event: evalEvent, eventsBefore: existing });
        const jobAfterEval = reduceJob(eventsAfterEval);
        validateDomainEvent({ jobBefore: jobAfterEval, event: failEvent, eventsBefore: eventsAfterEval });
      } catch {
        return null;
      }

      await commitTx([
        { kind: "JOB_EVENTS_APPENDED", tenantId, jobId, events: [evalEvent, failEvent] },
        {
          kind: "OUTBOX_ENQUEUE",
          messages: [
            {
              type: "NOTIFY_OPS_DISPATCH_FAILED",
              tenantId,
              jobId,
              at: failAt,
              reason: "CONFLICT",
              zoneId,
              window,
              sourceEventId: failEvent.id
            }
          ]
        }
      ]);
      return { jobId, status: "failed", reason: "CONFLICT" };
    };

    if (
      store.kind === "pg" &&
      typeof store.claimOutbox === "function" &&
      typeof store.markOutboxProcessed === "function" &&
      typeof store.markOutboxFailed === "function" &&
      typeof store.refreshFromDb === "function"
    ) {
      const claimed = await store.claimOutbox({ topic: "DISPATCH_REQUESTED", maxMessages, worker: "dispatch_v1" });
      if (claimed.length) await store.refreshFromDb();
      for (const row of claimed) {
        try {
          let result = await handleDispatchRequestedMessage(row.message);
          const lastError = result ? null : "skipped";
          await store.markOutboxProcessed({ ids: [row.id], lastError });
          if (result) processed.push(result);
          continue;
        } catch (err) {
          if (isPrevChainMismatchError(err)) {
            try {
              await store.refreshFromDb();
              const result = await handleDispatchRequestedMessage(row.message);
              const lastError = result ? null : "skipped";
              await store.markOutboxProcessed({ ids: [row.id], lastError });
              if (result) processed.push(result);
              continue;
	            } catch (err2) {
	              const lastError = typeof err2?.message === "string" && err2.message.trim() ? err2.message : String(err2 ?? "dispatch failed");
	              if (Number.isSafeInteger(row.attempts) && row.attempts >= outboxMaxAttempts) {
	                await store.markOutboxProcessed({ ids: [row.id], lastError: `DLQ:${lastError}` });
	              } else {
	                await store.markOutboxFailed({ ids: [row.id], lastError });
	              }
	              continue;
	            }
	          }
	          const lastError = typeof err?.message === "string" && err.message.trim() ? err.message : String(err ?? "dispatch failed");
	          if (Number.isSafeInteger(row.attempts) && row.attempts >= outboxMaxAttempts) {
	            await store.markOutboxProcessed({ ids: [row.id], lastError: `DLQ:${lastError}` });
	          } else {
	            await store.markOutboxFailed({ ids: [row.id], lastError });
	          }
	          continue;
	        }
	      }
      return { processed, cursor: store.dispatchCursor };
    }

    while (store.dispatchCursor < store.outbox.length && processed.length < maxMessages) {
      const message = store.outbox[store.dispatchCursor];
      store.dispatchCursor += 1;
      const result = await handleDispatchRequestedMessage(message);
      if (result) processed.push(result);
    }

    return { processed, cursor: store.dispatchCursor };
  }

  async function tickOperatorQueue({ maxMessages = 100 } = {}) {
    if (!Number.isSafeInteger(maxMessages) || maxMessages <= 0) throw new TypeError("maxMessages must be a positive safe integer");
    if (!Number.isSafeInteger(store.operatorQueueCursor) || store.operatorQueueCursor < 0) store.operatorQueueCursor = 0;

    const processed = [];
    while (store.operatorQueueCursor < store.outbox.length && processed.length < maxMessages) {
      const message = store.outbox[store.operatorQueueCursor];
      store.operatorQueueCursor += 1;
      if (!message || typeof message !== "object") continue;
      if (message.type !== "ESCALATION_NEEDED") continue;
      if (message.kind !== "OPERATOR_ASSIST") continue;

      const jobId = message.jobId;
      if (typeof jobId !== "string" || jobId.trim() === "") continue;

      const tenantId = normalizeTenant(message.tenantId ?? DEFAULT_TENANT_ID);
      const existing = getJobEvents(tenantId, jobId);
      if (existing.length === 0) continue;
      const jobBefore = reduceJob(existing);
      if (!jobBefore) continue;
      if (!jobBefore.booking?.requiresOperatorCoverage) continue;
      if (jobBefore.status !== "STALLED") continue;

      // Only queue once.
      if (
        jobBefore.assist?.status === "queued" ||
        jobBefore.assist?.status === "assigned" ||
        jobBefore.assist?.status === "accepted" ||
        jobBefore.assist?.status === "declined" ||
        jobBefore.assist?.status === "timeout"
      ) {
        continue;
      }

      const zoneId = getJobZoneId(jobBefore);
      const window = jobBefore.reservation
        ? { startAt: jobBefore.reservation.startAt, endAt: jobBefore.reservation.endAt }
        : jobBefore.booking
          ? { startAt: jobBefore.booking.startAt, endAt: jobBefore.booking.endAt }
          : null;

      const at = nowIso();
      const queueId = createId("aq");

      const queuedDraft = createChainedEvent({
        streamId: jobId,
        type: "ASSIST_QUEUED",
        at,
        actor: { type: "ops", id: "assist_queue_v0" },
        payload: { jobId, queueId, queuedAt: at, reason: "LIVENESS_STALL", priority: "HIGH" }
      });
      let events = appendChainedEvent({ events: existing, event: queuedDraft, signer: serverSigner });
      const queuedEvent = events[events.length - 1];

      // Prefer the reserved coverage operator if present.
      let operatorId = jobBefore.operatorCoverage?.status === "reserved" ? jobBefore.operatorCoverage.operatorId : null;
      if (operatorId) {
        const op = store.operators.get(operatorStoreKey(tenantId, operatorId));
        if (!op || op.shift?.status !== "open") operatorId = null;
        else if (normalizeZoneId(op.shift?.zoneId) !== zoneId) operatorId = null;
      }
      if (!operatorId) {
        const available = window
          ? listAvailableOperators({ tenantId, zoneId, window, ignoreJobId: jobId })
          : listAvailableOperators({ tenantId, zoneId, window: { startAt: at, endAt: at }, ignoreJobId: jobId });
        operatorId = available[0]?.id ?? null;
      }

      if (!operatorId) {
        const timedOutAt = nowIso();
        const timeoutDraft = createChainedEvent({
          streamId: jobId,
          type: "ASSIST_TIMEOUT",
          at: timedOutAt,
          actor: { type: "ops", id: "assist_queue_v0" },
          payload: { jobId, queueId, timedOutAt, reason: "NO_OPERATOR_CAPACITY" }
        });
        events = appendChainedEvent({ events, event: timeoutDraft, signer: serverSigner });
        const timeoutEvent = events[events.length - 1];

        try {
          validateDomainEvent({ jobBefore, event: queuedEvent, eventsBefore: existing });
          const jobAfterQueued = reduceJob([...existing, queuedEvent]);
          validateDomainEvent({ jobBefore: jobAfterQueued, event: timeoutEvent, eventsBefore: [...existing, queuedEvent] });
        } catch {
          continue;
        }

        await commitTx([{ kind: "JOB_EVENTS_APPENDED", tenantId, jobId, events: [queuedEvent, timeoutEvent] }]);
        processed.push({ jobId, status: "timeout" });
        continue;
      }

      const assignedAt = nowIso();
      const assignedDraft = createChainedEvent({
        streamId: jobId,
        type: "ASSIST_ASSIGNED",
        at: assignedAt,
        actor: { type: "ops", id: "assist_queue_v0" },
        payload: { jobId, queueId, operatorId, assignedAt }
      });
      events = appendChainedEvent({ events, event: assignedDraft, signer: serverSigner });
      const assignedEvent = events[events.length - 1];

      try {
        validateDomainEvent({ jobBefore, event: queuedEvent, eventsBefore: existing });
        const jobAfterQueued = reduceJob([...existing, queuedEvent]);
        validateDomainEvent({ jobBefore: jobAfterQueued, event: assignedEvent, eventsBefore: [...existing, queuedEvent] });
      } catch {
        continue;
      }

      await commitTx([{ kind: "JOB_EVENTS_APPENDED", tenantId, jobId, events: [queuedEvent, assignedEvent] }]);

      processed.push({ jobId, status: "assigned", operatorId });
    }

    return { processed, cursor: store.operatorQueueCursor };
  }

  async function tickRobotHealth({ maxMessages = 100 } = {}) {
    if (!Number.isSafeInteger(maxMessages) || maxMessages <= 0) throw new TypeError("maxMessages must be a positive safe integer");
    if (!Number.isSafeInteger(store.robotHealthCursor) || store.robotHealthCursor < 0) store.robotHealthCursor = 0;

    const processed = [];
    while (store.robotHealthCursor < store.outbox.length && processed.length < maxMessages) {
      const message = store.outbox[store.robotHealthCursor];
      store.robotHealthCursor += 1;

      if (!message || typeof message !== "object") continue;

      if (message.type !== "INCIDENT_RECORDED" && message.type !== "JOB_STALLED") continue;

      const robotId = message.robotId;
      if (typeof robotId !== "string" || robotId.trim() === "") continue;

      const tenantId = normalizeTenant(message.tenantId ?? DEFAULT_TENANT_ID);
      const existingRobotEvents = getRobotEvents(tenantId, robotId);
      if (existingRobotEvents.length === 0) continue;

      const robotBefore = reduceRobot(existingRobotEvents);
      if (!robotBefore) continue;

      // Idempotency: never re-quarantine a currently quarantined robot.
      if (robotBefore.status === "quarantined") continue;

      let shouldQuarantine = false;
      let quarantineReason = "MANUAL";
      let quarantineNotes = null;
      let quarantineIncidentId = null;
      let quarantineJobId = null;

      if (message.type === "INCIDENT_RECORDED") {
        const severity = message.severity;
        const incidentType = message.incidentType;
        const incidentId = message.incidentId ?? null;
        const jobId = message.jobId ?? null;

        if (typeof incidentId === "string" && incidentId.trim() !== "") {
          // Idempotency: avoid reprocessing the same incident.
          const already = existingRobotEvents.some((e) => e.type === "ROBOT_QUARANTINED" && e.payload?.incidentId === incidentId);
          if (already) continue;
        }

        // Policy: auto-quarantine on high severity or safety-related incidents.
        if (Number.isSafeInteger(severity) && severity >= 4) shouldQuarantine = true;
        if (incidentType === "SAFETY_NEAR_MISS" && Number.isSafeInteger(severity) && severity >= 3) shouldQuarantine = true;
        if (incidentType === "UNEXPECTED_HUMAN_CONTACT" && Number.isSafeInteger(severity) && severity >= 3) shouldQuarantine = true;

        if (shouldQuarantine) {
          quarantineReason = "INCIDENT";
          quarantineNotes = `auto quarantine: incident ${incidentType ?? "UNKNOWN"} severity ${severity ?? "?"}`;
          quarantineIncidentId = typeof incidentId === "string" ? incidentId : null;
          quarantineJobId = typeof jobId === "string" ? jobId : null;
        }
      }

      if (message.type === "JOB_STALLED") {
        const stallAt = message.at;
        const refMs = Date.parse(stallAt);
        if (Number.isFinite(refMs)) {
          const lookbackMs = 60 * 60_000;
          const sinceMs = refMs - lookbackMs;
          let stallCount = 0;
          for (const [key, events] of store.jobEvents.entries()) {
            const otherTenant = key.includes("\n") ? parseScopedKey(key).tenantId : DEFAULT_TENANT_ID;
            if (normalizeTenant(otherTenant) !== tenantId) continue;
            if (!Array.isArray(events) || events.length === 0) continue;
            for (const e of events) {
              if (e?.type !== "JOB_EXECUTION_STALLED") continue;
              const rid = e.payload?.robotId ?? null;
              if (rid !== robotId) continue;
              const t = Date.parse(e.at);
              if (Number.isFinite(t) && t >= sinceMs) stallCount += 1;
            }
          }
          if (stallCount >= 3) {
            shouldQuarantine = true;
            quarantineReason = "REPEATED_STALLS";
            quarantineNotes = `auto quarantine: ${stallCount} stalls in last ${lookbackMs / 60_000} minutes`;
          }
        }
      }

      if (!shouldQuarantine) continue;

      const quarantinedAt = nowIso();
      const quarantinePayload = {
        robotId,
        quarantinedAt,
        reason: quarantineReason,
        manualClearRequired: true,
        incidentId: quarantineIncidentId,
        jobId: quarantineJobId,
        notes: quarantineNotes
      };

      const draft = createChainedEvent({
        streamId: robotId,
        type: "ROBOT_QUARANTINED",
        at: quarantinedAt,
        actor: { type: "trust", id: "robot_health_v0" },
        payload: quarantinePayload
      });
      const nextRobotEvents = appendChainedEvent({ events: existingRobotEvents, event: draft, signer: serverSigner });
      const event = nextRobotEvents[nextRobotEvents.length - 1];

      try {
        enforceSignaturePolicy({ tenantId, signerKind: requiredSignerKindForEventType(event.type), event });
      } catch {
        continue;
      }

      try {
        reduceRobot(nextRobotEvents);
      } catch {
        continue;
      }

      const notifyMessages = [
        {
          type: "NOTIFY_OPS_ROBOT_QUARANTINED",
          tenantId,
          robotId,
          at: quarantinedAt,
          reason: quarantineReason,
          incidentId: quarantineIncidentId,
          jobId: quarantineJobId,
          ownerId: robotBefore.ownerId ?? null,
          sourceEventId: event.id
        }
      ];
      if (robotBefore.ownerId) {
        notifyMessages.push({
          type: "NOTIFY_OWNER_ROBOT_QUARANTINED",
          tenantId,
          ownerId: robotBefore.ownerId,
          robotId,
          at: quarantinedAt,
          reason: quarantineReason,
          incidentId: quarantineIncidentId,
          jobId: quarantineJobId,
          sourceEventId: event.id
        });
      }

      await commitTx([
        { kind: "ROBOT_EVENTS_APPENDED", tenantId, robotId, events: [event] },
        { kind: "OUTBOX_ENQUEUE", messages: notifyMessages }
      ]);

      processed.push({ robotId, status: "quarantined", reason: quarantineReason });
    }

    return { processed, cursor: store.robotHealthCursor };
  }

  async function tickJobAccounting({ maxMessages = 100 } = {}) {
    if (!Number.isSafeInteger(maxMessages) || maxMessages <= 0) throw new TypeError("maxMessages must be a positive safe integer");
    if (!Number.isSafeInteger(store.jobAccountingCursor) || store.jobAccountingCursor < 0) store.jobAccountingCursor = 0;

    const processed = [];

    const getLastSettledEventId = (events) => {
      for (let i = events.length - 1; i >= 0; i -= 1) {
        const e = events[i];
        if (e?.type === "SETTLED") return e.id ?? null;
      }
      return null;
    };

    const computeAssistSeconds = (events, { endAt }) => {
      const endMs = Date.parse(endAt);
      const openByOperatorId = new Map();
      const usedOperatorIds = new Set();

      let totalMs = 0;
      for (const e of events) {
        if (e?.type !== "ASSIST_STARTED" && e?.type !== "ASSIST_ENDED") continue;
        const operatorId = e.actor?.type === "operator" ? e.actor.id : null;
        if (!operatorId) continue;
        const t = Date.parse(e.at);
        if (!Number.isFinite(t)) continue;

        if (e.type === "ASSIST_STARTED") {
          usedOperatorIds.add(operatorId);
          const open = openByOperatorId.get(operatorId);
          if (Number.isFinite(open)) {
            const delta = t - open;
            if (delta > 0) totalMs += delta;
          }
          openByOperatorId.set(operatorId, t);
          continue;
        }

        const open = openByOperatorId.get(operatorId);
        if (!Number.isFinite(open)) continue;
        const delta = t - open;
        if (delta > 0) totalMs += delta;
        openByOperatorId.delete(operatorId);
      }

      if (Number.isFinite(endMs)) {
        for (const startMs of openByOperatorId.values()) {
          const delta = endMs - startMs;
          if (delta > 0) totalMs += delta;
        }
      }

      const assistSeconds = Math.floor(totalMs / 1000);
      return { assistSeconds, usedOperatorIds: Array.from(usedOperatorIds).sort() };
    };

    const computeTotalStallMs = (events, { endAt }) => {
      const endMs = Date.parse(endAt);
      let stallStartMs = null;
      let totalStallMs = 0;

      for (const e of events) {
        if (!e || typeof e !== "object") continue;
        const t = Date.parse(e.at);
        if (!Number.isFinite(t)) continue;

        if (e.type === "JOB_EXECUTION_STALLED") {
          if (stallStartMs === null) stallStartMs = t;
          continue;
        }
        if (e.type === "JOB_EXECUTION_RESUMED") {
          if (stallStartMs === null) continue;
          const delta = t - stallStartMs;
          if (delta > 0) totalStallMs += delta;
          stallStartMs = null;
        }
      }

      if (stallStartMs !== null && Number.isFinite(endMs)) {
        const delta = endMs - stallStartMs;
        if (delta > 0) totalStallMs += delta;
      }

      return totalStallMs;
    };

    while (store.jobAccountingCursor < store.outbox.length && processed.length < maxMessages) {
      const message = store.outbox[store.jobAccountingCursor];
      store.jobAccountingCursor += 1;

      if (!message || typeof message !== "object") continue;
      if (message.type !== "JOB_SETTLED") continue;

      const jobId = message.jobId;
      const settledEventId = message.settledEventId;
      if (typeof jobId !== "string" || jobId.trim() === "") continue;
      if (typeof settledEventId !== "string" || settledEventId.trim() === "") continue;

      const tenantId = normalizeTenant(message.tenantId ?? DEFAULT_TENANT_ID);
      const existing = getJobEvents(tenantId, jobId);
      if (existing.length === 0) continue;

      const lastSettledEventId = getLastSettledEventId(existing);
      if (!lastSettledEventId) continue;
      if (lastSettledEventId !== settledEventId) continue;

      const jobBefore = reduceJob(existing);
      if (!jobBefore) continue;
      if (jobBefore.status !== "SETTLED") continue;

      const alreadyCost = existing.some((e) => e.type === "OPERATOR_COST_RECORDED" && e.payload?.settledEventId === settledEventId);
      const alreadyBreach = existing.some((e) => e.type === "SLA_BREACH_DETECTED" && e.payload?.settledEventId === settledEventId);
      const alreadyCredit = existing.some((e) => e.type === "SLA_CREDIT_ISSUED" && e.payload?.settledEventId === settledEventId);

      const config = getTenantConfig(tenantId);
      const bookingCreditPolicy = jobBefore.booking?.creditPolicy ?? null;
      const shouldTryCredits = bookingCreditPolicy?.enabled === true;

      if (alreadyCost && alreadyBreach && (!shouldTryCredits || alreadyCredit)) {
        processed.push({ jobId, status: "noop" });
        continue;
      }

      const settledAt = message.at ?? nowIso();
      const endAt = jobBefore.execution?.completedAt ?? jobBefore.execution?.abortedAt ?? settledAt;

      const zoneId = getJobZoneId(jobBefore);
      const rateByZone = config?.operatorCost?.rateCentsPerMinuteByZone ?? {};
      const configuredRate = rateByZone[zoneId] ?? rateByZone.default ?? 0;
      const rateCentsPerMinute =
        Number.isSafeInteger(configuredRate) && configuredRate >= 0 ? configuredRate : 0;
      const basis = config?.operatorCost?.basis ?? "SHIFT_RATE";

      let events = existing;
      let workingJob = jobBefore;
      const appendedEvents = [];
      const outboxMessages = [];

      if (!alreadyCost) {
        const assist = computeAssistSeconds(events, { endAt });
        const assistSeconds = assist.assistSeconds;
        const operatorId = assist.usedOperatorIds.length === 1 ? assist.usedOperatorIds[0] : null;

        const costCents = computeOperatorCostCents({ assistSeconds, rateCentsPerMinute });
        const at = nowIso();
        const payload = {
          jobId,
          zoneId,
          operatorId,
          assistSeconds,
          rateCentsPerMinute,
          costCents,
          currency: "USD",
          basis,
          settledEventId
        };

        const draft = createChainedEvent({
          streamId: jobId,
          type: "OPERATOR_COST_RECORDED",
          at,
          actor: { type: "accounting", id: "job_accounting_v0" },
          payload
        });
        const nextEvents = appendChainedEvent({ events, event: draft, signer: serverSigner });
        const costEvent = nextEvents[nextEvents.length - 1];

        try {
          validateDomainEvent({ jobBefore: workingJob, event: costEvent, eventsBefore: events });
        } catch {
          continue;
        }

        let ledgerEntries = [];
        try {
          ledgerEntries = ledgerEntriesForJobEvent({ jobBefore: workingJob, event: costEvent, eventsBefore: events });
        } catch {
          continue;
        }

        events = nextEvents;
        try {
          workingJob = reduceJob(events);
        } catch {
          continue;
        }

        appendedEvents.push(costEvent);
        for (const entry of ledgerEntries) {
          if (!entry) continue;
          outboxMessages.push({ type: "LEDGER_ENTRY_APPLY", tenantId, jobId, sourceEventId: costEvent.id, entry });
        }
      }

      if (!alreadyBreach) {
        const booking = workingJob.booking ?? null;
        const policy = booking?.sla ?? null;
        const window = booking ? { startAt: booking.startAt, endAt: booking.endAt } : null;

        if (!booking || !policy || !window) {
          // Skip if booking data is missing; cannot compute SLA.
        } else {
          const breaches = [];

          const windowStartMs = Date.parse(window.startAt);
          const windowEndMs = Date.parse(window.endAt);

          const startedAt = workingJob.execution?.startedAt ?? null;
          const completedAt = workingJob.execution?.completedAt ?? null;
          const abortedAt = workingJob.execution?.abortedAt ?? null;

          const startedMs = startedAt ? Date.parse(startedAt) : NaN;
          const completedMs = completedAt ? Date.parse(completedAt) : NaN;
          const abortedMs = abortedAt ? Date.parse(abortedAt) : NaN;

          if (policy.mustStartWithinWindow === true && Number.isFinite(windowEndMs) && Number.isFinite(startedMs) && startedMs > windowEndMs) {
            breaches.push({
              type: SLA_BREACH_TYPE.START_LATE,
              startedAt,
              windowStartAt: window.startAt,
              windowEndAt: window.endAt,
              latenessMs: Math.max(0, startedMs - windowEndMs)
            });
          }

          if (Number.isFinite(windowEndMs) && Number.isFinite(completedMs) && completedMs > windowEndMs) {
            breaches.push({
              type: SLA_BREACH_TYPE.COMPLETE_LATE,
              completedAt,
              windowEndAt: window.endAt,
              latenessMs: Math.max(0, completedMs - windowEndMs)
            });
          }

          if (abortedAt && Number.isFinite(abortedMs)) {
            breaches.push({ type: SLA_BREACH_TYPE.ABORTED, abortedAt });
          }

          const totalStallMs = computeTotalStallMs(events, { endAt });
          if (Number.isSafeInteger(policy.maxStallMs) && policy.maxStallMs > 0 && totalStallMs > policy.maxStallMs) {
            breaches.push({
              type: SLA_BREACH_TYPE.EXCESS_STALL,
              totalStallMs,
              maxStallMs: policy.maxStallMs
            });
          }

          if (breaches.length) {
            const detectedAt = nowIso();
            const policyHash = workingJob.booking?.policyHash ?? null;
            const payload = {
              jobId,
              detectedAt,
              settledEventId,
              policyHash,
              window,
              policy,
              breaches
            };

            const draft = createChainedEvent({
              streamId: jobId,
              type: "SLA_BREACH_DETECTED",
              at: detectedAt,
              actor: { type: "accounting", id: "job_accounting_v0" },
              payload
            });
            const nextEvents = appendChainedEvent({ events, event: draft, signer: serverSigner });
            const breachEvent = nextEvents[nextEvents.length - 1];

            try {
              validateDomainEvent({ jobBefore: workingJob, event: breachEvent, eventsBefore: events });
            } catch {
              continue;
            }

            events = nextEvents;
            try {
              workingJob = reduceJob(events);
            } catch {
              continue;
            }

            appendedEvents.push(breachEvent);
          }
        }
      }

      if (shouldTryCredits && !alreadyCredit) {
        const alreadyHasBreach = events.some((e) => e.type === "SLA_BREACH_DETECTED" && e.payload?.settledEventId === settledEventId);

        const computeCreditAmountCents = ({ creditPolicy, breachEvent }) => {
          const defaultAmountCents = creditPolicy?.defaultAmountCents ?? 0;
          const maxCents = creditPolicy?.maxAmountCents ?? 0;
          const ladder = Array.isArray(creditPolicy?.ladder) ? creditPolicy.ladder : null;

          let amountCents = Number.isSafeInteger(defaultAmountCents) && defaultAmountCents > 0 ? defaultAmountCents : 0;

          if (ladder && ladder.length && breachEvent?.payload?.breaches && Array.isArray(breachEvent.payload.breaches)) {
            let maxLatenessMs = 0;
            let aborted = false;
            for (const b of breachEvent.payload.breaches) {
              if (b?.type === SLA_BREACH_TYPE.ABORTED) aborted = true;
              const lm = b?.latenessMs ?? null;
              if (Number.isSafeInteger(lm) && lm > maxLatenessMs) maxLatenessMs = lm;
            }
            if (aborted && maxLatenessMs === 0) maxLatenessMs = Number.MAX_SAFE_INTEGER;

            for (const tier of ladder) {
              const gte = tier?.latenessMsGte ?? null;
              const cents = tier?.amountCents ?? null;
              if (!Number.isSafeInteger(gte) || !Number.isSafeInteger(cents)) continue;
              if (gte <= maxLatenessMs) amountCents = Math.max(0, cents);
            }
          }

          if (Number.isSafeInteger(maxCents) && maxCents > 0) amountCents = Math.min(amountCents, maxCents);
          return amountCents;
        };

        if (alreadyHasBreach) {
          const breachEvent = (() => {
            for (let i = events.length - 1; i >= 0; i -= 1) {
              const e = events[i];
              if (e?.type !== "SLA_BREACH_DETECTED") continue;
              if (e?.payload?.settledEventId !== settledEventId) continue;
              return e;
            }
            return null;
          })();

          const amountCents = computeCreditAmountCents({ creditPolicy: bookingCreditPolicy, breachEvent });
          if (amountCents > 0) {
            let trigger = null;
            if (
              breachEvent &&
              breachEvent.id &&
              breachEvent.payload?.window?.startAt &&
              breachEvent.payload?.window?.endAt &&
              breachEvent.payload?.policy &&
              Array.isArray(breachEvent.payload?.breaches) &&
              breachEvent.payload.breaches.length
            ) {
              trigger = {
                type: SLA_CREDIT_TRIGGER_TYPE.SLA_BREACH,
                breachEventId: breachEvent.id,
                detectedAt: breachEvent.payload?.detectedAt ?? breachEvent.at,
                window: breachEvent.payload.window,
                policy: breachEvent.payload.policy,
                breaches: breachEvent.payload.breaches
              };
            }

            const issuedAt = nowIso();
            const policyHash = workingJob.booking?.policyHash ?? null;
            const payload = {
              jobId,
              creditId: createId("cred"),
              issuedAt,
              amountCents,
              currency: "USD",
              reason: "SLA_BREACH",
              settledEventId,
              policyHash,
              trigger
            };

            const draft = createChainedEvent({
              streamId: jobId,
              type: "SLA_CREDIT_ISSUED",
              at: issuedAt,
              actor: { type: "accounting", id: "job_accounting_v0" },
              payload
            });
            const nextEvents = appendChainedEvent({ events, event: draft, signer: serverSigner });
            const creditEvent = nextEvents[nextEvents.length - 1];

            try {
              validateDomainEvent({ jobBefore: workingJob, event: creditEvent, eventsBefore: events });
            } catch {
              continue;
            }

            let ledgerEntries = [];
            try {
              ledgerEntries = ledgerEntriesForJobEvent({ jobBefore: workingJob, event: creditEvent, eventsBefore: events });
            } catch {
              continue;
            }

            events = nextEvents;
            try {
              workingJob = reduceJob(events);
            } catch {
              continue;
            }

            appendedEvents.push(creditEvent);
            for (const entry of ledgerEntries) {
              if (!entry) continue;
              outboxMessages.push({ type: "LEDGER_ENTRY_APPLY", tenantId, jobId, sourceEventId: creditEvent.id, entry });
            }
          }
        }
      }

      if (appendedEvents.length === 0) {
        processed.push({ jobId, status: "noop" });
        continue;
      }

      const jobAfter = workingJob;

      const ops = [{ kind: "JOB_EVENTS_APPENDED", tenantId, jobId, events: appendedEvents }];
      if (outboxMessages.length) ops.push({ kind: "OUTBOX_ENQUEUE", messages: outboxMessages });

      await commitTx(ops);

      processed.push({ jobId, status: "recorded", events: appendedEvents.map((e) => e.type) });
    }

    return { processed, cursor: store.jobAccountingCursor };
  }

  async function tickEvidenceRetention({ maxJobs = 1000 } = {}) {
    if (!Number.isSafeInteger(maxJobs) || maxJobs <= 0) throw new TypeError("maxJobs must be a positive safe integer");
    const at = nowIso();
    const nowMs = Date.parse(at);
    const nowMsSafe = Number.isFinite(nowMs) ? nowMs : Date.now();

    const processed = [];
    let scanned = 0;

    if (!store.evidenceStore || typeof store.evidenceStore.deleteEvidence !== "function") {
      return { processed, scanned: 0, skipped: "evidence_store_unavailable" };
    }

    for (const jobSnap of store.jobs.values()) {
      if (!jobSnap?.id) continue;
      scanned += 1;
      if (scanned > maxJobs) break;

      const tenantId = normalizeTenant(jobSnap.tenantId ?? DEFAULT_TENANT_ID);
      const existing = getJobEvents(tenantId, jobSnap.id);
      if (!existing.length) continue;

      let jobBefore;
      try {
        jobBefore = reduceJob(existing);
      } catch {
        continue;
      }
      if (!jobBefore) continue;

      const retentionDays = jobBefore.booking?.evidencePolicy?.retentionDays ?? 0;
      if (!Number.isSafeInteger(retentionDays) || retentionDays <= 0) continue;

      const retentionMs = retentionDays * 24 * 60 * 60_000;
      const evidenceItems = Array.isArray(jobBefore.evidence) ? jobBefore.evidence : [];
      if (!evidenceItems.length) continue;

      let events = existing;
      const appended = [];

      for (const ev of evidenceItems) {
        const evidenceId = ev?.evidenceId ?? null;
        const evidenceRef = ev?.evidenceRef ?? null;
        const capturedAt = ev?.at ?? null;
        if (!evidenceId || typeof evidenceId !== "string") continue;
        if (!evidenceRef || typeof evidenceRef !== "string" || !evidenceRef.startsWith("obj://")) continue;
        if (ev?.expiredAt) continue;
        const capturedMs = capturedAt ? Date.parse(capturedAt) : NaN;
        if (!Number.isFinite(capturedMs)) continue;
        if (nowMsSafe - capturedMs <= retentionMs) continue;

        // Delete object (best effort), then append an auditable expiration event.
        try {
          await store.evidenceStore.deleteEvidence({ tenantId, evidenceRef });
        } catch {
          // Ignore deletion failure; we still record expiration so access is denied.
        }

        const payload = {
          jobId: jobBefore.id,
          evidenceId,
          evidenceRef,
          expiredAt: at,
          retentionDays,
          policyHash: jobBefore.booking?.policyHash ?? null
        };
        const draft = createChainedEvent({
          streamId: jobBefore.id,
          type: "EVIDENCE_EXPIRED",
          at,
          actor: { type: "retention", id: "retention_v0" },
          payload
        });
        const nextEvents = appendChainedEvent({ events, event: draft, signer: serverSigner });
        const expiredEvent = nextEvents[nextEvents.length - 1];

        try {
          enforceSignaturePolicy({ tenantId, signerKind: requiredSignerKindForEventType(expiredEvent.type), event: expiredEvent });
          validateDomainEvent({ jobBefore, event: expiredEvent, eventsBefore: events });
          reduceJob(nextEvents);
        } catch {
          continue;
        }

        events = nextEvents;
        appended.push(expiredEvent);
      }

      if (appended.length) {
        try {
          await commitTx([{ kind: "JOB_EVENTS_APPENDED", tenantId, jobId: jobBefore.id, events: appended }]);
          processed.push({ jobId: jobBefore.id, expired: appended.length });
        } catch {
          // Ignore: retention is best-effort and can retry later.
        }
      }
    }

    return { processed, scanned };
  }

  async function tickRetentionCleanup({
    tenantId = null,
    maxRows = retentionCleanupDefaultBatchSize,
    maxMillis = retentionCleanupDefaultMaxMillis,
    dryRun = retentionCleanupDefaultDryRun,
    requireLock = false
  } = {}) {
    const startedMs = Date.now();
    const scopedTenantId = tenantId === null || tenantId === undefined ? null : normalizeTenant(tenantId);
    const scope = scopedTenantId ? "tenant" : "global";

    if (!Number.isSafeInteger(maxRows) || maxRows <= 0) throw new TypeError("maxRows must be a positive safe integer");
    const safeMaxRows = Math.min(10_000, maxRows);
    if (!Number.isSafeInteger(maxMillis) || maxMillis <= 0) throw new TypeError("maxMillis must be a positive safe integer");
    const safeMaxMillis = Math.min(60_000, maxMillis);
    const safeDryRun = dryRun === true;

    const lockKey = RETENTION_CLEANUP_ADVISORY_LOCK_KEY;
    let locked = false;
    let lockClient = null;

    try {
      if (requireLock) {
        if (store?.kind === "pg" && store?.pg?.pool) {
          lockClient = await store.pg.pool.connect();
          const res = await lockClient.query("SELECT pg_try_advisory_lock(hashtext($1)) AS ok", [lockKey]);
          locked = Boolean(res.rows[0]?.ok);
          if (!locked) {
            try {
              lockClient.release();
            } catch {}
            lockClient = null;
            const runtimeMs = Date.now() - startedMs;
            logger.info("retention.cleanup.skip", { scope, reason: "already_running", dryRun: safeDryRun, runtimeMs });
            metricGauge("retention_run_seconds", { result: "already_running", scope, dry_run: safeDryRun ? "true" : "false" }, runtimeMs / 1000);
            metricInc("maintenance_runs_total", { kind: "retention_cleanup", result: "already_running", scope, dry_run: safeDryRun ? "true" : "false" }, 1);
            return {
              ok: false,
              code: "MAINTENANCE_ALREADY_RUNNING",
              scope,
              dryRun: safeDryRun,
              maxRows: safeMaxRows,
              maxMillis: safeMaxMillis,
              runtimeMs
            };
          }
        } else {
          store.__retentionCleanupLockHeld = store.__retentionCleanupLockHeld === true;
          if (store.__retentionCleanupLockHeld) {
            const runtimeMs = Date.now() - startedMs;
            logger.info("retention.cleanup.skip", { scope, reason: "already_running", dryRun: safeDryRun, runtimeMs });
            metricGauge("retention_run_seconds", { result: "already_running", scope, dry_run: safeDryRun ? "true" : "false" }, runtimeMs / 1000);
            metricInc("maintenance_runs_total", { kind: "retention_cleanup", result: "already_running", scope, dry_run: safeDryRun ? "true" : "false" }, 1);
            return {
              ok: false,
              code: "MAINTENANCE_ALREADY_RUNNING",
              scope,
              dryRun: safeDryRun,
              maxRows: safeMaxRows,
              maxMillis: safeMaxMillis,
              runtimeMs
            };
          }
          store.__retentionCleanupLockHeld = true;
          locked = true;
        }
      }

      const at = nowIso();
      try {
        logger.info("retention.cleanup.start", {
          scope,
          tenantId: scopedTenantId,
          dryRun: safeDryRun,
          maxRows: safeMaxRows,
          maxMillis: safeMaxMillis
        });

        const processed = [];
        let ingestRecordsPurgedTotal = 0;
        let deliveriesPurgedTotal = 0;
        let deliveryReceiptsPurgedTotal = 0;
        let timedOut = false;

        if (store?.kind === "pg" && typeof store.cleanupRetention === "function") {
          const result = await store.cleanupRetention({
            tenantId: scope === "global" ? null : scopedTenantId,
            maxRows: safeMaxRows,
            maxMillis: safeMaxMillis,
            dryRun: safeDryRun
          });
          processed.push(result);
          ingestRecordsPurgedTotal = Number(result?.ingestRecordsPurged ?? 0);
          deliveriesPurgedTotal = Number(result?.deliveriesPurged ?? 0);
          deliveryReceiptsPurgedTotal = Number(result?.deliveryReceiptsPurged ?? 0);
          timedOut = result?.timedOut === true;
        } else {
          const nowMs = Date.parse(at);
          const nowMsSafe = Number.isFinite(nowMs) ? nowMs : Date.now();

          const tenants = [];
          if (scopedTenantId) {
            tenants.push(scopedTenantId);
          } else if (store?.configByTenant instanceof Map) {
            for (const t of store.configByTenant.keys()) tenants.push(normalizeTenant(t));
          } else {
            tenants.push(DEFAULT_TENANT_ID);
          }

          // Dedupe
          const seen = new Set();
          const uniqueTenants = [];
          for (const t of tenants) {
            const n = normalizeTenant(t);
            if (seen.has(n)) continue;
            seen.add(n);
            uniqueTenants.push(n);
          }

          for (const t of uniqueTenants) {
            const elapsed = Date.now() - startedMs;
            if (elapsed >= safeMaxMillis) {
              timedOut = true;
              break;
            }

            let ingestRecordsPurged = 0;
            if (store.ingestRecords instanceof Map) {
              for (const [, r] of store.ingestRecords.entries()) {
                if (ingestRecordsPurged >= safeMaxRows) break;
                if (!r || typeof r !== "object") continue;
                if (normalizeTenant(r.tenantId ?? DEFAULT_TENANT_ID) !== t) continue;
                const expiresAt = r.expiresAt ?? null;
                if (!expiresAt || typeof expiresAt !== "string") continue;
                const expMs = Date.parse(expiresAt);
                if (!Number.isFinite(expMs)) continue;
                if (expMs > nowMsSafe) continue;
                ingestRecordsPurged += 1;
              }
            }

            if (!safeDryRun && store.ingestRecords instanceof Map && ingestRecordsPurged > 0) {
              for (const [key, r] of store.ingestRecords.entries()) {
                if (ingestRecordsPurgedTotal >= safeMaxRows) break;
                if (!r || typeof r !== "object") continue;
                if (normalizeTenant(r.tenantId ?? DEFAULT_TENANT_ID) !== t) continue;
                const expiresAt = r.expiresAt ?? null;
                if (!expiresAt || typeof expiresAt !== "string") continue;
                const expMs = Date.parse(expiresAt);
                if (!Number.isFinite(expMs)) continue;
                if (expMs > nowMsSafe) continue;
                store.ingestRecords.delete(key);
                ingestRecordsPurgedTotal += 1;
              }
            } else {
              ingestRecordsPurgedTotal += ingestRecordsPurged;
            }

            let deliveriesPurged = 0;
            let deliveryReceiptsPurged = 0;
            if (store.deliveries instanceof Map) {
              for (const [key, d] of store.deliveries.entries()) {
                if (deliveriesPurged >= safeMaxRows) break;
                if (!d || typeof d !== "object") continue;
                if (normalizeTenant(d.tenantId ?? DEFAULT_TENANT_ID) !== t) continue;
                if (d.state === "pending") continue;
                const expiresAt = d.expiresAt ?? null;
                if (!expiresAt || typeof expiresAt !== "string") continue;
                const expMs = Date.parse(expiresAt);
                if (!Number.isFinite(expMs)) continue;
                if (expMs > nowMsSafe) continue;
                deliveriesPurged += 1;
                if (store.deliveryReceipts instanceof Map && store.deliveryReceipts.has(key)) {
                  deliveryReceiptsPurged += 1;
                }
              }
            }

            if (!safeDryRun && store.deliveries instanceof Map && deliveriesPurged > 0) {
              for (const [key, d] of store.deliveries.entries()) {
                if (deliveriesPurgedTotal >= safeMaxRows) break;
                if (!d || typeof d !== "object") continue;
                if (normalizeTenant(d.tenantId ?? DEFAULT_TENANT_ID) !== t) continue;
                if (d.state === "pending") continue;
                const expiresAt = d.expiresAt ?? null;
                if (!expiresAt || typeof expiresAt !== "string") continue;
                const expMs = Date.parse(expiresAt);
                if (!Number.isFinite(expMs)) continue;
                if (expMs > nowMsSafe) continue;
                store.deliveries.delete(key);
                deliveriesPurgedTotal += 1;
                if (store.deliveryReceipts instanceof Map && store.deliveryReceipts.has(key)) {
                  store.deliveryReceipts.delete(key);
                  deliveryReceiptsPurgedTotal += 1;
                }
              }
            } else {
              deliveriesPurgedTotal += deliveriesPurged;
              deliveryReceiptsPurgedTotal += deliveryReceiptsPurged;
            }

            if (ingestRecordsPurged || deliveriesPurged || deliveryReceiptsPurged) {
              processed.push({ tenantId: t, ingestRecordsPurged, deliveriesPurged, deliveryReceiptsPurged, dryRun: safeDryRun });
            }
          }
        }

        const runtimeMs = Date.now() - startedMs;
        const summary = {
          ok: true,
          scope,
          tenantId: scopedTenantId,
          at,
          dryRun: safeDryRun,
          maxRows: safeMaxRows,
          maxMillis: safeMaxMillis,
          runtimeMs,
          timedOut,
          purged: {
            ingest_records: ingestRecordsPurgedTotal,
            deliveries: deliveriesPurgedTotal,
            delivery_receipts: deliveryReceiptsPurgedTotal
          },
          processed
        };

        logger.info("retention.cleanup.done", summary);

        metricGauge("retention_run_seconds", { result: "ok", scope, dry_run: safeDryRun ? "true" : "false" }, runtimeMs / 1000);
        metricInc("maintenance_runs_total", { kind: "retention_cleanup", result: "ok", scope, dry_run: safeDryRun ? "true" : "false" }, 1);
        if (!safeDryRun) {
          if (ingestRecordsPurgedTotal > 0) metricInc("retention_purged_total", { table: "ingest_records" }, ingestRecordsPurgedTotal);
          if (deliveriesPurgedTotal > 0) metricInc("retention_purged_total", { table: "deliveries" }, deliveriesPurgedTotal);
          if (deliveryReceiptsPurgedTotal > 0) metricInc("retention_purged_total", { table: "delivery_receipts" }, deliveryReceiptsPurgedTotal);
        }

        return summary;
      } catch (err) {
        const runtimeMs = Date.now() - startedMs;
        logger.error("retention.cleanup.error", { scope, tenantId: scopedTenantId, dryRun: safeDryRun, runtimeMs, err });
        metricGauge("retention_run_seconds", { result: "error", scope, dry_run: safeDryRun ? "true" : "false" }, runtimeMs / 1000);
        metricInc("maintenance_runs_total", { kind: "retention_cleanup", result: "error", scope, dry_run: safeDryRun ? "true" : "false" }, 1);
        metricInc("maintenance_fail_total", { kind: "retention_cleanup", scope }, 1);
        throw err;
      }
    } finally {
      if (requireLock) {
        if (lockClient) {
          try {
            await lockClient.query("SELECT pg_advisory_unlock(hashtext($1))", [lockKey]);
          } catch {}
          try {
            lockClient.release();
          } catch {}
        } else if (locked && store && typeof store === "object") {
          try {
            store.__retentionCleanupLockHeld = false;
          } catch {}
        }
      }
    }
  }

  function getPendingMonthCloseRequestEvent(events) {
    if (!Array.isArray(events)) throw new TypeError("events must be an array");
    let lastRequestIndex = -1;
    for (let i = events.length - 1; i >= 0; i -= 1) {
      const e = events[i];
      if (e?.type === "MONTH_CLOSE_REQUESTED") {
        lastRequestIndex = i;
        break;
      }
    }
    if (lastRequestIndex === -1) return null;
    for (let i = lastRequestIndex + 1; i < events.length; i += 1) {
      const e = events[i];
      if (e?.type === "MONTH_CLOSED") return null;
    }
    return events[lastRequestIndex];
  }

	  async function tickMonthClose({ maxMessages = 10 } = {}) {
	    if (!Number.isSafeInteger(maxMessages) || maxMessages <= 0) throw new TypeError("maxMessages must be a positive safe integer");
	    if (!Number.isSafeInteger(store.monthCloseCursor) || store.monthCloseCursor < 0) store.monthCloseCursor = 0;

	    const processed = [];

	    function monthRangeMs(yearMonth) {
	      parseYearMonth(yearMonth);
	      const [yRaw, mRaw] = String(yearMonth).split("-");
	      const y = Number(yRaw);
	      const m = Number(mRaw);
	      const startMs = Date.UTC(y, m - 1, 1, 0, 0, 0, 0);
	      const endMs = Date.UTC(m === 12 ? y + 1 : y, m === 12 ? 0 : m, 1, 0, 0, 0, 0);
	      return { startMs, endMs };
	    }

	    // Ensure ledger/app-side projections are up to date in memory mode so month-close can build
	    // allocation-backed party statements.
	    if (store.kind !== "pg" && Array.isArray(store.outbox)) {
	      try {
	        processInMemoryOutbox(store, { maxMessages: Number.MAX_SAFE_INTEGER });
	      } catch {
	        // ignore
	      }
	    }

	    while (store.monthCloseCursor < store.outbox.length && processed.length < maxMessages) {
	      const message = store.outbox[store.monthCloseCursor];
	      store.monthCloseCursor += 1;
	      if (!message || typeof message !== "object") continue;
      if (message.type !== "MONTH_CLOSE_REQUESTED") continue;

      const tenantId = normalizeTenant(message.tenantId ?? DEFAULT_TENANT_ID);
      const month = message.month ? String(message.month) : null;
      const basis = message.basis ? String(message.basis) : MONTH_CLOSE_BASIS.SETTLED_AT;
      if (!month) continue;

      const monthId = message.monthId ? String(message.monthId) : makeMonthCloseStreamId({ month, basis });
      const existing = getMonthEvents(tenantId, monthId);
      if (existing.length === 0) continue;

      const pending = getPendingMonthCloseRequestEvent(existing);
      if (!pending) continue;
      if (typeof message.sourceEventId === "string" && message.sourceEventId.trim() !== "" && pending.id !== message.sourceEventId) {
        continue;
      }

      // Only close once per request.
      const monthBefore = reduceMonthClose(existing);
      if (monthBefore?.status === "CLOSED") continue;

	      let statement;
      const stableGeneratedAt =
        (typeof message.at === "string" && message.at.trim() ? String(message.at) : null) ??
        (typeof pending?.at === "string" && pending.at.trim() ? String(pending.at) : null) ??
        (typeof pending?.payload?.requestedAt === "string" && pending.payload.requestedAt.trim() ? String(pending.payload.requestedAt) : null) ??
        nowIso();

      // Month-close hold policy: whether open holds block close.
      const tenantCfg = typeof store.getConfig === "function" ? store.getConfig(tenantId) : store.configByTenant?.get(tenantId) ?? store.config ?? null;
      let closeHoldPolicy = MONTH_CLOSE_HOLD_POLICY.BLOCK_HOLDS_ORIGINATED_IN_PERIOD;
      let closeHoldPolicySource = { kind: "config", eventId: null, chainHash: null, effectiveFrom: null };
      try {
        closeHoldPolicy = normalizeMonthCloseHoldPolicy(tenantCfg?.finance?.monthCloseHoldPolicy ?? null);
      } catch {
        closeHoldPolicy = MONTH_CLOSE_HOLD_POLICY.BLOCK_HOLDS_ORIGINATED_IN_PERIOD;
      }
      try {
        const { startMs, endMs } = monthRangeMs(month);

        // Effective-dated policy overrides live in the tenant governance stream.
        try {
          const govEvents = getMonthEvents(tenantId, GOVERNANCE_STREAM_ID);
          let selected = null;
          for (const e of govEvents) {
            if (e?.type !== "TENANT_POLICY_UPDATED") continue;
            const finance = e?.payload?.policy?.finance ?? null;
            const modeRaw = finance?.monthCloseHoldPolicy ?? null;
            if (!modeRaw) continue;
            const effectiveFrom = typeof e?.payload?.effectiveFrom === "string" && e.payload.effectiveFrom.trim() ? e.payload.effectiveFrom : e?.at ?? null;
            const effMs = effectiveFrom ? Date.parse(String(effectiveFrom)) : NaN;
            if (!Number.isFinite(effMs) || effMs >= endMs) continue;
            const normalized = normalizeMonthCloseHoldPolicy(modeRaw);
            if (!selected || effMs > selected.effMs) {
              selected = { effMs, effectiveFrom: String(effectiveFrom), policy: normalized, eventId: e?.id ?? null, chainHash: e?.chainHash ?? null };
            }
          }
          if (selected) {
            closeHoldPolicy = selected.policy;
            closeHoldPolicySource = { kind: "governance_event", eventId: selected.eventId, chainHash: selected.chainHash, effectiveFrom: selected.effectiveFrom };
          }
        } catch {
          // ignore governance policy parse failures; fall back to config
        }

        const blocking = [];
        for (const job of listJobs({ tenantId })) {
          if (!job?.id) continue;
          const hold = job.settlementHold ?? null;
          if (!hold || typeof hold !== "object") continue;
          if (String(hold.status ?? "").toUpperCase() !== "HELD") continue;
          if (closeHoldPolicy === MONTH_CLOSE_HOLD_POLICY.ALLOW_WITH_DISCLOSURE) continue;

          if (closeHoldPolicy === MONTH_CLOSE_HOLD_POLICY.BLOCK_ANY_OPEN_HOLDS) {
            blocking.push({ jobId: job.id, holdId: hold.holdId ?? null, heldAt: hold.heldAt ?? null });
            continue;
          }

          const heldAt = typeof hold.heldAt === "string" && hold.heldAt.trim() ? hold.heldAt : job.execution?.completedAt ?? null;
          const heldAtMs = heldAt ? Date.parse(String(heldAt)) : NaN;
          if (!Number.isFinite(heldAtMs)) continue;
          if (heldAtMs >= startMs && heldAtMs < endMs) {
            blocking.push({ jobId: job.id, holdId: hold.holdId ?? null, heldAt: heldAt ?? null });
          }
        }
        if (blocking.length) {
          metricInc("month_close_blocked_total", { tenantId, reason: "open_holds" }, 1);
          processed.push({ month, status: "failed", reason: "open_holds", closeHoldPolicy, closeHoldPolicySource, blocking });
          continue;
        }
      } catch (err) {
        processed.push({ month, status: "failed", reason: "open_holds_check_failed", message: err?.message ?? String(err ?? "") });
        continue;
      }
	      try {
	        let ledgerEntries = [];
	        try {
	          ledgerEntries = await listAllLedgerEntriesForTenant({ tenantId });
	        } catch {
	          ledgerEntries = [];
	        }
	        statement = computeMonthlyStatement({
	          tenantId,
	          customerId: null,
	          siteId: null,
	          month,
	          jobs: listJobs({ tenantId }),
	          getEventsForJob: (jobId) => getJobEvents(tenantId, jobId),
	          ledgerEntries,
	          nowIso: () => stableGeneratedAt
	        });
	      } catch {
	        processed.push({ month, status: "failed", reason: "invalid_statement" });
	        continue;
	      }

      const sliced = pending.chainHash ? sliceEventsThroughChainHash(existing, pending.chainHash) : existing;
      const generatedAt = stableGeneratedAt;

      // Held exposure rollforward (controller reconciliation hook): opening + new  releases  forfeits = ending.
      try {
        const { startMs, endMs } = monthRangeMs(month);

        function addAmounts(bucket, exposure) {
          if (!exposure || typeof exposure !== "object") return;
          const currency = typeof exposure.currency === "string" && exposure.currency.trim() ? exposure.currency : "USD";
          if (!bucket.byCurrency[currency]) {
            bucket.byCurrency[currency] = {
              holdCount: 0,
              amountGrossCents: 0,
              amountNetCents: 0,
              coverageFeeCents: 0
            };
          }
          const c = bucket.byCurrency[currency];
          c.holdCount += 1;
          c.amountGrossCents += Number.isSafeInteger(exposure.amountGrossCents) ? exposure.amountGrossCents : 0;
          c.amountNetCents += Number.isSafeInteger(exposure.amountNetCents) ? exposure.amountNetCents : 0;
          c.coverageFeeCents += Number.isSafeInteger(exposure.coverageFeeCents) ? exposure.coverageFeeCents : 0;
        }

        function emptyBucket() {
          return { holdCount: 0, byCurrency: {} };
        }

        const buckets = {
          opening: emptyBucket(),
          newHolds: emptyBucket(),
          released: emptyBucket(),
          forfeited: emptyBucket(),
          ending: emptyBucket()
        };

        const holdRows = [];
        const jobs = listJobs({ tenantId }).slice().sort((a, b) => String(a?.id ?? "").localeCompare(String(b?.id ?? "")));
        for (const job of jobs) {
          const hold = job?.settlementHold ?? null;
          if (!hold || typeof hold !== "object") continue;
          const holdId = typeof hold.holdId === "string" && hold.holdId.trim() ? hold.holdId : null;
          const heldAt = typeof hold.heldAt === "string" && hold.heldAt.trim() ? hold.heldAt : null;
          if (!holdId || !heldAt) continue;

          const heldAtMs = Date.parse(heldAt);
          if (!Number.isFinite(heldAtMs)) continue;

          const releasedAt = typeof hold.releasedAt === "string" && hold.releasedAt.trim() ? hold.releasedAt : null;
          const forfeitedAt = typeof hold.forfeitedAt === "string" && hold.forfeitedAt.trim() ? hold.forfeitedAt : null;
          const releasedAtMs = releasedAt ? Date.parse(releasedAt) : NaN;
          const forfeitedAtMs = forfeitedAt ? Date.parse(forfeitedAt) : NaN;

          const expected = hold.expectedExposure ?? null;
          const heldExposure = hold.heldExposure ?? null;

          const openAtStart =
            heldAtMs < startMs &&
            (!Number.isFinite(releasedAtMs) || releasedAtMs >= startMs) &&
            (!Number.isFinite(forfeitedAtMs) || forfeitedAtMs >= startMs);
          const openAtEnd =
            heldAtMs < endMs &&
            (!Number.isFinite(releasedAtMs) || releasedAtMs >= endMs) &&
            (!Number.isFinite(forfeitedAtMs) || forfeitedAtMs >= endMs);

          const isNew = heldAtMs >= startMs && heldAtMs < endMs;
          const isReleased = Number.isFinite(releasedAtMs) && releasedAtMs >= startMs && releasedAtMs < endMs;
          const isForfeited = Number.isFinite(forfeitedAtMs) && forfeitedAtMs >= startMs && forfeitedAtMs < endMs;

          if (openAtStart) {
            buckets.opening.holdCount += 1;
            addAmounts(buckets.opening, heldExposure);
          }
          if (isNew) {
            buckets.newHolds.holdCount += 1;
            addAmounts(buckets.newHolds, heldExposure);
          }
          if (isReleased) {
            buckets.released.holdCount += 1;
            addAmounts(buckets.released, heldExposure);
          }
          if (isForfeited) {
            buckets.forfeited.holdCount += 1;
            addAmounts(buckets.forfeited, heldExposure);
          }
          if (openAtEnd) {
            buckets.ending.holdCount += 1;
            addAmounts(buckets.ending, heldExposure);
          }

          const touched = isNew || isReleased || isForfeited || openAtStart || openAtEnd;
          if (touched) {
            holdRows.push({
              jobId: job.id,
              holdId,
              status: hold.status ?? null,
              heldAt,
              lastUpdatedAt: hold.lastUpdatedAt ?? null,
              releasedAt,
              forfeitedAt,
              forfeitureReason: hold.forfeitureReason ?? null,
              decisionRef: hold.decisionRef ?? null,
              decisionEventRef: hold.decisionEventRef ?? null,
              reasonCodes: Array.isArray(hold.reasonCodes) ? hold.reasonCodes : [],
              missingEvidence: Array.isArray(hold.missingEvidence) ? hold.missingEvidence : [],
              pricingAnchor: hold.pricingAnchor ?? null,
              expectedExposure: expected,
              heldExposure: heldExposure
            });
          }
        }

        holdRows.sort((a, b) => String(a.holdId).localeCompare(String(b.holdId)) || String(a.jobId).localeCompare(String(b.jobId)));

        const rollforward = {
          schemaVersion: "HeldExposureRollforwardReport.v1",
          period: month,
          basis,
          closeHoldPolicy,
          closeHoldPolicySource,
          window: {
            startAt: new Date(startMs).toISOString(),
            endAt: new Date(endMs).toISOString()
          },
          buckets
        };

        const rollArtifactId = `held_roll_${tenantId}_${month}_${pending.id}`;
        const rollBody = buildHeldExposureRollforwardV1({
          tenantId,
          period: month,
          basis,
          rollforward,
          holds: holdRows,
          events: sliced,
          artifactId: rollArtifactId,
          generatedAt
        });
        const rollCore = { ...rollBody, sourceEventId: pending.id, atChainHash: pending.chainHash ?? rollBody?.eventProof?.lastChainHash ?? null };
        const rollHash = computeArtifactHash(rollCore);
        const rollArtifact = { ...rollCore, artifactHash: rollHash };
        await store.putArtifact({ tenantId, artifact: rollArtifact });

        const rollDestinations = listDestinationsForTenant(tenantId).filter((d) => {
          const allowed = Array.isArray(d.artifactTypes) && d.artifactTypes.length ? d.artifactTypes : null;
          return !allowed || allowed.includes(ARTIFACT_TYPE.HELD_EXPOSURE_ROLLFORWARD_V1);
        });
        for (const dest of rollDestinations) {
          const dedupeKey = `${tenantId}:${dest.destinationId}:${ARTIFACT_TYPE.HELD_EXPOSURE_ROLLFORWARD_V1}:${rollArtifact.artifactId}:${rollArtifact.artifactHash}`;
          const scopeKey = `held_roll:period:${month}`;
          const orderSeq = 0;
          const priority = 89;
          const orderKey = `${scopeKey}\n${String(orderSeq)}\n${String(priority)}\n${rollArtifact.artifactId}`;
          await store.createDelivery({
            tenantId,
            delivery: {
              destinationId: dest.destinationId,
              artifactType: ARTIFACT_TYPE.HELD_EXPOSURE_ROLLFORWARD_V1,
              artifactId: rollArtifact.artifactId,
              artifactHash: rollArtifact.artifactHash,
              dedupeKey,
              scopeKey,
              orderSeq,
              priority,
              orderKey
            }
          });
        }
      } catch (err) {
        processed.push({ month, status: "failed", reason: "held_rollforward_failed", message: err?.message ?? String(err ?? "") });
        continue;
      }
      const statementArtifactId = `stmt_${tenantId}_${month}_${pending.id}`;
      const body = buildMonthlyStatementV1({
	        tenantId,
	        month,
	        basis,
	        statement,
	        events: sliced,
	        artifactId: statementArtifactId,
	        generatedAt
	      });
      const artifactCore = { ...body, sourceEventId: pending.id, atChainHash: pending.chainHash ?? body?.eventProof?.lastChainHash ?? null };
      const artifactHash = computeArtifactHash(artifactCore);
      const artifact = { ...artifactCore, artifactHash };

      try {
        await store.putArtifact({ tenantId, artifact });
      } catch (err) {
        // Artifact hash mismatch means a semantic drift; treat as failure and surface via ops.
        processed.push({ month, status: "failed", reason: err?.code ?? "artifact_put_failed" });
        continue;
      }

      const destinations = listDestinationsForTenant(tenantId).filter((d) => {
        const allowed = Array.isArray(d.artifactTypes) && d.artifactTypes.length ? d.artifactTypes : null;
        return !allowed || allowed.includes(ARTIFACT_TYPE.MONTHLY_STATEMENT_V1);
      });
	      for (const dest of destinations) {
	        const dedupeKey = `${tenantId}:${dest.destinationId}:${ARTIFACT_TYPE.MONTHLY_STATEMENT_V1}:${artifact.artifactId}:${artifact.artifactHash}`;
	        const scopeKey = `month:${month}`;
	        const orderSeq = 0;
	        const priority = 90;
	        const orderKey = `${scopeKey}\n${String(orderSeq)}\n${String(priority)}\n${artifact.artifactId}`;
        try {
          await store.createDelivery({
            tenantId,
            delivery: {
              destinationId: dest.destinationId,
              artifactType: ARTIFACT_TYPE.MONTHLY_STATEMENT_V1,
              artifactId: artifact.artifactId,
              artifactHash: artifact.artifactHash,
              dedupeKey,
              scopeKey,
              orderSeq,
              priority,
              orderKey
            }
          });
        } catch {
          // Best-effort: delivery rails will retry based on DB constraints/dedupe.
	        }
	      }

	      // Party statements + payout instructions (Connect v1).
	      try {
	        const periodBounds = parseYearMonth(month);
	        const startMs = Date.parse(periodBounds.startAt);
	        const endMs = Date.parse(periodBounds.endAt);
	        const includedJobIds = new Set((statement.jobs ?? []).map((j) => String(j?.jobId ?? "")).filter((id) => id && id.trim() !== ""));

	        const entries = await listAllLedgerEntriesForTenant({ tenantId });
	        const entriesById = new Map();
	        const includedEntryIds = new Set();
	        for (const entry of entries) {
	          if (!entry?.id || !entry?.at) continue;
	          const t = Date.parse(entry.at);
	          if (!Number.isFinite(t) || t < startMs || t >= endMs) continue;
	          entriesById.set(String(entry.id), entry);
	          const jobId = jobIdFromLedgerMemo(entry.memo ?? "");
	          if (jobId && includedJobIds.has(jobId)) includedEntryIds.add(String(entry.id));
	        }

	        const allAllocations = await listAllLedgerAllocationsForTenant({ tenantId });
	        const allocations = allAllocations.filter((a) => includedEntryIds.has(String(a?.entryId ?? "")));

	        const byParty = new Map(); // `${partyRole}\n${partyId}` -> allocations
	        for (const a of allocations) {
	          const partyRole = a.partyRole ?? null;
	          const partyId = a.partyId ?? null;
	          if (!partyRole || !partyId) continue;
	          const key = `${partyRole}\n${partyId}`;
	          const list = byParty.get(key) ?? [];
	          list.push(a);
	          byParty.set(key, list);
	        }

	        const partyInfo = new Map(); // key -> { partyId, partyRole, statementHash, statement }
	        for (const [key, partyAllocs] of byParty.entries()) {
	          const [partyRole, partyId] = key.split("\n");
	          const partyStatement = computePartyStatement({
	            tenantId,
	            partyId,
	            partyRole,
	            period: month,
	            basis,
	            allocations: partyAllocs,
	            entriesById,
	            currency: "USD"
	          });

	          const partyArtifactId = `pstmt_${tenantId}_${partyId}_${month}_${pending.id}`;
	          const partyBody = buildPartyStatementV1({
	            tenantId,
	            partyId,
	            partyRole,
	            period: month,
	            basis,
	            statement: partyStatement,
	            events: sliced,
	            artifactId: partyArtifactId,
	            generatedAt
	          });
	          const partyCore = {
	            ...partyBody,
	            // Multiple party statements can originate from a single month-close event.
	            // Add a deterministic suffix to keep source-event dedupe unique per party stream.
	            sourceEventId: `${pending.id}:party:${partyRole}:${partyId}`,
	            atChainHash: pending.chainHash ?? partyBody?.eventProof?.lastChainHash ?? null
	          };
	          const partyHash = computeArtifactHash(partyCore);
	          const partyArtifact = { ...partyCore, artifactHash: partyHash };
	          await store.putArtifact({ tenantId, artifact: partyArtifact });
	          if (typeof store.putPartyStatement === "function") {
	            await store.putPartyStatement({
	              tenantId,
	              statement: {
	                partyId,
	                period: month,
	                basis,
	                status: "CLOSED",
	                statementHash: partyHash,
	                artifactId: partyArtifactId,
	                artifactHash: partyHash,
	                closedAt: generatedAt
	              }
	            });
	          }

	          const partyDestinations = listDestinationsForTenant(tenantId).filter((d) => {
	            const allowed = Array.isArray(d.artifactTypes) && d.artifactTypes.length ? d.artifactTypes : null;
	            return !allowed || allowed.includes(ARTIFACT_TYPE.PARTY_STATEMENT_V1);
	          });
	          for (const dest of partyDestinations) {
	            const dedupeKey = `${tenantId}:${dest.destinationId}:${ARTIFACT_TYPE.PARTY_STATEMENT_V1}:${partyArtifact.artifactId}:${partyArtifact.artifactHash}`;
	            const scopeKey = `party:${partyId}:period:${month}`;
	            const orderSeq = 0;
	            const priority = 85;
	            const orderKey = `${scopeKey}\n${String(orderSeq)}\n${String(priority)}\n${partyArtifact.artifactId}`;
	            await store.createDelivery({
	              tenantId,
	              delivery: {
	                destinationId: dest.destinationId,
	                artifactType: ARTIFACT_TYPE.PARTY_STATEMENT_V1,
	                artifactId: partyArtifact.artifactId,
	                artifactHash: partyArtifact.artifactHash,
	                dedupeKey,
	                scopeKey,
	                orderSeq,
	                priority,
	                orderKey
	              }
	            });
	          }

	          partyInfo.set(key, { partyId, partyRole, statementHash: partyHash, statement: partyStatement });
	        }

	        for (const info of partyInfo.values()) {
	          const payoutAmountCents = computePayoutAmountCentsForStatement({ partyRole: info.partyRole, statement: info.statement });
	          if (!Number.isSafeInteger(payoutAmountCents) || payoutAmountCents <= 0) continue;
	          const payoutKey = payoutKeyFor({ tenantId, partyId: info.partyId, period: month, statementHash: info.statementHash });
	          const payoutArtifactId = `payout_${tenantId}_${info.partyId}_${month}_${info.statementHash}`;
	          const payoutBody = buildPayoutInstructionV1({
	            tenantId,
	            partyId: info.partyId,
	            partyRole: info.partyRole,
	            period: month,
	            statementHash: info.statementHash,
	            payoutKey,
	            currency: "USD",
	            amountCents: payoutAmountCents,
	            destinationRef: null,
	            events: sliced,
	            artifactId: payoutArtifactId,
	            generatedAt
	          });
	          const payoutCore = {
	            ...payoutBody,
	            // Multiple payout instructions can originate from one month-close event.
	            sourceEventId: `${pending.id}:payout:${info.partyRole}:${info.partyId}`,
	            atChainHash: pending.chainHash ?? payoutBody?.eventProof?.lastChainHash ?? null
	          };
	          const payoutHash = computeArtifactHash(payoutCore);
	          const payoutArtifact = { ...payoutCore, artifactHash: payoutHash };
	          await store.putArtifact({ tenantId, artifact: payoutArtifact });

	          const payoutDestinations = listDestinationsForTenant(tenantId).filter((d) => {
	            const allowed = Array.isArray(d.artifactTypes) && d.artifactTypes.length ? d.artifactTypes : null;
	            return !allowed || allowed.includes(ARTIFACT_TYPE.PAYOUT_INSTRUCTION_V1);
	          });
	          for (const dest of payoutDestinations) {
	            const dedupeKey = `${tenantId}:${dest.destinationId}:${ARTIFACT_TYPE.PAYOUT_INSTRUCTION_V1}:${payoutKey}:${payoutArtifact.artifactHash}`;
	            const scopeKey = `payout:${info.partyId}:period:${month}`;
	            const orderSeq = 0;
	            const priority = 95;
	            const orderKey = `${scopeKey}\n${String(orderSeq)}\n${String(priority)}\n${payoutArtifact.artifactId}`;
	            await store.createDelivery({
	              tenantId,
	              delivery: {
	                destinationId: dest.destinationId,
	                artifactType: ARTIFACT_TYPE.PAYOUT_INSTRUCTION_V1,
	                artifactId: payoutArtifact.artifactId,
	                artifactHash: payoutArtifact.artifactHash,
	                dedupeKey,
	                scopeKey,
	                orderSeq,
	                priority,
	                orderKey
	              }
	            });
	          }
	        }

	          // Finance Pack v1: GLBatch.v1 (canonical GL export input).
	          let glArtifact = null;
	          try {
	            const allocationRows = allocations.map((a) => {
	              const entry = entriesById.get(String(a.entryId ?? "")) ?? null;
	              return {
                entryId: String(a.entryId),
                postingId: String(a.postingId),
                accountId: String(a.accountId),
                partyId: String(a.partyId),
                partyRole: String(a.partyRole),
                currency: String(a.currency ?? "USD"),
                amountCents: Number(a.amountCents),
                memo: typeof entry?.memo === "string" ? entry.memo : null,
                at: typeof entry?.at === "string" ? entry.at : null
              };
            });

            const { body: glBody } = computeGlBatchBodyV1({
              tenantId,
              period: month,
              basis,
              allocationRows,
              generatedAt,
              monthClose: {
                month,
                basis,
                monthCloseEventId: pending.id,
                monthlyStatementArtifactHash: artifactHash
              }
            });

            const glArtifactId = `gl_${tenantId}_${month}_${pending.id}`;
            const glBatchBody = buildGlBatchV1({
              tenantId,
              period: month,
              basis,
              batch: glBody,
              events: sliced,
              artifactId: glArtifactId,
              generatedAt
            });
            const glCore = { ...glBatchBody, sourceEventId: pending.id, atChainHash: pending.chainHash ?? glBatchBody?.eventProof?.lastChainHash ?? null };
	            const glHash = computeArtifactHash(glCore);
	            glArtifact = { ...glCore, artifactHash: glHash };
	            await store.putArtifact({ tenantId, artifact: glArtifact });

            const glDestinations = listDestinationsForTenant(tenantId).filter((d) => {
              const allowed = Array.isArray(d.artifactTypes) && d.artifactTypes.length ? d.artifactTypes : null;
              return !allowed || allowed.includes(ARTIFACT_TYPE.GL_BATCH_V1);
            });
            for (const dest of glDestinations) {
              const dedupeKey = `${tenantId}:${dest.destinationId}:${ARTIFACT_TYPE.GL_BATCH_V1}:${glArtifact.artifactId}:${glArtifact.artifactHash}`;
              const scopeKey = `glbatch:period:${month}`;
              const orderSeq = 0;
              const priority = 96;
              const orderKey = `${scopeKey}\n${String(orderSeq)}\n${String(priority)}\n${glArtifact.artifactId}`;
              await store.createDelivery({
                tenantId,
                delivery: {
                  destinationId: dest.destinationId,
                  artifactType: ARTIFACT_TYPE.GL_BATCH_V1,
                  artifactId: glArtifact.artifactId,
                  artifactHash: glArtifact.artifactHash,
                  dedupeKey,
                  scopeKey,
                  orderSeq,
                  priority,
                  orderKey
                }
              });
            }
	          } catch (err) {
	            processed.push({ month, status: "failed", reason: err?.code ?? "gl_batch_failed" });
	            continue;
	          }

	          // Finance Pack v1: JournalCsv.v1 (delivered CSV export).
	          let journalCsvGateMode = "warn";
	          try {
	            const accountMap = await store.getFinanceAccountMap({ tenantId });
	            journalCsvGateMode =
	              accountMap && typeof accountMap === "object" && accountMap.exportPolicy?.gateMode === "strict" ? "strict" : "warn";

	            if (!accountMap) {
	              metricInc("finance_export_blocked_total", { tenantId, kind: "journal_csv", reason: "missing_account_map" }, 1);
	              if (journalCsvGateMode === "strict") {
	                const err = new Error("finance export blocked: missing finance account map");
	                err.code = "FINANCE_EXPORT_BLOCKED";
	                throw err;
	              }
	            } else {
	              const accountMapHash = computeFinanceAccountMapHash(accountMap);
	              const { csv, csvHash } = renderJournalCsvV1({ glBatchArtifact: glArtifact, accountMap });
	              const csvArtifactId = `journalcsv_${tenantId}_${month}_${pending.id}`;
	              const csvBody = buildJournalCsvV1({
	                tenantId,
	                period: month,
	                basis,
	                glBatchArtifactId: glArtifact.artifactId,
	                glBatchArtifactHash: glArtifact.artifactHash,
	                accountMapHash,
	                csv,
	                csvSha256: csvHash,
	                events: sliced,
	                artifactId: csvArtifactId,
	                generatedAt
	              });
	              const csvCore = {
	                ...csvBody,
	                sourceEventId: pending.id,
	                atChainHash: pending.chainHash ?? csvBody?.eventProof?.lastChainHash ?? null
	              };
	              const csvArtifactHash = computeArtifactHash(csvCore);
	              const csvArtifact = { ...csvCore, artifactHash: csvArtifactHash };
	              await store.putArtifact({ tenantId, artifact: csvArtifact });

	              metricInc("finance_journalcsv_emitted_total", { tenantId }, 1);

	              const csvDestinations = listDestinationsForTenant(tenantId).filter((d) => {
	                const allowed = Array.isArray(d.artifactTypes) && d.artifactTypes.length ? d.artifactTypes : null;
	                return !allowed || allowed.includes(ARTIFACT_TYPE.JOURNAL_CSV_V1);
	              });
	              for (const dest of csvDestinations) {
	                const dedupeKey = `${tenantId}:${dest.destinationId}:${ARTIFACT_TYPE.JOURNAL_CSV_V1}:${csvArtifact.artifactId}:${csvArtifact.artifactHash}`;
	                const scopeKey = `journalcsv:period:${month}`;
	                const orderSeq = 1;
	                const priority = 96;
	                const orderKey = `${scopeKey}\n${String(orderSeq)}\n${String(priority)}\n${csvArtifact.artifactId}`;
	                await store.createDelivery({
	                  tenantId,
	                  delivery: {
	                    destinationId: dest.destinationId,
	                    artifactType: ARTIFACT_TYPE.JOURNAL_CSV_V1,
	                    artifactId: csvArtifact.artifactId,
	                    artifactHash: csvArtifact.artifactHash,
	                    dedupeKey,
	                    scopeKey,
	                    orderSeq,
	                    priority,
	                    orderKey
	                  }
	                });
	              }
	            }
	          } catch (err) {
	            const reason = err?.code ?? "journal_csv_failed";
	            metricInc("finance_export_blocked_total", { tenantId, kind: "journal_csv", reason }, 1);
	            if (err?.code === "FINANCE_EXPORT_BLOCKED" || (journalCsvGateMode === "strict" && err?.code === "FINANCE_ACCOUNT_MAP_MISSING")) {
	              processed.push({ month, status: "failed", reason });
	              continue;
	            }
	          }
	      } catch (err) {
	        processed.push({ month, status: "failed", reason: err?.code ?? "party_statement_failed" });
	        continue;
	      }

	      const closedAt = nowIso();
	      const closedPayload = {
	        tenantId,
	        month,
        basis,
        closedAt,
        statementArtifactId,
        statementArtifactHash: artifactHash
      };

      let closedEvent;
      try {
        validateMonthClosedPayload(closedPayload);
        const draft = createChainedEvent({
          streamId: monthId,
          type: "MONTH_CLOSED",
          at: closedAt,
          actor: { type: "finance", id: "month_close_v1" },
          payload: closedPayload
        });
        const nextEvents = appendChainedEvent({ events: existing, event: draft, signer: serverSigner });
        closedEvent = nextEvents[nextEvents.length - 1];
        enforceSignaturePolicy({ tenantId, signerKind: requiredSignerKindForEventType(closedEvent.type), event: closedEvent });
      } catch {
        processed.push({ month, status: "failed", reason: "close_event_rejected" });
        continue;
      }

      try {
        await commitTx([{ kind: "MONTH_EVENTS_APPENDED", tenantId, monthId, events: [closedEvent] }]);
        processed.push({ month, status: "closed", statementArtifactId, statementArtifactHash: artifactHash });

        // Phase 2: FinancePackBundle.v1 (zip stored by hash + small pointer artifact delivered on rails).
        try {
          const finalMonthEvents = getMonthEvents(tenantId, monthId);
          const allArtifacts = typeof store.listArtifacts === "function" ? await store.listArtifacts({ tenantId }) : [];
          const monthArtifacts = (allArtifacts ?? []).filter((a) => {
            if (!a || typeof a !== "object") return false;
            if (a.period && String(a.period) === String(month)) return true;
            if (a.month && String(a.month) === String(month)) return true;
            return false;
          });

          const glBatch = monthArtifacts
            .filter((a) => a?.artifactType === "GLBatch.v1")
            .sort((a, b) => String(a?.artifactId ?? "").localeCompare(String(b?.artifactId ?? "")))
            .slice(-1)[0];
          const journalCsv = monthArtifacts
            .filter((a) => a?.artifactType === "JournalCsv.v1")
            .sort((a, b) => String(a?.artifactId ?? "").localeCompare(String(b?.artifactId ?? "")))
            .slice(-1)[0];
          const partyStatements = monthArtifacts.filter((a) => a?.artifactType === "PartyStatement.v1");

          if (glBatch && journalCsv && partyStatements.length && store.evidenceStore) {
            const reconcile = reconcileGlBatchAgainstPartyStatements({ glBatch, partyStatements });
              if (reconcile.ok) {
                const publicKeyByKeyId = store.publicKeyByKeyId instanceof Map ? store.publicKeyByKeyId : new Map();
                let signerKeys = [];
                if (typeof store.listSignerKeys === "function") {
                  const tenantKeys = await store.listSignerKeys({ tenantId });
                  const defaultKeys = await store.listSignerKeys({ tenantId: DEFAULT_TENANT_ID });
                  const all = [...(tenantKeys ?? []), ...(defaultKeys ?? [])];
                  const byKeyId = new Map();
                  for (const r of all) {
                    const keyId = r?.keyId ? String(r.keyId) : null;
                    if (!keyId) continue;
                    byKeyId.set(keyId, r);
                  }
                  signerKeys = Array.from(byKeyId.values());
                }
                const tenantGovEvents = getMonthEvents(tenantId, GOVERNANCE_STREAM_ID);
                const tenantGovSnapshot = {
                  streamId: GOVERNANCE_STREAM_ID,
                  lastChainHash: tenantGovEvents.length ? tenantGovEvents[tenantGovEvents.length - 1]?.chainHash ?? null : null,
                  lastEventId: tenantGovEvents.length ? tenantGovEvents[tenantGovEvents.length - 1]?.id ?? null : null
                };
                const govEvents = getMonthEvents(DEFAULT_TENANT_ID, GOVERNANCE_STREAM_ID);
                const govSnapshot = {
                  streamId: GOVERNANCE_STREAM_ID,
                  lastChainHash: govEvents.length ? govEvents[govEvents.length - 1]?.chainHash ?? null : null,
                  lastEventId: govEvents.length ? govEvents[govEvents.length - 1]?.id ?? null : null
                };
                const generatedAt = stableGeneratedAt;
                const { files: monthFiles, bundle: monthBundle } = buildMonthProofBundleV1({
                  tenantId,
                  period: String(month),
                  basis,
                  monthEvents: finalMonthEvents,
                  governanceEvents: govEvents,
                  governanceSnapshot: govSnapshot,
                  tenantGovernanceEvents: tenantGovEvents,
                  tenantGovernanceSnapshot: tenantGovSnapshot,
                  artifacts: monthArtifacts,
                  contractDocsByHash: new Map(),
                  publicKeyByKeyId,
                  signerKeys,
                  manifestSigner: serverSigner,
                  requireHeadAttestation: true,
                  generatedAt
                });

              const protocol = "1.0";
              const reconcileBytes = new TextEncoder().encode(`${canonicalJsonStringify(reconcile)}\n`);
              const { files, bundle } = buildFinancePackBundleV1({
                tenantId,
                period: String(month),
                protocol,
                createdAt: stableGeneratedAt,
                monthProofBundle: monthBundle,
                monthProofFiles: monthFiles,
                requireMonthProofAttestation: true,
                verificationReportSigner: serverSigner,
                glBatchArtifact: glBatch,
                journalCsvArtifact: journalCsv,
                reconcileReport: reconcile,
                reconcileReportBytes: reconcileBytes
              });

              const zipBytes = buildDeterministicZipStore({ files, mtime: new Date(stableGeneratedAt) });
              const bundleHash = sha256HexBytes(zipBytes);
              const evidenceRef = `obj://finance-pack/${String(month)}/${bundleHash}.zip`;

              let alreadyExisted = false;
              try {
                const existingZip = await store.evidenceStore.readEvidence({ tenantId, evidenceRef });
                const existingHash = sha256HexBytes(existingZip.data);
                if (existingHash !== bundleHash) throw new Error("finance pack bundle already exists with different bytes");
                alreadyExisted = true;
              } catch (err) {
                if (err?.code !== "ENOENT") throw err;
              }
              if (!alreadyExisted) {
                await store.evidenceStore.putEvidence({ tenantId, evidenceRef, data: zipBytes });
              }

              const pointerArtifactId = `finance_pack_${tenantId}_${String(month)}_${bundleHash}`;
              const objectStore =
                store.evidenceStore?.kind === "s3"
                  ? {
                      kind: "s3",
                      endpoint: store.evidenceStore.endpoint,
                      region: store.evidenceStore.region,
                      bucket: store.evidenceStore.bucket,
                      key: typeof store.evidenceStore.keyFor === "function" ? store.evidenceStore.keyFor({ tenantId, evidenceRef }) : null,
                      forcePathStyle: store.evidenceStore.forcePathStyle !== false
                    }
                  : { kind: store.evidenceStore?.kind ?? "unknown" };

              const pointerBody = buildFinancePackBundlePointerV1({
                tenantId,
                period: String(month),
                basis,
                bundleHash,
                bundleManifestHash: bundle.manifestHash,
                monthProofBundleHash: monthBundle.manifestHash,
                glBatchHash: String(glBatch.artifactHash),
                journalCsvHash: String(journalCsv.csvSha256),
                reconcileReportHash: sha256HexBytes(reconcileBytes),
                financeAccountMapHash: String(journalCsv.accountMapHash),
                evidenceRef,
                objectStore,
                events: finalMonthEvents,
                artifactId: pointerArtifactId,
                generatedAt: stableGeneratedAt
              });
              const pointerCore = { ...pointerBody, sourceEventId: pending.id, atChainHash: closedEvent.chainHash ?? pointerBody?.eventProof?.lastChainHash ?? null };
              const pointerHash = computeArtifactHash(pointerCore);
              const pointerArtifact = { ...pointerCore, artifactHash: pointerHash };
              await store.putArtifact({ tenantId, artifact: pointerArtifact });

              const fpDestinations = listDestinationsForTenant(tenantId).filter((d) => {
                const allowed = Array.isArray(d.artifactTypes) && d.artifactTypes.length ? d.artifactTypes : null;
                return !allowed || allowed.includes(ARTIFACT_TYPE.FINANCE_PACK_BUNDLE_V1);
              });
              for (const dest of fpDestinations) {
                const dedupeKey = `${tenantId}:${dest.destinationId}:${ARTIFACT_TYPE.FINANCE_PACK_BUNDLE_V1}:${pointerArtifact.artifactId}:${pointerArtifact.artifactHash}`;
                const scopeKey = `finance_pack:period:${month}`;
                const orderSeq = 2;
                const priority = 97;
                const orderKey = `${scopeKey}\n${String(orderSeq)}\n${String(priority)}\n${pointerArtifact.artifactId}`;
                await store.createDelivery({
                  tenantId,
                  delivery: {
                    destinationId: dest.destinationId,
                    artifactType: ARTIFACT_TYPE.FINANCE_PACK_BUNDLE_V1,
                    artifactId: pointerArtifact.artifactId,
                    artifactHash: pointerArtifact.artifactHash,
                    dedupeKey,
                    scopeKey,
                    orderSeq,
                    priority,
                    orderKey
                  }
                });
              }
            }
          }
        } catch (err) {
          logger.warn("finance_pack.memory.failed", { tenantId, month, basis, err });
        }
      } catch {
        // Ignore: may be concurrent close; idempotency via prevChainHash will prevent forks.
        processed.push({ month, status: "conflict" });
      }
    }

    return { processed, cursor: store.monthCloseCursor };
  }

  async function tickLiveness({ maxJobs = 1000 } = {}) {
    if (!Number.isSafeInteger(maxJobs) || maxJobs <= 0) throw new TypeError("maxJobs must be a positive safe integer");

    const at = nowIso();
    const nowMs = Date.parse(at);
    const appended = [];

    let scanned = 0;
    for (const job of store.jobs.values()) {
      if (!job?.id) continue;
      const tenantId = normalizeTenant(job.tenantId ?? DEFAULT_TENANT_ID);
      scanned += 1;
      if (scanned > maxJobs) break;

      const existing = getJobEvents(tenantId, job.id);
      if (existing.length === 0) continue;

      const jobBefore = reduceJob(existing);
      if (!jobBefore) continue;

      const envTier = jobBefore.booking?.environmentTier ?? null;
      const policy = computeLivenessPolicy({ environmentTier: envTier });

      const startedAt = jobBefore.execution?.startedAt ?? null;
      if (!startedAt) continue;

      const lastHeartbeatAt = jobBefore.execution?.lastHeartbeatAt ?? startedAt;
      const lastMs = Date.parse(lastHeartbeatAt);
      if (!Number.isFinite(lastMs)) continue;

      // If executing and heartbeat is overdue, append a stall event.
      if ((jobBefore.status === "EXECUTING" || jobBefore.status === "ASSISTED") && nowMs - lastMs > policy.stallAfterMs) {
        const robotId = jobBefore.execution?.robotId ?? jobBefore.reservation?.robotId ?? jobBefore.match?.robotId ?? null;
        if (!robotId) continue;

        const draft = createChainedEvent({
          streamId: jobBefore.id,
          type: "JOB_EXECUTION_STALLED",
          at,
          actor: { type: "liveness", id: "liveness_v0" },
          payload: {
            jobId: jobBefore.id,
            robotId,
            detectedAt: at,
            reason: "NO_HEARTBEAT",
            lastHeartbeatAt,
            policy
          }
        });

        const nextEvents = appendChainedEvent({ events: existing, event: draft, signer: serverSigner });
        const event = nextEvents[nextEvents.length - 1];

        try {
          enforceSignaturePolicy({ tenantId, signerKind: requiredSignerKindForEventType(event.type), event });
          validateDomainEvent({ jobBefore, event, eventsBefore: existing });
        } catch {
          continue;
        }

        let jobAfter;
        try {
          jobAfter = reduceJob(nextEvents);
        } catch {
          continue;
        }

        const outboxMessages = [];
        if (jobBefore.status !== jobAfter.status) {
          outboxMessages.push({
            type: "JOB_STATUS_CHANGED",
            tenantId,
            jobId: jobBefore.id,
            fromStatus: jobBefore.status,
            toStatus: jobAfter.status,
            at: event.at
          });
        }
        outboxMessages.push({
          type: "JOB_STALLED",
          tenantId,
          jobId: jobBefore.id,
          robotId,
          at: event.at,
          sourceEventId: event.id
        });
        outboxMessages.push({
          type: "NOTIFY_OPS_JOB_STALLED",
          tenantId,
          jobId: jobBefore.id,
          robotId,
          at: event.at,
          zoneId: getJobZoneId(jobBefore),
          environmentTier: jobBefore.booking?.environmentTier ?? null,
          reason: "NO_HEARTBEAT",
          sourceEventId: event.id
        });
        if (jobBefore.booking?.requiresOperatorCoverage) {
          const zoneId = getJobZoneId(jobBefore);
          const window = jobBefore.reservation
            ? { startAt: jobBefore.reservation.startAt, endAt: jobBefore.reservation.endAt }
            : jobBefore.booking
              ? { startAt: jobBefore.booking.startAt, endAt: jobBefore.booking.endAt }
              : { startAt: at, endAt: at };
          const hasReservedCoverage = jobBefore.operatorCoverage?.status === "reserved";
          const activeOperators = hasReservedCoverage ? 1 : listAvailableOperators({ tenantId, zoneId, window, ignoreJobId: jobBefore.id }).length;
          outboxMessages.push({
            type: "ESCALATION_NEEDED",
            tenantId,
            jobId: jobBefore.id,
            at: event.at,
            kind: "OPERATOR_ASSIST",
            zoneId,
            capacityAvailable: activeOperators > 0
          });
        }

        const ops = [{ kind: "JOB_EVENTS_APPENDED", tenantId, jobId: jobBefore.id, events: [event] }];
        if (outboxMessages.length) ops.push({ kind: "OUTBOX_ENQUEUE", messages: outboxMessages });

        await commitTx(ops);

        appended.push(event);
        continue;
      }

      // If stalled and heartbeats have resumed, append a server-driven resume event.
      if (jobBefore.status === "STALLED") {
        const stalledAt = jobBefore.execution?.stalledAt ?? null;
        const lastHb = jobBefore.execution?.lastHeartbeatAt ?? null;
        if (!stalledAt || !lastHb) continue;
        const stalledMs = Date.parse(stalledAt);
        const lastHbMs = Date.parse(lastHb);
        if (!Number.isFinite(stalledMs) || !Number.isFinite(lastHbMs)) continue;
        if (lastHbMs <= stalledMs) continue;
        if (nowMs - lastHbMs > policy.stallAfterMs) continue;

        const robotId = jobBefore.execution?.robotId ?? jobBefore.reservation?.robotId ?? jobBefore.match?.robotId ?? null;
        if (!robotId) continue;

        const draft = createChainedEvent({
          streamId: jobBefore.id,
          type: "JOB_EXECUTION_RESUMED",
          at,
          actor: { type: "liveness", id: "liveness_v0" },
          payload: { jobId: jobBefore.id, robotId, resumedAt: at }
        });

        const nextEvents = appendChainedEvent({ events: existing, event: draft, signer: serverSigner });
        const event = nextEvents[nextEvents.length - 1];

        try {
          enforceSignaturePolicy({ tenantId, signerKind: requiredSignerKindForEventType(event.type), event });
          validateDomainEvent({ jobBefore, event, eventsBefore: existing });
        } catch {
          continue;
        }

        let jobAfter;
        try {
          jobAfter = reduceJob(nextEvents);
        } catch {
          continue;
        }

        const outboxMessages = [];
        if (jobBefore.status !== jobAfter.status) {
          outboxMessages.push({
            type: "JOB_STATUS_CHANGED",
            tenantId,
            jobId: jobBefore.id,
            fromStatus: jobBefore.status,
            toStatus: jobAfter.status,
            at: event.at
          });
        }

        const ops = [{ kind: "JOB_EVENTS_APPENDED", tenantId, jobId: jobBefore.id, events: [event] }];
        if (outboxMessages.length) ops.push({ kind: "OUTBOX_ENQUEUE", messages: outboxMessages });

        await commitTx(ops);

        appended.push(event);
      }
    }

    return { at, appended };
  }

  function enforceSignaturePolicy({ tenantId, signerKind, event }) {
    const t = normalizeTenant(tenantId);
    if (signerKind === SIGNER_KIND.SERVER && (event.actor.type === "robot" || event.actor.type === "operator")) {
      throw new TypeError("server-signed event types may not use robot/operator actor types");
    }

    function assertSignerKeyActive({ keyId, purpose }) {
      if (!keyId) throw new TypeError("missing signerKeyId");
      const key = makeScopedKey({ tenantId: t, id: String(keyId) });
      const record = store.signerKeys?.get?.(key) ?? null;
      if (!record) throw new TypeError("signer key is not registered");
      const status = typeof record.status === "string" && record.status.trim() ? normalizeSignerKeyStatus(record.status) : SIGNER_KEY_STATUS.ACTIVE;
      if (status !== SIGNER_KEY_STATUS.ACTIVE) throw new TypeError("signer key is not active");
      if (purpose) {
        const expectedPurpose = normalizeSignerKeyPurpose(purpose);
        const gotPurpose =
          typeof record.purpose === "string" && record.purpose.trim() ? normalizeSignerKeyPurpose(record.purpose) : SIGNER_KEY_PURPOSE.SERVER;
        if (gotPurpose !== expectedPurpose) throw new TypeError("signer key purpose mismatch");
      }
      return record;
    }

    let effectiveSignerKind = signerKind;
    if (effectiveSignerKind === SIGNER_KIND.SERVER_OR_OPERATOR) {
      if (event.actor.type === "operator") effectiveSignerKind = SIGNER_KIND.OPERATOR;
      else if (event.actor.type === "robot") throw new TypeError("server_or_operator events may not use actor.type=robot");
      else effectiveSignerKind = SIGNER_KIND.SERVER;
    }
    if (effectiveSignerKind === SIGNER_KIND.SERVER_OR_ROBOT) {
      if (event.actor.type === "robot") effectiveSignerKind = SIGNER_KIND.ROBOT;
      else if (event.actor.type === "operator") throw new TypeError("server_or_robot events may not use actor.type=operator");
      else effectiveSignerKind = SIGNER_KIND.SERVER;
    }
    if (effectiveSignerKind === SIGNER_KIND.NONE) {
      if (event.actor.type === "robot") effectiveSignerKind = SIGNER_KIND.ROBOT;
      if (event.actor.type === "operator") effectiveSignerKind = SIGNER_KIND.OPERATOR;
    }

    if (effectiveSignerKind === SIGNER_KIND.ROBOT) {
      if (event.actor.type !== "robot") throw new TypeError("robot-signed events require actor.type=robot");
      const robot = store.robots.get(robotStoreKey(t, event.actor.id));
      if (!robot) throw new TypeError("unknown robot actor.id");
      if (!robot.signerKeyId) throw new TypeError("robot has no registered signerKeyId");
      if (!event.signature) throw new TypeError("robot-signed events require signature");
      if (event.signerKeyId !== robot.signerKeyId) throw new TypeError("event.signerKeyId does not match robot signerKeyId");
      assertSignerKeyActive({ keyId: event.signerKeyId, purpose: SIGNER_KEY_PURPOSE.ROBOT });
    }
    if (effectiveSignerKind === SIGNER_KIND.OPERATOR) {
      if (event.actor.type !== "operator") throw new TypeError("operator-signed events require actor.type=operator");
      const operator = store.operators.get(operatorStoreKey(t, event.actor.id));
      if (!operator) throw new TypeError("unknown operator actor.id");
      if (!operator.signerKeyId) throw new TypeError("operator has no registered signerKeyId");
      if (!event.signature) throw new TypeError("operator-signed events require signature");
      if (event.signerKeyId !== operator.signerKeyId) throw new TypeError("event.signerKeyId does not match operator signerKeyId");
      assertSignerKeyActive({ keyId: event.signerKeyId, purpose: SIGNER_KEY_PURPOSE.OPERATOR });
    }
    if (effectiveSignerKind === SIGNER_KIND.ROBOT_OR_OPERATOR) {
      if (event.actor.type !== "robot" && event.actor.type !== "operator") {
        throw new TypeError("robot_or_operator-signed events require actor.type=robot|operator");
      }
      const entity =
        event.actor.type === "robot" ? store.robots.get(robotStoreKey(t, event.actor.id)) : store.operators.get(operatorStoreKey(t, event.actor.id));
      if (!entity) throw new TypeError(`unknown ${event.actor.type} actor.id`);
      if (!entity.signerKeyId) throw new TypeError(`${event.actor.type} has no registered signerKeyId`);
      if (!event.signature) throw new TypeError("robot_or_operator-signed events require signature");
      if (event.signerKeyId !== entity.signerKeyId) {
        throw new TypeError(`event.signerKeyId does not match ${event.actor.type} signerKeyId`);
      }
      assertSignerKeyActive({
        keyId: event.signerKeyId,
        purpose: event.actor.type === "robot" ? SIGNER_KEY_PURPOSE.ROBOT : SIGNER_KEY_PURPOSE.OPERATOR
      });
    }
    if (effectiveSignerKind === SIGNER_KIND.SERVER) {
      if (!event.signature) throw new TypeError("server-signed events require signature");
      if (event.signerKeyId !== store.serverSigner.keyId) throw new TypeError("event.signerKeyId is not the server key");
    }
  }

  function listJobs({ tenantId } = {}) {
    const t = normalizeTenant(tenantId);
    const jobs = [];
    for (const job of store.jobs.values()) {
      if (!job?.id) continue;
      const jobTenant = normalizeTenant(job.tenantId ?? DEFAULT_TENANT_ID);
      if (jobTenant !== t) continue;
      jobs.push(job);
    }
    jobs.sort((a, b) => String(a.id).localeCompare(String(b.id)));
    return jobs;
  }

  function listRobots({ tenantId } = {}) {
    const t = normalizeTenant(tenantId);
    const robots = [];
    for (const robot of store.robots.values()) {
      if (!robot?.id) continue;
      const robotTenant = normalizeTenant(robot.tenantId ?? DEFAULT_TENANT_ID);
      if (robotTenant !== t) continue;
      robots.push(robot);
    }
    robots.sort((a, b) => String(a.id).localeCompare(String(b.id)));
    return robots;
  }

  function listAgentIdentities({ tenantId, status = null } = {}) {
    const t = normalizeTenant(tenantId);
    const statusFilter = status ? String(status).trim().toLowerCase() : null;
    const agents = [];
    if (!(store.agentIdentities instanceof Map)) return agents;
    for (const row of store.agentIdentities.values()) {
      if (!row || typeof row !== "object") continue;
      const rowTenant = normalizeTenant(row.tenantId ?? DEFAULT_TENANT_ID);
      if (rowTenant !== t) continue;
      if (statusFilter !== null && String(row.status ?? "").toLowerCase() !== statusFilter) continue;
      agents.push(row);
    }
    agents.sort((left, right) => String(left.agentId ?? "").localeCompare(String(right.agentId ?? "")));
    return agents;
  }

  function listAgentRuns({ tenantId, agentId = null, status = null } = {}) {
    const t = normalizeTenant(tenantId);
    const statusFilter = status ? String(status).trim().toLowerCase() : null;
    const runs = [];
    if (!(store.agentRuns instanceof Map)) return runs;
    for (const row of store.agentRuns.values()) {
      if (!row || typeof row !== "object") continue;
      const rowTenant = normalizeTenant(row.tenantId ?? DEFAULT_TENANT_ID);
      if (rowTenant !== t) continue;
      if (agentId !== null && String(row.agentId ?? "") !== String(agentId)) continue;
      if (statusFilter !== null && String(row.status ?? "").toLowerCase() !== statusFilter) continue;
      runs.push(row);
    }
    runs.sort((left, right) => String(left.runId ?? "").localeCompare(String(right.runId ?? "")));
    return runs;
  }

  async function listAgentRunSettlementsForRuns({ tenantId, runs = [] } = {}) {
    const t = normalizeTenant(tenantId);
    const out = [];
    if (!Array.isArray(runs) || runs.length === 0) return out;
    for (const run of runs) {
      const runId = run?.runId;
      if (typeof runId !== "string" || runId.trim() === "") continue;
      try {
        const settlement = await getAgentRunSettlementRecord({ tenantId: t, runId });
        if (settlement && typeof settlement === "object" && !Array.isArray(settlement)) out.push(settlement);
      } catch {
        // Ignore unsupported settlement store or missing record.
      }
    }
    return out;
  }

  function parseReputationVersion(rawValue) {
    if (rawValue === null || rawValue === undefined || String(rawValue).trim() === "") return "v1";
    const value = String(rawValue).trim().toLowerCase();
    if (value !== "v1" && value !== "v2") throw new TypeError("reputationVersion must be v1 or v2");
    return value;
  }

  function parseReputationWindow(rawValue) {
    if (rawValue === null || rawValue === undefined || String(rawValue).trim() === "") return AGENT_REPUTATION_WINDOW.THIRTY_DAYS;
    const value = String(rawValue).trim();
    if (!Object.values(AGENT_REPUTATION_WINDOW).includes(value)) throw new TypeError("reputationWindow must be one of 7d|30d|allTime");
    return value;
  }

  function parseDiscoveryStatus(rawValue) {
    if (rawValue === null || rawValue === undefined || String(rawValue).trim() === "") return "active";
    const value = String(rawValue).trim().toLowerCase();
    if (value !== "active" && value !== "suspended" && value !== "revoked" && value !== "all") {
      throw new TypeError("status must be active|suspended|revoked|all");
    }
    return value;
  }

  function parseScoreStrategy(rawValue) {
    if (rawValue === null || rawValue === undefined || String(rawValue).trim() === "") return "balanced";
    const value = String(rawValue).trim().toLowerCase();
    if (value !== "balanced" && value !== "recent_bias") throw new TypeError("scoreStrategy must be balanced|recent_bias");
    return value;
  }

  function computeMarketplaceRankingScore({ reputation, strategy = "balanced", reputationVersion = "v2", reputationWindow = AGENT_REPUTATION_WINDOW.THIRTY_DAYS } = {}) {
    const baseScore = Number(reputation?.trustScore ?? 0);
    if (strategy !== "recent_bias") return Math.max(0, Math.min(100, baseScore));

    if (reputationVersion !== "v2") return Math.max(0, Math.min(100, baseScore));
    const recentWindow = reputation?.windows?.[AGENT_REPUTATION_WINDOW.SEVEN_DAYS];
    const selectedWindow = reputation?.windows?.[reputationWindow];
    const recentScore = Number(recentWindow?.trustScore ?? baseScore);
    const selectedScore = Number(selectedWindow?.trustScore ?? baseScore);
    const blended = Math.round(recentScore * 0.7 + selectedScore * 0.3);
    return Math.max(0, Math.min(100, blended));
  }

  async function computeAgentReputationSnapshotVersioned({ tenantId, agentId, at = nowIso(), reputationVersion = "v1", reputationWindow = AGENT_REPUTATION_WINDOW.THIRTY_DAYS } = {}) {
    const t = normalizeTenant(tenantId);
    const a = String(agentId ?? "");
    if (a.trim() === "") throw new TypeError("agentId is required");
    const version = parseReputationVersion(reputationVersion);
    const window = parseReputationWindow(reputationWindow);

    let runs = [];
    if (typeof store.listAgentRuns === "function") {
      try {
        const pagedRuns = [];
        const pageSize = 1000;
        let offset = 0;
        let page = 0;
        while (page < 200) {
          page += 1;
          const batch = await store.listAgentRuns({ tenantId: t, agentId: a, status: null, limit: pageSize, offset });
          if (!Array.isArray(batch) || batch.length === 0) break;
          pagedRuns.push(...batch);
          if (batch.length < pageSize) break;
          offset += batch.length;
        }
        runs = pagedRuns;
      } catch {
        runs = [];
      }
    } else {
      runs = listAgentRuns({ tenantId: t, agentId: a, status: null });
    }

    const settlements = await listAgentRunSettlementsForRuns({ tenantId: t, runs });
    if (version === "v2") {
      return computeAgentReputationV2({
        tenantId: t,
        agentId: a,
        runs,
        settlements,
        at,
        primaryWindow: window
      });
    }
    return computeAgentReputation({ tenantId: t, agentId: a, runs, settlements, at });
  }

  async function searchMarketplaceAgents({
    tenantId,
    capability = null,
    status = "active",
    minTrustScore = null,
    riskTier = null,
    limit = 50,
    offset = 0,
    includeReputation = true,
    reputationVersion = "v2",
    reputationWindow = AGENT_REPUTATION_WINDOW.THIRTY_DAYS,
    scoreStrategy = "balanced"
  } = {}) {
    const t = normalizeTenant(tenantId);
    const safeLimit = Number.isSafeInteger(limit) && limit > 0 ? Math.min(100, limit) : 50;
    const safeOffset = Number.isSafeInteger(offset) && offset >= 0 ? offset : 0;
    const statusFilter = parseDiscoveryStatus(status);
    const version = parseReputationVersion(reputationVersion);
    const window = parseReputationWindow(reputationWindow);
    const rankingStrategy = parseScoreStrategy(scoreStrategy);

    const capabilityFilter = capability && String(capability).trim() !== "" ? String(capability).trim() : null;
    const minScore = minTrustScore === null || minTrustScore === undefined ? null : Number(minTrustScore);
    if (minScore !== null && (!Number.isSafeInteger(minScore) || minScore < 0 || minScore > 100)) {
      throw new TypeError("minTrustScore must be an integer within 0..100");
    }
    const riskTierFilter = riskTier === null || riskTier === undefined ? null : String(riskTier).trim().toLowerCase();
    if (riskTierFilter !== null && riskTierFilter !== "low" && riskTierFilter !== "guarded" && riskTierFilter !== "elevated" && riskTierFilter !== "high") {
      throw new TypeError("riskTier must be low|guarded|elevated|high");
    }

    let agents;
    if (typeof store.listAgentIdentities === "function") {
      agents = await store.listAgentIdentities({ tenantId: t, status: statusFilter === "all" ? null : statusFilter, limit: 10_000, offset: 0 });
    } else {
      agents = listAgentIdentities({ tenantId: t, status: statusFilter === "all" ? null : statusFilter });
    }

    if (capabilityFilter) {
      agents = agents.filter((agentIdentity) => Array.isArray(agentIdentity?.capabilities) && agentIdentity.capabilities.includes(capabilityFilter));
    }

    const ranked = [];
    for (const agentIdentity of agents) {
      const agentId = String(agentIdentity?.agentId ?? "");
      if (!agentId) continue;
      const reputation = await computeAgentReputationSnapshotVersioned({
        tenantId: t,
        agentId,
        at: nowIso(),
        reputationVersion: version,
        reputationWindow: window
      });
      const trustScore = Number(reputation?.trustScore ?? 0);
      const riskTierValue = String(reputation?.riskTier ?? "high");
      if (minScore !== null && trustScore < minScore) continue;
      if (riskTierFilter !== null && riskTierValue !== riskTierFilter) continue;
      const runVolume =
        version === "v2" ? Number(reputation?.windows?.[window]?.totalRuns ?? 0) : Number(reputation?.totalRuns ?? 0);
      const rankingScore = computeMarketplaceRankingScore({
        reputation,
        strategy: rankingStrategy,
        reputationVersion: version,
        reputationWindow: window
      });
      ranked.push({
        agentIdentity,
        reputation,
        trustScore,
        riskTier: riskTierValue,
        runVolume,
        rankingScore
      });
    }

    ranked.sort((left, right) => {
      if (right.rankingScore !== left.rankingScore) return right.rankingScore - left.rankingScore;
      if (right.trustScore !== left.trustScore) return right.trustScore - left.trustScore;
      if (right.runVolume !== left.runVolume) return right.runVolume - left.runVolume;
      return String(left.agentIdentity?.agentId ?? "").localeCompare(String(right.agentIdentity?.agentId ?? ""));
    });

    const total = ranked.length;
    const paged = ranked.slice(safeOffset, safeOffset + safeLimit);
    const results = paged.map((entry, index) => {
      const item = {
        rank: safeOffset + index + 1,
        rankingScore: entry.rankingScore,
        riskTier: entry.riskTier,
        agentIdentity: entry.agentIdentity
      };
      if (includeReputation) item.reputation = entry.reputation;
      return item;
    });

    return {
      reputationVersion: version,
      reputationWindow: window,
      scoreStrategy: rankingStrategy,
      total,
      limit: safeLimit,
      offset: safeOffset,
      results
    };
  }

  function parseMarketplaceRfqStatus(rawValue, { allowAll = true, defaultStatus = "all" } = {}) {
    if (rawValue === null || rawValue === undefined || String(rawValue).trim() === "") return defaultStatus;
    const value = String(rawValue).trim().toLowerCase();
    if (value === "open" || value === "assigned" || value === "cancelled" || value === "closed") return value;
    if (allowAll && value === "all") return value;
    throw new TypeError("status must be open|assigned|cancelled|closed|all");
  }

  function parseMarketplaceBidStatus(rawValue, { allowAll = true, defaultStatus = "all" } = {}) {
    if (rawValue === null || rawValue === undefined || String(rawValue).trim() === "") return defaultStatus;
    const value = String(rawValue).trim().toLowerCase();
    if (value === "pending" || value === "accepted" || value === "rejected") return value;
    if (allowAll && value === "all") return value;
    throw new TypeError("status must be pending|accepted|rejected|all");
  }

  function parseMarketplaceCapabilityListingStatus(rawValue, { allowAll = true, defaultStatus = "all" } = {}) {
    if (rawValue === null || rawValue === undefined || String(rawValue).trim() === "") return defaultStatus;
    const value = String(rawValue).trim().toLowerCase();
    if (value === "active" || value === "paused" || value === "retired") return value;
    if (allowAll && value === "all") return value;
    throw new TypeError("status must be active|paused|retired|all");
  }

  function parseMarketplaceProviderPublicationStatus(rawValue, { allowAll = true, defaultStatus = "all" } = {}) {
    if (rawValue === null || rawValue === undefined || String(rawValue).trim() === "") return defaultStatus;
    const value = String(rawValue).trim().toLowerCase();
    if (value === "certified" || value === "conformance_failed" || value === "draft") return value;
    if (allowAll && value === "all") return value;
    throw new TypeError("status must be certified|conformance_failed|draft|all");
  }

  function parseMarketplaceProviderId(rawValue, { fieldPath = "providerId", allowNull = false } = {}) {
    if (rawValue === null || rawValue === undefined || String(rawValue).trim() === "") {
      if (allowNull) return null;
      throw new TypeError(`${fieldPath} is required`);
    }
    const value = String(rawValue).trim();
    if (value.length > 160) throw new TypeError(`${fieldPath} must be <= 160 chars`);
    if (!/^[A-Za-z0-9._:-]+$/.test(value)) throw new TypeError(`${fieldPath} must match [A-Za-z0-9._:-]+`);
    return value;
  }

  function parseInteractionDirection({
    fromTypeRaw,
    toTypeRaw,
    defaultFromType = "agent",
    defaultToType = "agent"
  } = {}) {
    return normalizeInteractionDirection({
      fromType: fromTypeRaw,
      toType: toTypeRaw,
      defaultFromType,
      defaultToType
    });
  }

  const MARKETPLACE_POLICY_REF_SCHEMA_VERSION = "MarketplaceSettlementPolicyRef.v1";
  const MARKETPLACE_PROVIDER_PUBLICATION_SCHEMA_VERSION = "MarketplaceProviderPublication.v1";
  const TENANT_SETTLEMENT_POLICY_SCHEMA_VERSION = "TenantSettlementPolicy.v1";
  const TENANT_SETTLEMENT_POLICY_ROLLOUT_SCHEMA_VERSION = "TenantSettlementPolicyRollout.v1";
  const TENANT_SETTLEMENT_POLICY_DIFF_SCHEMA_VERSION = "TenantSettlementPolicyDiff.v1";
  const SETTLEMENT_POLICY_ROLLOUT_HISTORY_LIMIT = 200;
  const SETTLEMENT_POLICY_ROLLOUT_STAGE = Object.freeze({
    DRAFT: "draft",
    CANARY: "canary",
    ACTIVE: "active"
  });
  const MARKETPLACE_BID_ACCEPTANCE_SCHEMA_VERSION = "MarketplaceBidAcceptance.v1";
  const MARKETPLACE_AGREEMENT_ACCEPTANCE_SCHEMA_VERSION = "MarketplaceAgreementAcceptance.v1";
  const MARKETPLACE_AGREEMENT_ACCEPTANCE_SIGNATURE_SCHEMA_VERSION = "MarketplaceAgreementAcceptanceSignature.v2";
  const MARKETPLACE_AGREEMENT_CHANGE_ORDER_ACCEPTANCE_SIGNATURE_SCHEMA_VERSION =
    "MarketplaceAgreementChangeOrderAcceptanceSignature.v2";
  const MARKETPLACE_AGREEMENT_CANCELLATION_ACCEPTANCE_SIGNATURE_SCHEMA_VERSION =
    "MarketplaceAgreementCancellationAcceptanceSignature.v2";
  const MARKETPLACE_AGREEMENT_POLICY_BINDING_SCHEMA_VERSION = "MarketplaceAgreementPolicyBinding.v2";
  const AGENT_DELEGATION_LINK_SCHEMA_VERSION = "AgentDelegationLink.v1";
  const AGENT_ACTING_ON_BEHALF_OF_SCHEMA_VERSION = "AgentActingOnBehalfOf.v1";
  const X402_AGENT_PASSPORT_SCHEMA_VERSION = "AgentPassport.v1";
  const X402_QUOTE_SCHEMA_VERSION = "X402Quote.v1";
  const X402_WALLET_POLICY_SCHEMA_VERSION = "X402WalletPolicy.v1";
  const MARKETPLACE_DELEGATION_SCOPE_AGREEMENT_ACCEPT = "marketplace.agreement.accept";
  const MARKETPLACE_DELEGATION_SCOPE_AGREEMENT_CHANGE_ORDER = "marketplace.agreement.change_order";
  const MARKETPLACE_DELEGATION_SCOPE_AGREEMENT_CANCEL = "marketplace.agreement.cancel";
  const DELEGATION_TRACE_CONTEXT_TYPE = Object.freeze({
    AGREEMENT_ACCEPTANCE: "agreement_acceptance",
    CHANGE_ORDER_ACCEPTANCE: "change_order_acceptance",
    CANCELLATION_ACCEPTANCE: "cancellation_acceptance"
  });

  function parseSettlementPolicyRegistryId(rawValue, { fieldPath = "policyId", allowNull = false } = {}) {
    if (rawValue === null || rawValue === undefined || String(rawValue).trim() === "") {
      if (allowNull) return null;
      throw new TypeError(`${fieldPath} is required`);
    }
    const value = String(rawValue).trim();
    if (!/^[A-Za-z0-9._:-]{1,128}$/.test(value)) {
      throw new TypeError(`${fieldPath} must match /^[A-Za-z0-9._:-]{1,128}$/`);
    }
    return value;
  }

  function parseSettlementPolicyVersion(rawValue, { fieldPath = "policyVersion", allowNull = false } = {}) {
    if (rawValue === null || rawValue === undefined || rawValue === "") {
      if (allowNull) return null;
      throw new TypeError(`${fieldPath} is required`);
    }
    const value = Number(rawValue);
    if (!Number.isSafeInteger(value) || value <= 0) {
      throw new TypeError(`${fieldPath} must be a positive safe integer`);
    }
    return value;
  }

  function normalizeOptionalHashInput(rawValue, fieldPath) {
    if (rawValue === null || rawValue === undefined || rawValue === "") return null;
    if (typeof rawValue !== "string" || rawValue.trim() === "") {
      throw new TypeError(`${fieldPath} must be a non-empty string`);
    }
    return rawValue.trim().toLowerCase();
  }

  function normalizeSha256HashInput(rawValue, fieldPath, { allowNull = true } = {}) {
    if (rawValue === null || rawValue === undefined || rawValue === "") {
      if (allowNull) return null;
      throw new TypeError(`${fieldPath} is required`);
    }
    if (typeof rawValue !== "string") throw new TypeError(`${fieldPath} must be a sha256 hex string`);
    const value = rawValue.trim().toLowerCase();
    if (!/^[0-9a-f]{64}$/.test(value)) throw new TypeError(`${fieldPath} must match /^[0-9a-f]{64}$/`);
    return value;
  }

  function normalizeOptionalX402RefInput(rawValue, fieldPath, { allowNull = true, max = 200 } = {}) {
    if (rawValue === null || rawValue === undefined || rawValue === "") {
      if (allowNull) return null;
      throw new TypeError(`${fieldPath} is required`);
    }
    if (typeof rawValue !== "string") throw new TypeError(`${fieldPath} must be a string`);
    const value = rawValue.trim();
    if (!value) {
      if (allowNull) return null;
      throw new TypeError(`${fieldPath} is required`);
    }
    if (value.length > max) throw new TypeError(`${fieldPath} must be <= ${max} chars`);
    if (!/^[A-Za-z0-9:_-]+$/.test(value)) throw new TypeError(`${fieldPath} must match ^[A-Za-z0-9:_-]+$`);
    return value;
  }

  function normalizeOptionalX402PositiveSafeInt(rawValue, fieldPath, { allowNull = true } = {}) {
    if (rawValue === null || rawValue === undefined || rawValue === "") {
      if (allowNull) return null;
      throw new TypeError(`${fieldPath} is required`);
    }
    const value = Number(rawValue);
    if (!Number.isSafeInteger(value) || value <= 0) throw new TypeError(`${fieldPath} must be a positive safe integer`);
    return value;
  }

  function normalizeX402AgentPassportInput(rawValue, { fieldPath = "agentPassport", allowNull = true } = {}) {
    if (rawValue === null || rawValue === undefined) {
      if (allowNull) return null;
      throw new TypeError(`${fieldPath} is required`);
    }
    if (typeof rawValue !== "object" || Array.isArray(rawValue)) {
      throw new TypeError(`${fieldPath} must be an object`);
    }
    const schemaVersionRaw =
      typeof rawValue.schemaVersion === "string" && rawValue.schemaVersion.trim() !== ""
        ? rawValue.schemaVersion.trim()
        : X402_AGENT_PASSPORT_SCHEMA_VERSION;
    if (schemaVersionRaw !== X402_AGENT_PASSPORT_SCHEMA_VERSION) {
      throw new TypeError(`${fieldPath}.schemaVersion must be ${X402_AGENT_PASSPORT_SCHEMA_VERSION}`);
    }
    const sponsorRef = normalizeOptionalX402RefInput(rawValue.sponsorRef, `${fieldPath}.sponsorRef`, { allowNull: false, max: 200 });
    const agentKeyId = normalizeOptionalX402RefInput(rawValue.agentKeyId, `${fieldPath}.agentKeyId`, { allowNull: false, max: 200 });
    const sponsorWalletRef = normalizeOptionalX402RefInput(rawValue.sponsorWalletRef, `${fieldPath}.sponsorWalletRef`, {
      allowNull: true,
      max: 200
    });
    const delegationRef = normalizeOptionalX402RefInput(rawValue.delegationRef, `${fieldPath}.delegationRef`, { allowNull: true, max: 200 });
    const policyRef = normalizeOptionalX402RefInput(rawValue.policyRef, `${fieldPath}.policyRef`, { allowNull: true, max: 200 });
    const policyVersion = normalizeOptionalX402PositiveSafeInt(rawValue.policyVersion, `${fieldPath}.policyVersion`, {
      allowNull: true
    });
    const expiresAt =
      rawValue.expiresAt === null || rawValue.expiresAt === undefined || String(rawValue.expiresAt).trim() === ""
        ? null
        : String(rawValue.expiresAt).trim();
    if (expiresAt !== null && !Number.isFinite(Date.parse(expiresAt))) {
      throw new TypeError(`${fieldPath}.expiresAt must be an ISO timestamp`);
    }
    return normalizeForCanonicalJson(
      {
        schemaVersion: X402_AGENT_PASSPORT_SCHEMA_VERSION,
        sponsorRef,
        ...(sponsorWalletRef ? { sponsorWalletRef } : {}),
        agentKeyId,
        ...(delegationRef ? { delegationRef } : {}),
        ...(policyRef ? { policyRef } : {}),
        ...(policyVersion ? { policyVersion } : {}),
        ...(expiresAt ? { expiresAt } : {})
      },
      { path: "$" }
    );
  }

  function buildX402QuoteRecord({
    gateId,
    quoteId,
    providerId,
    toolId = null,
    amountCents,
    currency,
    requestBindingMode = null,
    requestBindingSha256 = null,
    quotedAt,
    expiresAt
  } = {}) {
    const normalized = normalizeForCanonicalJson(
      {
        schemaVersion: X402_QUOTE_SCHEMA_VERSION,
        gateId: normalizeOptionalX402RefInput(gateId, "quote.gateId", { allowNull: false, max: 200 }),
        quoteId: normalizeOptionalX402RefInput(quoteId, "quote.quoteId", { allowNull: false, max: 200 }),
        providerId: normalizeOptionalX402RefInput(providerId, "quote.providerId", { allowNull: false, max: 200 }),
        ...(toolId ? { toolId: normalizeOptionalX402RefInput(toolId, "quote.toolId", { allowNull: false, max: 200 }) } : {}),
        amountCents: normalizeOptionalX402PositiveSafeInt(amountCents, "quote.amountCents", { allowNull: false }),
        currency: typeof currency === "string" && currency.trim() !== "" ? currency.trim().toUpperCase() : "USD",
        ...(requestBindingMode ? { requestBindingMode: String(requestBindingMode).trim().toLowerCase() } : {}),
        ...(requestBindingSha256
          ? {
              requestBindingSha256: normalizeSha256HashInput(requestBindingSha256, "quote.requestBindingSha256", { allowNull: false })
            }
          : {}),
        quotedAt: String(quotedAt),
        expiresAt: String(expiresAt)
      },
      { path: "$" }
    );
    const quoteSha256 = sha256Hex(canonicalJsonStringify(normalized));
    return normalizeForCanonicalJson(
      {
        ...normalized,
        quoteSha256
      },
      { path: "$" }
    );
  }

  function buildX402AgentPassportPolicyFingerprint(passport) {
    if (!passport || typeof passport !== "object" || Array.isArray(passport)) return null;
    const normalized = normalizeForCanonicalJson(
      {
        schemaVersion: X402_AGENT_PASSPORT_SCHEMA_VERSION,
        sponsorRef:
          typeof passport.sponsorRef === "string" && passport.sponsorRef.trim() !== "" ? passport.sponsorRef.trim() : null,
        sponsorWalletRef:
          typeof passport.sponsorWalletRef === "string" && passport.sponsorWalletRef.trim() !== ""
            ? passport.sponsorWalletRef.trim()
            : null,
        agentKeyId:
          typeof passport.agentKeyId === "string" && passport.agentKeyId.trim() !== "" ? passport.agentKeyId.trim() : null,
        delegationRef:
          typeof passport.delegationRef === "string" && passport.delegationRef.trim() !== "" ? passport.delegationRef.trim() : null,
        policyRef: typeof passport.policyRef === "string" && passport.policyRef.trim() !== "" ? passport.policyRef.trim() : null,
        policyVersion: Number.isSafeInteger(Number(passport.policyVersion)) ? Number(passport.policyVersion) : null,
        expiresAt: typeof passport.expiresAt === "string" && passport.expiresAt.trim() !== "" ? passport.expiresAt.trim() : null
      },
      { path: "$" }
    );
    return sha256Hex(canonicalJsonStringify(normalized));
  }

  function normalizeX402WalletPolicyStatusInput(rawValue, { fieldPath = "status", allowNull = false } = {}) {
    if (rawValue === null || rawValue === undefined || String(rawValue).trim() === "") {
      if (allowNull) return null;
      return "active";
    }
    const value = String(rawValue).trim().toLowerCase();
    if (value !== "active" && value !== "disabled") {
      throw new TypeError(`${fieldPath} must be active|disabled`);
    }
    return value;
  }

  function normalizeX402WalletPolicyAllowedIdsInput(rawValue, fieldPath, { allowNull = true, max = 200 } = {}) {
    if (rawValue === null || rawValue === undefined || rawValue === "") {
      if (allowNull) return [];
      throw new TypeError(`${fieldPath} is required`);
    }
    let parsed = rawValue;
    if (typeof parsed === "string") {
      const trimmed = parsed.trim();
      if (!trimmed) return [];
      parsed = trimmed.split(",").map((entry) => entry.trim());
    }
    if (!Array.isArray(parsed)) throw new TypeError(`${fieldPath} must be an array`);
    const out = [];
    const seen = new Set();
    for (const entry of parsed) {
      const id = normalizeOptionalX402RefInput(entry, fieldPath, { allowNull: true, max });
      if (!id) continue;
      if (seen.has(id)) continue;
      seen.add(id);
      out.push(id);
    }
    return out;
  }

  function normalizeX402WalletPolicyAllowedCurrenciesInput(rawValue, fieldPath, { allowNull = true } = {}) {
    if (rawValue === null || rawValue === undefined || rawValue === "") {
      if (allowNull) return [];
      throw new TypeError(`${fieldPath} is required`);
    }
    let parsed = rawValue;
    if (typeof parsed === "string") {
      const trimmed = parsed.trim();
      if (!trimmed) return [];
      parsed = trimmed.split(",").map((entry) => entry.trim());
    }
    if (!Array.isArray(parsed)) throw new TypeError(`${fieldPath} must be an array`);
    const out = [];
    const seen = new Set();
    for (const entry of parsed) {
      if (entry === null || entry === undefined || String(entry).trim() === "") continue;
      const currency = String(entry).trim().toUpperCase();
      if (!/^[A-Z][A-Z0-9_]{2,11}$/.test(currency)) {
        throw new TypeError(`${fieldPath} values must match ^[A-Z][A-Z0-9_]{2,11}$`);
      }
      if (seen.has(currency)) continue;
      seen.add(currency);
      out.push(currency);
    }
    return out;
  }

  function normalizeX402WalletPolicyAllowedReversalActionsInput(rawValue, fieldPath, { allowNull = true } = {}) {
    if (rawValue === null || rawValue === undefined || rawValue === "") {
      if (allowNull) return [];
      throw new TypeError(`${fieldPath} is required`);
    }
    if (!Array.isArray(rawValue)) throw new TypeError(`${fieldPath} must be an array`);
    const out = [];
    const seen = new Set();
    for (const entry of rawValue) {
      if (entry === null || entry === undefined || String(entry).trim() === "") continue;
      const action = String(entry).trim().toLowerCase();
      if (action !== "void_authorization" && action !== "request_refund" && action !== "resolve_refund") {
        throw new TypeError(`${fieldPath} values must be void_authorization|request_refund|resolve_refund`);
      }
      if (seen.has(action)) continue;
      seen.add(action);
      out.push(action);
    }
    return out;
  }

  function buildX402WalletPolicyFingerprint(policy) {
    if (!policy || typeof policy !== "object" || Array.isArray(policy)) return null;
    const normalized = normalizeForCanonicalJson(
      {
        schemaVersion: X402_WALLET_POLICY_SCHEMA_VERSION,
        sponsorRef: normalizeOptionalX402RefInput(policy.sponsorRef ?? null, "policy.sponsorRef", { allowNull: true, max: 200 }),
        sponsorWalletRef: normalizeOptionalX402RefInput(policy.sponsorWalletRef ?? null, "policy.sponsorWalletRef", {
          allowNull: false,
          max: 200
        }),
        policyRef: normalizeOptionalX402RefInput(policy.policyRef ?? null, "policy.policyRef", { allowNull: false, max: 200 }),
        policyVersion: normalizeOptionalX402PositiveSafeInt(policy.policyVersion ?? null, "policy.policyVersion", { allowNull: false }),
        status: normalizeX402WalletPolicyStatusInput(policy.status ?? null, { allowNull: false }),
        maxAmountCents: normalizeOptionalNonNegativeSafeInt(policy.maxAmountCents ?? null, {
          fieldName: "policy.maxAmountCents",
          allowNull: true
        }),
        maxDailyAuthorizationCents: normalizeOptionalNonNegativeSafeInt(policy.maxDailyAuthorizationCents ?? null, {
          fieldName: "policy.maxDailyAuthorizationCents",
          allowNull: true
        }),
        allowedProviderIds: normalizeX402WalletPolicyAllowedIdsInput(policy.allowedProviderIds ?? [], "policy.allowedProviderIds"),
        allowedToolIds: normalizeX402WalletPolicyAllowedIdsInput(policy.allowedToolIds ?? [], "policy.allowedToolIds"),
        allowedAgentKeyIds: normalizeX402WalletPolicyAllowedIdsInput(policy.allowedAgentKeyIds ?? [], "policy.allowedAgentKeyIds"),
        allowedCurrencies: normalizeX402WalletPolicyAllowedCurrenciesInput(policy.allowedCurrencies ?? [], "policy.allowedCurrencies"),
        allowedReversalActions: normalizeX402WalletPolicyAllowedReversalActionsInput(
          policy.allowedReversalActions ?? [],
          "policy.allowedReversalActions"
        ),
        requireQuote: policy.requireQuote === true,
        requireStrictRequestBinding: policy.requireStrictRequestBinding === true,
        requireAgentKeyMatch: policy.requireAgentKeyMatch === true
      },
      { path: "$" }
    );
    return sha256Hex(canonicalJsonStringify(normalized));
  }

  function normalizeX402WalletPolicyInput(rawValue, { fieldPath = "policy", existing = null } = {}) {
    if (!rawValue || typeof rawValue !== "object" || Array.isArray(rawValue)) {
      throw new TypeError(`${fieldPath} must be an object`);
    }
    const schemaVersionRaw =
      typeof rawValue.schemaVersion === "string" && rawValue.schemaVersion.trim() !== ""
        ? rawValue.schemaVersion.trim()
        : X402_WALLET_POLICY_SCHEMA_VERSION;
    if (schemaVersionRaw !== X402_WALLET_POLICY_SCHEMA_VERSION) {
      throw new TypeError(`${fieldPath}.schemaVersion must be ${X402_WALLET_POLICY_SCHEMA_VERSION}`);
    }
    const sponsorRef = normalizeOptionalX402RefInput(rawValue.sponsorRef ?? null, `${fieldPath}.sponsorRef`, {
      allowNull: true,
      max: 200
    });
    const sponsorWalletRef = normalizeOptionalX402RefInput(rawValue.sponsorWalletRef, `${fieldPath}.sponsorWalletRef`, {
      allowNull: false,
      max: 200
    });
    const policyRef = normalizeOptionalX402RefInput(rawValue.policyRef, `${fieldPath}.policyRef`, { allowNull: false, max: 200 });
    const policyVersion = normalizeOptionalX402PositiveSafeInt(rawValue.policyVersion, `${fieldPath}.policyVersion`, {
      allowNull: false
    });
    const status = normalizeX402WalletPolicyStatusInput(rawValue.status ?? null, { fieldPath: `${fieldPath}.status`, allowNull: false });
    const maxAmountCents = normalizeOptionalNonNegativeSafeInt(rawValue.maxAmountCents ?? null, {
      fieldName: `${fieldPath}.maxAmountCents`,
      allowNull: true
    });
    const maxDailyAuthorizationCents = normalizeOptionalNonNegativeSafeInt(rawValue.maxDailyAuthorizationCents ?? null, {
      fieldName: `${fieldPath}.maxDailyAuthorizationCents`,
      allowNull: true
    });
    const allowedProviderIds = normalizeX402WalletPolicyAllowedIdsInput(
      rawValue.allowedProviderIds ?? [],
      `${fieldPath}.allowedProviderIds`
    );
    const allowedToolIds = normalizeX402WalletPolicyAllowedIdsInput(rawValue.allowedToolIds ?? [], `${fieldPath}.allowedToolIds`);
    const allowedAgentKeyIds = normalizeX402WalletPolicyAllowedIdsInput(
      rawValue.allowedAgentKeyIds ?? [],
      `${fieldPath}.allowedAgentKeyIds`
    );
    const allowedCurrencies = normalizeX402WalletPolicyAllowedCurrenciesInput(
      rawValue.allowedCurrencies ?? [],
      `${fieldPath}.allowedCurrencies`
    );
    const allowedReversalActions = normalizeX402WalletPolicyAllowedReversalActionsInput(
      rawValue.allowedReversalActions ?? [],
      `${fieldPath}.allowedReversalActions`
    );
    const requireQuote = rawValue.requireQuote === true;
    const requireStrictRequestBinding = rawValue.requireStrictRequestBinding === true;
    const requireAgentKeyMatch = rawValue.requireAgentKeyMatch === true;
    const description =
      rawValue.description === null || rawValue.description === undefined || String(rawValue.description).trim() === ""
        ? null
        : String(rawValue.description).trim().slice(0, 500);
    const metadata =
      rawValue.metadata === null || rawValue.metadata === undefined
        ? null
        : typeof rawValue.metadata === "object" && !Array.isArray(rawValue.metadata)
          ? { ...rawValue.metadata }
          : (() => {
              throw new TypeError(`${fieldPath}.metadata must be an object or null`);
            })();
    const createdAt =
      typeof existing?.createdAt === "string" && Number.isFinite(Date.parse(existing.createdAt))
        ? existing.createdAt
        : nowIso();
    const updatedAt = nowIso();
    const base = normalizeForCanonicalJson(
      {
        schemaVersion: X402_WALLET_POLICY_SCHEMA_VERSION,
        sponsorRef,
        sponsorWalletRef,
        policyRef,
        policyVersion,
        status,
        maxAmountCents,
        maxDailyAuthorizationCents,
        allowedProviderIds,
        allowedToolIds,
        allowedAgentKeyIds,
        allowedCurrencies,
        allowedReversalActions,
        requireQuote,
        requireStrictRequestBinding,
        requireAgentKeyMatch,
        description,
        metadata,
        createdAt,
        updatedAt
      },
      { path: "$" }
    );
    return normalizeForCanonicalJson(
      {
        ...base,
        policyFingerprint: buildX402WalletPolicyFingerprint(base)
      },
      { path: "$" }
    );
  }

  function x402WalletPolicyStoreKey({ tenantId, sponsorWalletRef, policyRef, policyVersion }) {
    return makeScopedKey({
      tenantId: normalizeTenant(tenantId),
      id: `${normalizeOptionalX402RefInput(sponsorWalletRef, "sponsorWalletRef", { allowNull: false, max: 200 })}::${normalizeOptionalX402RefInput(
        policyRef,
        "policyRef",
        { allowNull: false, max: 200 }
      )}::${normalizeOptionalX402PositiveSafeInt(policyVersion, "policyVersion", { allowNull: false })}`
    });
  }

  function getX402WalletPolicyRecord({ tenantId, sponsorWalletRef, policyRef, policyVersion }) {
    if (typeof store.getX402WalletPolicy === "function") {
      return store.getX402WalletPolicy({ tenantId, sponsorWalletRef, policyRef, policyVersion });
    }
    if (!(store.x402WalletPolicies instanceof Map)) return null;
    return store.x402WalletPolicies.get(
      x402WalletPolicyStoreKey({ tenantId, sponsorWalletRef, policyRef, policyVersion })
    ) ?? null;
  }

  async function listX402WalletPolicyRecords({
    tenantId,
    sponsorWalletRef = null,
    sponsorRef = null,
    policyRef = null,
    status = null,
    limit = 200,
    offset = 0
  } = {}) {
    const t = normalizeTenant(tenantId);
    const sponsorWalletFilter =
      sponsorWalletRef === null || sponsorWalletRef === undefined || String(sponsorWalletRef).trim() === ""
        ? null
        : normalizeOptionalX402RefInput(sponsorWalletRef, "sponsorWalletRef", { allowNull: false, max: 200 });
    const sponsorFilter =
      sponsorRef === null || sponsorRef === undefined || String(sponsorRef).trim() === ""
        ? null
        : normalizeOptionalX402RefInput(sponsorRef, "sponsorRef", { allowNull: false, max: 200 });
    const policyFilter =
      policyRef === null || policyRef === undefined || String(policyRef).trim() === ""
        ? null
        : normalizeOptionalX402RefInput(policyRef, "policyRef", { allowNull: false, max: 200 });
    const statusFilter =
      status === null || status === undefined || String(status).trim() === ""
        ? null
        : normalizeX402WalletPolicyStatusInput(status, { fieldPath: "status", allowNull: false });
    const safeLimit = Number.isSafeInteger(Number(limit)) && Number(limit) > 0 ? Math.min(1000, Number(limit)) : 200;
    const safeOffset = Number.isSafeInteger(Number(offset)) && Number(offset) >= 0 ? Number(offset) : 0;
    if (typeof store.listX402WalletPolicies === "function") {
      return await store.listX402WalletPolicies({
        tenantId: t,
        sponsorWalletRef: sponsorWalletFilter,
        sponsorRef: sponsorFilter,
        policyRef: policyFilter,
        status: statusFilter,
        limit: safeLimit,
        offset: safeOffset
      });
    }
    const rows = [];
    if (!(store.x402WalletPolicies instanceof Map)) return rows;
    for (const row of store.x402WalletPolicies.values()) {
      if (!row || typeof row !== "object" || Array.isArray(row)) continue;
      if (normalizeTenant(row.tenantId ?? DEFAULT_TENANT_ID) !== t) continue;
      if (sponsorWalletFilter && String(row.sponsorWalletRef ?? "") !== sponsorWalletFilter) continue;
      if (sponsorFilter && String(row.sponsorRef ?? "") !== sponsorFilter) continue;
      if (policyFilter && String(row.policyRef ?? "") !== policyFilter) continue;
      if (statusFilter && String(row.status ?? "") !== statusFilter) continue;
      rows.push(row);
    }
    rows.sort((left, right) => {
      const leftAt = Number.isFinite(Date.parse(String(left.updatedAt ?? ""))) ? Date.parse(String(left.updatedAt)) : Number.NaN;
      const rightAt = Number.isFinite(Date.parse(String(right.updatedAt ?? ""))) ? Date.parse(String(right.updatedAt)) : Number.NaN;
      if (Number.isFinite(leftAt) && Number.isFinite(rightAt) && rightAt !== leftAt) return rightAt - leftAt;
      const sponsorOrder = String(left.sponsorWalletRef ?? "").localeCompare(String(right.sponsorWalletRef ?? ""));
      if (sponsorOrder !== 0) return sponsorOrder;
      const policyOrder = String(left.policyRef ?? "").localeCompare(String(right.policyRef ?? ""));
      if (policyOrder !== 0) return policyOrder;
      return Number(right.policyVersion ?? 0) - Number(left.policyVersion ?? 0);
    });
    return rows.slice(safeOffset, safeOffset + safeLimit);
  }

  async function resolveX402WalletPolicyForIssuerQuery({
    tenantId,
    sponsorWalletRef,
    policyRef = null,
    policyVersion = null
  } = {}) {
    const normalizedTenantId = normalizeTenant(tenantId);
    const normalizedWalletRef = normalizeOptionalX402RefInput(sponsorWalletRef, "sponsorWalletRef", {
      allowNull: false,
      max: 200
    });
    const normalizedPolicyRef =
      policyRef === null || policyRef === undefined || String(policyRef).trim() === ""
        ? null
        : normalizeOptionalX402RefInput(policyRef, "policyRef", { allowNull: false, max: 200 });
    const normalizedPolicyVersion =
      policyVersion === null || policyVersion === undefined || policyVersion === ""
        ? null
        : normalizeOptionalX402PositiveSafeInt(policyVersion, "policyVersion", { allowNull: false });

    if (normalizedPolicyRef && normalizedPolicyVersion) {
      const policy = await getX402WalletPolicyRecord({
        tenantId: normalizedTenantId,
        sponsorWalletRef: normalizedWalletRef,
        policyRef: normalizedPolicyRef,
        policyVersion: normalizedPolicyVersion
      });
      return policy ?? null;
    }

    const listed = await listX402WalletPolicyRecords({
      tenantId: normalizedTenantId,
      sponsorWalletRef: normalizedWalletRef,
      status: "active",
      limit: 1,
      offset: 0
    });
    return Array.isArray(listed) && listed.length > 0 ? listed[0] : null;
  }

  function toX402WalletLedgerEntry(receipt) {
    if (!receipt || typeof receipt !== "object" || Array.isArray(receipt)) return null;
    const settlementReceipt =
      receipt.settlementReceipt && typeof receipt.settlementReceipt === "object" && !Array.isArray(receipt.settlementReceipt)
        ? receipt.settlementReceipt
        : null;
    const amountCents = Number(settlementReceipt?.amountCents ?? 0);
    const releasedAmountCents = Number(settlementReceipt?.releasedAmountCents ?? 0);
    const refundedAmountCents = Number(settlementReceipt?.refundedAmountCents ?? 0);
    const safeAmount = Number.isSafeInteger(amountCents) ? amountCents : 0;
    const safeReleased = Number.isSafeInteger(releasedAmountCents) ? releasedAmountCents : 0;
    const safeRefunded = Number.isSafeInteger(refundedAmountCents) ? refundedAmountCents : 0;
    return normalizeForCanonicalJson(
      {
        schemaVersion: "X402WalletLedgerEntry.v1",
        receiptId: receipt.receiptId ?? null,
        gateId: receipt.gateId ?? null,
        runId: receipt.runId ?? null,
        sponsorRef: receipt.sponsorRef ?? null,
        sponsorWalletRef: receipt.sponsorWalletRef ?? null,
        providerId: receipt.providerId ?? null,
        toolId: receipt.toolId ?? null,
        settlementState: receipt.settlementState ?? null,
        verificationStatus: receipt.verificationStatus ?? null,
        settledAt: receipt.settledAt ?? null,
        currency:
          typeof settlementReceipt?.currency === "string" && settlementReceipt.currency.trim() !== ""
            ? settlementReceipt.currency.trim().toUpperCase()
            : "USD",
        amountCents: safeAmount,
        releasedAmountCents: safeReleased,
        refundedAmountCents: safeRefunded,
        netAmountCents: safeReleased - safeRefunded
      },
      { path: "$" }
    );
  }

  function summarizeX402WalletLedgerEntries(entries = []) {
    let grossAuthorizedCents = 0;
    let releasedCents = 0;
    let refundedCents = 0;
    for (const entry of Array.isArray(entries) ? entries : []) {
      if (!entry || typeof entry !== "object" || Array.isArray(entry)) continue;
      const authorized = Number(entry.amountCents ?? 0);
      const released = Number(entry.releasedAmountCents ?? 0);
      const refunded = Number(entry.refundedAmountCents ?? 0);
      if (Number.isSafeInteger(authorized)) grossAuthorizedCents += authorized;
      if (Number.isSafeInteger(released)) releasedCents += released;
      if (Number.isSafeInteger(refunded)) refundedCents += refunded;
    }
    return normalizeForCanonicalJson(
      {
        schemaVersion: "X402WalletLedgerSummary.v1",
        grossAuthorizedCents,
        releasedCents,
        refundedCents,
        netSettledCents: releasedCents - refundedCents
      },
      { path: "$" }
    );
  }

  function summarizeX402WalletAuthorizationState({
    tenantId,
    sponsorWalletRef
  } = {}) {
    if (!(store?.x402Gates instanceof Map)) {
      return {
        schemaVersion: "X402WalletAuthorizationSummary.v1",
        reservedCount: 0,
        reservedAmountCents: 0,
        settledCount: 0,
        settledAmountCents: 0
      };
    }
    const normalizedTenantId = normalizeTenantId(tenantId ?? DEFAULT_TENANT_ID);
    const walletRef = normalizeOptionalX402RefInput(sponsorWalletRef, "sponsorWalletRef", { allowNull: false, max: 200 });
    let reservedCount = 0;
    let reservedAmountCents = 0;
    let settledCount = 0;
    let settledAmountCents = 0;
    for (const gate of store.x402Gates.values()) {
      if (!gate || typeof gate !== "object" || Array.isArray(gate)) continue;
      if (normalizeTenantId(gate.tenantId ?? DEFAULT_TENANT_ID) !== normalizedTenantId) continue;
      const gateWalletRef =
        gate?.agentPassport && typeof gate.agentPassport === "object" && !Array.isArray(gate.agentPassport)
          ? typeof gate.agentPassport.sponsorWalletRef === "string" && gate.agentPassport.sponsorWalletRef.trim() !== ""
            ? gate.agentPassport.sponsorWalletRef.trim()
            : null
          : null;
      if (gateWalletRef !== walletRef) continue;
      const authorization =
        gate.authorization && typeof gate.authorization === "object" && !Array.isArray(gate.authorization)
          ? gate.authorization
          : null;
      const status = String(authorization?.status ?? "").toLowerCase();
      const amountCents = Number(gate?.terms?.amountCents ?? authorization?.walletEscrow?.amountCents ?? 0);
      if (!Number.isSafeInteger(amountCents) || amountCents <= 0) continue;
      if (status === "reserved") {
        reservedCount += 1;
        reservedAmountCents += amountCents;
      } else if (status === "settled") {
        settledCount += 1;
        settledAmountCents += amountCents;
      }
    }
    return normalizeForCanonicalJson(
      {
        schemaVersion: "X402WalletAuthorizationSummary.v1",
        reservedCount,
        reservedAmountCents,
        settledCount,
        settledAmountCents
      },
      { path: "$" }
    );
  }

  function buildX402WalletPolicyError(code, message, details = null) {
    const err = new Error(message);
    err.code = code;
    if (details !== null && details !== undefined) err.details = details;
    return err;
  }

  async function assertX402WalletPolicyForAuthorization({
    tenantId,
    gate,
    policy,
    amountCents,
    currency,
    payeeProviderId,
    effectiveQuoteId,
    effectiveRequestBindingMode,
    effectiveRequestBindingSha256,
    nowAt
  }) {
    if (!policy || typeof policy !== "object" || Array.isArray(policy)) return;
    const status = String(policy.status ?? "active").toLowerCase();
    if (status !== "active") {
      throw buildX402WalletPolicyError("X402_WALLET_POLICY_DISABLED", "x402 wallet policy is disabled");
    }

    const maxAmountCents = Number.isSafeInteger(policy.maxAmountCents) && policy.maxAmountCents >= 0 ? policy.maxAmountCents : null;
    if (maxAmountCents !== null && Number(amountCents) > maxAmountCents) {
      throw buildX402WalletPolicyError(
        "X402_WALLET_POLICY_AMOUNT_LIMIT_EXCEEDED",
        "x402 wallet policy maxAmountCents exceeded",
        { amountCents, maxAmountCents }
      );
    }

    const policySponsorWalletRef =
      typeof policy.sponsorWalletRef === "string" && policy.sponsorWalletRef.trim() !== "" ? policy.sponsorWalletRef.trim() : null;
    const maxDailyAuthorizationCents =
      Number.isSafeInteger(policy.maxDailyAuthorizationCents) && policy.maxDailyAuthorizationCents >= 0
        ? policy.maxDailyAuthorizationCents
        : null;
    if (
      maxDailyAuthorizationCents !== null &&
      policySponsorWalletRef
    ) {
      const dayKey = String(nowAt).slice(0, 10);
      const currentExposureCents = computeX402DailyAuthorizedExposureCents({
        tenantId,
        dayKey,
        excludeGateId: gate?.gateId ?? null,
        sponsorWalletRef: policySponsorWalletRef
      });
      const projectedExposureCents = currentExposureCents + Number(amountCents);
      if (projectedExposureCents > maxDailyAuthorizationCents) {
        throw buildX402WalletPolicyError(
          "X402_WALLET_POLICY_DAILY_LIMIT_EXCEEDED",
          "x402 wallet policy maxDailyAuthorizationCents exceeded",
          {
            sponsorWalletRef: policySponsorWalletRef,
            dayKey,
            amountCents,
            currentExposureCents,
            projectedExposureCents,
            maxDailyAuthorizationCents
          }
        );
      }
    }

    if (Array.isArray(policy.allowedProviderIds) && policy.allowedProviderIds.length > 0) {
      if (!policy.allowedProviderIds.includes(String(payeeProviderId ?? ""))) {
        throw buildX402WalletPolicyError(
          "X402_WALLET_POLICY_PROVIDER_NOT_ALLOWED",
          "x402 wallet policy provider is not allowed",
          { payeeProviderId: payeeProviderId ?? null, allowedProviderIds: policy.allowedProviderIds }
        );
      }
    }

    const toolId =
      typeof gate?.toolId === "string" && gate.toolId.trim() !== ""
        ? gate.toolId.trim()
        : typeof gate?.terms?.toolId === "string" && gate.terms.toolId.trim() !== ""
          ? gate.terms.toolId.trim()
          : null;
    if (Array.isArray(policy.allowedToolIds) && policy.allowedToolIds.length > 0) {
      if (!toolId || !policy.allowedToolIds.includes(toolId)) {
        throw buildX402WalletPolicyError(
          "X402_WALLET_POLICY_TOOL_NOT_ALLOWED",
          "x402 wallet policy tool is not allowed",
          { toolId, allowedToolIds: policy.allowedToolIds }
        );
      }
    }

    const gateAgentKeyId =
      gate?.agentPassport && typeof gate.agentPassport === "object" && !Array.isArray(gate.agentPassport)
        ? typeof gate.agentPassport.agentKeyId === "string" && gate.agentPassport.agentKeyId.trim() !== ""
          ? gate.agentPassport.agentKeyId.trim()
          : null
        : null;
    if (Array.isArray(policy.allowedAgentKeyIds) && policy.allowedAgentKeyIds.length > 0) {
      if (!gateAgentKeyId || !policy.allowedAgentKeyIds.includes(gateAgentKeyId)) {
        throw buildX402WalletPolicyError(
          "X402_WALLET_POLICY_AGENT_KEY_NOT_ALLOWED",
          "x402 wallet policy agent key is not allowed",
          { agentKeyId: gateAgentKeyId, allowedAgentKeyIds: policy.allowedAgentKeyIds }
        );
      }
    }

    if (Array.isArray(policy.allowedCurrencies) && policy.allowedCurrencies.length > 0) {
      const normalizedCurrency = String(currency ?? "").toUpperCase();
      if (!policy.allowedCurrencies.includes(normalizedCurrency)) {
        throw buildX402WalletPolicyError(
          "X402_WALLET_POLICY_CURRENCY_NOT_ALLOWED",
          "x402 wallet policy currency is not allowed",
          { currency: normalizedCurrency, allowedCurrencies: policy.allowedCurrencies }
        );
      }
    }

    if (policy.requireQuote === true && !effectiveQuoteId) {
      throw buildX402WalletPolicyError(
        "X402_WALLET_POLICY_QUOTE_REQUIRED",
        "x402 wallet policy requires quote-bound authorization"
      );
    }
    if (
      policy.requireStrictRequestBinding === true &&
      (effectiveRequestBindingMode !== "strict" || !effectiveRequestBindingSha256)
    ) {
      throw buildX402WalletPolicyError(
        "X402_WALLET_POLICY_REQUEST_BINDING_REQUIRED",
        "x402 wallet policy requires strict request binding"
      );
    }
    if (policy.requireAgentKeyMatch === true) {
      const payerAgentId = typeof gate?.payerAgentId === "string" && gate.payerAgentId.trim() !== "" ? gate.payerAgentId.trim() : null;
      if (!payerAgentId) {
        throw buildX402WalletPolicyError("X402_WALLET_POLICY_AGENT_KEY_MISMATCH", "x402 wallet policy agent key does not match payer key");
      }
      const payerIdentity = await getAgentIdentityRecord({ tenantId, agentId: payerAgentId });
      const payerKeyId =
        payerIdentity?.keys && typeof payerIdentity.keys === "object" && !Array.isArray(payerIdentity.keys)
          ? String(payerIdentity.keys.keyId ?? "").trim()
          : "";
      if (!gateAgentKeyId || !payerKeyId || gateAgentKeyId !== payerKeyId) {
        throw buildX402WalletPolicyError(
          "X402_WALLET_POLICY_AGENT_KEY_MISMATCH",
          "x402 wallet policy agent key does not match payer key",
          { agentKeyId: gateAgentKeyId, payerKeyId: payerKeyId || null }
        );
      }
    }
  }

  async function resolveX402WalletPolicyForPassport({ tenantId, gateAgentPassport }) {
    const sponsorWalletRef =
      typeof gateAgentPassport?.sponsorWalletRef === "string" && gateAgentPassport.sponsorWalletRef.trim() !== ""
        ? gateAgentPassport.sponsorWalletRef.trim()
        : null;
    const policyRef =
      typeof gateAgentPassport?.policyRef === "string" && gateAgentPassport.policyRef.trim() !== ""
        ? gateAgentPassport.policyRef.trim()
        : null;
    const policyVersion =
      Number.isSafeInteger(Number(gateAgentPassport?.policyVersion)) && Number(gateAgentPassport.policyVersion) > 0
        ? Number(gateAgentPassport.policyVersion)
        : null;
    if (!sponsorWalletRef && !policyRef && !policyVersion) return { policy: null, sponsorWalletRef: null };
    if (!sponsorWalletRef || !policyRef || !policyVersion) {
      return {
        policy: null,
        sponsorWalletRef,
        error: {
          code: "X402_WALLET_POLICY_REFERENCE_INVALID",
          message: "agentPassport must include sponsorWalletRef + policyRef + policyVersion"
        }
      };
    }
    const policy = await getX402WalletPolicyRecord({ tenantId, sponsorWalletRef, policyRef, policyVersion });
    if (!policy) {
      return {
        policy: null,
        sponsorWalletRef,
        error: {
          code: "X402_WALLET_POLICY_NOT_FOUND",
          message: "x402 wallet policy not found for agent passport"
        }
      };
    }
    return { policy, sponsorWalletRef };
  }

  function tenantSettlementPolicyStoreKey({ tenantId, policyId, policyVersion }) {
    return makeScopedKey({
      tenantId: normalizeTenant(tenantId),
      id: `${parseSettlementPolicyRegistryId(policyId, { fieldPath: "policyId" })}::${parseSettlementPolicyVersion(policyVersion, {
        fieldPath: "policyVersion"
      })}`
    });
  }

  function parseSettlementPolicyRefInput(input, { fieldPath = "policyRef", allowNull = true } = {}) {
    if (input === null || input === undefined) {
      if (allowNull) return null;
      throw new TypeError(`${fieldPath} is required`);
    }
    if (typeof input !== "object" || Array.isArray(input)) {
      throw new TypeError(`${fieldPath} must be an object`);
    }
    const source =
      typeof input.source === "string" && input.source.trim() !== "" ? String(input.source).trim().toLowerCase() : "tenant_registry";
    if (source !== "tenant_registry" && source !== "inline") {
      throw new TypeError(`${fieldPath}.source must be tenant_registry|inline`);
    }
    const policyId = parseSettlementPolicyRegistryId(input.policyId, {
      fieldPath: `${fieldPath}.policyId`,
      allowNull: source === "inline"
    });
    const policyVersion = parseSettlementPolicyVersion(input.policyVersion, { fieldPath: `${fieldPath}.policyVersion` });
    return {
      schemaVersion: MARKETPLACE_POLICY_REF_SCHEMA_VERSION,
      source,
      policyId,
      policyVersion,
      policyHash: normalizeOptionalHashInput(input.policyHash, `${fieldPath}.policyHash`),
      verificationMethodHash: normalizeOptionalHashInput(input.verificationMethodHash, `${fieldPath}.verificationMethodHash`)
    };
  }

  function listTenantSettlementPolicyRecords({
    tenantId,
    policyId = null
  } = {}) {
    const t = normalizeTenant(tenantId);
    const policyIdFilter =
      policyId === null || policyId === undefined || String(policyId).trim() === ""
        ? null
        : parseSettlementPolicyRegistryId(policyId, { fieldPath: "policyId" });
    const rows = [];
    if (!(store.tenantSettlementPolicies instanceof Map)) return rows;
    for (const row of store.tenantSettlementPolicies.values()) {
      if (!row || typeof row !== "object") continue;
      const rowTenant = normalizeTenant(row.tenantId ?? DEFAULT_TENANT_ID);
      if (rowTenant !== t) continue;
      if (policyIdFilter && String(row.policyId ?? "") !== policyIdFilter) continue;
      rows.push(row);
    }
    rows.sort((left, right) => {
      const leftAt = Date.parse(String(left.updatedAt ?? ""));
      const rightAt = Date.parse(String(right.updatedAt ?? ""));
      if (Number.isFinite(leftAt) && Number.isFinite(rightAt) && rightAt !== leftAt) return rightAt - leftAt;
      const policyIdOrder = String(left.policyId ?? "").localeCompare(String(right.policyId ?? ""));
      if (policyIdOrder !== 0) return policyIdOrder;
      return Number(right.policyVersion ?? 0) - Number(left.policyVersion ?? 0);
    });
    return rows;
  }

  function getTenantSettlementPolicyRecord({ tenantId, policyId, policyVersion }) {
    if (!(store.tenantSettlementPolicies instanceof Map)) return null;
    return store.tenantSettlementPolicies.get(tenantSettlementPolicyStoreKey({ tenantId, policyId, policyVersion })) ?? null;
  }

  function tenantSettlementPolicyRolloutStoreKey({ tenantId }) {
    return makeScopedKey({ tenantId: normalizeTenant(tenantId), id: "rollout" });
  }

  function parseTenantSettlementPolicyRefInput(input, { fieldPath = "policyRef", allowNull = false } = {}) {
    if (input === null || input === undefined || input === "") {
      if (allowNull) return null;
      throw new TypeError(`${fieldPath} is required`);
    }
    if (typeof input !== "object" || Array.isArray(input)) {
      throw new TypeError(`${fieldPath} must be an object`);
    }
    const policyId = parseSettlementPolicyRegistryId(input.policyId, { fieldPath: `${fieldPath}.policyId` });
    const policyVersion = parseSettlementPolicyVersion(input.policyVersion, { fieldPath: `${fieldPath}.policyVersion` });
    return { policyId, policyVersion };
  }

  function cloneTenantSettlementPolicyRef(ref) {
    if (!ref || typeof ref !== "object" || Array.isArray(ref)) return null;
    const parsed = parseTenantSettlementPolicyRefInput(ref, { allowNull: true });
    if (!parsed) return null;
    return normalizeForCanonicalJson(
      {
        schemaVersion: MARKETPLACE_POLICY_REF_SCHEMA_VERSION,
        source: "tenant_registry",
        policyId: parsed.policyId,
        policyVersion: parsed.policyVersion,
        policyHash:
          typeof ref.policyHash === "string" && ref.policyHash.trim() !== ""
            ? String(ref.policyHash).trim().toLowerCase()
            : null,
        verificationMethodHash:
          typeof ref.verificationMethodHash === "string" && ref.verificationMethodHash.trim() !== ""
            ? String(ref.verificationMethodHash).trim().toLowerCase()
            : null
      },
      { path: "$" }
    );
  }

  function normalizeTenantSettlementPolicyRef(record) {
    if (!record || typeof record !== "object" || Array.isArray(record)) return null;
    const policyId = parseSettlementPolicyRegistryId(record.policyId, { fieldPath: "policyId" });
    const policyVersion = parseSettlementPolicyVersion(record.policyVersion, { fieldPath: "policyVersion" });
    return normalizeForCanonicalJson(
      {
        schemaVersion: MARKETPLACE_POLICY_REF_SCHEMA_VERSION,
        source: "tenant_registry",
        policyId,
        policyVersion,
        policyHash: normalizeOptionalHashInput(record.policyHash, "policyHash"),
        verificationMethodHash: normalizeOptionalHashInput(record.verificationMethodHash, "verificationMethodHash")
      },
      { path: "$" }
    );
  }

  function settlementPolicyRefEquals(a, b) {
    const left = cloneTenantSettlementPolicyRef(a);
    const right = cloneTenantSettlementPolicyRef(b);
    if (!left && !right) return true;
    if (!left || !right) return false;
    return String(left.policyId) === String(right.policyId) && Number(left.policyVersion) === Number(right.policyVersion);
  }

  function parseSettlementPolicyRolloutStage(rawValue, { fieldPath = "stage", allowNull = false } = {}) {
    if (rawValue === null || rawValue === undefined || String(rawValue).trim() === "") {
      if (allowNull) return null;
      throw new TypeError(`${fieldPath} is required`);
    }
    const value = String(rawValue).trim().toLowerCase();
    if (
      value !== SETTLEMENT_POLICY_ROLLOUT_STAGE.DRAFT &&
      value !== SETTLEMENT_POLICY_ROLLOUT_STAGE.CANARY &&
      value !== SETTLEMENT_POLICY_ROLLOUT_STAGE.ACTIVE
    ) {
      throw new TypeError(`${fieldPath} must be draft|canary|active`);
    }
    return value;
  }

  function parseSettlementPolicyRolloutPercent(rawValue, { fieldPath = "rolloutPercent", allowNull = false } = {}) {
    if (rawValue === null || rawValue === undefined || rawValue === "") {
      if (allowNull) return null;
      throw new TypeError(`${fieldPath} is required`);
    }
    const value = Number(rawValue);
    if (!Number.isSafeInteger(value) || value < 1 || value > 100) {
      throw new TypeError(`${fieldPath} must be an integer in range 1..100`);
    }
    return value;
  }

  function normalizeSettlementPolicyRolloutNote(rawValue) {
    if (rawValue === null || rawValue === undefined) return null;
    const value = String(rawValue).trim();
    if (!value) return null;
    return value.slice(0, 500);
  }

  function flattenSettlementPolicyDiffObject(value, { pathPrefix = "", out = new Map() } = {}) {
    if (value === null || value === undefined) {
      out.set(pathPrefix || "$", null);
      return out;
    }
    if (Array.isArray(value)) {
      out.set(pathPrefix || "$", value);
      return out;
    }
    if (typeof value !== "object") {
      out.set(pathPrefix || "$", value);
      return out;
    }
    const keys = Object.keys(value).sort((a, b) => String(a).localeCompare(String(b)));
    if (!keys.length) {
      out.set(pathPrefix || "$", {});
      return out;
    }
    for (const key of keys) {
      const nextPath = pathPrefix ? `${pathPrefix}.${key}` : key;
      flattenSettlementPolicyDiffObject(value[key], { pathPrefix: nextPath, out });
    }
    return out;
  }

  function buildTenantSettlementPolicyDiff({ fromPolicy, toPolicy, includeUnchanged = false, limit = 200 } = {}) {
    const left = fromPolicy && typeof fromPolicy === "object" && !Array.isArray(fromPolicy) ? fromPolicy : {};
    const right = toPolicy && typeof toPolicy === "object" && !Array.isArray(toPolicy) ? toPolicy : {};
    const leftMap = flattenSettlementPolicyDiffObject(left);
    const rightMap = flattenSettlementPolicyDiffObject(right);
    const paths = [...new Set([...leftMap.keys(), ...rightMap.keys()])].sort((a, b) => String(a).localeCompare(String(b)));
    const changes = [];
    let changed = 0;
    let added = 0;
    let removed = 0;
    let unchanged = 0;

    for (const pathName of paths) {
      const hasBefore = leftMap.has(pathName);
      const hasAfter = rightMap.has(pathName);
      const fromValue = hasBefore ? leftMap.get(pathName) : null;
      const toValue = hasAfter ? rightMap.get(pathName) : null;
      const equal = hasBefore === hasAfter && JSON.stringify(fromValue) === JSON.stringify(toValue);
      if (equal) {
        unchanged += 1;
        if (!includeUnchanged) continue;
        changes.push({ path: pathName, kind: "unchanged", fromValue, toValue });
        continue;
      }
      if (!hasBefore && hasAfter) {
        added += 1;
        changes.push({ path: pathName, kind: "added", fromValue: null, toValue });
        continue;
      }
      if (hasBefore && !hasAfter) {
        removed += 1;
        changes.push({ path: pathName, kind: "removed", fromValue, toValue: null });
        continue;
      }
      changed += 1;
      changes.push({ path: pathName, kind: "changed", fromValue, toValue });
    }

    const safeLimit = Number.isSafeInteger(limit) && limit > 0 ? Math.min(2000, limit) : 200;
    return {
      summary: {
        totalPaths: paths.length,
        changed,
        added,
        removed,
        unchanged,
        includeUnchanged: Boolean(includeUnchanged)
      },
      changes: changes.slice(0, safeLimit),
      limited: changes.length > safeLimit
    };
  }

  function deriveTenantSettlementPolicyActiveFallbackRef({ tenantId }) {
    const policies = listTenantSettlementPolicyRecords({ tenantId });
    if (!policies.length) return null;
    return normalizeTenantSettlementPolicyRef(policies[0]);
  }

  function getTenantSettlementPolicyRolloutRecord({ tenantId }) {
    if (!(store.tenantSettlementPolicyRollouts instanceof Map)) return null;
    return store.tenantSettlementPolicyRollouts.get(tenantSettlementPolicyRolloutStoreKey({ tenantId })) ?? null;
  }

  function defaultTenantSettlementPolicyRollout({ activePolicyRef = null } = {}) {
    return {
      schemaVersion: TENANT_SETTLEMENT_POLICY_ROLLOUT_SCHEMA_VERSION,
      stages: {
        draft: null,
        canary: { policyRef: null, rolloutPercent: 0 },
        active: cloneTenantSettlementPolicyRef(activePolicyRef)
      },
      history: []
    };
  }

  function normalizeTenantSettlementPolicyRollout({ tenantId, rollout, activeFallbackRef = null } = {}) {
    const fallbackRef = cloneTenantSettlementPolicyRef(activeFallbackRef ?? deriveTenantSettlementPolicyActiveFallbackRef({ tenantId }));
    const out = defaultTenantSettlementPolicyRollout({ activePolicyRef: fallbackRef });
    const source = rollout && typeof rollout === "object" && !Array.isArray(rollout) ? rollout : {};
    const stages = source.stages && typeof source.stages === "object" && !Array.isArray(source.stages) ? source.stages : {};

    const resolveRef = (ref) => {
      const parsed = parseTenantSettlementPolicyRefInput(ref, { allowNull: true });
      if (!parsed) return null;
      const row = getTenantSettlementPolicyRecord({
        tenantId,
        policyId: parsed.policyId,
        policyVersion: parsed.policyVersion
      });
      return row ? normalizeTenantSettlementPolicyRef(row) : null;
    };

    out.stages.draft = resolveRef(stages.draft);
    const canarySource = stages.canary && typeof stages.canary === "object" && !Array.isArray(stages.canary) ? stages.canary : {};
    const canaryRef = resolveRef(canarySource.policyRef ?? null);
    let canaryPercent = 0;
    try {
      canaryPercent = parseSettlementPolicyRolloutPercent(canarySource.rolloutPercent, { allowNull: true }) ?? 0;
    } catch {
      canaryPercent = 0;
    }
    out.stages.canary = {
      policyRef: canaryRef,
      rolloutPercent: canaryRef ? Math.max(1, canaryPercent || 10) : 0
    };

    out.stages.active = resolveRef(stages.active ?? fallbackRef);
    if (!out.stages.active && fallbackRef) {
      out.stages.active = resolveRef(fallbackRef);
    }

    const rows = Array.isArray(source.history) ? source.history : [];
    const normalizedHistory = [];
    for (const row of rows) {
      if (!row || typeof row !== "object" || Array.isArray(row)) continue;
      let stage = null;
      try {
        stage = parseSettlementPolicyRolloutStage(row.stage, { allowNull: true });
      } catch {
        stage = null;
      }
      let rolloutPercent = null;
      try {
        rolloutPercent = parseSettlementPolicyRolloutPercent(row.rolloutPercent, { allowNull: true });
      } catch {
        rolloutPercent = null;
      }
      const at = typeof row.at === "string" && Number.isFinite(Date.parse(row.at)) ? row.at : nowIso();
      const action = typeof row.action === "string" && row.action.trim() !== "" ? row.action.trim().slice(0, 80) : "update";
      const note = normalizeSettlementPolicyRolloutNote(row.note);
      const actorPrincipalId =
        typeof row.actorPrincipalId === "string" && row.actorPrincipalId.trim() !== ""
          ? row.actorPrincipalId.trim().slice(0, 160)
          : null;
      normalizedHistory.push({
        at,
        action,
        stage,
        fromPolicyRef: cloneTenantSettlementPolicyRef(row.fromPolicyRef ?? null),
        toPolicyRef: cloneTenantSettlementPolicyRef(row.toPolicyRef ?? null),
        rolloutPercent,
        note,
        actorPrincipalId
      });
    }
    out.history = normalizedHistory.slice(-SETTLEMENT_POLICY_ROLLOUT_HISTORY_LIMIT);
    return out;
  }

  function appendTenantSettlementPolicyRolloutHistory({ rollout, entry }) {
    if (!rollout || typeof rollout !== "object" || Array.isArray(rollout)) return;
    if (!Array.isArray(rollout.history)) rollout.history = [];
    let stage = null;
    try {
      stage = parseSettlementPolicyRolloutStage(entry?.stage ?? null, { allowNull: true });
    } catch {
      stage = null;
    }
    let rolloutPercent = null;
    try {
      rolloutPercent = parseSettlementPolicyRolloutPercent(entry?.rolloutPercent ?? null, { allowNull: true });
    } catch {
      rolloutPercent = null;
    }
    rollout.history.push({
      at: typeof entry?.at === "string" && Number.isFinite(Date.parse(entry.at)) ? entry.at : nowIso(),
      action:
        typeof entry?.action === "string" && entry.action.trim() !== ""
          ? entry.action.trim().slice(0, 80)
          : "update",
      stage,
      fromPolicyRef: cloneTenantSettlementPolicyRef(entry?.fromPolicyRef ?? null),
      toPolicyRef: cloneTenantSettlementPolicyRef(entry?.toPolicyRef ?? null),
      rolloutPercent,
      note: normalizeSettlementPolicyRolloutNote(entry?.note),
      actorPrincipalId:
        typeof entry?.actorPrincipalId === "string" && entry.actorPrincipalId.trim() !== ""
          ? entry.actorPrincipalId.trim().slice(0, 160)
          : null
    });
    if (rollout.history.length > SETTLEMENT_POLICY_ROLLOUT_HISTORY_LIMIT) {
      rollout.history = rollout.history.slice(-SETTLEMENT_POLICY_ROLLOUT_HISTORY_LIMIT);
    }
  }

  function findTenantSettlementPolicyRollbackTargetRef({ rollout, currentActiveRef }) {
    const rows = Array.isArray(rollout?.history) ? [...rollout.history] : [];
    for (let idx = rows.length - 1; idx >= 0; idx -= 1) {
      const row = rows[idx];
      if (!row || row.stage !== SETTLEMENT_POLICY_ROLLOUT_STAGE.ACTIVE) continue;
      const fromRef = cloneTenantSettlementPolicyRef(row.fromPolicyRef ?? null);
      if (!fromRef) continue;
      if (settlementPolicyRefEquals(fromRef, currentActiveRef)) continue;
      return fromRef;
    }
    return null;
  }

  function selectTenantSettlementPolicyControlPlaneState({ tenantId, policyId = null } = {}) {
    const policies = listTenantSettlementPolicyRecords({ tenantId, policyId });
    const allPolicies = listTenantSettlementPolicyRecords({ tenantId });
    const policyIds = [...new Set(allPolicies.map((row) => String(row.policyId ?? "")))]
      .filter(Boolean)
      .sort((a, b) => String(a).localeCompare(String(b)));
    const fallbackRef = deriveTenantSettlementPolicyActiveFallbackRef({ tenantId });
    const rollout = normalizeTenantSettlementPolicyRollout({
      tenantId,
      rollout: getTenantSettlementPolicyRolloutRecord({ tenantId }),
      activeFallbackRef: fallbackRef
    });
    const activePolicy = rollout.stages.active
      ? getTenantSettlementPolicyRecord({
          tenantId,
          policyId: rollout.stages.active.policyId,
          policyVersion: rollout.stages.active.policyVersion
        })
      : null;
    const draftPolicy = rollout.stages.draft
      ? getTenantSettlementPolicyRecord({
          tenantId,
          policyId: rollout.stages.draft.policyId,
          policyVersion: rollout.stages.draft.policyVersion
        })
      : null;
    const canaryPolicy = rollout.stages.canary?.policyRef
      ? getTenantSettlementPolicyRecord({
          tenantId,
          policyId: rollout.stages.canary.policyRef.policyId,
          policyVersion: rollout.stages.canary.policyRef.policyVersion
        })
      : null;
    return {
      tenantId,
      policyIds,
      policies,
      rollout,
      defaultPolicyRef: rollout.stages.active ?? fallbackRef ?? null,
      rolloutStagePolicies: {
        draft: draftPolicy ?? null,
        canary: canaryPolicy ?? null,
        active: activePolicy ?? null
      },
      rolloutHistory: Array.isArray(rollout.history) ? rollout.history.slice(-50).reverse() : []
    };
  }

  function resolveMarketplaceSettlementPolicySelection({
    tenantId,
    policyRefInput = null,
    verificationMethodInput = undefined,
    settlementPolicyInput = undefined,
    fallbackVerificationMethodInput = undefined,
    fallbackSettlementPolicyInput = undefined
  } = {}) {
    const parsedRef = parseSettlementPolicyRefInput(policyRefInput, { allowNull: true });
    let explicitVerificationMethod = undefined;
    if (verificationMethodInput !== undefined) {
      try {
        explicitVerificationMethod = parseVerificationMethodInput(verificationMethodInput ?? null);
      } catch (err) {
        err.code = err?.code ?? "INVALID_VERIFICATION_METHOD";
        throw err;
      }
    }
    let explicitPolicy = undefined;
    if (settlementPolicyInput !== undefined) {
      try {
        explicitPolicy = parseSettlementPolicyInput(settlementPolicyInput ?? null);
      } catch (err) {
        err.code = err?.code ?? "INVALID_SETTLEMENT_POLICY";
        throw err;
      }
    }

    if (parsedRef && parsedRef.source === "tenant_registry") {
      const policyRecord = getTenantSettlementPolicyRecord({
        tenantId,
        policyId: parsedRef.policyId,
        policyVersion: parsedRef.policyVersion
      });
      if (!policyRecord) {
        const err = new Error("policyRef not found in tenant settlement policy registry");
        err.code = "TENANT_SETTLEMENT_POLICY_NOT_FOUND";
        throw err;
      }
      if (parsedRef.policyHash && parsedRef.policyHash !== String(policyRecord.policyHash ?? "").toLowerCase()) {
        const err = new Error("policyRef.policyHash does not match tenant registry");
        err.code = "TENANT_SETTLEMENT_POLICY_REF_MISMATCH";
        throw err;
      }
      if (
        parsedRef.verificationMethodHash &&
        parsedRef.verificationMethodHash !== String(policyRecord.verificationMethodHash ?? "").toLowerCase()
      ) {
        const err = new Error("policyRef.verificationMethodHash does not match tenant registry");
        err.code = "TENANT_SETTLEMENT_POLICY_REF_MISMATCH";
        throw err;
      }
      if (explicitPolicy && explicitPolicy.policyHash !== policyRecord.policyHash) {
        const err = new Error("policy payload does not match policyRef");
        err.code = "TENANT_SETTLEMENT_POLICY_REF_MISMATCH";
        throw err;
      }
      if (explicitVerificationMethod && computeVerificationMethodHash(explicitVerificationMethod) !== policyRecord.verificationMethodHash) {
        const err = new Error("verificationMethod payload does not match policyRef");
        err.code = "TENANT_SETTLEMENT_POLICY_REF_MISMATCH";
        throw err;
      }
      return {
        verificationMethod: policyRecord.verificationMethod,
        policy: policyRecord.policy,
        policyRef: normalizeForCanonicalJson(
          {
            schemaVersion: MARKETPLACE_POLICY_REF_SCHEMA_VERSION,
            source: "tenant_registry",
            policyId: policyRecord.policyId,
            policyVersion: policyRecord.policyVersion,
            policyHash: policyRecord.policyHash,
            verificationMethodHash: policyRecord.verificationMethodHash
          },
          { path: "$" }
        )
      };
    }

    let verificationMethod = explicitVerificationMethod;
    if (verificationMethod === undefined) {
      try {
        verificationMethod =
          fallbackVerificationMethodInput !== undefined
            ? parseVerificationMethodInput(fallbackVerificationMethodInput ?? null)
            : parseVerificationMethodInput(null);
      } catch (err) {
        err.code = err?.code ?? "INVALID_VERIFICATION_METHOD";
        throw err;
      }
    }
    let policy = explicitPolicy;
    if (policy === undefined) {
      try {
        policy =
          fallbackSettlementPolicyInput !== undefined
            ? parseSettlementPolicyInput(fallbackSettlementPolicyInput ?? null)
            : parseSettlementPolicyInput(null);
      } catch (err) {
        err.code = err?.code ?? "INVALID_SETTLEMENT_POLICY";
        throw err;
      }
    }
    const verificationMethodHash = computeVerificationMethodHash(verificationMethod);
    const policyRef = normalizeForCanonicalJson(
      {
        schemaVersion: MARKETPLACE_POLICY_REF_SCHEMA_VERSION,
        source: "inline",
        policyId: null,
        policyVersion: Number(policy.policyVersion ?? 1),
        policyHash: policy.policyHash,
        verificationMethodHash
      },
      { path: "$" }
    );
    return { verificationMethod, policy, policyRef };
  }

  function resolveAgreementPolicyMaterial({ tenantId, agreement }) {
    const agreementObj = agreement && typeof agreement === "object" && !Array.isArray(agreement) ? agreement : null;
    let policyRef = null;
    if (agreementObj?.policyRef && typeof agreementObj.policyRef === "object" && !Array.isArray(agreementObj.policyRef)) {
      try {
        policyRef = parseSettlementPolicyRefInput(agreementObj.policyRef, { allowNull: true });
      } catch {
        policyRef = null;
      }
    }
    let policy =
      agreementObj?.policy && typeof agreementObj.policy === "object" && !Array.isArray(agreementObj.policy) ? agreementObj.policy : null;
    let verificationMethod =
      agreementObj?.verificationMethod && typeof agreementObj.verificationMethod === "object" && !Array.isArray(agreementObj.verificationMethod)
        ? agreementObj.verificationMethod
        : null;

    if ((!policy || !verificationMethod) && policyRef?.source === "tenant_registry" && policyRef.policyId) {
      const registryRecord = getTenantSettlementPolicyRecord({
        tenantId,
        policyId: policyRef.policyId,
        policyVersion: policyRef.policyVersion
      });
      if (registryRecord) {
        if (!policy) policy = registryRecord.policy;
        if (!verificationMethod) verificationMethod = registryRecord.verificationMethod;
      }
    }

    const policyHash =
      agreementObj?.policyHash ??
      (policy && typeof policy.policyHash === "string" ? policy.policyHash : null) ??
      policyRef?.policyHash ??
      null;
    const verificationMethodHash =
      agreementObj?.verificationMethodHash ??
      (verificationMethod ? computeVerificationMethodHash(verificationMethod) : null) ??
      policyRef?.verificationMethodHash ??
      null;
    const policyVersion =
      (policy && Number.isSafeInteger(Number(policy.policyVersion)) ? Number(policy.policyVersion) : null) ??
      (policyRef && Number.isSafeInteger(Number(policyRef.policyVersion)) ? Number(policyRef.policyVersion) : null);
    return {
      policy,
      verificationMethod,
      policyRef,
      policyHash,
      verificationMethodHash,
      policyVersion
    };
  }

  function resolveAgreementVerifierRef(verificationMethod) {
    return resolveSettlementVerifierRef({ verificationMethod: verificationMethod ?? null });
  }

  function evaluateRunSettlementVerifierExecution({ verificationMethod, run, verification }) {
    const baseVerificationStatus = run?.status === "failed" ? "red" : verification?.verificationStatus;
    return evaluateSettlementVerifierExecution({
      verificationMethod: verificationMethod ?? null,
      run: run ?? null,
      verification: verification ?? null,
      baseVerificationStatus
    });
  }

  function parsePagination({ limitRaw, offsetRaw, defaultLimit = 50, maxLimit = 200 } = {}) {
    const limit = limitRaw === null || limitRaw === undefined || String(limitRaw).trim() === "" ? defaultLimit : Number(limitRaw);
    const offset = offsetRaw === null || offsetRaw === undefined || String(offsetRaw).trim() === "" ? 0 : Number(offsetRaw);
    const safeLimit = Number.isSafeInteger(limit) && limit > 0 ? Math.min(maxLimit, limit) : defaultLimit;
    const safeOffset = Number.isSafeInteger(offset) && offset >= 0 ? offset : 0;
    return { limit: safeLimit, offset: safeOffset };
  }

  function parseMarketplaceCapabilityListingId(rawValue, { fieldPath = "listingId", allowNull = false } = {}) {
    if (rawValue === null || rawValue === undefined || String(rawValue).trim() === "") {
      if (allowNull) return null;
      throw new TypeError(`${fieldPath} is required`);
    }
    const value = String(rawValue).trim();
    if (value.length > 128) throw new TypeError(`${fieldPath} must be <= 128 chars`);
    if (!/^[A-Za-z0-9._:-]+$/.test(value)) throw new TypeError(`${fieldPath} must match [A-Za-z0-9._:-]+`);
    return value;
  }

  function normalizeMarketplaceCapabilityTagsInput(rawValue, { fieldPath = "tags" } = {}) {
    if (rawValue === undefined || rawValue === null) return [];
    if (!Array.isArray(rawValue)) throw new TypeError(`${fieldPath} must be an array`);
    const out = [];
    for (const row of rawValue) {
      const value = String(row ?? "").trim();
      if (!value) continue;
      if (value.length > 64) throw new TypeError(`${fieldPath} entries must be <= 64 chars`);
      if (!out.includes(value)) out.push(value);
    }
    return out;
  }

  function normalizeMarketplaceCapabilityPriceModelInput(rawValue, { fieldPath = "priceModel" } = {}) {
    if (rawValue === undefined || rawValue === null) return null;
    if (typeof rawValue !== "object" || Array.isArray(rawValue)) throw new TypeError(`${fieldPath} must be an object`);
    const modeRaw = String(rawValue.mode ?? "fixed").trim().toLowerCase();
    const mode = modeRaw === "fixed" || modeRaw === "hourly" || modeRaw === "per_unit" || modeRaw === "quote" ? modeRaw : null;
    if (!mode) throw new TypeError(`${fieldPath}.mode must be fixed|hourly|per_unit|quote`);
    const amountRaw = rawValue.amountCents;
    let amountCents = null;
    if (amountRaw !== undefined && amountRaw !== null && String(amountRaw).trim() !== "") {
      const parsed = Number(amountRaw);
      if (!Number.isSafeInteger(parsed) || parsed <= 0) throw new TypeError(`${fieldPath}.amountCents must be a positive safe integer`);
      amountCents = parsed;
    }
    let minAmountCents = null;
    if (rawValue.minAmountCents !== undefined && rawValue.minAmountCents !== null && String(rawValue.minAmountCents).trim() !== "") {
      const parsed = Number(rawValue.minAmountCents);
      if (!Number.isSafeInteger(parsed) || parsed <= 0) throw new TypeError(`${fieldPath}.minAmountCents must be a positive safe integer`);
      minAmountCents = parsed;
    }
    let maxAmountCents = null;
    if (rawValue.maxAmountCents !== undefined && rawValue.maxAmountCents !== null && String(rawValue.maxAmountCents).trim() !== "") {
      const parsed = Number(rawValue.maxAmountCents);
      if (!Number.isSafeInteger(parsed) || parsed <= 0) throw new TypeError(`${fieldPath}.maxAmountCents must be a positive safe integer`);
      maxAmountCents = parsed;
    }
    if (minAmountCents !== null && maxAmountCents !== null && maxAmountCents < minAmountCents) {
      throw new TypeError(`${fieldPath}.maxAmountCents must be >= minAmountCents`);
    }
    const currency = rawValue.currency === undefined || rawValue.currency === null ? "USD" : String(rawValue.currency).trim().toUpperCase();
    if (!currency) throw new TypeError(`${fieldPath}.currency must be a non-empty string`);
    const unit = rawValue.unit === undefined || rawValue.unit === null ? null : String(rawValue.unit).trim() || null;
    if (unit && unit.length > 64) throw new TypeError(`${fieldPath}.unit must be <= 64 chars`);
    return {
      schemaVersion: "MarketplaceCapabilityPriceModel.v1",
      mode,
      amountCents,
      minAmountCents,
      maxAmountCents,
      currency,
      unit
    };
  }

  function getMarketplaceCapabilityListing({ tenantId, listingId } = {}) {
    if (!(store.marketplaceCapabilityListings instanceof Map)) return null;
    const id = String(listingId ?? "").trim();
    if (!id) return null;
    return store.marketplaceCapabilityListings.get(capabilityListingStoreKey(tenantId, id)) ?? null;
  }

  function listMarketplaceCapabilityListings({
    tenantId,
    status = "all",
    capability = null,
    sellerAgentId = null,
    search = null
  } = {}) {
    const t = normalizeTenant(tenantId);
    const statusFilter = parseMarketplaceCapabilityListingStatus(status, { allowAll: true, defaultStatus: "all" });
    const capabilityFilter = capability && String(capability).trim() !== "" ? String(capability).trim() : null;
    const sellerFilter = sellerAgentId && String(sellerAgentId).trim() !== "" ? String(sellerAgentId).trim() : null;
    const searchFilter = search && String(search).trim() !== "" ? String(search).trim().toLowerCase() : null;
    if (!(store.marketplaceCapabilityListings instanceof Map)) return [];

    const rows = [];
    for (const row of store.marketplaceCapabilityListings.values()) {
      if (!row || typeof row !== "object") continue;
      if (normalizeTenant(row.tenantId ?? DEFAULT_TENANT_ID) !== t) continue;
      const rowStatus = String(row.status ?? "active").toLowerCase();
      if (statusFilter !== "all" && rowStatus !== statusFilter) continue;
      if (capabilityFilter && String(row.capability ?? "") !== capabilityFilter) continue;
      if (sellerFilter && String(row.sellerAgentId ?? "") !== sellerFilter) continue;
      if (searchFilter) {
        const haystack = [
          row.listingId,
          row.capability,
          row.title,
          row.description,
          row.category,
          ...(Array.isArray(row.tags) ? row.tags : [])
        ]
          .map((value) => String(value ?? "").toLowerCase())
          .join(" ");
        if (!haystack.includes(searchFilter)) continue;
      }
      rows.push(row);
    }
    rows.sort((left, right) => {
      const leftAt = Date.parse(String(left.updatedAt ?? left.createdAt ?? ""));
      const rightAt = Date.parse(String(right.updatedAt ?? right.createdAt ?? ""));
      if (Number.isFinite(leftAt) && Number.isFinite(rightAt) && rightAt !== leftAt) return rightAt - leftAt;
      return String(left.listingId ?? "").localeCompare(String(right.listingId ?? ""));
    });
    return rows;
  }

  function getMarketplaceProviderPublication({ tenantId, providerId } = {}) {
    if (!(store.marketplaceProviderPublications instanceof Map)) return null;
    const id = String(providerId ?? "").trim();
    if (!id) return null;
    return store.marketplaceProviderPublications.get(providerPublicationStoreKey(tenantId, id)) ?? null;
  }

  function listMarketplaceProviderPublications({
    tenantId,
    status = "certified",
    providerId = null,
    search = null,
    toolId = null
  } = {}) {
    if (!(store.marketplaceProviderPublications instanceof Map)) return [];
    const t = normalizeTenant(tenantId);
    const statusFilter = parseMarketplaceProviderPublicationStatus(status, { allowAll: true, defaultStatus: "certified" });
    const providerFilter = providerId && String(providerId).trim() !== "" ? String(providerId).trim() : null;
    const searchFilter = search && String(search).trim() !== "" ? String(search).trim().toLowerCase() : null;
    const toolFilter = toolId && String(toolId).trim() !== "" ? String(toolId).trim() : null;

    const rows = [];
    for (const row of store.marketplaceProviderPublications.values()) {
      if (!row || typeof row !== "object") continue;
      if (normalizeTenant(row.tenantId ?? DEFAULT_TENANT_ID) !== t) continue;
      const rowStatus = String(row.status ?? "draft").toLowerCase();
      if (statusFilter !== "all" && rowStatus !== statusFilter) continue;
      if (providerFilter && String(row.providerId ?? "") !== providerFilter) continue;
      if (toolFilter) {
        const tools = Array.isArray(row?.manifest?.tools) ? row.manifest.tools : [];
        const hasTool = tools.some((tool) => String(tool?.toolId ?? "") === toolFilter);
        if (!hasTool) continue;
      }
      if (searchFilter) {
        const tools = Array.isArray(row?.manifest?.tools) ? row.manifest.tools : [];
        const haystack = [
          row.providerId,
          row.description,
          row.baseUrl,
          row.status,
          ...(Array.isArray(row.tags) ? row.tags : []),
          ...tools.map((tool) => `${tool?.toolId ?? ""} ${tool?.mcpToolName ?? ""} ${tool?.description ?? ""}`)
        ]
          .map((value) => String(value ?? "").toLowerCase())
          .join(" ");
        if (!haystack.includes(searchFilter)) continue;
      }
      rows.push(row);
    }

    rows.sort((left, right) => {
      const leftAt = Date.parse(String(left.updatedAt ?? left.publishedAt ?? ""));
      const rightAt = Date.parse(String(right.updatedAt ?? right.publishedAt ?? ""));
      if (Number.isFinite(leftAt) && Number.isFinite(rightAt) && rightAt !== leftAt) return rightAt - leftAt;
      return String(left.providerId ?? "").localeCompare(String(right.providerId ?? ""));
    });
    return rows;
  }

  function buildMarketplaceProviderCertificationBadge(publication) {
    if (!publication || typeof publication !== "object" || Array.isArray(publication)) return null;
    const toolCount = Array.isArray(publication?.manifest?.tools) ? publication.manifest.tools.length : 0;
    const conformance =
      publication?.conformanceReport && typeof publication.conformanceReport === "object" && !Array.isArray(publication.conformanceReport)
        ? {
            schemaVersion: publication.conformanceReport.schemaVersion ?? null,
            generatedAt: publication.conformanceReport.generatedAt ?? null,
            verdict: publication.conformanceReport.verdict ?? null
          }
        : null;
    const binding = normalizeForCanonicalJson(
      {
        schemaVersion: "MarketplaceProviderCertificationBadgeBinding.v1",
        providerId: publication.providerId ?? null,
        publicationId: publication.publicationId ?? null,
        status: publication.status ?? null,
        certified: publication.certified === true,
        certifiedAt: publication.certifiedAt ?? null,
        updatedAt: publication.updatedAt ?? null,
        manifestHash: publication.manifestHash ?? null,
        providerSigningKeyId: publication?.providerSigning?.keyId ?? null,
        toolCount,
        conformance
      },
      { path: "$" }
    );
    return {
      schemaVersion: "MarketplaceProviderCertificationBadge.v1",
      providerId: publication.providerId ?? null,
      publicationId: publication.publicationId ?? null,
      status: publication.status ?? null,
      certified: publication.certified === true,
      certifiedAt: publication.certifiedAt ?? null,
      updatedAt: publication.updatedAt ?? null,
      manifestHash: publication.manifestHash ?? null,
      providerSigningKeyId: publication?.providerSigning?.keyId ?? null,
      toolCount,
      conformance,
      badgeHash: sha256Hex(canonicalJsonStringify(binding))
    };
  }

  function listMarketplaceToolListings({
    tenantId,
    status = "certified",
    providerId = null,
    toolId = null,
    search = null,
    tags = null
  } = {}) {
    const rows = listMarketplaceProviderPublications({ tenantId, status, providerId, toolId: null, search: null });
    const toolFilter = toolId && String(toolId).trim() !== "" ? String(toolId).trim() : null;
    const searchFilter = search && String(search).trim() !== "" ? String(search).trim().toLowerCase() : null;
    const requiredTags =
      tags === null || tags === undefined
        ? []
        : String(tags)
            .split(",")
            .map((row) => row.trim())
            .filter(Boolean);

    const out = [];
    for (const row of rows) {
      const tools = Array.isArray(row?.manifest?.tools) ? row.manifest.tools : [];
      const defaults = row?.manifest?.defaults && typeof row.manifest.defaults === "object" && !Array.isArray(row.manifest.defaults)
        ? row.manifest.defaults
        : {};
      for (const tool of tools) {
        if (!tool || typeof tool !== "object" || Array.isArray(tool)) continue;
        const rowToolId = String(tool?.toolId ?? "").trim();
        if (!rowToolId) continue;
        if (toolFilter && rowToolId !== toolFilter) continue;
        const providerTags = Array.isArray(row.tags) ? row.tags.map((tag) => String(tag ?? "").trim()).filter(Boolean) : [];
        const toolTags = Array.isArray(tool.tags) ? tool.tags.map((tag) => String(tag ?? "").trim()).filter(Boolean) : [];
        const combinedTagSet = new Set([...providerTags, ...toolTags]);
        if (requiredTags.length > 0) {
          const hasAllTags = requiredTags.every((tag) => combinedTagSet.has(tag));
          if (!hasAllTags) continue;
        }
        const listing = {
          schemaVersion: "MarketplaceToolListing.v1",
          providerId: row.providerId ?? null,
          publicationId: row.publicationId ?? null,
          certified: row.certified === true,
          providerStatus: row.status ?? null,
          providerDescription: row.description ?? null,
          providerTags,
          manifestSchemaVersion: row.manifestSchemaVersion ?? null,
          manifestHash: row.manifestHash ?? null,
          toolId: rowToolId,
          mcpToolName: typeof tool?.mcpToolName === "string" && tool.mcpToolName.trim() !== "" ? tool.mcpToolName.trim() : null,
          description: typeof tool?.description === "string" && tool.description.trim() !== "" ? tool.description.trim() : null,
          method: typeof tool?.method === "string" && tool.method.trim() !== "" ? String(tool.method).toUpperCase() : null,
          paidPath: typeof tool?.paidPath === "string" && tool.paidPath.trim() !== "" ? tool.paidPath.trim() : null,
          upstreamPath: typeof tool?.upstreamPath === "string" && tool.upstreamPath.trim() !== "" ? tool.upstreamPath.trim() : null,
          tags: toolTags,
          pricing: {
            amountCents: Number.isSafeInteger(Number(tool?.pricing?.amountCents))
              ? Number(tool.pricing.amountCents)
              : Number.isSafeInteger(Number(defaults?.amountCents))
                ? Number(defaults.amountCents)
                : null,
            currency:
              typeof tool?.pricing?.currency === "string" && tool.pricing.currency.trim() !== ""
                ? String(tool.pricing.currency).trim().toUpperCase()
                : typeof defaults?.currency === "string" && defaults.currency.trim() !== ""
                  ? String(defaults.currency).trim().toUpperCase()
                  : null
          },
          idempotency:
            typeof tool?.idempotency === "string" && tool.idempotency.trim() !== ""
              ? tool.idempotency.trim()
              : typeof defaults?.idempotency === "string" && defaults.idempotency.trim() !== ""
                ? defaults.idempotency.trim()
                : null,
          signatureMode:
            typeof tool?.signatureMode === "string" && tool.signatureMode.trim() !== ""
              ? tool.signatureMode.trim()
              : typeof defaults?.signatureMode === "string" && defaults.signatureMode.trim() !== ""
                ? defaults.signatureMode.trim()
                : null,
          authMode:
            typeof tool?.auth?.mode === "string" && tool.auth.mode.trim() !== ""
              ? tool.auth.mode.trim()
              : null,
          certificationBadge: buildMarketplaceProviderCertificationBadge(row),
          publishedAt: row.publishedAt ?? null,
          updatedAt: row.updatedAt ?? null
        };
        if (searchFilter) {
          const haystack = [
            listing.providerId,
            listing.toolId,
            listing.mcpToolName,
            listing.description,
            listing.paidPath,
            listing.upstreamPath,
            ...(providerTags ?? []),
            ...(toolTags ?? [])
          ]
            .map((value) => String(value ?? "").toLowerCase())
            .join(" ");
          if (!haystack.includes(searchFilter)) continue;
        }
        out.push(listing);
      }
    }

    out.sort((left, right) => {
      const leftAt = Date.parse(String(left.updatedAt ?? left.publishedAt ?? ""));
      const rightAt = Date.parse(String(right.updatedAt ?? right.publishedAt ?? ""));
      if (Number.isFinite(leftAt) && Number.isFinite(rightAt) && rightAt !== leftAt) return rightAt - leftAt;
      const providerOrder = String(left.providerId ?? "").localeCompare(String(right.providerId ?? ""));
      if (providerOrder !== 0) return providerOrder;
      return String(left.toolId ?? "").localeCompare(String(right.toolId ?? ""));
    });
    return out;
  }

  function listMarketplaceRfqs({
    tenantId,
    status = "all",
    capability = null,
    posterAgentId = null
  } = {}) {
    const t = normalizeTenant(tenantId);
    const statusFilter = parseMarketplaceRfqStatus(status, { allowAll: true, defaultStatus: "all" });
    const capabilityFilter = capability && String(capability).trim() !== "" ? String(capability).trim() : null;
    const posterFilter = posterAgentId && String(posterAgentId).trim() !== "" ? String(posterAgentId).trim() : null;

    const rows = [];
    if (!(store.marketplaceRfqs instanceof Map)) return rows;
    for (const row of store.marketplaceRfqs.values()) {
      if (!row || typeof row !== "object") continue;
      const rowTenant = normalizeTenant(row.tenantId ?? DEFAULT_TENANT_ID);
      if (rowTenant !== t) continue;
      const rowStatus = String(row.status ?? "open").toLowerCase();
      if (statusFilter !== "all" && rowStatus !== statusFilter) continue;
      if (capabilityFilter && String(row.capability ?? "") !== capabilityFilter) continue;
      if (posterFilter && String(row.posterAgentId ?? "") !== posterFilter) continue;
      rows.push(row);
    }

    rows.sort((left, right) => {
      const leftAt = Date.parse(String(left.createdAt ?? ""));
      const rightAt = Date.parse(String(right.createdAt ?? ""));
      if (Number.isFinite(leftAt) && Number.isFinite(rightAt) && rightAt !== leftAt) return rightAt - leftAt;
      return String(left.rfqId ?? "").localeCompare(String(right.rfqId ?? ""));
    });
    return rows;
  }

  function toMarketplaceRfqResponse(rfq) {
    if (!rfq || typeof rfq !== "object" || Array.isArray(rfq)) return null;
    return {
      ...rfq,
      schemaVersion: "MarketplaceRfq.v1",
      rfqId: typeof rfq.rfqId === "string" && rfq.rfqId.trim() !== "" ? rfq.rfqId : null
    };
  }

  function toMarketplaceBidResponse(bid) {
    if (!bid || typeof bid !== "object" || Array.isArray(bid)) return null;
    return {
      ...bid,
      rfqId: typeof bid.rfqId === "string" && bid.rfqId.trim() !== "" ? bid.rfqId : null
    };
  }

  function getMarketplaceRfq({ tenantId, rfqId }) {
    if (!(store.marketplaceRfqs instanceof Map)) return null;
    return store.marketplaceRfqs.get(rfqStoreKey(tenantId, rfqId)) ?? null;
  }

  function findMarketplaceRfqByRunId({ tenantId, runId }) {
    if (!(store.marketplaceRfqs instanceof Map)) return null;
    const t = normalizeTenant(tenantId);
    for (const rfq of store.marketplaceRfqs.values()) {
      if (!rfq || typeof rfq !== "object") continue;
      if (normalizeTenant(rfq.tenantId ?? DEFAULT_TENANT_ID) !== t) continue;
      if (String(rfq.runId ?? "") !== String(runId)) continue;
      return rfq;
    }
    return null;
  }

  function buildDelegationTraceRecord({
    tenantId,
    rfq,
    agreement,
    contextType,
    contextId = null,
    acceptedByAgentId = null,
    acceptanceSignature
  } = {}) {
    if (!acceptanceSignature || typeof acceptanceSignature !== "object" || Array.isArray(acceptanceSignature)) return null;
    const actingOnBehalfOf =
      acceptanceSignature.actingOnBehalfOf &&
      typeof acceptanceSignature.actingOnBehalfOf === "object" &&
      !Array.isArray(acceptanceSignature.actingOnBehalfOf)
        ? acceptanceSignature.actingOnBehalfOf
        : null;
    if (!actingOnBehalfOf) return null;
    const delegationChainRaw = Array.isArray(actingOnBehalfOf.delegationChain) ? actingOnBehalfOf.delegationChain : null;
    if (!delegationChainRaw || delegationChainRaw.length === 0) return null;
    const delegationChain = normalizeForCanonicalJson(delegationChainRaw, { path: "$" });
    const chainHash =
      typeof actingOnBehalfOf.chainHash === "string" && actingOnBehalfOf.chainHash.trim() !== ""
        ? actingOnBehalfOf.chainHash.trim()
        : sha256Hex(canonicalJsonStringify(delegationChain));
    const runId = String(rfq?.runId ?? agreement?.runId ?? "");
    const rfqId = String(rfq?.rfqId ?? "");
    const agreementId = String(agreement?.agreementId ?? "");
    if (!runId || !rfqId || !agreementId) return null;
    return normalizeForCanonicalJson(
      {
        chainHash,
        tenantId: normalizeTenant(tenantId),
        runId,
        rfqId,
        agreementId,
        contextType,
        contextId,
        signedAt:
          typeof acceptanceSignature.signedAt === "string" && acceptanceSignature.signedAt.trim() !== ""
            ? acceptanceSignature.signedAt.trim()
            : null,
        signerAgentId:
          typeof acceptanceSignature.signerAgentId === "string" && acceptanceSignature.signerAgentId.trim() !== ""
            ? acceptanceSignature.signerAgentId.trim()
            : null,
        signerKeyId:
          typeof acceptanceSignature.signerKeyId === "string" && acceptanceSignature.signerKeyId.trim() !== ""
            ? acceptanceSignature.signerKeyId.trim()
            : null,
        acceptedByAgentId:
          typeof acceptedByAgentId === "string" && acceptedByAgentId.trim() !== "" ? acceptedByAgentId.trim() : null,
        principalAgentId:
          typeof actingOnBehalfOf.principalAgentId === "string" && actingOnBehalfOf.principalAgentId.trim() !== ""
            ? actingOnBehalfOf.principalAgentId.trim()
            : null,
        delegateAgentId:
          typeof actingOnBehalfOf.delegateAgentId === "string" && actingOnBehalfOf.delegateAgentId.trim() !== ""
            ? actingOnBehalfOf.delegateAgentId.trim()
            : null,
        delegationChain
      },
      { path: "$" }
    );
  }

  function collectDelegationTracesFromRfq({ tenantId, rfq } = {}) {
    const traces = [];
    if (!rfq || typeof rfq !== "object" || Array.isArray(rfq)) return traces;
    const agreement = rfq?.agreement && typeof rfq.agreement === "object" && !Array.isArray(rfq.agreement) ? rfq.agreement : null;
    if (!agreement) return traces;

    const agreementTrace = buildDelegationTraceRecord({
      tenantId,
      rfq,
      agreement,
      contextType: DELEGATION_TRACE_CONTEXT_TYPE.AGREEMENT_ACCEPTANCE,
      contextId: agreement.agreementId ?? null,
      acceptedByAgentId: agreement.acceptedByAgentId ?? null,
      acceptanceSignature: agreement.acceptanceSignature ?? null
    });
    if (agreementTrace) traces.push(agreementTrace);

    const changeOrders = Array.isArray(agreement?.terms?.changeOrders) ? agreement.terms.changeOrders : [];
    for (const changeOrder of changeOrders) {
      if (!changeOrder || typeof changeOrder !== "object" || Array.isArray(changeOrder)) continue;
      const trace = buildDelegationTraceRecord({
        tenantId,
        rfq,
        agreement,
        contextType: DELEGATION_TRACE_CONTEXT_TYPE.CHANGE_ORDER_ACCEPTANCE,
        contextId: changeOrder.changeOrderId ?? null,
        acceptedByAgentId: changeOrder.acceptedByAgentId ?? null,
        acceptanceSignature: changeOrder.acceptanceSignature ?? null
      });
      if (trace) traces.push(trace);
    }

    const cancellation =
      rfq?.metadata?.cancellation && typeof rfq.metadata.cancellation === "object" && !Array.isArray(rfq.metadata.cancellation)
        ? rfq.metadata.cancellation
        : null;
    if (cancellation) {
      const trace = buildDelegationTraceRecord({
        tenantId,
        rfq,
        agreement,
        contextType: DELEGATION_TRACE_CONTEXT_TYPE.CANCELLATION_ACCEPTANCE,
        contextId: cancellation.cancellationId ?? null,
        acceptedByAgentId: cancellation.acceptedByAgentId ?? null,
        acceptanceSignature: cancellation.acceptanceSignature ?? null
      });
      if (trace) traces.push(trace);
    }

    return traces;
  }

  function listDelegationTraces({
    tenantId,
    runId = null,
    chainHash = null,
    delegationId = null,
    signerKeyId = null,
    signerAgentId = null,
    limit = 200,
    offset = 0
  } = {}) {
    const normalizedRunId = typeof runId === "string" && runId.trim() !== "" ? runId.trim() : null;
    const normalizedChainHash =
      typeof chainHash === "string" && chainHash.trim() !== "" ? chainHash.trim().toLowerCase() : null;
    const normalizedDelegationId =
      typeof delegationId === "string" && delegationId.trim() !== "" ? delegationId.trim() : null;
    const normalizedSignerKeyId =
      typeof signerKeyId === "string" && signerKeyId.trim() !== "" ? signerKeyId.trim() : null;
    const normalizedSignerAgentId =
      typeof signerAgentId === "string" && signerAgentId.trim() !== "" ? signerAgentId.trim() : null;

    const traces = [];
    const rfqs = listMarketplaceRfqs({ tenantId, status: "all" });
    for (const rfq of rfqs) {
      const perRfq = collectDelegationTracesFromRfq({ tenantId, rfq });
      for (const trace of perRfq) {
        if (normalizedRunId && String(trace.runId ?? "") !== normalizedRunId) continue;
        if (normalizedChainHash && String(trace.chainHash ?? "").toLowerCase() !== normalizedChainHash) continue;
        if (normalizedSignerKeyId && String(trace.signerKeyId ?? "") !== normalizedSignerKeyId) continue;
        if (normalizedSignerAgentId && String(trace.signerAgentId ?? "") !== normalizedSignerAgentId) continue;
        if (
          normalizedDelegationId &&
          !trace.delegationChain.some((row) => row && typeof row === "object" && String(row.delegationId ?? "") === normalizedDelegationId)
        ) {
          continue;
        }
        traces.push(trace);
      }
    }

    traces.sort((left, right) => {
      const leftMs = Date.parse(String(left.signedAt ?? ""));
      const rightMs = Date.parse(String(right.signedAt ?? ""));
      if (Number.isFinite(leftMs) && Number.isFinite(rightMs) && rightMs !== leftMs) return rightMs - leftMs;
      if (String(left.runId ?? "") !== String(right.runId ?? "")) return String(left.runId ?? "").localeCompare(String(right.runId ?? ""));
      if (String(left.rfqId ?? "") !== String(right.rfqId ?? "")) return String(left.rfqId ?? "").localeCompare(String(right.rfqId ?? ""));
      if (String(left.contextType ?? "") !== String(right.contextType ?? "")) {
        return String(left.contextType ?? "").localeCompare(String(right.contextType ?? ""));
      }
      return String(left.contextId ?? "").localeCompare(String(right.contextId ?? ""));
    });

    const safeLimit = Number.isSafeInteger(limit) && limit > 0 ? Math.min(1000, limit) : 200;
    const safeOffset = Number.isSafeInteger(offset) && offset >= 0 ? offset : 0;
    return {
      traces: traces.slice(safeOffset, safeOffset + safeLimit),
      total: traces.length,
      limit: safeLimit,
      offset: safeOffset
    };
  }

  function listMarketplaceRfqBids({
    tenantId,
    rfqId,
    status = "all",
    bidderAgentId = null
  } = {}) {
    const statusFilter = parseMarketplaceBidStatus(status, { allowAll: true, defaultStatus: "all" });
    const bidderFilter = bidderAgentId && String(bidderAgentId).trim() !== "" ? String(bidderAgentId).trim() : null;

    if (!(store.marketplaceRfqBids instanceof Map)) return [];
    const rows = store.marketplaceRfqBids.get(rfqStoreKey(tenantId, rfqId));
    const all = Array.isArray(rows) ? rows : [];
    const filtered = [];
    for (const row of all) {
      if (!row || typeof row !== "object") continue;
      const rowStatus = String(row.status ?? "pending").toLowerCase();
      if (statusFilter !== "all" && rowStatus !== statusFilter) continue;
      if (bidderFilter && String(row.bidderAgentId ?? "") !== bidderFilter) continue;
      filtered.push(row);
    }
    filtered.sort((left, right) => {
      const leftAmount = Number(left.amountCents ?? Number.MAX_SAFE_INTEGER);
      const rightAmount = Number(right.amountCents ?? Number.MAX_SAFE_INTEGER);
      if (Number.isFinite(leftAmount) && Number.isFinite(rightAmount) && leftAmount !== rightAmount) return leftAmount - rightAmount;
      const leftAt = Date.parse(String(left.createdAt ?? ""));
      const rightAt = Date.parse(String(right.createdAt ?? ""));
      if (Number.isFinite(leftAt) && Number.isFinite(rightAt) && leftAt !== rightAt) return leftAt - rightAt;
      return String(left.bidId ?? "").localeCompare(String(right.bidId ?? ""));
    });
    return filtered;
  }

  function listOperators({ tenantId } = {}) {
    const t = normalizeTenant(tenantId);
    const operators = [];
    for (const op of store.operators.values()) {
      if (!op?.id) continue;
      const opTenant = normalizeTenant(op.tenantId ?? DEFAULT_TENANT_ID);
      if (opTenant !== t) continue;
      operators.push(op);
    }
    operators.sort((a, b) => String(a.id).localeCompare(String(b.id)));
    return operators;
  }

  function listContracts({ tenantId } = {}) {
    const t = normalizeTenant(tenantId);
    const contracts = [];
    if (!(store.contracts instanceof Map)) return contracts;
    for (const c of store.contracts.values()) {
      if (!c?.contractId) continue;
      const cTenant = normalizeTenant(c.tenantId ?? DEFAULT_TENANT_ID);
      if (cTenant !== t) continue;
      contracts.push(c);
    }
    contracts.sort((a, b) => String(a.contractId).localeCompare(String(b.contractId)));
    return contracts;
  }

  function getJobEvents(tenantId, jobId) {
    return store.jobEvents.get(jobStoreKey(tenantId, jobId)) ?? [];
  }

  async function getJobEventsFresh(tenantId, jobId, { force = false } = {}) {
    let events = force ? [] : getJobEvents(tenantId, jobId);
    if ((force || !events.length) && typeof store.listAggregateEvents === "function") {
      try {
        events = await store.listAggregateEvents({ tenantId, aggregateType: "job", aggregateId: String(jobId) });
        if (Array.isArray(events) && events.length) setJobEvents(tenantId, jobId, events);
      } catch {
        events = [];
      }
    }
    return Array.isArray(events) ? events : [];
  }

  function setJobEvents(tenantId, jobId, events) {
    store.jobEvents.set(jobStoreKey(tenantId, jobId), events);
  }

  function getRobotEvents(tenantId, robotId) {
    return store.robotEvents.get(robotStoreKey(tenantId, robotId)) ?? [];
  }

  async function getRobotFresh(tenantId, robotId) {
    const key = robotStoreKey(tenantId, robotId);
    let robot = store.robots.get(key) ?? null;
    if (!robot && typeof store.listAggregateEvents === "function") {
      try {
        const events = await store.listAggregateEvents({ tenantId, aggregateType: "robot", aggregateId: String(robotId) });
        if (Array.isArray(events) && events.length) {
          setRobotEvents(tenantId, robotId, events);
          robot = reduceRobot(events);
          if (robot) store.robots.set(key, robot);
        }
      } catch {
        robot = null;
      }
    }
    return robot;
  }

  function setRobotEvents(tenantId, robotId, events) {
    store.robotEvents.set(robotStoreKey(tenantId, robotId), events);
  }

  function getOperatorEvents(tenantId, operatorId) {
    return store.operatorEvents.get(operatorStoreKey(tenantId, operatorId)) ?? [];
  }

  async function getOperatorFresh(tenantId, operatorId) {
    const key = operatorStoreKey(tenantId, operatorId);
    let operator = store.operators.get(key) ?? null;
    if (!operator && typeof store.listAggregateEvents === "function") {
      try {
        const events = await store.listAggregateEvents({ tenantId, aggregateType: "operator", aggregateId: String(operatorId) });
        if (Array.isArray(events) && events.length) {
          setOperatorEvents(tenantId, operatorId, events);
          operator = reduceOperator(events);
          if (operator) store.operators.set(key, operator);
        }
      } catch {
        operator = null;
      }
    }
    return operator;
  }

  function setOperatorEvents(tenantId, operatorId, events) {
    store.operatorEvents.set(operatorStoreKey(tenantId, operatorId), events);
  }

  async function ensureSignerContextFresh({ tenantId, event } = {}) {
    const t = normalizeTenant(tenantId);
    if (!event || typeof event !== "object" || Array.isArray(event)) return;

    const actorType = event?.actor?.type;
    const actorId = typeof event?.actor?.id === "string" && event.actor.id.trim() ? event.actor.id : null;
    if (actorType === "robot" && actorId) await getRobotFresh(t, actorId);
    if (actorType === "operator" && actorId) await getOperatorFresh(t, actorId);

    const signerKeyId = typeof event?.signerKeyId === "string" && event.signerKeyId.trim() ? event.signerKeyId : null;
    if (!signerKeyId) return;

    const signerMapKey = makeScopedKey({ tenantId: t, id: signerKeyId });
    const hasSignerKey = store.signerKeys?.get?.(signerMapKey) ?? null;
    const hasPublicKey = store.publicKeyByKeyId?.get?.(signerKeyId) ?? null;
    if (hasSignerKey && hasPublicKey) return;

    if (typeof store.getSignerKey === "function") {
      try {
        const signerKey = await store.getSignerKey({ tenantId: t, keyId: signerKeyId });
        if (signerKey && store.signerKeys instanceof Map) {
          store.signerKeys.set(signerMapKey, signerKey);
        }
        if (signerKey?.publicKeyPem && store.publicKeyByKeyId instanceof Map) {
          store.publicKeyByKeyId.set(signerKeyId, signerKey.publicKeyPem);
        }
      } catch {
        // Keep local signer context as-is if DB lookup fails.
      }
    }
  }

  function normalizeAgentRunEventRecord(event) {
    if (!event || typeof event !== "object" || Array.isArray(event)) return event;
    if (event.schemaVersion === AGENT_RUN_EVENT_SCHEMA_VERSION) return event;
    return { ...event, schemaVersion: AGENT_RUN_EVENT_SCHEMA_VERSION };
  }

  function normalizeAgentRunEventRecords(events) {
    if (!Array.isArray(events)) return [];
    return events.map(normalizeAgentRunEventRecord);
  }

  async function getAgentRunEvents(tenantId, runId) {
    if (typeof store.getAgentRunEvents === "function") {
      try {
        const events = await store.getAgentRunEvents({ tenantId, runId });
        return normalizeAgentRunEventRecords(events);
      } catch {
        // Fall through to local projection below.
      }
    }
    return normalizeAgentRunEventRecords(store.agentRunEvents.get(runStoreKey(tenantId, runId)) ?? []);
  }

  function setAgentRunEvents(tenantId, runId, events) {
    store.agentRunEvents.set(runStoreKey(tenantId, runId), normalizeAgentRunEventRecords(events));
  }

  async function getAgentWalletRecord({ tenantId, agentId }) {
    if (typeof store.getAgentWallet === "function") return store.getAgentWallet({ tenantId, agentId });
    if (store.agentWallets instanceof Map) return store.agentWallets.get(makeScopedKey({ tenantId, id: String(agentId) })) ?? null;
    throw new TypeError("agent wallets not supported for this store");
  }

  async function getAgentIdentityRecord({ tenantId, agentId }) {
    if (typeof store.getAgentIdentity === "function") return store.getAgentIdentity({ tenantId, agentId });
    if (store.agentIdentities instanceof Map) return store.agentIdentities.get(makeScopedKey({ tenantId, id: String(agentId) })) ?? null;
    throw new TypeError("agent identities not supported for this store");
  }

  async function getAgentRunSettlementRecord({ tenantId, runId }) {
    if (typeof store.getAgentRunSettlement === "function") return store.getAgentRunSettlement({ tenantId, runId });
    if (store.agentRunSettlements instanceof Map) return store.agentRunSettlements.get(makeScopedKey({ tenantId, id: String(runId) })) ?? null;
    throw new TypeError("agent run settlements not supported for this store");
  }

  function buildSettlementKernelRefs({
    settlement,
    run = null,
    agreementId = null,
    decisionStatus,
    decisionMode,
    decisionReason = null,
    verificationStatus = null,
    policyHash = null,
    verificationMethodHash = null,
    verificationMethodMode = null,
    verifierId = "settld.policy-engine",
    verifierVersion = "v1",
    verifierHash = null,
    resolutionEventId = null,
    status = null,
    releasedAmountCents = null,
    refundedAmountCents = null,
    releaseRatePct = null,
    finalityState = SETTLEMENT_FINALITY_STATE.PENDING,
    settledAt = null,
    createdAt,
    bindings = null
	  }) {
	    if (!settlement || typeof settlement !== "object") return { decisionRecord: null, settlementReceipt: null };
	    const at = createdAt ?? nowIso();

	    // v2 decision records require replay-critical policy pinning. For non-marketplace runs, callers may not pass
	    // explicit policy hashes; fall back to the policy/method actually present in the settlement trace, otherwise
	    // the system defaults (which are what evaluation uses when nothing is specified).
	    const lowerHexOrNull = (value) => {
	      if (typeof value !== "string") return null;
	      const trimmed = value.trim().toLowerCase();
	      if (!trimmed) return null;
	      return trimmed;
	    };
	    let effectivePolicyHash = lowerHexOrNull(policyHash);
	    let effectiveVerificationMethodHash = lowerHexOrNull(verificationMethodHash);
	    try {
	      if (!effectivePolicyHash || !/^[0-9a-f]{64}$/.test(effectivePolicyHash)) {
	        const tracePolicy =
	          settlement?.decisionTrace?.policy && typeof settlement.decisionTrace.policy === "object" && !Array.isArray(settlement.decisionTrace.policy)
	            ? settlement.decisionTrace.policy
	            : null;
	        effectivePolicyHash = tracePolicy ? parseSettlementPolicyInput(tracePolicy).policyHash : null;
	      }
	    } catch {
	      effectivePolicyHash = null;
	    }
	    try {
	      if (!effectiveVerificationMethodHash || !/^[0-9a-f]{64}$/.test(effectiveVerificationMethodHash)) {
	        const traceMethod =
	          settlement?.decisionTrace?.verificationMethod &&
	          typeof settlement.decisionTrace.verificationMethod === "object" &&
	          !Array.isArray(settlement.decisionTrace.verificationMethod)
	            ? settlement.decisionTrace.verificationMethod
	            : null;
	        effectiveVerificationMethodHash = traceMethod ? computeVerificationMethodHash(parseVerificationMethodInput(traceMethod)) : null;
	      }
	    } catch {
	      effectiveVerificationMethodHash = null;
	    }
	    if (!effectivePolicyHash) {
	      // Default policy hash must always exist; if this fails, something is badly wrong with policy normalization.
	      effectivePolicyHash = parseSettlementPolicyInput(null).policyHash;
	    }
	    if (!effectiveVerificationMethodHash) {
	      effectiveVerificationMethodHash = computeVerificationMethodHash(parseVerificationMethodInput(null));
	    }
		    const decisionRecord = buildSettlementDecisionRecord({
		      schemaVersion: "SettlementDecisionRecord.v2",
		      decisionId: `dec_${createId("setl")}`,
		      tenantId: settlement.tenantId,
		      runId: settlement.runId,
		      settlementId: settlement.settlementId,
		      agreementId,
		      decisionStatus,
		      decisionMode,
		      decisionReason,
		      verificationStatus,
		      policyHashUsed: effectivePolicyHash,
		      verificationMethodHashUsed: effectiveVerificationMethodHash ?? undefined,
		      policyRef: { policyHash: effectivePolicyHash, verificationMethodHash: effectiveVerificationMethodHash },
      verifierRef: {
		        verifierId,
		        verifierVersion,
		        verifierHash,
		        modality: verificationMethodMode ?? null
	      },
      ...(bindings && typeof bindings === "object" && !Array.isArray(bindings) ? { bindings } : {}),
      runStatus: run?.status ?? settlement.runStatus ?? null,
      runLastEventId: run?.lastEventId ?? null,
      runLastChainHash: run?.lastChainHash ?? null,
      resolutionEventId,
      decidedAt: at
    });
    const receiptStatus = status ?? settlement.status;
    const receiptReleaseRatePct =
      Number.isSafeInteger(Number(releaseRatePct))
        ? Number(releaseRatePct)
        : Number.isSafeInteger(Number(settlement.releaseRatePct))
          ? Number(settlement.releaseRatePct)
          : receiptStatus === AGENT_RUN_SETTLEMENT_STATUS.RELEASED
            ? 100
            : 0;
    const receipt = buildSettlementReceipt({
      receiptId: `rcpt_${createId("setl")}`,
      tenantId: settlement.tenantId,
      runId: settlement.runId,
      settlementId: settlement.settlementId,
      decisionRecord,
      status: receiptStatus,
      amountCents: settlement.amountCents,
      releasedAmountCents:
        Number.isSafeInteger(Number(releasedAmountCents))
          ? Number(releasedAmountCents)
          : Number.isSafeInteger(Number(settlement.releasedAmountCents))
            ? Number(settlement.releasedAmountCents)
            : 0,
      refundedAmountCents:
        Number.isSafeInteger(Number(refundedAmountCents))
          ? Number(refundedAmountCents)
          : Number.isSafeInteger(Number(settlement.refundedAmountCents))
            ? Number(settlement.refundedAmountCents)
            : 0,
      releaseRatePct: receiptReleaseRatePct,
      currency: settlement.currency,
      runStatus: run?.status ?? settlement.runStatus ?? null,
      resolutionEventId: resolutionEventId ?? settlement.resolutionEventId ?? null,
      finalityState,
      settledAt: settledAt ?? settlement.resolvedAt ?? null,
      ...(bindings && typeof bindings === "object" && !Array.isArray(bindings) ? { bindings } : {}),
      createdAt: at
    });
    return { decisionRecord, settlementReceipt: receipt };
  }

  function buildSettlementResponseBody(settlement) {
    const { decisionRecord, settlementReceipt } = extractSettlementKernelArtifacts(settlement);
    const kernelVerification = verifySettlementKernelArtifacts({ settlement });
    return {
      settlement,
      decisionRecord,
      settlementReceipt,
      kernelVerification
    };
  }

  function assertSettlementKernelBindingsForResolution({
    settlement,
    runId,
    phase,
    allowMissingArtifacts = false
  }) {
    const verification = verifySettlementKernelArtifacts({ settlement, runId });
    if (verification.valid) return verification;
    if (allowMissingArtifacts) {
      const nonMissingErrors = (verification.errors ?? []).filter(
        (code) =>
          code !== SETTLEMENT_KERNEL_VERIFICATION_CODE.DECISION_RECORD_MISSING &&
          code !== SETTLEMENT_KERNEL_VERIFICATION_CODE.SETTLEMENT_RECEIPT_MISSING
      );
      if (!nonMissingErrors.length) return verification;
    }
    const err = new Error(`settlement kernel binding invalid (${phase})`);
    err.code = "SETTLEMENT_KERNEL_BINDING_INVALID";
    err.detail = {
      phase,
      runId: String(runId ?? settlement?.runId ?? ""),
      settlementId: settlement?.settlementId ?? null,
      errors: verification.errors
    };
    throw err;
  }

  function parseEvidenceRefSha256(evidenceRefs, prefix) {
    if (!Array.isArray(evidenceRefs)) return null;
    const normalizedPrefix = typeof prefix === "string" && prefix.trim() !== "" ? prefix.trim() : "";
    if (!normalizedPrefix) return null;
    for (const row of evidenceRefs) {
      const text = typeof row === "string" ? row.trim() : "";
      if (!text || !text.startsWith(normalizedPrefix)) continue;
      const candidate = text.slice(normalizedPrefix.length).trim().toLowerCase();
      if (/^[0-9a-f]{64}$/.test(candidate)) return candidate;
    }
    return null;
  }

  function normalizeX402ReversalActionInput(value) {
    const action = typeof value === "string" ? value.trim().toLowerCase() : "";
    if (!action) throw new TypeError("action is required");
    if (action !== "void_authorization" && action !== "request_refund" && action !== "resolve_refund") {
      throw new TypeError("action must be void_authorization|request_refund|resolve_refund");
    }
    return action;
  }

  function normalizeX402ReversalDecisionInput(value) {
    if (value === null || value === undefined || String(value).trim() === "") return null;
    const out = String(value).trim().toLowerCase();
    if (out !== "accepted" && out !== "denied") {
      throw new TypeError("providerDecision must be accepted|denied when provided");
    }
    return out;
  }

  function normalizeX402ReversalReasonInput(value) {
    if (value === null || value === undefined || String(value).trim() === "") return null;
    const out = String(value).trim();
    if (out.length > 1000) throw new TypeError("reason must be <= 1000 chars");
    return out;
  }

  function normalizeX402ReversalEvidenceRefsInput(value) {
    if (value === null || value === undefined) return [];
    if (!Array.isArray(value)) throw new TypeError("evidenceRefs must be an array when provided");
    const out = [];
    const seen = new Set();
    for (let index = 0; index < value.length; index += 1) {
      const raw = value[index];
      const text = typeof raw === "string" ? raw.trim() : "";
      if (!text) throw new TypeError(`evidenceRefs[${index}] must be a non-empty string`);
      if (seen.has(text)) continue;
      seen.add(text);
      out.push(text);
    }
    return out;
  }

  function normalizeX402ReversalCommandInput(value) {
    if (!value || typeof value !== "object" || Array.isArray(value)) {
      throw new TypeError("command is required");
    }
    return value;
  }

  function normalizeX402ProviderRefundDecisionEnvelopeInput(value) {
    if (value === null || value === undefined) return null;
    if (!value || typeof value !== "object" || Array.isArray(value)) {
      throw new TypeError("providerDecisionArtifact must be an object when provided");
    }
    return value;
  }

  function x402SettlementReceiptIdFromSettlement(settlement) {
    const receiptId =
      settlement?.decisionTrace?.settlementReceipt &&
      typeof settlement.decisionTrace.settlementReceipt === "object" &&
      !Array.isArray(settlement.decisionTrace.settlementReceipt) &&
      typeof settlement.decisionTrace.settlementReceipt.receiptId === "string" &&
      settlement.decisionTrace.settlementReceipt.receiptId.trim() !== ""
        ? settlement.decisionTrace.settlementReceipt.receiptId.trim()
        : null;
    return receiptId;
  }

  function resolveX402GateQuoteBinding({ gate, settlement } = {}) {
    const bindings =
      settlement?.decisionTrace?.bindings && typeof settlement.decisionTrace.bindings === "object" && !Array.isArray(settlement.decisionTrace.bindings)
        ? settlement.decisionTrace.bindings
        : null;
    const quoteId =
      typeof bindings?.quote?.quoteId === "string" && bindings.quote.quoteId.trim() !== ""
        ? bindings.quote.quoteId.trim()
        : typeof gate?.quote?.quoteId === "string" && gate.quote.quoteId.trim() !== ""
          ? gate.quote.quoteId.trim()
          : null;
    const requestSha256 =
      typeof bindings?.request?.sha256 === "string" && /^[0-9a-f]{64}$/i.test(bindings.request.sha256.trim())
        ? bindings.request.sha256.trim().toLowerCase()
        : null;
    const sponsorRef =
      typeof bindings?.spendAuthorization?.sponsorRef === "string" && bindings.spendAuthorization.sponsorRef.trim() !== ""
        ? bindings.spendAuthorization.sponsorRef.trim()
        : typeof gate?.agentPassport?.sponsorRef === "string" && gate.agentPassport.sponsorRef.trim() !== ""
          ? gate.agentPassport.sponsorRef.trim()
          : null;
    return { quoteId, requestSha256, sponsorRef };
  }

  function buildX402ReversalEventRecord({
    tenantId,
    gateId,
    receiptId,
    action,
    eventType,
    occurredAt,
    reason = null,
    providerDecision = null,
    evidenceRefs = [],
    command = null,
    commandVerification = null,
    providerDecisionArtifact = null,
    providerDecisionVerification = null,
    settlementStatusBefore = null,
    settlementStatusAfter = null,
    previousEventHash = null,
    eventId = null
  } = {}) {
    const normalizedEvent = normalizeForCanonicalJson(
      {
        schemaVersion: "X402GateReversalEvent.v1",
        eventId: typeof eventId === "string" && eventId.trim() !== "" ? eventId.trim() : createId("x402rev"),
        tenantId: normalizeTenantId(tenantId ?? DEFAULT_TENANT_ID),
        gateId: String(gateId ?? "").trim(),
        receiptId: String(receiptId ?? "").trim(),
        action: String(action ?? "").trim().toLowerCase(),
        eventType: String(eventType ?? "").trim(),
        occurredAt: String(occurredAt ?? nowIso()),
        ...(reason ? { reason: String(reason) } : {}),
        ...(providerDecision ? { providerDecision: String(providerDecision).toLowerCase() } : {}),
        ...(Array.isArray(evidenceRefs) && evidenceRefs.length > 0 ? { evidenceRefs: evidenceRefs.slice() } : {}),
        ...(command && typeof command === "object" && !Array.isArray(command) ? { command } : {}),
        ...(commandVerification && typeof commandVerification === "object" && !Array.isArray(commandVerification)
          ? { commandVerification }
          : {}),
        ...(providerDecisionArtifact && typeof providerDecisionArtifact === "object" && !Array.isArray(providerDecisionArtifact)
          ? { providerDecisionArtifact }
          : {}),
        ...(providerDecisionVerification && typeof providerDecisionVerification === "object" && !Array.isArray(providerDecisionVerification)
          ? { providerDecisionVerification }
          : {}),
        ...(settlementStatusBefore ? { settlementStatusBefore: String(settlementStatusBefore).toLowerCase() } : {}),
        ...(settlementStatusAfter ? { settlementStatusAfter: String(settlementStatusAfter).toLowerCase() } : {}),
        ...(typeof previousEventHash === "string" && previousEventHash.trim() !== "" ? { prevEventHash: previousEventHash.trim() } : {})
      },
      { path: "$" }
    );
    const hashInput = normalizeForCanonicalJson(
      {
        ...normalizedEvent
      },
      { path: "$" }
    );
    const eventHash = sha256Hex(canonicalJsonStringify(hashInput));
    return normalizeForCanonicalJson(
      {
        ...normalizedEvent,
        eventHash
      },
      { path: "$" }
    );
  }

  function appendX402GateReversalTimeline({
    gate,
    eventType,
    at,
    reason = null,
    providerDecision = null,
    evidenceRefs = [],
    eventId = null,
    eventHash = null,
    prevEventHash = null,
    action = null,
    commandId = null
  } = {}) {
    const previousReversal =
      gate?.reversal && typeof gate.reversal === "object" && !Array.isArray(gate.reversal)
        ? gate.reversal
        : null;
    const previousTimeline = Array.isArray(previousReversal?.timeline) ? previousReversal.timeline : [];
    const normalizedEvidenceRefs = Array.isArray(evidenceRefs) ? evidenceRefs.slice() : [];
    const event = normalizeForCanonicalJson(
      {
        eventType,
        at,
        ...(reason ? { reason } : {}),
        ...(providerDecision ? { providerDecision } : {}),
        ...(action ? { action: String(action).toLowerCase() } : {}),
        ...(eventId ? { eventId } : {}),
        ...(eventHash ? { eventHash } : {}),
        ...(prevEventHash ? { prevEventHash } : {}),
        ...(commandId ? { commandId } : {}),
        ...(normalizedEvidenceRefs.length ? { evidenceRefs: normalizedEvidenceRefs } : {})
      },
      { path: "$" }
    );
    const timeline = [...previousTimeline, event];
    return normalizeForCanonicalJson(
      {
        schemaVersion: "X402GateReversal.v1",
        status:
          typeof previousReversal?.status === "string" && previousReversal.status.trim() !== ""
            ? previousReversal.status.trim()
            : "none",
        requestedAt:
          typeof previousReversal?.requestedAt === "string" && previousReversal.requestedAt.trim() !== ""
            ? previousReversal.requestedAt.trim()
            : null,
        resolvedAt:
          typeof previousReversal?.resolvedAt === "string" && previousReversal.resolvedAt.trim() !== ""
            ? previousReversal.resolvedAt.trim()
            : null,
        providerDecision:
          typeof previousReversal?.providerDecision === "string" && previousReversal.providerDecision.trim() !== ""
            ? previousReversal.providerDecision.trim()
            : null,
        reason:
          typeof previousReversal?.reason === "string" && previousReversal.reason.trim() !== ""
            ? previousReversal.reason.trim()
            : null,
        evidenceRefs: Array.isArray(previousReversal?.evidenceRefs) ? previousReversal.evidenceRefs.slice() : [],
        timeline
      },
      { path: "$" }
    );
  }

  function normalizeProviderSignatureStatus({
    providerSignatureRequired = false,
    providerSignature = null,
    providerReasonCodes = []
  } = {}) {
    const required = providerSignatureRequired === true;
    const present = providerSignature && typeof providerSignature === "object" && !Array.isArray(providerSignature);
    const verified = required ? present && (!Array.isArray(providerReasonCodes) || providerReasonCodes.length === 0) : present;
    const providerKeyId = present && typeof providerSignature.keyId === "string" && providerSignature.keyId.trim() !== "" ? providerSignature.keyId : null;
    const firstReason =
      Array.isArray(providerReasonCodes) && providerReasonCodes.length > 0 && typeof providerReasonCodes[0] === "string"
        ? providerReasonCodes[0]
        : null;
    return {
      required,
      present,
      verified,
      providerKeyId,
      error: firstReason
    };
  }

  function normalizeProviderQuoteSignatureStatus({
    providerQuoteSignatureRequired = false,
    providerQuoteSignature = null,
    providerReasonCodes = []
  } = {}) {
    const required = providerQuoteSignatureRequired === true;
    const present = providerQuoteSignature && typeof providerQuoteSignature === "object" && !Array.isArray(providerQuoteSignature);
    const verified = required ? present && (!Array.isArray(providerReasonCodes) || providerReasonCodes.length === 0) : present;
    const providerKeyId =
      present && typeof providerQuoteSignature.keyId === "string" && providerQuoteSignature.keyId.trim() !== ""
        ? providerQuoteSignature.keyId
        : null;
    const firstReason =
      Array.isArray(providerReasonCodes) && providerReasonCodes.length > 0 && typeof providerReasonCodes[0] === "string"
        ? providerReasonCodes[0]
        : null;
    const quoteId =
      present && typeof providerQuoteSignature.quoteId === "string" && providerQuoteSignature.quoteId.trim() !== ""
        ? providerQuoteSignature.quoteId
        : null;
    const quoteSha256 =
      present && typeof providerQuoteSignature.quoteSha256 === "string" && /^[0-9a-f]{64}$/i.test(providerQuoteSignature.quoteSha256.trim())
        ? providerQuoteSignature.quoteSha256.trim().toLowerCase()
        : null;
    return {
      required,
      present,
      verified,
      providerKeyId,
      quoteId,
      quoteSha256,
      error: firstReason
    };
  }

  function buildVerificationKeyEvidence(signatureLike) {
    if (!signatureLike || typeof signatureLike !== "object" || Array.isArray(signatureLike)) return null;
    const publicKeyPem =
      typeof signatureLike.publicKeyPem === "string" && signatureLike.publicKeyPem.trim() !== "" ? signatureLike.publicKeyPem.trim() : null;
    if (!publicKeyPem) return null;
    try {
      const key = crypto.createPublicKey(publicKeyPem);
      const exported = key.export({ format: "jwk" });
      if (!exported || typeof exported !== "object" || Array.isArray(exported)) return null;
      if (String(exported.kty ?? "") !== "OKP") return null;
      if (String(exported.crv ?? "") !== "Ed25519") return null;
      if (typeof exported.x !== "string" || exported.x.trim() === "") return null;
      const jwk = normalizeForCanonicalJson(
        {
          kty: "OKP",
          crv: "Ed25519",
          x: exported.x.trim()
        },
        { path: "$" }
      );
      const jwkThumbprintSha256 = sha256Hex(canonicalJsonStringify(jwk));
      return {
        schemaVersion: "VerificationKeyEvidence.v1",
        keyId:
          typeof signatureLike.keyId === "string" && signatureLike.keyId.trim() !== ""
            ? signatureLike.keyId.trim()
            : keyIdFromPublicKeyPem(publicKeyPem),
        publicKeyPem,
        jwk,
        jwkThumbprintSha256
      };
    } catch {
      return null;
    }
  }

  function parseX402ReceiptListQuery(url) {
    const parseBound = (raw, name) => {
      if (raw === null || raw === undefined || String(raw).trim() === "") return null;
      const text = String(raw).trim();
      if (!Number.isFinite(Date.parse(text))) throw new TypeError(`${name} must be an ISO date-time`);
      return new Date(text).toISOString();
    };
    const parseNullableTrimmed = (raw) => {
      if (raw === null || raw === undefined) return null;
      const text = String(raw).trim();
      return text === "" ? null : text;
    };
    const parsePositiveInt = (raw, fallback, { min = 1, max = 1000, name = "limit" } = {}) => {
      if (raw === null || raw === undefined || String(raw).trim() === "") return fallback;
      const n = Number(raw);
      if (!Number.isSafeInteger(n) || n < min || n > max) throw new TypeError(`${name} must be an integer within ${min}..${max}`);
      return n;
    };
    const parseNonNegativeInt = (raw, fallback, { max = 100_000, name = "offset" } = {}) => {
      if (raw === null || raw === undefined || String(raw).trim() === "") return fallback;
      const n = Number(raw);
      if (!Number.isSafeInteger(n) || n < 0 || n > max) throw new TypeError(`${name} must be an integer within 0..${max}`);
      return n;
    };
    return {
      agentId: parseNullableTrimmed(url.searchParams.get("agent_id") ?? url.searchParams.get("agentId")),
      sponsorId: parseNullableTrimmed(url.searchParams.get("sponsor_id") ?? url.searchParams.get("sponsorId")),
      sponsorWalletRef: parseNullableTrimmed(url.searchParams.get("sponsor_wallet_ref") ?? url.searchParams.get("sponsorWalletRef")),
      toolId: parseNullableTrimmed(url.searchParams.get("tool_id") ?? url.searchParams.get("toolId")),
      state: parseNullableTrimmed(url.searchParams.get("state")),
      from: parseBound(url.searchParams.get("from"), "from"),
      to: parseBound(url.searchParams.get("to"), "to"),
      cursor: parseNullableTrimmed(url.searchParams.get("cursor")),
      limit: parsePositiveInt(url.searchParams.get("limit"), 200, { name: "limit" }),
      offset: parseNonNegativeInt(url.searchParams.get("offset"), 0, { name: "offset" })
    };
  }

  function normalizeX402WalletIssuerDecisionTokenInput(value, fieldPath = "walletAuthorizationDecisionToken", { allowNull = true } = {}) {
    if (value === null || value === undefined || String(value).trim() === "") {
      if (allowNull) return null;
      throw new TypeError(`${fieldPath} is required`);
    }
    const out = String(value).trim();
    if (out.length > 16_384) throw new TypeError(`${fieldPath} must be <= 16384 chars`);
    if (!/^[A-Za-z0-9_-]+$/.test(out)) throw new TypeError(`${fieldPath} must be base64url token text`);
    return out;
  }

  function normalizePolicyDecisionId(value) {
    if (typeof value !== "string") return null;
    const trimmed = value.trim();
    return trimmed === "" ? null : trimmed;
  }

  function normalizeSafeIntOrNull(value, { min = 0, max = Number.MAX_SAFE_INTEGER } = {}) {
    if (value === null || value === undefined || value === "") return null;
    const n = Number(value);
    if (!Number.isSafeInteger(n) || n < min || n > max) return null;
    return n;
  }

  function computePolicyDecisionEvaluationHash({
    policyHashUsed = null,
    verificationMethodHashUsed = null,
    policyDecision = null
  } = {}) {
    const reasons =
      Array.isArray(policyDecision?.reasonCodes) && policyDecision.reasonCodes.length > 0
        ? Array.from(
            new Set(
              policyDecision.reasonCodes
                .map((code) => (typeof code === "string" ? code.trim() : ""))
                .filter(Boolean)
            )
          ).sort((a, b) => a.localeCompare(b))
        : [];
    const payload = normalizeForCanonicalJson(
      {
        schemaVersion: "PolicyDecisionEvaluationInput.v1",
        policyHash: typeof policyHashUsed === "string" && /^[0-9a-f]{64}$/.test(policyHashUsed.trim().toLowerCase())
          ? policyHashUsed.trim().toLowerCase()
          : null,
        verificationMethodHash:
          typeof verificationMethodHashUsed === "string" && /^[0-9a-f]{64}$/.test(verificationMethodHashUsed.trim().toLowerCase())
            ? verificationMethodHashUsed.trim().toLowerCase()
            : null,
        verificationStatus: typeof policyDecision?.verificationStatus === "string" ? policyDecision.verificationStatus.trim().toLowerCase() : null,
        runStatus: typeof policyDecision?.runStatus === "string" ? policyDecision.runStatus.trim().toLowerCase() : null,
        shouldAutoResolve: policyDecision?.shouldAutoResolve === true,
        releaseRatePct: normalizeSafeIntOrNull(policyDecision?.releaseRatePct, { min: 0, max: 100 }),
        releaseAmountCents: normalizeSafeIntOrNull(policyDecision?.releaseAmountCents, { min: 0 }),
        refundAmountCents: normalizeSafeIntOrNull(policyDecision?.refundAmountCents, { min: 0 }),
        settlementStatus: typeof policyDecision?.settlementStatus === "string" ? policyDecision.settlementStatus.trim().toLowerCase() : null,
        reasons
      },
      { path: "$" }
    );
    return sha256Hex(canonicalJsonStringify(payload));
  }

  function buildPolicyDecisionFingerprint({
    policyInput = null,
    policyHashUsed = null,
    verificationMethodHashUsed = null,
    policyDecision = null
  } = {}) {
    const rawPolicy = policyInput && typeof policyInput === "object" && !Array.isArray(policyInput) ? policyInput : {};
    const policyVersion =
      normalizeSafeIntOrNull(policyDecision?.policy?.policyVersion, { min: 1 }) ??
      normalizeSafeIntOrNull(rawPolicy.policyVersion, { min: 1 }) ??
      null;
    const policyId =
      normalizePolicyDecisionId(rawPolicy.policyId) ??
      normalizePolicyDecisionId(rawPolicy.id) ??
      null;
    const normalizedPolicyHash =
      typeof policyHashUsed === "string" && /^[0-9a-f]{64}$/.test(policyHashUsed.trim().toLowerCase())
        ? policyHashUsed.trim().toLowerCase()
        : null;
    const normalizedVerificationMethodHash =
      typeof verificationMethodHashUsed === "string" && /^[0-9a-f]{64}$/.test(verificationMethodHashUsed.trim().toLowerCase())
        ? verificationMethodHashUsed.trim().toLowerCase()
        : null;
    return normalizeForCanonicalJson(
      {
        fingerprintVersion: "PolicyDecisionFingerprint.v1",
        policyId,
        policyVersion,
        policyHash: normalizedPolicyHash,
        verificationMethodHash: normalizedVerificationMethodHash,
        evaluationHash: computePolicyDecisionEvaluationHash({
          policyHashUsed: normalizedPolicyHash,
          verificationMethodHashUsed: normalizedVerificationMethodHash,
          policyDecision
        })
      },
      { path: "$" }
    );
  }

  async function getArbitrationCaseRecord({ tenantId, caseId }) {
    if (typeof store.getArbitrationCase === "function") return store.getArbitrationCase({ tenantId, caseId });
    if (store.arbitrationCases instanceof Map) return store.arbitrationCases.get(makeScopedKey({ tenantId, id: String(caseId) })) ?? null;
    throw new TypeError("arbitration cases not supported for this store");
  }

  async function listArbitrationCaseRecords({ tenantId, runId = null, disputeId = null, status = null, limit = 200, offset = 0 } = {}) {
    if (typeof store.listArbitrationCases === "function") {
      return store.listArbitrationCases({ tenantId, runId, disputeId, status, limit, offset });
    }
    if (!(store.arbitrationCases instanceof Map)) throw new TypeError("arbitration cases not supported for this store");
    const statusFilter = typeof status === "string" && status.trim() !== "" ? status.trim().toLowerCase() : null;
    const rows = [];
    for (const row of store.arbitrationCases.values()) {
      if (!row || typeof row !== "object") continue;
      if (normalizeTenantId(row.tenantId ?? DEFAULT_TENANT_ID) !== normalizeTenantId(tenantId ?? DEFAULT_TENANT_ID)) continue;
      if (runId !== null && String(row.runId ?? "") !== String(runId)) continue;
      if (disputeId !== null && String(row.disputeId ?? "") !== String(disputeId)) continue;
      if (statusFilter && String(row.status ?? "").toLowerCase() !== statusFilter) continue;
      rows.push(row);
    }
    rows.sort((left, right) => String(left.caseId ?? "").localeCompare(String(right.caseId ?? "")));
    const safeLimit = Number.isSafeInteger(limit) && limit > 0 ? Math.min(1000, limit) : 200;
    const safeOffset = Number.isSafeInteger(offset) && offset >= 0 ? offset : 0;
    return rows.slice(safeOffset, safeOffset + safeLimit);
  }

  async function listArbitrationCaseRecordsAll({
    tenantId,
    runId = null,
    disputeId = null,
    status = null,
    pageSize = 1000
  } = {}) {
    const normalizedPageSize =
      Number.isSafeInteger(pageSize) && pageSize > 0 ? Math.min(1000, pageSize) : 1000;
    const all = [];
    let offset = 0;
    while (true) {
      const chunk = await listArbitrationCaseRecords({
        tenantId,
        runId,
        disputeId,
        status,
        limit: normalizedPageSize,
        offset
      });
      const rows = Array.isArray(chunk) ? chunk : [];
      if (!rows.length) break;
      all.push(...rows);
      if (rows.length < normalizedPageSize) break;
      offset += normalizedPageSize;
    }
    return all;
  }

  async function getToolCallHoldRecord({ tenantId, holdHash }) {
    if (typeof store.getToolCallHold === "function") return store.getToolCallHold({ tenantId, holdHash });
    if (store.toolCallHolds instanceof Map) return store.toolCallHolds.get(makeScopedKey({ tenantId, id: String(holdHash) })) ?? null;
    throw new TypeError("tool call holds not supported for this store");
  }

  async function listToolCallHoldRecords({ tenantId, agreementHash = null, status = null, limit = 200, offset = 0 } = {}) {
    if (typeof store.listToolCallHolds === "function") {
      return store.listToolCallHolds({ tenantId, agreementHash, status, limit, offset });
    }
    if (!(store.toolCallHolds instanceof Map)) throw new TypeError("tool call holds not supported for this store");
    const statusFilter = typeof status === "string" && status.trim() !== "" ? status.trim().toLowerCase() : null;
    const agreementFilter = typeof agreementHash === "string" && agreementHash.trim() !== "" ? agreementHash.trim().toLowerCase() : null;
    const rows = [];
    for (const row of store.toolCallHolds.values()) {
      if (!row || typeof row !== "object") continue;
      if (normalizeTenantId(row.tenantId ?? DEFAULT_TENANT_ID) !== normalizeTenantId(tenantId ?? DEFAULT_TENANT_ID)) continue;
      if (agreementFilter && String(row.agreementHash ?? "").toLowerCase() !== agreementFilter) continue;
      if (statusFilter && String(row.status ?? "").toLowerCase() !== statusFilter) continue;
      rows.push(row);
    }
    rows.sort((a, b) => String(a.holdHash ?? "").localeCompare(String(b.holdHash ?? "")));
    const safeLimit = Number.isSafeInteger(limit) && limit > 0 ? Math.min(1000, limit) : 200;
    const safeOffset = Number.isSafeInteger(offset) && offset >= 0 ? offset : 0;
    return rows.slice(safeOffset, safeOffset + safeLimit);
  }

  async function getSettlementAdjustmentRecord({ tenantId, adjustmentId }) {
    if (typeof store.getSettlementAdjustment === "function") return store.getSettlementAdjustment({ tenantId, adjustmentId });
    if (store.settlementAdjustments instanceof Map) {
      return store.settlementAdjustments.get(makeScopedKey({ tenantId, id: String(adjustmentId) })) ?? null;
    }
    throw new TypeError("settlement adjustments not supported for this store");
  }

  const FINANCE_RECONCILIATION_TRIAGE_SOURCE_TYPE = Object.freeze({
    FINANCE_RECONCILE: "finance_reconcile",
    MONEY_RAILS_RECONCILE: "money_rails_reconcile"
  });
  const FINANCE_RECONCILIATION_TRIAGE_STATUS = Object.freeze({
    OPEN: "open",
    ACKNOWLEDGED: "acknowledged",
    IN_PROGRESS: "in_progress",
    RESOLVED: "resolved",
    DISMISSED: "dismissed"
  });
  const FINANCE_RECONCILIATION_TRIAGE_SEVERITY = Object.freeze({
    LOW: "low",
    MEDIUM: "medium",
    HIGH: "high",
    CRITICAL: "critical"
  });
  const FINANCE_RECONCILIATION_TRIAGE_STATUS_SET = new Set(Object.values(FINANCE_RECONCILIATION_TRIAGE_STATUS));
  const FINANCE_RECONCILIATION_TRIAGE_SOURCE_TYPE_SET = new Set(Object.values(FINANCE_RECONCILIATION_TRIAGE_SOURCE_TYPE));
  const FINANCE_RECONCILIATION_TRIAGE_SEVERITY_SET = new Set(Object.values(FINANCE_RECONCILIATION_TRIAGE_SEVERITY));

  function normalizeFinanceReconciliationTriageSourceType(value, { allowNull = false, fieldName = "sourceType" } = {}) {
    if (value === null || value === undefined || String(value).trim() === "") {
      if (allowNull) return null;
      throw new TypeError(`${fieldName} is required`);
    }
    const normalized = String(value).trim().toLowerCase();
    if (!FINANCE_RECONCILIATION_TRIAGE_SOURCE_TYPE_SET.has(normalized)) {
      throw new TypeError(`${fieldName} must be one of: ${Array.from(FINANCE_RECONCILIATION_TRIAGE_SOURCE_TYPE_SET).join("|")}`);
    }
    return normalized;
  }

  function normalizeFinanceReconciliationTriageStatus(value, { allowNull = false, fieldName = "status" } = {}) {
    if (value === null || value === undefined || String(value).trim() === "") {
      if (allowNull) return null;
      throw new TypeError(`${fieldName} is required`);
    }
    const normalized = String(value).trim().toLowerCase();
    if (!FINANCE_RECONCILIATION_TRIAGE_STATUS_SET.has(normalized)) {
      throw new TypeError(`${fieldName} must be one of: ${Array.from(FINANCE_RECONCILIATION_TRIAGE_STATUS_SET).join("|")}`);
    }
    return normalized;
  }

  function normalizeFinanceReconciliationTriageSeverity(value, { allowNull = true, fieldName = "severity" } = {}) {
    if (value === null || value === undefined || String(value).trim() === "") {
      if (allowNull) return null;
      throw new TypeError(`${fieldName} is required`);
    }
    const normalized = String(value).trim().toLowerCase();
    if (!FINANCE_RECONCILIATION_TRIAGE_SEVERITY_SET.has(normalized)) {
      throw new TypeError(`${fieldName} must be one of: ${Array.from(FINANCE_RECONCILIATION_TRIAGE_SEVERITY_SET).join("|")}`);
    }
    return normalized;
  }

  function normalizeNonEmptyStringOrNull(value) {
    if (value === null || value === undefined) return null;
    const text = String(value).trim();
    return text ? text : null;
  }

  function normalizeFinanceReconciliationPeriod(value, { fieldName = "period", allowNull = false } = {}) {
    const normalized = normalizeBillingPeriodInput(value, { defaultToNow: false });
    if (!normalized) {
      if (allowNull) return null;
      throw new TypeError(`${fieldName} is required`);
    }
    return normalized;
  }

  function buildFinanceReconciliationTriageKey({ sourceType, period, providerId = null, mismatchType, mismatchKey }) {
    const normalizedSourceType = normalizeFinanceReconciliationTriageSourceType(sourceType, { allowNull: false, fieldName: "sourceType" });
    const normalizedPeriod = normalizeFinanceReconciliationPeriod(period, { fieldName: "period", allowNull: false });
    const normalizedProviderId = normalizeNonEmptyStringOrNull(providerId);
    const normalizedMismatchType = normalizeNonEmptyStringOrNull(mismatchType);
    const normalizedMismatchKey = normalizeNonEmptyStringOrNull(mismatchKey);
    if (!normalizedMismatchType) throw new TypeError("mismatchType is required");
    if (!normalizedMismatchKey) throw new TypeError("mismatchKey is required");
    const raw = [
      normalizedSourceType,
      normalizedPeriod,
      normalizedProviderId ?? "none",
      normalizedMismatchType,
      normalizedMismatchKey
    ].join("\n");
    return `frt_${normalizedPeriod.replaceAll("-", "")}_${sha256Hex(raw).slice(0, 24)}`;
  }

  function stableMismatchKeyFromObject(value, { prefix }) {
    const normalized = normalizeForCanonicalJson(value ?? {}, { path: "$" });
    const hash = sha256Hex(canonicalJsonStringify(normalized)).slice(0, 24);
    return `${prefix}_${hash}`;
  }

  function buildFinanceReconcileMismatchQueue({ period, reconcile }) {
    const normalizedPeriod = normalizeFinanceReconciliationPeriod(period, { fieldName: "period", allowNull: false });
    const mismatchCodes = Array.isArray(reconcile?.mismatchCodes) ? reconcile.mismatchCodes : [];
    return mismatchCodes
      .map((rawCode) => (typeof rawCode === "string" ? rawCode.trim() : ""))
      .filter(Boolean)
      .map((code) => ({
        sourceType: FINANCE_RECONCILIATION_TRIAGE_SOURCE_TYPE.FINANCE_RECONCILE,
        period: normalizedPeriod,
        providerId: null,
        mismatchType: "mismatch_code",
        mismatchKey: code,
        mismatchCode: code,
        severity: FINANCE_RECONCILIATION_TRIAGE_SEVERITY.HIGH,
        title: code,
        details: { mismatchCode: code }
      }));
  }

  function buildMoneyRailReconcileMismatchQueue({ period, providerId, mismatches }) {
    const normalizedPeriod = normalizeFinanceReconciliationPeriod(period, { fieldName: "period", allowNull: false });
    const normalizedProviderId = normalizeNonEmptyStringOrNull(providerId);
    const mismatchGroups = mismatches && typeof mismatches === "object" && !Array.isArray(mismatches) ? mismatches : {};
    const specs = [
      { field: "missingOperations", mismatchType: "missing_operation", severity: FINANCE_RECONCILIATION_TRIAGE_SEVERITY.CRITICAL, code: "MONEY_RAIL_MISSING_OPERATION" },
      { field: "amountMismatches", mismatchType: "amount_mismatch", severity: FINANCE_RECONCILIATION_TRIAGE_SEVERITY.HIGH, code: "MONEY_RAIL_AMOUNT_MISMATCH" },
      { field: "currencyMismatches", mismatchType: "currency_mismatch", severity: FINANCE_RECONCILIATION_TRIAGE_SEVERITY.HIGH, code: "MONEY_RAIL_CURRENCY_MISMATCH" },
      { field: "terminalFailures", mismatchType: "terminal_failure", severity: FINANCE_RECONCILIATION_TRIAGE_SEVERITY.CRITICAL, code: "MONEY_RAIL_TERMINAL_FAILURE" },
      { field: "unexpectedOperations", mismatchType: "unexpected_operation", severity: FINANCE_RECONCILIATION_TRIAGE_SEVERITY.HIGH, code: "MONEY_RAIL_UNEXPECTED_OPERATION" },
      { field: "duplicateExpected", mismatchType: "duplicate_expected", severity: FINANCE_RECONCILIATION_TRIAGE_SEVERITY.MEDIUM, code: "MONEY_RAIL_DUPLICATE_EXPECTED" }
    ];
    const queue = [];
    for (const spec of specs) {
      const rows = Array.isArray(mismatchGroups?.[spec.field]) ? mismatchGroups[spec.field] : [];
      for (const row of rows) {
        const operationId = normalizeNonEmptyStringOrNull(row?.operationId);
        const payoutKey = normalizeNonEmptyStringOrNull(row?.payoutKey);
        const mismatchKey =
          operationId ??
          payoutKey ??
          stableMismatchKeyFromObject(row, { prefix: spec.mismatchType });
        queue.push({
          sourceType: FINANCE_RECONCILIATION_TRIAGE_SOURCE_TYPE.MONEY_RAILS_RECONCILE,
          period: normalizedPeriod,
          providerId: normalizedProviderId,
          mismatchType: spec.mismatchType,
          mismatchKey,
          mismatchCode: spec.code,
          severity: spec.severity,
          title: operationId ? `${spec.mismatchType}:${operationId}` : `${spec.mismatchType}:${mismatchKey}`,
          details: row
        });
      }
    }
    return queue;
  }

  async function getFinanceReconciliationTriageRecord({ tenantId, triageKey }) {
    if (typeof store.getFinanceReconciliationTriage === "function") {
      return store.getFinanceReconciliationTriage({ tenantId, triageKey });
    }
    if (store.financeReconciliationTriages instanceof Map) {
      return store.financeReconciliationTriages.get(makeScopedKey({ tenantId, id: String(triageKey) })) ?? null;
    }
    throw new TypeError("finance reconciliation triage not supported for this store");
  }

  async function putFinanceReconciliationTriageRecord({ tenantId, triage, audit = null }) {
    if (typeof store.putFinanceReconciliationTriage === "function") {
      return store.putFinanceReconciliationTriage({ tenantId, triage, audit });
    }
    if (store.financeReconciliationTriages instanceof Map) {
      const key = makeScopedKey({ tenantId, id: String(triage?.triageKey ?? "") });
      store.financeReconciliationTriages.set(key, triage);
      if (audit && typeof store.appendOpsAudit === "function") {
        await store.appendOpsAudit({ tenantId, audit });
      }
      return triage;
    }
    throw new TypeError("finance reconciliation triage not supported for this store");
  }

  async function listFinanceReconciliationTriageRecords({
    tenantId,
    period = null,
    status = null,
    sourceType = null,
    providerId = null,
    limit = 200,
    offset = 0
  } = {}) {
    if (typeof store.listFinanceReconciliationTriages === "function") {
      return store.listFinanceReconciliationTriages({ tenantId, period, status, sourceType, providerId, limit, offset });
    }
    if (!(store.financeReconciliationTriages instanceof Map)) {
      throw new TypeError("finance reconciliation triage not supported for this store");
    }
    const normalizedTenantId = normalizeTenantId(tenantId ?? DEFAULT_TENANT_ID);
    const normalizedPeriod = normalizeFinanceReconciliationPeriod(period, { fieldName: "period", allowNull: true });
    const normalizedStatus = normalizeFinanceReconciliationTriageStatus(status, { fieldName: "status", allowNull: true });
    const normalizedSourceType = normalizeFinanceReconciliationTriageSourceType(sourceType, { fieldName: "sourceType", allowNull: true });
    const normalizedProviderId = normalizeNonEmptyStringOrNull(providerId);
    const rows = [];
    for (const row of store.financeReconciliationTriages.values()) {
      if (!row || typeof row !== "object") continue;
      if (normalizeTenantId(row.tenantId ?? DEFAULT_TENANT_ID) !== normalizedTenantId) continue;
      if (normalizedPeriod && String(row.period ?? "") !== normalizedPeriod) continue;
      if (normalizedStatus && String(row.status ?? "").toLowerCase() !== normalizedStatus) continue;
      if (normalizedSourceType && String(row.sourceType ?? "").toLowerCase() !== normalizedSourceType) continue;
      if (normalizedProviderId !== null && String(row.providerId ?? "") !== normalizedProviderId) continue;
      rows.push(row);
    }
    rows.sort((left, right) => {
      const leftMs = Date.parse(String(left?.updatedAt ?? left?.createdAt ?? ""));
      const rightMs = Date.parse(String(right?.updatedAt ?? right?.createdAt ?? ""));
      if (Number.isFinite(leftMs) && Number.isFinite(rightMs) && rightMs !== leftMs) return rightMs - leftMs;
      return String(left?.triageKey ?? "").localeCompare(String(right?.triageKey ?? ""));
    });
    const safeLimit = Number.isSafeInteger(limit) && limit > 0 ? Math.min(1000, limit) : 200;
    const safeOffset = Number.isSafeInteger(offset) && offset >= 0 ? offset : 0;
    return rows.slice(safeOffset, safeOffset + safeLimit);
  }

  async function listFinanceReconciliationTriageRecordsAll({
    tenantId,
    period = null,
    status = null,
    sourceType = null,
    providerId = null,
    pageSize = 1000
  } = {}) {
    const normalizedPageSize = Number.isSafeInteger(pageSize) && pageSize > 0 ? Math.min(1000, pageSize) : 1000;
    const out = [];
    let offset = 0;
    while (true) {
      const chunk = await listFinanceReconciliationTriageRecords({
        tenantId,
        period,
        status,
        sourceType,
        providerId,
        limit: normalizedPageSize,
        offset
      });
      const rows = Array.isArray(chunk) ? chunk : [];
      if (!rows.length) break;
      out.push(...rows);
      if (rows.length < normalizedPageSize) break;
      offset += normalizedPageSize;
    }
    return out;
  }

  async function decorateReconciliationMismatchQueueWithTriages({
    tenantId,
    period,
    sourceType,
    providerId = null,
    queue
  } = {}) {
    const rows = Array.isArray(queue) ? queue : [];
    if (!rows.length) {
      return {
        queue: [],
        summary: {
          total: 0,
          byStatus: {},
          unresolved: 0,
          resolved: 0
        }
      };
    }
    let triages = [];
    try {
      triages = await listFinanceReconciliationTriageRecordsAll({
        tenantId,
        period,
        sourceType,
        providerId,
        pageSize: 1000
      });
    } catch {
      triages = [];
    }
    const byTriageKey = new Map();
    for (const row of triages) {
      const triageKey = normalizeNonEmptyStringOrNull(row?.triageKey);
      if (!triageKey) continue;
      byTriageKey.set(triageKey, row);
    }
    const decorated = rows.map((item) => {
      const triageKey = buildFinanceReconciliationTriageKey({
        sourceType: sourceType ?? item?.sourceType,
        period,
        providerId,
        mismatchType: item?.mismatchType,
        mismatchKey: item?.mismatchKey
      });
      const triage = byTriageKey.get(triageKey) ?? null;
      return {
        ...item,
        triageKey,
        triage: triage
          ? {
              status: triage.status ?? null,
              ownerPrincipalId: triage.ownerPrincipalId ?? null,
              severity: triage.severity ?? null,
              notes: triage.notes ?? null,
              revision: triage.revision ?? null,
              updatedAt: triage.updatedAt ?? null
            }
          : null
      };
    });
    const byStatus = {};
    let unresolved = 0;
    let resolved = 0;
    for (const row of decorated) {
      const status = normalizeFinanceReconciliationTriageStatus(row?.triage?.status, { allowNull: true }) ?? FINANCE_RECONCILIATION_TRIAGE_STATUS.OPEN;
      byStatus[status] = (byStatus[status] ?? 0) + 1;
      if (status === FINANCE_RECONCILIATION_TRIAGE_STATUS.RESOLVED || status === FINANCE_RECONCILIATION_TRIAGE_STATUS.DISMISSED) resolved += 1;
      else unresolved += 1;
    }
    return {
      queue: decorated,
      summary: {
        total: decorated.length,
        byStatus,
        unresolved,
        resolved
      }
    };
  }

  const BILLABLE_USAGE_EVENT_SCHEMA_VERSION = "BillableUsageEvent.v1";
  const BILLABLE_USAGE_EVENT_TYPE = Object.freeze({
    VERIFIED_RUN: "verified_run",
    SETTLED_VOLUME: "settled_volume",
    ARBITRATION_USAGE: "arbitration_usage"
  });
  const BILLING_INVOICE_DRAFT_SCHEMA_VERSION = "BillingInvoiceDraft.v1";
  const BILLING_INVOICE_LINE_ITEM_CODE = Object.freeze({
    SUBSCRIPTION_BASE: "SUBSCRIPTION_BASE",
    VERIFIED_RUN_OVERAGE: "VERIFIED_RUN_OVERAGE",
    SETTLED_VOLUME_FEE: "SETTLED_VOLUME_FEE",
    ARBITRATION_USAGE_FEE: "ARBITRATION_USAGE_FEE"
  });

  function deriveBillablePeriod(occurredAt) {
    const normalized = typeof occurredAt === "string" && Number.isFinite(Date.parse(occurredAt)) ? new Date(occurredAt).toISOString() : nowIso();
    return String(normalized.slice(0, 7));
  }

  function normalizeBillingPeriodInput(value, { defaultToNow = true } = {}) {
    if (value === null || value === undefined || String(value).trim() === "") {
      return defaultToNow ? deriveBillablePeriod(nowIso()) : null;
    }
    const normalized = String(value).trim();
    if (!/^\d{4}-\d{2}$/.test(normalized)) {
      throw new TypeError("period must match YYYY-MM");
    }
    return normalized;
  }

  function makeHttpStatusError(statusCode, message, { code = null } = {}) {
    const err = new Error(message);
    err.statusCode = Number.isSafeInteger(statusCode) ? statusCode : 500;
    if (code) err.code = String(code);
    return err;
  }

  function listFinanceReconcileTenantIds({ tenantId = null, maxTenants = effectiveFinanceReconcileMaxTenants } = {}) {
    if (tenantId !== null && tenantId !== undefined) return [normalizeTenant(tenantId)];

    const safeMaxTenants = Number.isSafeInteger(maxTenants) && maxTenants > 0 ? Math.min(1000, maxTenants) : effectiveFinanceReconcileMaxTenants;
    const seen = new Set();
    const discovered = [];
    const maybePush = (value) => {
      const normalized = normalizeTenant(value ?? DEFAULT_TENANT_ID);
      if (seen.has(normalized)) return;
      seen.add(normalized);
      discovered.push(normalized);
    };

    maybePush(DEFAULT_TENANT_ID);

    if (store?.configByTenant instanceof Map) {
      for (const id of store.configByTenant.keys()) maybePush(id);
    }
    if (store?.jobs instanceof Map) {
      for (const job of store.jobs.values()) maybePush(job?.tenantId ?? DEFAULT_TENANT_ID);
    }
    if (store?.artifacts instanceof Map) {
      for (const artifact of store.artifacts.values()) maybePush(artifact?.tenantId ?? DEFAULT_TENANT_ID);
    }

    discovered.sort((a, b) => String(a).localeCompare(String(b)));
    return discovered.slice(0, safeMaxTenants);
  }

  function listFinanceReconcilePeriodsFromArtifacts({ artifacts, maxPeriodsPerTenant = effectiveFinanceReconcileMaxPeriodsPerTenant } = {}) {
    const periods = new Set();
    const rows = Array.isArray(artifacts) ? artifacts : [];
    for (const artifact of rows) {
      if (artifact?.artifactType !== ARTIFACT_TYPE.GL_BATCH_V1) continue;
      const rawPeriod = artifact?.period ?? null;
      try {
        const normalized = normalizeFinanceReconciliationPeriod(rawPeriod, { fieldName: "period", allowNull: false });
        periods.add(normalized);
      } catch {
        continue;
      }
    }
    const ordered = Array.from(periods).sort((a, b) => String(b).localeCompare(String(a)));
    const safeMaxPeriods = Number.isSafeInteger(maxPeriodsPerTenant) && maxPeriodsPerTenant > 0 ? Math.min(24, maxPeriodsPerTenant) : effectiveFinanceReconcileMaxPeriodsPerTenant;
    return ordered.slice(0, safeMaxPeriods);
  }

  function listMoneyRailReconcilePeriodsFromArtifacts({ artifacts, maxPeriodsPerTenant = effectiveMoneyRailReconcileMaxPeriodsPerTenant } = {}) {
    const periods = new Set();
    const rows = Array.isArray(artifacts) ? artifacts : [];
    for (const artifact of rows) {
      if (artifact?.artifactType !== ARTIFACT_TYPE.PAYOUT_INSTRUCTION_V1) continue;
      const rawPeriod = artifact?.period ?? null;
      try {
        const normalized = normalizeFinanceReconciliationPeriod(rawPeriod, { fieldName: "period", allowNull: false });
        periods.add(normalized);
      } catch {
        continue;
      }
    }
    const ordered = Array.from(periods).sort((a, b) => String(b).localeCompare(String(a)));
    const safeMaxPeriods =
      Number.isSafeInteger(maxPeriodsPerTenant) && maxPeriodsPerTenant > 0
        ? Math.min(24, maxPeriodsPerTenant)
        : effectiveMoneyRailReconcileMaxPeriodsPerTenant;
    return ordered.slice(0, safeMaxPeriods);
  }

  function listMoneyRailProviderIdsForReconcile({ providerId = null, maxProvidersPerTenant = effectiveMoneyRailReconcileMaxProvidersPerTenant } = {}) {
    if (providerId !== null && providerId !== undefined && String(providerId).trim() !== "") {
      return [String(providerId).trim()];
    }
    const safeMaxProviders =
      Number.isSafeInteger(maxProvidersPerTenant) && maxProvidersPerTenant > 0
        ? Math.min(200, maxProvidersPerTenant)
        : effectiveMoneyRailReconcileMaxProvidersPerTenant;
    const ids = Array.from(moneyRailAdaptersByProviderId.keys()).sort((a, b) => String(a).localeCompare(String(b)));
    return ids.slice(0, safeMaxProviders);
  }

  async function computeFinanceReconcileReport({
    tenantId,
    period,
    persist = false,
    includeTriages = true
  } = {}) {
    const normalizedTenantId = normalizeTenant(tenantId ?? DEFAULT_TENANT_ID);
    const normalizedPeriod = normalizeFinanceReconciliationPeriod(period, { fieldName: "period", allowNull: false });

    if (typeof store.listArtifacts !== "function") throw makeHttpStatusError(501, "artifacts not supported for this store");

    const artifacts = await store.listArtifacts({ tenantId: normalizedTenantId });
    const glCandidates = artifacts.filter((a) => a?.artifactType === ARTIFACT_TYPE.GL_BATCH_V1 && String(a?.period ?? "") === String(normalizedPeriod));
    if (!glCandidates.length) throw makeHttpStatusError(404, "GL batch not found");
    glCandidates.sort((a, b) => String(a?.generatedAt ?? a?.artifactId ?? "").localeCompare(String(b?.generatedAt ?? b?.artifactId ?? "")));
    const glBatch = glCandidates[glCandidates.length - 1];

    const partyStatements = artifacts
      .filter((a) => a?.artifactType === ARTIFACT_TYPE.PARTY_STATEMENT_V1 && String(a?.period ?? "") === String(normalizedPeriod))
      .sort((a, b) => String(a?.artifactId ?? "").localeCompare(String(b?.artifactId ?? "")));
    if (!partyStatements.length) throw makeHttpStatusError(404, "party statements not found");

    const reconcile = reconcileGlBatchAgainstPartyStatements({ glBatch, partyStatements });
    const reconcileBytes = new TextEncoder().encode(`${canonicalJsonStringify(reconcile)}\n`);
    const reportHash = sha256HexBytes(reconcileBytes);

    let artifactSummary = null;
    if (persist) {
      if (typeof store.putArtifact !== "function") throw makeHttpStatusError(501, "artifact persistence not supported for this store");

      const artifactId = `reconcile_${String(normalizedPeriod).replaceAll(/[^0-9a-zA-Z_-]/g, "_")}_${reportHash.slice(0, 24)}`;
      const generatedAtMsCandidates = [
        glBatch?.generatedAt ? Date.parse(String(glBatch.generatedAt)) : Number.NaN,
        ...partyStatements.map((statement) => (statement?.generatedAt ? Date.parse(String(statement.generatedAt)) : Number.NaN))
      ].filter((ms) => Number.isFinite(ms));
      const generatedAtMs = generatedAtMsCandidates.length ? Math.max(...generatedAtMsCandidates) : Date.parse(`${String(normalizedPeriod)}-01T00:00:00.000Z`);
      const generatedAt = Number.isFinite(generatedAtMs) ? new Date(generatedAtMs).toISOString() : nowIso();
      const artifactBody = normalizeForCanonicalJson(
        {
          schemaVersion: RECONCILE_REPORT_ARTIFACT_TYPE,
          artifactType: RECONCILE_REPORT_ARTIFACT_TYPE,
          artifactId,
          tenantId: normalizedTenantId,
          period: normalizedPeriod,
          generatedAt,
          reportHash,
          inputs: {
            glBatchArtifactId: glBatch?.artifactId ?? null,
            glBatchArtifactHash: glBatch?.artifactHash ?? null,
            partyStatementArtifactIds: partyStatements.map((a) => a?.artifactId).filter((id) => typeof id === "string" && id.trim() !== ""),
            partyStatementArtifactHashes: partyStatements
              .map((a) => a?.artifactHash)
              .filter((hash) => typeof hash === "string" && hash.trim() !== "")
          },
          reconcile
        },
        { path: "$" }
      );
      const artifactHash = computeArtifactHash(artifactBody);
      const artifact = { ...artifactBody, artifactHash };
      let storedArtifact = artifact;
      try {
        await store.putArtifact({ tenantId: normalizedTenantId, artifact });
      } catch (err) {
        if (err?.code !== "ARTIFACT_HASH_MISMATCH") throw err;
        if (typeof store.getArtifact !== "function") throw err;
        const existing = await store.getArtifact({ tenantId: normalizedTenantId, artifactId });
        if (!existing || typeof existing?.artifactHash !== "string" || existing.artifactHash.trim() === "") throw err;
        storedArtifact = existing;
      }

      let deliveriesCreated = 0;
      if (typeof store.createDelivery === "function") {
        const destinations = listDestinationsForTenant(normalizedTenantId).filter((d) => {
          const allowed = Array.isArray(d?.artifactTypes) && d.artifactTypes.length ? d.artifactTypes : null;
          return !allowed || allowed.includes(RECONCILE_REPORT_ARTIFACT_TYPE);
        });
        for (const dest of destinations) {
          const resolvedArtifactHash = String(storedArtifact.artifactHash);
          const dedupeKey = `${normalizedTenantId}:${dest.destinationId}:${RECONCILE_REPORT_ARTIFACT_TYPE}:${artifactId}:${resolvedArtifactHash}`;
          const scopeKey = `finance_reconcile:period:${normalizedPeriod}`;
          const orderSeq = Date.parse(generatedAt);
          const priority = 96;
          const orderKey = `${scopeKey}\n${String(orderSeq)}\n${String(priority)}\n${artifactId}`;
          try {
            await store.createDelivery({
              tenantId: normalizedTenantId,
              delivery: {
                destinationId: dest.destinationId,
                artifactType: RECONCILE_REPORT_ARTIFACT_TYPE,
                artifactId,
                artifactHash: resolvedArtifactHash,
                dedupeKey,
                scopeKey,
                orderSeq,
                priority,
                orderKey
              }
            });
            deliveriesCreated += 1;
          } catch (err) {
            if (err?.code === "DELIVERY_DEDUPE_CONFLICT") continue;
            throw err;
          }
        }
      }

      artifactSummary = {
        artifactId,
        artifactHash: String(storedArtifact.artifactHash),
        deliveriesCreated
      };
    }

    let triageQueue = null;
    let triageSummary = null;
    if (includeTriages) {
      const mismatchQueue = buildFinanceReconcileMismatchQueue({ period: normalizedPeriod, reconcile });
      const triageDecorated = await decorateReconciliationMismatchQueueWithTriages({
        tenantId: normalizedTenantId,
        period: normalizedPeriod,
        sourceType: FINANCE_RECONCILIATION_TRIAGE_SOURCE_TYPE.FINANCE_RECONCILE,
        providerId: null,
        queue: mismatchQueue
      });
      triageQueue = triageDecorated.queue;
      triageSummary = triageDecorated.summary;
    }

    return {
      tenantId: normalizedTenantId,
      period: normalizedPeriod,
      reportHash,
      reconcile,
      inputs: {
        glBatchArtifactId: glBatch?.artifactId ?? null,
        glBatchArtifactHash: glBatch?.artifactHash ?? null,
        partyStatementArtifactIds: partyStatements.map((a) => a?.artifactId).filter((id) => typeof id === "string" && id.trim() !== ""),
        partyStatementArtifactHashes: partyStatements.map((a) => a?.artifactHash).filter((hash) => typeof hash === "string" && hash.trim() !== "")
      },
      artifact: artifactSummary,
      triageQueue,
      triageSummary
    };
  }

  async function computeMoneyRailReconcileReport({
    tenantId,
    period,
    providerId,
    persist = false,
    includeTriages = true
  } = {}) {
    const normalizedTenantId = normalizeTenant(tenantId ?? DEFAULT_TENANT_ID);
    const normalizedPeriod = normalizeFinanceReconciliationPeriod(period, { fieldName: "period", allowNull: false });
    const normalizedProviderId = normalizeNonEmptyStringOrNull(providerId) ?? defaultMoneyRailProviderId;

    if (typeof store.listArtifacts !== "function") throw makeHttpStatusError(501, "artifacts not supported for this store");
    const adapter = getMoneyRailAdapter(normalizedProviderId);
    if (!adapter) throw makeHttpStatusError(404, "money rail provider not found");
    if (typeof adapter.listOperations !== "function") {
      throw makeHttpStatusError(409, "money rail provider does not support reconciliation listing");
    }

    const artifacts = await store.listArtifacts({ tenantId: normalizedTenantId });
    const payoutInstructions = artifacts
      .filter(
        (artifact) =>
          artifact?.artifactType === ARTIFACT_TYPE.PAYOUT_INSTRUCTION_V1 &&
          String(artifact?.period ?? "") === String(normalizedPeriod)
      )
      .map((artifact) => {
        const payoutKey =
          typeof artifact?.payoutKey === "string" && artifact.payoutKey.trim() !== "" ? artifact.payoutKey.trim() : null;
        const amountCents = Number.isSafeInteger(artifact?.payout?.amountCents) ? artifact.payout.amountCents : null;
        const currency =
          typeof artifact?.payout?.currency === "string" && artifact.payout.currency.trim() !== ""
            ? artifact.payout.currency.trim().toUpperCase()
            : "USD";
        return {
          artifactId: artifact?.artifactId ?? null,
          artifactHash: artifact?.artifactHash ?? null,
          payoutKey,
          operationId: payoutKey ? `mop_${payoutKey}` : null,
          amountCents,
          currency,
          partyId: typeof artifact?.partyId === "string" ? artifact.partyId : null,
          partyRole: typeof artifact?.partyRole === "string" ? artifact.partyRole : null
        };
      })
      .filter((row) => row.payoutKey && row.operationId && Number.isSafeInteger(row.amountCents))
      .sort(
        (a, b) =>
          String(a.operationId).localeCompare(String(b.operationId)) ||
          String(a.artifactId ?? "").localeCompare(String(b.artifactId ?? ""))
      );

    const expectedByOperationId = new Map();
    const duplicateExpected = [];
    for (const row of payoutInstructions) {
      if (!expectedByOperationId.has(row.operationId)) {
        expectedByOperationId.set(row.operationId, row);
        continue;
      }
      const first = expectedByOperationId.get(row.operationId);
      duplicateExpected.push({
        operationId: row.operationId,
        payoutKey: row.payoutKey,
        primaryArtifactId: first?.artifactId ?? null,
        duplicateArtifactId: row.artifactId ?? null
      });
    }

    const listedOperationsRaw = await adapter.listOperations({ tenantId: normalizedTenantId });
    const listedOperations = (Array.isArray(listedOperationsRaw) ? listedOperationsRaw : [])
      .filter((operation) => {
        if (!operation || typeof operation !== "object") return false;
        if (String(operation?.direction ?? "").toLowerCase() !== "payout") return false;
        const payoutKey = extractPayoutKeyFromMoneyRailOperation(operation);
        return payoutKeyMatchesPeriod({ payoutKey, period: normalizedPeriod });
      })
      .sort((a, b) => String(a?.operationId ?? "").localeCompare(String(b?.operationId ?? "")));

    const operationById = new Map();
    const operationStateCounts = Object.fromEntries(
      Object.values(MONEY_RAIL_OPERATION_STATE).map((state) => [state, 0])
    );
    for (const operation of listedOperations) {
      const operationId = typeof operation?.operationId === "string" ? operation.operationId : null;
      if (!operationId || operationById.has(operationId)) continue;
      operationById.set(operationId, operation);
      const state = String(operation?.state ?? "").toLowerCase();
      if (state in operationStateCounts) operationStateCounts[state] += 1;
    }

    const missingOperations = [];
    const amountMismatches = [];
    const currencyMismatches = [];
    const terminalFailures = [];
    const unexpectedOperations = [];
    let expectedPayoutAmountCents = 0;
    let matchedCount = 0;
    let settledCount = 0;
    let inFlightCount = 0;
    let cancelledCount = 0;
    for (const expected of expectedByOperationId.values()) {
      expectedPayoutAmountCents += expected.amountCents;
      const operation = operationById.get(expected.operationId) ?? null;
      if (!operation) {
        missingOperations.push({
          operationId: expected.operationId,
          payoutKey: expected.payoutKey,
          amountCents: expected.amountCents,
          currency: expected.currency,
          partyId: expected.partyId,
          artifactId: expected.artifactId
        });
        continue;
      }

      const actualAmountCents = Number.isSafeInteger(operation?.amountCents) ? operation.amountCents : null;
      if (actualAmountCents !== expected.amountCents) {
        amountMismatches.push({
          operationId: expected.operationId,
          payoutKey: expected.payoutKey,
          expectedAmountCents: expected.amountCents,
          actualAmountCents
        });
      }

      const actualCurrency =
        typeof operation?.currency === "string" && operation.currency.trim() !== ""
          ? operation.currency.trim().toUpperCase()
          : null;
      if (actualCurrency !== expected.currency) {
        currencyMismatches.push({
          operationId: expected.operationId,
          payoutKey: expected.payoutKey,
          expectedCurrency: expected.currency,
          actualCurrency
        });
      }

      const state = String(operation?.state ?? "").toLowerCase();
      if (state === MONEY_RAIL_OPERATION_STATE.FAILED || state === MONEY_RAIL_OPERATION_STATE.REVERSED) {
        terminalFailures.push({
          operationId: expected.operationId,
          payoutKey: expected.payoutKey,
          state,
          reasonCode: operation?.reasonCode ?? null
        });
      } else if (state === MONEY_RAIL_OPERATION_STATE.CONFIRMED) {
        settledCount += 1;
      } else if (state === MONEY_RAIL_OPERATION_STATE.CANCELLED) {
        cancelledCount += 1;
      } else {
        inFlightCount += 1;
      }

      matchedCount += 1;
    }

    for (const operation of operationById.values()) {
      const operationId = String(operation?.operationId ?? "");
      if (expectedByOperationId.has(operationId)) continue;
      unexpectedOperations.push({
        operationId,
        payoutKey: extractPayoutKeyFromMoneyRailOperation(operation),
        amountCents: Number.isSafeInteger(operation?.amountCents) ? operation.amountCents : null,
        currency: operation?.currency ?? null,
        state: operation?.state ?? null,
        reasonCode: operation?.reasonCode ?? null
      });
    }
    unexpectedOperations.sort((a, b) => String(a.operationId).localeCompare(String(b.operationId)));

    const criticalMismatchCount =
      missingOperations.length +
      amountMismatches.length +
      currencyMismatches.length +
      terminalFailures.length +
      unexpectedOperations.length +
      duplicateExpected.length;
    const status = criticalMismatchCount === 0 ? "pass" : "fail";
    const mismatchRows = {
      missingOperations,
      amountMismatches,
      currencyMismatches,
      terminalFailures,
      unexpectedOperations,
      duplicateExpected
    };
    const summary = {
      expectedPayoutCount: expectedByOperationId.size,
      expectedPayoutAmountCents,
      operationCount: operationById.size,
      matchedCount,
      settledCount,
      inFlightCount,
      cancelledCount,
      criticalMismatchCount,
      operationStateCounts
    };
    const reportCore = normalizeForCanonicalJson(
      {
        schemaVersion: MONEY_RAIL_RECONCILE_REPORT_ARTIFACT_TYPE,
        tenantId: normalizedTenantId,
        period: normalizedPeriod,
        providerId: normalizedProviderId,
        status,
        summary,
        mismatches: mismatchRows
      },
      { path: "$" }
    );
    const reportHash = sha256Hex(canonicalJsonStringify(reportCore));

    let artifactSummary = null;
    if (persist) {
      const artifactId = `money_rail_reconcile_${normalizedPeriod.replaceAll(/[^0-9a-zA-Z_-]/g, "_")}_${normalizedProviderId.replaceAll(
        /[^0-9a-zA-Z_-]/g,
        "_"
      )}_${reportHash.slice(0, 24)}`;
      const artifactBody = normalizeForCanonicalJson(
        {
          schemaVersion: MONEY_RAIL_RECONCILE_REPORT_ARTIFACT_TYPE,
          artifactType: MONEY_RAIL_RECONCILE_REPORT_ARTIFACT_TYPE,
          artifactId,
          tenantId: normalizedTenantId,
          period: normalizedPeriod,
          providerId: normalizedProviderId,
          generatedAt: nowIso(),
          reportHash,
          report: reportCore
        },
        { path: "$" }
      );
      const artifactHash = computeArtifactHash(artifactBody);
      const artifact = { ...artifactBody, artifactHash };
      let storedArtifact = artifact;
      try {
        await store.putArtifact({ tenantId: normalizedTenantId, artifact });
      } catch (err) {
        if (err?.code !== "ARTIFACT_HASH_MISMATCH") throw err;
        if (typeof store.getArtifact !== "function") throw err;
        const existing = await store.getArtifact({ tenantId: normalizedTenantId, artifactId });
        if (!existing || typeof existing?.artifactHash !== "string" || existing.artifactHash.trim() === "") throw err;
        storedArtifact = existing;
      }

      let deliveriesCreated = 0;
      if (typeof store.createDelivery === "function") {
        const destinations = listDestinationsForTenant(normalizedTenantId).filter((d) => {
          const allowed = Array.isArray(d?.artifactTypes) && d.artifactTypes.length ? d.artifactTypes : null;
          return !allowed || allowed.includes(MONEY_RAIL_RECONCILE_REPORT_ARTIFACT_TYPE);
        });
        for (const dest of destinations) {
          const resolvedArtifactHash = String(storedArtifact.artifactHash);
          const dedupeKey = `${normalizedTenantId}:${dest.destinationId}:${MONEY_RAIL_RECONCILE_REPORT_ARTIFACT_TYPE}:${artifactId}:${resolvedArtifactHash}`;
          const scopeKey = `money_rail_reconcile:period:${normalizedPeriod}:provider:${normalizedProviderId}`;
          const orderSeq = Date.parse(artifactBody.generatedAt);
          const priority = 96;
          const orderKey = `${scopeKey}\n${String(orderSeq)}\n${String(priority)}\n${artifactId}`;
          try {
            await store.createDelivery({
              tenantId: normalizedTenantId,
              delivery: {
                destinationId: dest.destinationId,
                artifactType: MONEY_RAIL_RECONCILE_REPORT_ARTIFACT_TYPE,
                artifactId,
                artifactHash: resolvedArtifactHash,
                dedupeKey,
                scopeKey,
                orderSeq,
                priority,
                orderKey
              }
            });
            deliveriesCreated += 1;
          } catch (err) {
            if (err?.code === "DELIVERY_DEDUPE_CONFLICT") continue;
            throw err;
          }
        }
      }
      artifactSummary = {
        artifactId,
        artifactHash: String(storedArtifact.artifactHash),
        deliveriesCreated
      };
    }

    const mismatchQueue = buildMoneyRailReconcileMismatchQueue({
      period: normalizedPeriod,
      providerId: normalizedProviderId,
      mismatches: mismatchRows
    });
    const triageDecorated = includeTriages
      ? await decorateReconciliationMismatchQueueWithTriages({
          tenantId: normalizedTenantId,
          period: normalizedPeriod,
          sourceType: FINANCE_RECONCILIATION_TRIAGE_SOURCE_TYPE.MONEY_RAILS_RECONCILE,
          providerId: normalizedProviderId,
          queue: mismatchQueue
        })
      : { queue: null, summary: null };

    return {
      ok: true,
      tenantId: normalizedTenantId,
      period: normalizedPeriod,
      providerId: normalizedProviderId,
      status,
      reportHash,
      summary,
      mismatches: mismatchRows,
      artifact: artifactSummary,
      triageQueue: triageDecorated.queue,
      triageSummary: triageDecorated.summary
    };
  }

  async function tickMoneyRailReconciliation({
    tenantId = null,
    period = null,
    providerId = null,
    maxTenants = effectiveMoneyRailReconcileMaxTenants,
    maxPeriodsPerTenant = effectiveMoneyRailReconcileMaxPeriodsPerTenant,
    maxProvidersPerTenant = effectiveMoneyRailReconcileMaxProvidersPerTenant,
    force = false,
    requireLock = false
  } = {}) {
    const startedAtWallMs = Date.now();
    const startedAt = nowIso();
    const startedAtMs = Date.parse(startedAt);
    const scopedTenantId = tenantId === null || tenantId === undefined ? null : normalizeTenant(tenantId);
    const normalizedPeriod = normalizeFinanceReconciliationPeriod(period, { fieldName: "period", allowNull: true });
    const normalizedProviderId = normalizeNonEmptyStringOrNull(providerId);
    const scope = scopedTenantId ? "tenant" : "global";
    const safeMaxTenants =
      Number.isSafeInteger(maxTenants) && maxTenants > 0 ? Math.min(1000, maxTenants) : effectiveMoneyRailReconcileMaxTenants;
    const safeMaxPeriodsPerTenant =
      Number.isSafeInteger(maxPeriodsPerTenant) && maxPeriodsPerTenant > 0
        ? Math.min(24, maxPeriodsPerTenant)
        : effectiveMoneyRailReconcileMaxPeriodsPerTenant;
    const safeMaxProvidersPerTenant =
      Number.isSafeInteger(maxProvidersPerTenant) && maxProvidersPerTenant > 0
        ? Math.min(200, maxProvidersPerTenant)
        : effectiveMoneyRailReconcileMaxProvidersPerTenant;

    if (!effectiveMoneyRailReconcileEnabled) {
      return {
        ok: true,
        scope,
        tenantId: scopedTenantId,
        period: normalizedPeriod,
        providerId: normalizedProviderId,
        skipped: true,
        reason: "disabled"
      };
    }
    if (typeof store.listArtifacts !== "function") {
      return {
        ok: false,
        scope,
        tenantId: scopedTenantId,
        period: normalizedPeriod,
        providerId: normalizedProviderId,
        code: "ARTIFACT_STORE_UNSUPPORTED",
        message: "artifacts not supported for this store"
      };
    }
    if (moneyRailReconcileState.inFlight) {
      return {
        ok: false,
        scope,
        tenantId: scopedTenantId,
        period: normalizedPeriod,
        providerId: normalizedProviderId,
        code: "MAINTENANCE_ALREADY_RUNNING",
        message: "money rail reconciliation maintenance is already running"
      };
    }
    if (
      force !== true &&
      effectiveMoneyRailReconcileIntervalSeconds > 0 &&
      Number.isFinite(moneyRailReconcileState.nextEligibleAtMs) &&
      moneyRailReconcileState.nextEligibleAtMs > startedAtMs
    ) {
      return {
        ok: true,
        scope,
        tenantId: scopedTenantId,
        period: normalizedPeriod,
        providerId: normalizedProviderId,
        skipped: true,
        reason: "interval_not_elapsed",
        nextEligibleAt: new Date(moneyRailReconcileState.nextEligibleAtMs).toISOString()
      };
    }

    const lockKey = MONEY_RAIL_RECONCILE_ADVISORY_LOCK_KEY;
    let locked = false;
    let lockClient = null;

    moneyRailReconcileState.inFlight = true;
    moneyRailReconcileState.lastRunAt = startedAt;
    moneyRailReconcileState.nextEligibleAtMs =
      effectiveMoneyRailReconcileIntervalSeconds > 0
        ? startedAtMs + effectiveMoneyRailReconcileIntervalSeconds * 1000
        : startedAtMs;
    try {
      if (requireLock) {
        if (store?.kind === "pg" && store?.pg?.pool) {
          lockClient = await store.pg.pool.connect();
          const res = await lockClient.query("SELECT pg_try_advisory_lock(hashtext($1)) AS ok", [lockKey]);
          locked = Boolean(res.rows[0]?.ok);
          if (!locked) {
            try {
              lockClient.release();
            } catch {}
            lockClient = null;
            return {
              ok: false,
              code: "MAINTENANCE_ALREADY_RUNNING",
              scope,
              tenantId: scopedTenantId,
              period: normalizedPeriod,
              providerId: normalizedProviderId,
              maxTenants: safeMaxTenants,
              maxPeriodsPerTenant: safeMaxPeriodsPerTenant,
              maxProvidersPerTenant: safeMaxProvidersPerTenant,
              runtimeMs: Date.now() - startedAtWallMs
            };
          }
        } else {
          store.__moneyRailReconcileLockHeld = store.__moneyRailReconcileLockHeld === true;
          if (store.__moneyRailReconcileLockHeld) {
            return {
              ok: false,
              code: "MAINTENANCE_ALREADY_RUNNING",
              scope,
              tenantId: scopedTenantId,
              period: normalizedPeriod,
              providerId: normalizedProviderId,
              maxTenants: safeMaxTenants,
              maxPeriodsPerTenant: safeMaxPeriodsPerTenant,
              maxProvidersPerTenant: safeMaxProvidersPerTenant,
              runtimeMs: Date.now() - startedAtWallMs
            };
          }
          store.__moneyRailReconcileLockHeld = true;
          locked = true;
        }
      }

      const tenantIds = listFinanceReconcileTenantIds({ tenantId: scopedTenantId, maxTenants: safeMaxTenants });
      const results = [];
      let attempted = 0;
      let reconciled = 0;
      let passCount = 0;
      let failCount = 0;
      let skippedNoInputs = 0;
      let errored = 0;
      let artifactsPersisted = 0;
      let deliveriesCreated = 0;

      for (const currentTenantId of tenantIds) {
        const artifacts = await store.listArtifacts({ tenantId: currentTenantId });
        const periods = normalizedPeriod
          ? [normalizedPeriod]
          : listMoneyRailReconcilePeriodsFromArtifacts({ artifacts, maxPeriodsPerTenant: safeMaxPeriodsPerTenant });
        if (!periods.length) {
          skippedNoInputs += 1;
          results.push({ tenantId: currentTenantId, period: null, providerId: normalizedProviderId, status: "skipped", reason: "no_payout_instruction" });
          continue;
        }
        const providerIds = listMoneyRailProviderIdsForReconcile({
          providerId: normalizedProviderId,
          maxProvidersPerTenant: safeMaxProvidersPerTenant
        });
        if (!providerIds.length) {
          skippedNoInputs += 1;
          results.push({ tenantId: currentTenantId, period: periods[0] ?? null, providerId: null, status: "skipped", reason: "no_provider" });
          continue;
        }
        for (const currentPeriod of periods) {
          for (const currentProviderId of providerIds) {
            attempted += 1;
            try {
              // eslint-disable-next-line no-await-in-loop
              const report = await computeMoneyRailReconcileReport({
                tenantId: currentTenantId,
                period: currentPeriod,
                providerId: currentProviderId,
                persist: true,
                includeTriages: false
              });
              const status = String(report?.status ?? "unknown").toLowerCase();
              reconciled += 1;
              if (status === "pass") passCount += 1;
              else failCount += 1;
              if (report?.artifact) {
                artifactsPersisted += 1;
                deliveriesCreated += Number(report.artifact.deliveriesCreated ?? 0);
              }
              results.push({
                tenantId: currentTenantId,
                period: currentPeriod,
                providerId: currentProviderId,
                status,
                reportHash: report?.reportHash ?? null,
                artifactId: report?.artifact?.artifactId ?? null
              });
            } catch (err) {
              const statusCode = Number(err?.statusCode);
              if (statusCode === 404) {
                skippedNoInputs += 1;
                results.push({
                  tenantId: currentTenantId,
                  period: currentPeriod,
                  providerId: currentProviderId,
                  status: "skipped",
                  reason: err?.message ?? "inputs_missing"
                });
                continue;
              }
              errored += 1;
              results.push({
                tenantId: currentTenantId,
                period: currentPeriod,
                providerId: currentProviderId,
                status: "error",
                code: err?.code ?? null,
                error: err?.message ?? "unknown error"
              });
            }
          }
        }
      }

      const completedAt = nowIso();
      const runtimeMs = Date.now() - startedAtWallMs;
      const ok = errored === 0;
      const summary = {
        tenantCount: tenantIds.length,
        attempted,
        reconciled,
        passCount,
        failCount,
        skippedNoInputs,
        errored,
        artifactsPersisted,
        deliveriesCreated
      };
      const result = {
        ok,
        scope,
        tenantId: scopedTenantId,
        period: normalizedPeriod,
        providerId: normalizedProviderId,
        force: force === true,
        maxTenants: safeMaxTenants,
        maxPeriodsPerTenant: safeMaxPeriodsPerTenant,
        maxProvidersPerTenant: safeMaxProvidersPerTenant,
        startedAt,
        completedAt,
        runtimeMs,
        summary,
        results
      };

      if (ok) moneyRailReconcileState.lastSuccessAt = completedAt;
      moneyRailReconcileState.lastResult = result;
      try {
        store.__moneyRailReconcileLastRunAt = startedAt;
        if (ok) store.__moneyRailReconcileLastSuccessAt = completedAt;
        store.__moneyRailReconcileLastResult = result;
      } catch {}

      metricInc("maintenance_runs_total", { kind: "money_rails_reconcile", result: ok ? "ok" : "error", scope }, 1);
      metricGauge("maintenance_last_run_ok_gauge", { kind: "money_rails_reconcile" }, ok ? 1 : 0);
      if (!ok) metricInc("maintenance_fail_total", { kind: "money_rails_reconcile", scope }, 1);

      return result;
    } catch (err) {
      const completedAt = nowIso();
      const failure = {
        ok: false,
        scope,
        tenantId: scopedTenantId,
        period: normalizedPeriod,
        providerId: normalizedProviderId,
        startedAt,
        completedAt,
        runtimeMs: Date.now() - startedAtWallMs,
        error: err?.message ?? "unknown error"
      };
      moneyRailReconcileState.lastResult = failure;
      try {
        store.__moneyRailReconcileLastRunAt = startedAt;
        store.__moneyRailReconcileLastResult = failure;
      } catch {}
      metricInc("maintenance_runs_total", { kind: "money_rails_reconcile", result: "error", scope }, 1);
      metricGauge("maintenance_last_run_ok_gauge", { kind: "money_rails_reconcile" }, 0);
      metricInc("maintenance_fail_total", { kind: "money_rails_reconcile", scope }, 1);
      return failure;
    } finally {
      moneyRailReconcileState.inFlight = false;
      if (requireLock) {
        if (lockClient) {
          try {
            await lockClient.query("SELECT pg_advisory_unlock(hashtext($1))", [lockKey]);
          } catch {}
          try {
            lockClient.release();
          } catch {}
        } else if (locked && store && typeof store === "object") {
          try {
            store.__moneyRailReconcileLockHeld = false;
          } catch {}
        }
      }
    }
  }

  async function tickFinanceReconciliation({
    tenantId = null,
    period = null,
    maxTenants = effectiveFinanceReconcileMaxTenants,
    maxPeriodsPerTenant = effectiveFinanceReconcileMaxPeriodsPerTenant,
    force = false,
    requireLock = false
  } = {}) {
    const startedAtWallMs = Date.now();
    const startedAt = nowIso();
    const startedAtMs = Date.parse(startedAt);
    const scopedTenantId = tenantId === null || tenantId === undefined ? null : normalizeTenant(tenantId);
    const scope = scopedTenantId ? "tenant" : "global";
    const normalizedPeriod = normalizeFinanceReconciliationPeriod(period, { fieldName: "period", allowNull: true });
    const safeMaxTenants = Number.isSafeInteger(maxTenants) && maxTenants > 0 ? Math.min(1000, maxTenants) : effectiveFinanceReconcileMaxTenants;
    const safeMaxPeriodsPerTenant =
      Number.isSafeInteger(maxPeriodsPerTenant) && maxPeriodsPerTenant > 0
        ? Math.min(24, maxPeriodsPerTenant)
        : effectiveFinanceReconcileMaxPeriodsPerTenant;

    if (!effectiveFinanceReconcileEnabled) {
      return {
        ok: true,
        scope,
        tenantId: scopedTenantId,
        period: normalizedPeriod,
        skipped: true,
        reason: "disabled"
      };
    }
    if (typeof store.listArtifacts !== "function") {
      return {
        ok: false,
        scope,
        tenantId: scopedTenantId,
        period: normalizedPeriod,
        code: "ARTIFACT_STORE_UNSUPPORTED",
        message: "artifacts not supported for this store"
      };
    }
    if (financeReconcileState.inFlight) {
      return {
        ok: false,
        scope,
        tenantId: scopedTenantId,
        period: normalizedPeriod,
        code: "MAINTENANCE_ALREADY_RUNNING",
        message: "finance reconciliation maintenance is already running"
      };
    }
    if (
      force !== true &&
      effectiveFinanceReconcileIntervalSeconds > 0 &&
      Number.isFinite(financeReconcileState.nextEligibleAtMs) &&
      financeReconcileState.nextEligibleAtMs > startedAtMs
    ) {
      return {
        ok: true,
        scope,
        tenantId: scopedTenantId,
        period: normalizedPeriod,
        skipped: true,
        reason: "interval_not_elapsed",
        nextEligibleAt: new Date(financeReconcileState.nextEligibleAtMs).toISOString()
      };
    }

    const lockKey = FINANCE_RECONCILE_ADVISORY_LOCK_KEY;
    let locked = false;
    let lockClient = null;

    financeReconcileState.inFlight = true;
    financeReconcileState.lastRunAt = startedAt;
    financeReconcileState.nextEligibleAtMs =
      effectiveFinanceReconcileIntervalSeconds > 0
        ? startedAtMs + effectiveFinanceReconcileIntervalSeconds * 1000
        : startedAtMs;
    try {
      if (requireLock) {
        if (store?.kind === "pg" && store?.pg?.pool) {
          lockClient = await store.pg.pool.connect();
          const res = await lockClient.query("SELECT pg_try_advisory_lock(hashtext($1)) AS ok", [lockKey]);
          locked = Boolean(res.rows[0]?.ok);
          if (!locked) {
            try {
              lockClient.release();
            } catch {}
            lockClient = null;
            return {
              ok: false,
              code: "MAINTENANCE_ALREADY_RUNNING",
              scope,
              tenantId: scopedTenantId,
              period: normalizedPeriod,
              maxTenants: safeMaxTenants,
              maxPeriodsPerTenant: safeMaxPeriodsPerTenant,
              runtimeMs: Date.now() - startedAtWallMs
            };
          }
        } else {
          store.__financeReconcileLockHeld = store.__financeReconcileLockHeld === true;
          if (store.__financeReconcileLockHeld) {
            return {
              ok: false,
              code: "MAINTENANCE_ALREADY_RUNNING",
              scope,
              tenantId: scopedTenantId,
              period: normalizedPeriod,
              maxTenants: safeMaxTenants,
              maxPeriodsPerTenant: safeMaxPeriodsPerTenant,
              runtimeMs: Date.now() - startedAtWallMs
            };
          }
          store.__financeReconcileLockHeld = true;
          locked = true;
        }
      }

      const tenantIds = listFinanceReconcileTenantIds({ tenantId: scopedTenantId, maxTenants: safeMaxTenants });
      const results = [];
      let attemptedPeriods = 0;
      let reconciledPeriods = 0;
      let passCount = 0;
      let failCount = 0;
      let skippedNoInputs = 0;
      let erroredPeriods = 0;
      let artifactsPersisted = 0;
      let deliveriesCreated = 0;

      for (const currentTenantId of tenantIds) {
        const artifacts = await store.listArtifacts({ tenantId: currentTenantId });
        const periods = normalizedPeriod ? [normalizedPeriod] : listFinanceReconcilePeriodsFromArtifacts({ artifacts, maxPeriodsPerTenant: safeMaxPeriodsPerTenant });
        if (!periods.length) {
          skippedNoInputs += 1;
          results.push({ tenantId: currentTenantId, period: null, status: "skipped", reason: "no_gl_batch" });
          continue;
        }

        for (const currentPeriod of periods) {
          attemptedPeriods += 1;
          try {
            // eslint-disable-next-line no-await-in-loop
            const report = await computeFinanceReconcileReport({
              tenantId: currentTenantId,
              period: currentPeriod,
              persist: true,
              includeTriages: false
            });
            const status = report?.reconcile?.ok === true ? "pass" : "fail";
            reconciledPeriods += 1;
            if (status === "pass") passCount += 1;
            else failCount += 1;
            if (report?.artifact) {
              artifactsPersisted += 1;
              deliveriesCreated += Number(report.artifact.deliveriesCreated ?? 0);
            }
            results.push({
              tenantId: currentTenantId,
              period: currentPeriod,
              status,
              reportHash: report.reportHash ?? null,
              artifactId: report?.artifact?.artifactId ?? null
            });
          } catch (err) {
            if (Number(err?.statusCode) === 404) {
              skippedNoInputs += 1;
              results.push({
                tenantId: currentTenantId,
                period: currentPeriod,
                status: "skipped",
                reason: err?.message ?? "inputs_missing"
              });
              continue;
            }
            erroredPeriods += 1;
            results.push({
              tenantId: currentTenantId,
              period: currentPeriod,
              status: "error",
              code: err?.code ?? null,
              error: err?.message ?? "unknown error"
            });
          }
        }
      }

      const completedAt = nowIso();
      const runtimeMs = Date.now() - startedAtWallMs;
      const ok = erroredPeriods === 0;
      const summary = {
        tenantCount: tenantIds.length,
        attemptedPeriods,
        reconciledPeriods,
        passCount,
        failCount,
        skippedNoInputs,
        erroredPeriods,
        artifactsPersisted,
        deliveriesCreated
      };
      const result = {
        ok,
        scope,
        tenantId: scopedTenantId,
        period: normalizedPeriod,
        force: force === true,
        maxTenants: safeMaxTenants,
        maxPeriodsPerTenant: safeMaxPeriodsPerTenant,
        startedAt,
        completedAt,
        runtimeMs,
        summary,
        results
      };

      if (ok) financeReconcileState.lastSuccessAt = completedAt;
      financeReconcileState.lastResult = result;
      try {
        store.__financeReconcileLastRunAt = startedAt;
        if (ok) store.__financeReconcileLastSuccessAt = completedAt;
        store.__financeReconcileLastResult = result;
      } catch {}

      metricInc("maintenance_runs_total", { kind: "finance_reconcile", result: ok ? "ok" : "error", scope }, 1);
      metricGauge("maintenance_last_run_ok_gauge", { kind: "finance_reconcile" }, ok ? 1 : 0);
      if (!ok) metricInc("maintenance_fail_total", { kind: "finance_reconcile", scope }, 1);

      return result;
    } catch (err) {
      const completedAt = nowIso();
      const failure = {
        ok: false,
        scope,
        tenantId: scopedTenantId,
        period: normalizedPeriod,
        startedAt,
        completedAt,
        runtimeMs: Date.now() - startedAtWallMs,
        error: err?.message ?? "unknown error"
      };
      financeReconcileState.lastResult = failure;
      try {
        store.__financeReconcileLastRunAt = startedAt;
        store.__financeReconcileLastResult = failure;
      } catch {}
      metricInc("maintenance_runs_total", { kind: "finance_reconcile", result: "error", scope }, 1);
      metricGauge("maintenance_last_run_ok_gauge", { kind: "finance_reconcile" }, 0);
      metricInc("maintenance_fail_total", { kind: "finance_reconcile", scope }, 1);
      return failure;
    } finally {
      financeReconcileState.inFlight = false;
      if (requireLock) {
        if (lockClient) {
          try {
            await lockClient.query("SELECT pg_advisory_unlock(hashtext($1))", [lockKey]);
          } catch {}
          try {
            lockClient.release();
          } catch {}
        } else if (locked && store && typeof store === "object") {
          try {
            store.__financeReconcileLockHeld = false;
          } catch {}
        }
      }
    }
  }

  function resolveActiveSubscriptionPlanId(billingCfg) {
    const subscription = normalizeBillingSubscriptionRecord(billingCfg?.subscription ?? null, {
      allowNull: true,
      strictPlan: false
    });
    const subscriptionPlanId = subscription?.plan ?? null;
    const subscriptionStatus =
      typeof subscription?.status === "string" && subscription.status.trim() !== ""
        ? subscription.status.trim().toLowerCase()
        : null;
    const subscriptionPlanEligible =
      Boolean(subscriptionPlanId) &&
      subscriptionStatus !== "canceled" &&
      subscriptionStatus !== "cancelled" &&
      subscriptionStatus !== "incomplete_expired" &&
      subscriptionStatus !== "ended" &&
      subscriptionStatus !== "terminated";
    return subscriptionPlanEligible ? subscriptionPlanId : null;
  }

  function resolveTenantBillingPlan({ tenantId }) {
    const cfg = getTenantConfig(tenantId) ?? {};
    const billingCfg = cfg?.billing && typeof cfg.billing === "object" && !Array.isArray(cfg.billing) ? cfg.billing : {};
    const configuredPlanId = normalizeBillingPlanId(billingCfg.plan ?? BILLING_PLAN_ID.FREE, {
      allowNull: false,
      defaultPlan: BILLING_PLAN_ID.FREE
    });
    const planId = resolveActiveSubscriptionPlanId(billingCfg) ?? configuredPlanId;
    const overrides = normalizeBillingPlanOverrides(billingCfg.planOverrides ?? null, { allowNull: true });
    const hardLimitEnforced = effectiveBillingPlanEnforcementEnabled && billingCfg.hardLimitEnforced !== false;
    return resolveBillingPlan({
      planId,
      overrides,
      hardLimitEnforced
    });
  }

  function normalizeOptionalNonNegativeSafeInt(value, { fieldName, allowNull = true } = {}) {
    if (value === null || value === undefined || String(value).trim() === "") {
      if (allowNull) return null;
      throw new TypeError(`${fieldName} is required`);
    }
    const n = Number(value);
    if (!Number.isSafeInteger(n) || n < 0) throw new TypeError(`${fieldName} must be a non-negative safe integer`);
    return n;
  }

  const MONEY_RAIL_CHARGEBACK_NEGATIVE_BALANCE_MODE = Object.freeze({
    HOLD: "hold",
    NET: "net"
  });

  function normalizeMoneyRailChargebackNegativeBalanceMode(value, { fieldName = "moneyRails.chargebacks.negativeBalanceMode" } = {}) {
    const normalized = normalizeNonEmptyStringOrNull(value);
    if (normalized === null) return MONEY_RAIL_CHARGEBACK_NEGATIVE_BALANCE_MODE.HOLD;
    const mode = String(normalized).toLowerCase();
    if (
      mode !== MONEY_RAIL_CHARGEBACK_NEGATIVE_BALANCE_MODE.HOLD &&
      mode !== MONEY_RAIL_CHARGEBACK_NEGATIVE_BALANCE_MODE.NET
    ) {
      throw new TypeError(`${fieldName} must be hold|net`);
    }
    return mode;
  }

  function normalizeMoneyRailChargebackPolicy(value, { allowNull = true, nowAt = null } = {}) {
    if (value === null || value === undefined) {
      if (allowNull) return null;
      return {
        schemaVersion: "MoneyRailChargebackPolicy.v1",
        enabled: false,
        negativeBalanceMode: MONEY_RAIL_CHARGEBACK_NEGATIVE_BALANCE_MODE.HOLD,
        maxOutstandingCents: null,
        updatedAt: nowAt ?? null
      };
    }
    if (!value || typeof value !== "object" || Array.isArray(value)) {
      throw new TypeError("moneyRails.chargebacks must be an object or null");
    }
    return {
      schemaVersion: "MoneyRailChargebackPolicy.v1",
      enabled: value.enabled === true,
      negativeBalanceMode: normalizeMoneyRailChargebackNegativeBalanceMode(value.negativeBalanceMode),
      maxOutstandingCents: normalizeOptionalNonNegativeSafeInt(value.maxOutstandingCents, {
        fieldName: "moneyRails.chargebacks.maxOutstandingCents",
        allowNull: true
      }),
      updatedAt: normalizeBillingTimestampInput(value.updatedAt) ?? nowAt ?? null
    };
  }

  function normalizeMoneyRailAllowedProviderIds(value, { fieldName = "moneyRails.allowedProviderIds" } = {}) {
    if (value === null || value === undefined) return null;
    if (!Array.isArray(value)) throw new TypeError(`${fieldName} must be an array or null`);
    const out = [];
    const seen = new Set();
    for (const raw of value) {
      const id = String(raw ?? "").trim();
      if (!id) throw new TypeError(`${fieldName} entries must be non-empty strings`);
      if (seen.has(id)) continue;
      seen.add(id);
      out.push(id);
    }
    return out.length ? out : [];
  }

  function normalizeStripeConnectAccountId(value, { fieldName = "moneyRails.connect.accountId", allowNull = false } = {}) {
    if (value === null || value === undefined || String(value).trim() === "") {
      if (allowNull) return null;
      throw new TypeError(`${fieldName} is required`);
    }
    const accountId = String(value).trim();
    if (!/^acct_[A-Za-z0-9_]+$/.test(accountId)) {
      throw new TypeError(`${fieldName} must match /^acct_[A-Za-z0-9_]+$/`);
    }
    return accountId;
  }

  const MONEY_RAIL_CONNECT_KYB_STATUS = Object.freeze({
    PENDING: "pending",
    RESTRICTED: "restricted",
    VERIFIED: "verified",
    REJECTED: "rejected",
    UNKNOWN: "unknown"
  });

  function normalizeUniqueStringList(value, { fieldName, allowNull = true } = {}) {
    if (value === null || value === undefined) {
      if (allowNull) return [];
      throw new TypeError(`${fieldName} is required`);
    }
    if (!Array.isArray(value)) throw new TypeError(`${fieldName} must be an array`);
    const out = [];
    const seen = new Set();
    for (const entry of value) {
      const v = normalizeNonEmptyStringOrNull(entry);
      if (!v) continue;
      if (seen.has(v)) continue;
      seen.add(v);
      out.push(v);
    }
    out.sort((a, b) => String(a).localeCompare(String(b)));
    return out;
  }

  function normalizeMoneyRailConnectKybStatus(value, { fieldName = "moneyRails.connect.accounts[].kybStatus", allowNull = true } = {}) {
    const normalized = normalizeNonEmptyStringOrNull(value);
    if (!normalized) {
      if (allowNull) return null;
      throw new TypeError(`${fieldName} is required`);
    }
    const status = String(normalized).toLowerCase();
    if (!Object.values(MONEY_RAIL_CONNECT_KYB_STATUS).includes(status)) {
      throw new TypeError(
        `${fieldName} must be ${Object.values(MONEY_RAIL_CONNECT_KYB_STATUS).join("|")}`
      );
    }
    return status;
  }

  function normalizeMoneyRailConnectAccounts(value, { nowAt = null } = {}) {
    if (value === null || value === undefined) return [];
    if (!Array.isArray(value)) throw new TypeError("moneyRails.connect.accounts must be an array");
    const out = [];
    const seen = new Set();
    for (const row of value) {
      if (!row || typeof row !== "object" || Array.isArray(row)) {
        throw new TypeError("moneyRails.connect.accounts[] must be an object");
      }
      const accountId = normalizeStripeConnectAccountId(row.accountId, {
        fieldName: "moneyRails.connect.accounts[].accountId",
        allowNull: false
      });
      if (seen.has(accountId)) continue;
      seen.add(accountId);
      const partyId = normalizeNonEmptyStringOrNull(row.partyId);
      const partyRole = normalizeNonEmptyStringOrNull(row.partyRole);
      const statusRaw = normalizeNonEmptyStringOrNull(row.status) ?? "active";
      const status = String(statusRaw).toLowerCase();
      if (status !== "active" && status !== "disabled") {
        throw new TypeError("moneyRails.connect.accounts[].status must be active|disabled");
      }
      out.push({
        schemaVersion: "MoneyRailConnectAccount.v1",
        accountId,
        partyId,
        partyRole,
        payoutsEnabled: row.payoutsEnabled !== false,
        transfersEnabled: row.transfersEnabled !== false,
        status,
        kybStatus: normalizeMoneyRailConnectKybStatus(row.kybStatus, {
          fieldName: "moneyRails.connect.accounts[].kybStatus",
          allowNull: true
        }),
        kybCurrentlyDue: normalizeUniqueStringList(row.kybCurrentlyDue, {
          fieldName: "moneyRails.connect.accounts[].kybCurrentlyDue",
          allowNull: true
        }),
        kybPendingVerification: normalizeUniqueStringList(row.kybPendingVerification, {
          fieldName: "moneyRails.connect.accounts[].kybPendingVerification",
          allowNull: true
        }),
        kybDisabledReason: normalizeNonEmptyStringOrNull(row.kybDisabledReason),
        kybLastSyncAt: normalizeBillingTimestampInput(row.kybLastSyncAt) ?? null,
        kybLastSyncError: normalizeNonEmptyStringOrNull(row.kybLastSyncError),
        updatedAt: normalizeBillingTimestampInput(row.updatedAt) ?? nowAt ?? null
      });
    }
    out.sort((a, b) => String(a.accountId).localeCompare(String(b.accountId)));
    return out;
  }

  function normalizeMoneyRailConnectConfig(value, { allowNull = true, nowAt = null } = {}) {
    if (value === null || value === undefined) {
      if (allowNull) return null;
      return {
        schemaVersion: "MoneyRailConnectConfig.v1",
        enabled: false,
        defaultAccountId: null,
        accounts: [],
        updatedAt: nowAt ?? null
      };
    }
    if (!value || typeof value !== "object" || Array.isArray(value)) {
      throw new TypeError("moneyRails.connect must be an object or null");
    }
    const accounts = normalizeMoneyRailConnectAccounts(value.accounts ?? [], { nowAt });
    const accountIds = new Set(accounts.map((row) => row.accountId));
    const defaultAccountId = normalizeStripeConnectAccountId(value.defaultAccountId, {
      fieldName: "moneyRails.connect.defaultAccountId",
      allowNull: true
    });
    if (defaultAccountId !== null && !accountIds.has(defaultAccountId)) {
      throw new TypeError("moneyRails.connect.defaultAccountId must reference an account in moneyRails.connect.accounts");
    }
    return {
      schemaVersion: "MoneyRailConnectConfig.v1",
      enabled: value.enabled === true,
      defaultAccountId,
      accounts,
      updatedAt: normalizeBillingTimestampInput(value.updatedAt) ?? nowAt ?? null
    };
  }

  function normalizeMoneyRailControls(input, { allowNull = true, defaultRealMoneyEnabled = false, nowAt = null } = {}) {
    if (input === null || input === undefined) {
      if (allowNull) return null;
      return {
        schemaVersion: "MoneyRailControls.v1",
        realMoneyEnabled: defaultRealMoneyEnabled === true,
        payoutKillSwitch: false,
        maxPayoutAmountCents: null,
        dailyPayoutLimitCents: null,
        allowedProviderIds: null,
        connect: null,
        chargebacks: null,
        updatedAt: nowAt ?? null
      };
    }
    if (typeof input !== "object" || Array.isArray(input)) {
      throw new TypeError("moneyRails must be an object or null");
    }
    return {
      schemaVersion: "MoneyRailControls.v1",
      realMoneyEnabled: input.realMoneyEnabled === true,
      payoutKillSwitch: input.payoutKillSwitch === true,
      maxPayoutAmountCents: normalizeOptionalNonNegativeSafeInt(input.maxPayoutAmountCents, {
        fieldName: "moneyRails.maxPayoutAmountCents",
        allowNull: true
      }),
      dailyPayoutLimitCents: normalizeOptionalNonNegativeSafeInt(input.dailyPayoutLimitCents, {
        fieldName: "moneyRails.dailyPayoutLimitCents",
        allowNull: true
      }),
      allowedProviderIds: normalizeMoneyRailAllowedProviderIds(input.allowedProviderIds),
      connect: normalizeMoneyRailConnectConfig(input.connect ?? null, { allowNull: true, nowAt }),
      chargebacks: normalizeMoneyRailChargebackPolicy(input.chargebacks ?? null, { allowNull: true, nowAt }),
      updatedAt: normalizeBillingTimestampInput(input.updatedAt) ?? nowAt ?? null
    };
  }

  function resolveTenantMoneyRailControls({ billingCfg = null } = {}) {
    const normalized = normalizeMoneyRailControls(billingCfg?.moneyRails ?? null, {
      allowNull: true,
      defaultRealMoneyEnabled: false,
      nowAt: null
    });
    if (normalized) return normalized;
    return {
      schemaVersion: "MoneyRailControls.v1",
      realMoneyEnabled: false,
      payoutKillSwitch: false,
      maxPayoutAmountCents: null,
      dailyPayoutLimitCents: null,
      allowedProviderIds: null,
      connect: normalizeMoneyRailConnectConfig(null, { allowNull: false, nowAt: null }),
      chargebacks: normalizeMoneyRailChargebackPolicy(null, { allowNull: false, nowAt: null }),
      updatedAt: null
    };
  }

  function resolveStripeConnectAccountForPayout({ connectConfig, partyId } = {}) {
    const connect = normalizeMoneyRailConnectConfig(connectConfig ?? null, { allowNull: false, nowAt: null });
    if (connect.enabled !== true) {
      return { ok: false, code: "STRIPE_CONNECT_DISABLED", message: "stripe connect payouts are disabled for this tenant" };
    }
    const isEligible = (row) =>
      row &&
      row.status === "active" &&
      row.payoutsEnabled === true;
    const accounts = Array.isArray(connect.accounts) ? connect.accounts : [];
    const byParty = accounts.find((row) => row.partyId === partyId && isEligible(row)) ?? null;
    if (byParty) return { ok: true, account: byParty };
    const byDefault =
      connect.defaultAccountId !== null
        ? accounts.find((row) => row.accountId === connect.defaultAccountId && isEligible(row)) ?? null
        : null;
    if (byDefault) return { ok: true, account: byDefault };
    return {
      ok: false,
      code: "STRIPE_CONNECT_ACCOUNT_REQUIRED",
      message: "no active Stripe Connect account is configured for this payout party"
    };
  }

  function isStripeMoneyRailProviderId(providerId) {
    return typeof providerId === "string" && providerId.trim().toLowerCase().startsWith("stripe");
  }

  function parseStripeConnectAccountFromCounterpartyRef(counterpartyRef) {
    const raw = normalizeNonEmptyStringOrNull(counterpartyRef);
    if (!raw || !raw.startsWith("stripe_connect:")) return null;
    const accountIdRaw = raw.slice("stripe_connect:".length);
    try {
      return normalizeStripeConnectAccountId(accountIdRaw, {
        fieldName: "counterpartyRef",
        allowNull: false
      });
    } catch {
      return null;
    }
  }

  function deriveStripeConnectKybSnapshot(stripeAccount) {
    const account = stripeAccount && typeof stripeAccount === "object" && !Array.isArray(stripeAccount) ? stripeAccount : {};
    const requirements =
      account.requirements && typeof account.requirements === "object" && !Array.isArray(account.requirements)
        ? account.requirements
        : {};
    const payoutsEnabled = account.payouts_enabled === true;
    const transfersEnabled = account.transfers_enabled === true;
    const detailsSubmitted = account.details_submitted === true;
    const kybCurrentlyDue = normalizeUniqueStringList(requirements.currently_due, {
      fieldName: "requirements.currently_due",
      allowNull: true
    });
    const kybPendingVerification = normalizeUniqueStringList(requirements.pending_verification, {
      fieldName: "requirements.pending_verification",
      allowNull: true
    });
    const kybDisabledReason =
      normalizeNonEmptyStringOrNull(requirements.disabled_reason) ??
      normalizeNonEmptyStringOrNull(account.disabled_reason);
    let kybStatus = MONEY_RAIL_CONNECT_KYB_STATUS.UNKNOWN;
    if (kybDisabledReason) {
      kybStatus = MONEY_RAIL_CONNECT_KYB_STATUS.REJECTED;
    } else if (
      payoutsEnabled === true &&
      transfersEnabled === true &&
      detailsSubmitted === true &&
      kybCurrentlyDue.length === 0 &&
      kybPendingVerification.length === 0
    ) {
      kybStatus = MONEY_RAIL_CONNECT_KYB_STATUS.VERIFIED;
    } else if (kybCurrentlyDue.length > 0 || kybPendingVerification.length > 0) {
      kybStatus = MONEY_RAIL_CONNECT_KYB_STATUS.PENDING;
    } else if (detailsSubmitted !== true) {
      kybStatus = MONEY_RAIL_CONNECT_KYB_STATUS.RESTRICTED;
    } else {
      kybStatus = MONEY_RAIL_CONNECT_KYB_STATUS.PENDING;
    }
    return {
      payoutsEnabled,
      transfersEnabled,
      kybStatus,
      kybCurrentlyDue,
      kybPendingVerification,
      kybDisabledReason
    };
  }

  function isMoneyRailExposureStateForDailyLimit(state) {
    const normalized = String(state ?? "").trim().toLowerCase();
    return (
      normalized === MONEY_RAIL_OPERATION_STATE.INITIATED ||
      normalized === MONEY_RAIL_OPERATION_STATE.SUBMITTED ||
      normalized === MONEY_RAIL_OPERATION_STATE.CONFIRMED
    );
  }

  function computeMoneyRailDailyPayoutExposureCents({ operations, dayKey }) {
    const list = Array.isArray(operations) ? operations : [];
    let total = 0;
    for (const operation of list) {
      if (!operation || typeof operation !== "object") continue;
      if (String(operation.direction ?? "").trim().toLowerCase() !== "payout") continue;
      if (!isMoneyRailExposureStateForDailyLimit(operation.state)) continue;
      const initiatedAt = typeof operation.initiatedAt === "string" ? operation.initiatedAt : typeof operation.createdAt === "string" ? operation.createdAt : null;
      if (!initiatedAt || initiatedAt.slice(0, 10) !== dayKey) continue;
      const amountCents = Number(operation.amountCents);
      if (!Number.isSafeInteger(amountCents) || amountCents <= 0) continue;
      total += amountCents;
    }
    return total;
  }

  function normalizeMoneyRailOperationPartyId(operation) {
    const fromMetadata = normalizeNonEmptyStringOrNull(operation?.metadata?.partyId);
    if (fromMetadata) return fromMetadata;
    const counterpartyRef = normalizeNonEmptyStringOrNull(operation?.counterpartyRef);
    if (counterpartyRef && counterpartyRef.startsWith("party:")) {
      const maybePartyId = normalizeNonEmptyStringOrNull(counterpartyRef.slice("party:".length));
      if (maybePartyId) return maybePartyId;
    }
    return null;
  }

  function listMoneyRailOperationsChronological(operations) {
    const list = Array.isArray(operations) ? operations.filter((row) => row && typeof row === "object" && !Array.isArray(row)) : [];
    const keyed = list.map((row, idx) => ({ row, idx }));
    keyed.sort((a, b) => {
      const aAt = Date.parse(String(a.row?.initiatedAt ?? a.row?.createdAt ?? ""));
      const bAt = Date.parse(String(b.row?.initiatedAt ?? b.row?.createdAt ?? ""));
      const aMs = Number.isFinite(aAt) ? aAt : Number.MAX_SAFE_INTEGER;
      const bMs = Number.isFinite(bAt) ? bAt : Number.MAX_SAFE_INTEGER;
      if (aMs !== bMs) return aMs - bMs;
      const byId = String(a.row?.operationId ?? "").localeCompare(String(b.row?.operationId ?? ""));
      if (byId !== 0) return byId;
      return a.idx - b.idx;
    });
    return keyed.map((entry) => entry.row);
  }

  function normalizeMoneyRailRecoveryAppliedCents(operation) {
    const value = Number(operation?.metadata?.chargebackRecoveryAppliedCents);
    if (!Number.isSafeInteger(value) || value <= 0) return 0;
    return value;
  }

  function deriveMoneyRailChargebackExposureByParty({ operations, period = null } = {}) {
    const normalizedPeriod = normalizeFinanceReconciliationPeriod(period, {
      fieldName: "period",
      allowNull: true
    });
    const rowsByPartyId = new Map();
    const ordered = listMoneyRailOperationsChronological(operations);
    for (const operation of ordered) {
      if (String(operation?.direction ?? "").toLowerCase() !== MONEY_RAIL_DIRECTION.PAYOUT) continue;
      const payoutKey = extractPayoutKeyFromMoneyRailOperation(operation);
      if (normalizedPeriod && !payoutKeyMatchesPeriod({ payoutKey, period: normalizedPeriod })) continue;
      const partyId = normalizeMoneyRailOperationPartyId(operation);
      if (!partyId) continue;
      const amountCents = Number(operation?.amountCents);
      if (!Number.isSafeInteger(amountCents) || amountCents <= 0) continue;
      const current = rowsByPartyId.get(partyId) ?? {
        partyId,
        outstandingCents: 0,
        totalReversedAmountCents: 0,
        totalRecoveredCents: 0,
        reversedCount: 0,
        recoveryCount: 0,
        latestReversedAt: null
      };
      const state = String(operation?.state ?? "").toLowerCase();
      if (state === MONEY_RAIL_OPERATION_STATE.REVERSED) {
        current.outstandingCents += amountCents;
        current.totalReversedAmountCents += amountCents;
        current.reversedCount += 1;
        current.latestReversedAt = operation?.reversedAt ?? operation?.updatedAt ?? operation?.initiatedAt ?? current.latestReversedAt ?? null;
      }
      if (
        state === MONEY_RAIL_OPERATION_STATE.INITIATED ||
        state === MONEY_RAIL_OPERATION_STATE.SUBMITTED ||
        state === MONEY_RAIL_OPERATION_STATE.CONFIRMED
      ) {
        const requestedRecoveryCents = normalizeMoneyRailRecoveryAppliedCents(operation);
        const appliedRecoveryCents = Math.min(current.outstandingCents, requestedRecoveryCents);
        if (appliedRecoveryCents > 0) {
          current.outstandingCents -= appliedRecoveryCents;
          current.totalRecoveredCents += appliedRecoveryCents;
          current.recoveryCount += 1;
        }
      }
      rowsByPartyId.set(partyId, current);
    }
    return rowsByPartyId;
  }

  function normalizeBillingProvider(value) {
    if (value === null || value === undefined || String(value).trim() === "") return null;
    return String(value).trim().toLowerCase();
  }

  function normalizeBillingTimestampInput(value) {
    if (value === null || value === undefined) return null;
    if (typeof value === "string" && value.trim() === "") return null;
    if (typeof value === "string" && /^\d+$/.test(value.trim())) {
      value = Number(value.trim());
    }
    if (typeof value === "number" && Number.isFinite(value)) {
      const millis = value > 1_000_000_000_000 ? value : value * 1000;
      if (!Number.isFinite(millis)) return null;
      return new Date(millis).toISOString();
    }
    const millis = Date.parse(String(value));
    if (!Number.isFinite(millis)) return null;
    return new Date(millis).toISOString();
  }

  function normalizeOptionalBillingPlanId(value, { strict = false } = {}) {
    if (value === null || value === undefined || String(value).trim() === "") return null;
    try {
      return normalizeBillingPlanId(value, { allowNull: false, defaultPlan: BILLING_PLAN_ID.FREE });
    } catch (err) {
      if (strict) throw err;
      return null;
    }
  }

  function normalizeBillingSubscriptionRecord(input, { allowNull = true, strictPlan = false } = {}) {
    if (input === null || input === undefined) {
      if (allowNull) return null;
      throw new TypeError("billing subscription is required");
    }
    if (typeof input !== "object" || Array.isArray(input)) {
      throw new TypeError("billing subscription must be an object");
    }

    const customerIdRaw = input.customerId ?? input.providerCustomerId ?? null;
    const subscriptionIdRaw = input.subscriptionId ?? input.providerSubscriptionId ?? null;
    const priceIdRaw = input.priceId ?? input.providerPriceId ?? null;
    const sourceEventCreatedAtRaw = input.sourceEventCreatedAt ?? input.eventCreatedAt ?? null;
    const metadataRaw = input.metadata ?? null;
    const metadata =
      metadataRaw && typeof metadataRaw === "object" && !Array.isArray(metadataRaw)
        ? { ...metadataRaw }
        : null;

    return {
      provider: normalizeBillingProvider(input.provider),
      customerId: customerIdRaw === null || customerIdRaw === undefined || String(customerIdRaw).trim() === "" ? null : String(customerIdRaw).trim(),
      subscriptionId:
        subscriptionIdRaw === null || subscriptionIdRaw === undefined || String(subscriptionIdRaw).trim() === ""
          ? null
          : String(subscriptionIdRaw).trim(),
      priceId: priceIdRaw === null || priceIdRaw === undefined || String(priceIdRaw).trim() === "" ? null : String(priceIdRaw).trim(),
      status:
        input.status === null || input.status === undefined || String(input.status).trim() === ""
          ? null
          : String(input.status).trim().toLowerCase(),
      plan: normalizeOptionalBillingPlanId(input.plan ?? input.planId ?? null, { strict: strictPlan }),
      currentPeriodStart: normalizeBillingTimestampInput(input.currentPeriodStart ?? input.currentPeriodStartAt ?? null),
      currentPeriodEnd: normalizeBillingTimestampInput(input.currentPeriodEnd ?? input.currentPeriodEndAt ?? null),
      cancelAtPeriodEnd: input.cancelAtPeriodEnd === true,
      canceledAt: normalizeBillingTimestampInput(input.canceledAt ?? null),
      sourceEventCreatedAt: normalizeBillingTimestampInput(sourceEventCreatedAtRaw),
      lastEventId:
        input.lastEventId === null || input.lastEventId === undefined || String(input.lastEventId).trim() === ""
          ? null
          : String(input.lastEventId).trim(),
      lastEventType:
        input.lastEventType === null || input.lastEventType === undefined || String(input.lastEventType).trim() === ""
          ? null
          : String(input.lastEventType).trim(),
      updatedAt: normalizeBillingTimestampInput(input.updatedAt) ?? nowIso(),
      metadata
    };
  }

  function readMetadataPlanCandidate(value) {
    if (!value || typeof value !== "object" || Array.isArray(value)) return null;
    const candidates = [value.settldPlan, value.settld_plan, value.plan, value.planId, value.plan_id];
    for (const candidate of candidates) {
      if (candidate === null || candidate === undefined || String(candidate).trim() === "") continue;
      const normalized = normalizeOptionalBillingPlanId(candidate, { strict: false });
      if (normalized) return normalized;
    }
    return null;
  }

  function extractStripeSubscriptionPrice(subscriptionObject) {
    if (!subscriptionObject || typeof subscriptionObject !== "object" || Array.isArray(subscriptionObject)) return null;
    const itemList = Array.isArray(subscriptionObject?.items?.data) ? subscriptionObject.items.data : [];
    for (const item of itemList) {
      if (!item || typeof item !== "object" || Array.isArray(item)) continue;
      const price = item.price;
      if (price && typeof price === "object" && !Array.isArray(price)) {
        return price;
      }
    }
    const planLike = subscriptionObject.plan;
    if (planLike && typeof planLike === "object" && !Array.isArray(planLike)) return planLike;
    return null;
  }

  function resolveStripePlanIdFromConfiguredPrice(priceId) {
    const normalizedPriceId = typeof priceId === "string" ? priceId.trim() : "";
    if (!normalizedPriceId) return null;
    if (effectiveBillingStripePriceIdBuilder && normalizedPriceId === effectiveBillingStripePriceIdBuilder) {
      return BILLING_PLAN_ID.BUILDER;
    }
    if (effectiveBillingStripePriceIdGrowth && normalizedPriceId === effectiveBillingStripePriceIdGrowth) {
      return BILLING_PLAN_ID.GROWTH;
    }
    if (effectiveBillingStripePriceIdEnterprise && normalizedPriceId === effectiveBillingStripePriceIdEnterprise) {
      return BILLING_PLAN_ID.ENTERPRISE;
    }
    return null;
  }

  function resolveStripeSubscriptionPlanId(subscriptionObject) {
    const directCandidate = readMetadataPlanCandidate(subscriptionObject?.metadata ?? null);
    if (directCandidate) return directCandidate;
    const price = extractStripeSubscriptionPrice(subscriptionObject);
    const fromPriceMetadata = readMetadataPlanCandidate(price?.metadata ?? null);
    if (fromPriceMetadata) return fromPriceMetadata;
    const fromConfiguredPrice = resolveStripePlanIdFromConfiguredPrice(price?.id ?? null);
    if (fromConfiguredPrice) return fromConfiguredPrice;
    return null;
  }

  function normalizeStripeSubscriptionWebhookEvent(input) {
    if (!input || typeof input !== "object" || Array.isArray(input)) {
      throw new TypeError("stripe event payload must be an object");
    }
    const eventId = typeof input.id === "string" && input.id.trim() !== "" ? input.id.trim() : null;
    const eventType = typeof input.type === "string" && input.type.trim() !== "" ? input.type.trim() : null;
    if (!eventId) throw new TypeError("stripe event id is required");
    if (!eventType) throw new TypeError("stripe event type is required");
    const object = input?.data?.object ?? null;
    if (!object || typeof object !== "object" || Array.isArray(object)) {
      throw new TypeError("stripe event data.object is required");
    }

    const price = extractStripeSubscriptionPrice(object);
    const priceId = price?.id ?? null;
    const planId = resolveStripeSubscriptionPlanId(object);
    const statusFromEvent = eventType === "customer.subscription.deleted" ? "canceled" : object.status;

    return {
      eventId,
      eventType,
      occurredAt: normalizeBillingTimestampInput(input.created) ?? nowIso(),
      subscription: normalizeBillingSubscriptionRecord(
        {
          provider: "stripe",
          customerId: object.customer ?? null,
          subscriptionId: object.id ?? null,
          priceId,
          status: statusFromEvent,
          plan: planId,
          currentPeriodStart: object.current_period_start ?? null,
          currentPeriodEnd: object.current_period_end ?? null,
          cancelAtPeriodEnd: object.cancel_at_period_end === true,
          canceledAt: object.canceled_at ?? null,
          sourceEventCreatedAt: input.created ?? null,
          lastEventId: eventId,
          lastEventType: eventType,
          metadata: object.metadata ?? null,
          updatedAt: nowIso()
        },
        { allowNull: false, strictPlan: false }
      )
    };
  }

  function normalizeBillingProviderEventDedupList(value) {
    if (!Array.isArray(value)) return [];
    const deduped = [];
    const seen = new Set();
    for (const entry of value) {
      if (entry === null || entry === undefined) continue;
      const text = String(entry).trim();
      if (!text || seen.has(text)) continue;
      seen.add(text);
      deduped.push(text);
    }
    return deduped;
  }

  function normalizeOptionalAbsoluteUrl(input, { fieldName = "url" } = {}) {
    if (input === null || input === undefined || String(input).trim() === "") return null;
    let parsed;
    try {
      parsed = new URL(String(input));
    } catch {
      throw new TypeError(`${fieldName} must be an absolute URL`);
    }
    if (parsed.protocol !== "https:" && parsed.protocol !== "http:") {
      throw new TypeError(`${fieldName} must use http or https`);
    }
    return parsed.toString();
  }

  function deriveRequestBaseUrl(req) {
    const forwardedProtoRaw = req?.headers?.["x-forwarded-proto"] ?? null;
    const forwardedHostRaw = req?.headers?.["x-forwarded-host"] ?? req?.headers?.host ?? null;
    const proto = String(Array.isArray(forwardedProtoRaw) ? forwardedProtoRaw[0] : forwardedProtoRaw ?? "")
      .split(",")[0]
      .trim()
      .toLowerCase();
    const host = String(Array.isArray(forwardedHostRaw) ? forwardedHostRaw[0] : forwardedHostRaw ?? "")
      .split(",")[0]
      .trim();
    if (!host) return null;
    const scheme = proto === "http" || proto === "https" ? proto : "https";
    return `${scheme}://${host}`;
  }

  function buildStripeBillingHostedSessionUrl({
    baseUrl,
    tenantId,
    sessionId,
    context = {}
  } = {}) {
    const base = normalizeOptionalAbsoluteUrl(baseUrl, { fieldName: "baseUrl" });
    if (!base) throw new TypeError("baseUrl must be configured");
    const u = new URL(base);
    u.searchParams.set("session_id", String(sessionId));
    u.searchParams.set("tenant", normalizeTenant(tenantId));
    for (const [key, rawValue] of Object.entries(context ?? {})) {
      if (rawValue === null || rawValue === undefined || String(rawValue).trim() === "") continue;
      u.searchParams.set(String(key), String(rawValue));
    }
    return u.toString();
  }

  function resolveStripePriceIdForPlanId(planId) {
    const normalizedPlan = normalizeBillingPlanId(planId, { allowNull: false, defaultPlan: BILLING_PLAN_ID.FREE });
    if (normalizedPlan === BILLING_PLAN_ID.BUILDER) return effectiveBillingStripePriceIdBuilder || null;
    if (normalizedPlan === BILLING_PLAN_ID.GROWTH) return effectiveBillingStripePriceIdGrowth || null;
    if (normalizedPlan === BILLING_PLAN_ID.ENTERPRISE) return effectiveBillingStripePriceIdEnterprise || null;
    return null;
  }

  function normalizeStripeApiBaseUrl(value) {
    const normalized = normalizeOptionalAbsoluteUrl(value, { fieldName: "billingStripeApiBaseUrl" });
    if (!normalized) throw new TypeError("billingStripeApiBaseUrl must be configured");
    return normalized.replace(/\/+$/, "");
  }

  const stripeCircuitState = {
    consecutiveFailures: 0,
    openedUntilMs: 0
  };

  function sleep(ms) {
    const delayMs = Number(ms);
    if (!Number.isFinite(delayMs) || delayMs <= 0) return Promise.resolve();
    return new Promise((resolve) => setTimeout(resolve, delayMs));
  }

  function computeStripeRetryDelayMs({ attempt }) {
    const base = Math.max(0, effectiveBillingStripeRetryBaseMs);
    const max = Math.max(1, effectiveBillingStripeRetryMaxMs);
    const exponent = Math.max(0, Number(attempt) - 1);
    const withoutJitter = Math.min(max, base * Math.pow(2, exponent));
    if (withoutJitter <= 0) return 0;
    const jitter = 0.8 + deliveryRandom() * 0.4; // 0.8x..1.2x
    return Math.max(0, Math.min(max, Math.round(withoutJitter * jitter)));
  }

  function normalizeAuditDetailsObject(value) {
    return value && typeof value === "object" && !Array.isArray(value) ? value : {};
  }

  function cloneJsonLike(value) {
    if (value === null || value === undefined) return null;
    try {
      return JSON.parse(JSON.stringify(value));
    } catch {
      return null;
    }
  }

  function makeSystemOpsAuditRecord({
    tenantId,
    action,
    targetType = null,
    targetId = null,
    details = null,
    at = nowIso()
  } = {}) {
    return makeOpsAuditRecord({
      tenantId,
      actorKeyId: null,
      actorPrincipalId: "system:billing_stripe_sync",
      requestId: createId("req_system"),
      action: String(action ?? "OPS_SYSTEM"),
      targetType,
      targetId,
      at,
      details
    });
  }

  async function appendSystemBillingProviderIngestAudit(
    applied,
    { tenantId, source = "webhook", replayed = false, replayAuditId = null, captureDuplicate = false } = {}
  ) {
    if (typeof store.appendOpsAudit !== "function") return;
    if (!applied || typeof applied !== "object") return;
    if (applied.duplicate === true && captureDuplicate !== true) return;
    await store.appendOpsAudit({
      tenantId,
      audit: makeSystemOpsAuditRecord({
        tenantId,
        action: "BILLING_PROVIDER_EVENT_INGEST",
        targetType: "billing_provider_event",
        targetId: applied.eventId ?? null,
        details: {
          provider: applied.provider ?? "stripe",
          eventId: applied.eventId ?? null,
          eventType: applied.eventType ?? null,
          source: typeof source === "string" && source.trim() !== "" ? source.trim() : "webhook",
          replayed: replayed === true,
          replayAuditId: replayAuditId ?? null,
          duplicate: applied.duplicate === true,
          ignored: applied.ignored === true,
          planChanged: applied?.applied?.planChanged === true,
          previousPlan: applied?.applied?.previousPlan ?? null,
          nextPlan: applied?.applied?.nextPlan ?? null,
          subscriptionId: applied?.subscription?.subscriptionId ?? null,
          customerId: applied?.subscription?.customerId ?? null,
          status: applied?.subscription?.status ?? null
        }
      })
    });
  }

  async function appendSystemBillingProviderRejectedAudit({
    tenantId,
    provider = "stripe",
    eventId = null,
    eventType = null,
    reason = null,
    message = null,
    source = "webhook",
    event = null,
    details = null
  } = {}) {
    if (typeof store.appendOpsAudit !== "function") return;
    const replayEvent = event && typeof event === "object" && !Array.isArray(event) ? cloneJsonLike(event) : null;
    await store.appendOpsAudit({
      tenantId,
      audit: makeSystemOpsAuditRecord({
        tenantId,
        action: "BILLING_PROVIDER_EVENT_REJECTED",
        targetType: "billing_provider_event",
        targetId: eventId ?? null,
        details: {
          provider: provider ?? "stripe",
          eventId: eventId ?? null,
          eventType: eventType ?? null,
          reason: reason ?? null,
          message: message ?? null,
          source: typeof source === "string" && source.trim() !== "" ? source.trim() : "webhook",
          replayable: Boolean(replayEvent),
          event: replayEvent,
          ...(details && typeof details === "object" && !Array.isArray(details) ? details : {})
        }
      })
    });
  }

  function normalizeStripeErrorFromResponseBody(json) {
    const stripeError = json && typeof json === "object" && !Array.isArray(json) && json.error && typeof json.error === "object" ? json.error : null;
    if (!stripeError) return null;
    return {
      message: typeof stripeError.message === "string" && stripeError.message.trim() !== "" ? stripeError.message.trim() : null,
      type: typeof stripeError.type === "string" && stripeError.type.trim() !== "" ? stripeError.type.trim() : null,
      code: typeof stripeError.code === "string" && stripeError.code.trim() !== "" ? stripeError.code.trim() : null
    };
  }

  function isStripeFailureRetryable({ httpStatus = null, isNetworkError = false } = {}) {
    if (isNetworkError) return true;
    if (!Number.isFinite(httpStatus)) return false;
    if (httpStatus === 408 || httpStatus === 409 || httpStatus === 425 || httpStatus === 429) return true;
    if (httpStatus >= 500) return true;
    return false;
  }

  function stripeErrorCategory({ httpStatus = null, isNetworkError = false, circuitOpen = false } = {}) {
    if (circuitOpen) return "circuit_open";
    if (isNetworkError) return "network_error";
    if (!Number.isFinite(httpStatus)) return "unknown";
    if (httpStatus === 429) return "rate_limited";
    if (httpStatus >= 500) return "upstream_unavailable";
    if (httpStatus >= 400) return "upstream_rejected";
    return "unknown";
  }

  function createStripeProviderError({
    message,
    endpoint,
    attempt = 1,
    maxAttempts = 1,
    httpStatus = null,
    providerCode = null,
    providerType = null,
    providerRequestId = null,
    retryable = false,
    code = "BILLING_PROVIDER_UPSTREAM_ERROR",
    circuitOpenUntil = null,
    isNetworkError = false
  } = {}) {
    const err = new Error(message || "stripe request failed");
    err.code = code;
    err.provider = "stripe";
    err.endpoint = endpoint;
    err.attempt = attempt;
    err.maxAttempts = maxAttempts;
    err.httpStatus = Number.isFinite(Number(httpStatus)) ? Number(httpStatus) : null;
    err.providerCode = providerCode ?? null;
    err.providerType = providerType ?? null;
    err.providerRequestId = providerRequestId ?? null;
    err.retryable = retryable === true;
    err.circuitOpenUntil = circuitOpenUntil ?? null;
    err.category = stripeErrorCategory({
      httpStatus: err.httpStatus,
      isNetworkError,
      circuitOpen: code === "BILLING_PROVIDER_CIRCUIT_OPEN"
    });
    return err;
  }

  function serializeStripeProviderError(err) {
    if (!err || typeof err !== "object") return { message: null };
    return {
      message: typeof err.message === "string" ? err.message : null,
      provider: "stripe",
      category: typeof err.category === "string" ? err.category : null,
      retryable: err.retryable === true,
      httpStatus: Number.isFinite(Number(err.httpStatus)) ? Number(err.httpStatus) : null,
      providerCode: typeof err.providerCode === "string" ? err.providerCode : null,
      providerType: typeof err.providerType === "string" ? err.providerType : null,
      providerRequestId: typeof err.providerRequestId === "string" ? err.providerRequestId : null,
      endpoint: typeof err.endpoint === "string" ? err.endpoint : null,
      attempt: Number.isFinite(Number(err.attempt)) ? Number(err.attempt) : null,
      maxAttempts: Number.isFinite(Number(err.maxAttempts)) ? Number(err.maxAttempts) : null,
      circuitOpenUntil: typeof err.circuitOpenUntil === "string" ? err.circuitOpenUntil : null
    };
  }

  function stripeProviderErrorStatusCode(err, fallback = 502) {
    if (err?.code === "BILLING_PROVIDER_CIRCUIT_OPEN") return 503;
    return fallback;
  }

  function shouldContributeStripeCircuitFailure(err) {
    if (!err || typeof err !== "object") return false;
    if (err.code === "BILLING_PROVIDER_CIRCUIT_OPEN") return false;
    if (err.retryable === true) return true;
    const httpStatus = Number(err.httpStatus);
    if (Number.isFinite(httpStatus) && (httpStatus >= 500 || httpStatus === 429)) return true;
    return false;
  }

  function resetStripeCircuit() {
    stripeCircuitState.consecutiveFailures = 0;
    stripeCircuitState.openedUntilMs = 0;
  }

  function recordStripeCircuitFailure(err) {
    if (!shouldContributeStripeCircuitFailure(err)) {
      resetStripeCircuit();
      return;
    }
    stripeCircuitState.consecutiveFailures += 1;
    if (stripeCircuitState.consecutiveFailures < effectiveBillingStripeCircuitFailureThreshold) return;
    stripeCircuitState.openedUntilMs = Date.now() + effectiveBillingStripeCircuitOpenMs;
    stripeCircuitState.consecutiveFailures = 0;
  }

  async function stripeApiRequestJson({ method = "POST", endpoint, formData = null } = {}) {
    if (!effectiveBillingStripeSecretKey) throw new Error("stripe secret key is not configured");
    const fetchImpl = effectiveBillingStripeFetchFn ?? (typeof fetch === "function" ? fetch : null);
    if (!fetchImpl) throw new Error("global fetch is not available");
    const requestMethod = String(method ?? "POST").trim().toUpperCase();
    if (requestMethod !== "POST" && requestMethod !== "GET") {
      throw new TypeError("stripe request method must be POST or GET");
    }
    if (stripeCircuitState.openedUntilMs > Date.now()) {
      throw createStripeProviderError({
        message: "stripe circuit is open; request temporarily blocked",
        endpoint: String(endpoint),
        retryable: true,
        code: "BILLING_PROVIDER_CIRCUIT_OPEN",
        circuitOpenUntil: new Date(stripeCircuitState.openedUntilMs).toISOString()
      });
    }
    const target = `${normalizeStripeApiBaseUrl(effectiveBillingStripeApiBaseUrl)}${String(endpoint)}`;
    const maxAttempts = Math.max(1, effectiveBillingStripeRetryMaxAttempts);
    let lastError = null;
    for (let attempt = 1; attempt <= maxAttempts; attempt += 1) {
      const requestHeaders = {
        authorization: `Bearer ${effectiveBillingStripeSecretKey}`
      };
      const requestInit = {
        method: requestMethod,
        headers: requestHeaders
      };
      if (requestMethod === "POST") {
        requestHeaders["content-type"] = "application/x-www-form-urlencoded";
        requestInit.body = new URLSearchParams(formData ?? {});
      }
      try {
        const resp = await fetchImpl(target, requestInit);
        const text = await resp.text();
        let json = null;
        try {
          json = JSON.parse(text);
        } catch {
          json = null;
        }
        if (!resp.ok) {
          const stripeError = normalizeStripeErrorFromResponseBody(json);
          const retryable = isStripeFailureRetryable({
            httpStatus: resp.status,
            isNetworkError: false
          });
          const canRetryAttempt = retryable && attempt < maxAttempts;
          const err = createStripeProviderError({
            message: stripeError?.message ?? text ?? `stripe API request failed (${resp.status})`,
            endpoint: String(endpoint),
            attempt,
            maxAttempts,
            httpStatus: resp.status,
            providerCode: stripeError?.code ?? null,
            providerType: stripeError?.type ?? null,
            providerRequestId: resp?.headers?.get?.("request-id") ?? null,
            retryable
          });
          if (canRetryAttempt) {
            lastError = err;
            await sleep(computeStripeRetryDelayMs({ attempt }));
            continue;
          }
          recordStripeCircuitFailure(err);
          throw err;
        }
        if (!json || typeof json !== "object" || Array.isArray(json)) {
          const err = createStripeProviderError({
            message: "stripe API returned invalid JSON",
            endpoint: String(endpoint),
            attempt,
            maxAttempts,
            retryable: false,
            code: "BILLING_PROVIDER_INVALID_RESPONSE"
          });
          recordStripeCircuitFailure(err);
          throw err;
        }
        resetStripeCircuit();
        return json;
      } catch (err) {
        if (err && typeof err === "object" && (err.code === "BILLING_PROVIDER_UPSTREAM_ERROR" || err.code === "BILLING_PROVIDER_INVALID_RESPONSE" || err.code === "BILLING_PROVIDER_CIRCUIT_OPEN")) {
          if (err.code !== "BILLING_PROVIDER_UPSTREAM_ERROR" || err.retryable !== true || attempt >= maxAttempts) {
            throw err;
          }
          lastError = err;
          await sleep(computeStripeRetryDelayMs({ attempt }));
          continue;
        }
        const retryable = isStripeFailureRetryable({
          httpStatus: null,
          isNetworkError: true
        });
        const canRetryAttempt = retryable && attempt < maxAttempts;
        const wrapped = createStripeProviderError({
          message: err?.message ?? "network error while calling stripe",
          endpoint: String(endpoint),
          attempt,
          maxAttempts,
          retryable,
          isNetworkError: true
        });
        if (canRetryAttempt) {
          lastError = wrapped;
          await sleep(computeStripeRetryDelayMs({ attempt }));
          continue;
        }
        recordStripeCircuitFailure(wrapped);
        throw wrapped;
      }
    }
    if (lastError) {
      recordStripeCircuitFailure(lastError);
      throw lastError;
    }
    throw createStripeProviderError({
      message: "stripe request failed after retries",
      endpoint: String(endpoint),
      attempt: maxAttempts,
      maxAttempts,
      retryable: false
    });
  }

  async function stripeApiPostJson({ endpoint, formData }) {
    return stripeApiRequestJson({ method: "POST", endpoint, formData });
  }

  async function stripeApiGetJson({ endpoint }) {
    return stripeApiRequestJson({ method: "GET", endpoint, formData: null });
  }

  function isStripeNoSuchCustomerError(err) {
    const message = err && typeof err.message === "string" ? err.message : "";
    return /\bno such customer\b/i.test(message);
  }

  function computeBillableUsageEventDigestRows(events) {
    const rows = [];
    for (const row of Array.isArray(events) ? events : []) {
      if (!row || typeof row !== "object") continue;
      rows.push({
        eventKey: typeof row.eventKey === "string" ? row.eventKey : "",
        eventType: typeof row.eventType === "string" ? row.eventType : "",
        quantity: Number.isSafeInteger(Number(row.quantity)) ? Number(row.quantity) : 0,
        amountCents: Number.isSafeInteger(Number(row.amountCents)) ? Number(row.amountCents) : 0,
        currency: typeof row.currency === "string" && row.currency.trim() !== "" ? row.currency : null,
        occurredAt: typeof row.occurredAt === "string" ? row.occurredAt : null,
        sourceType: typeof row.sourceType === "string" ? row.sourceType : null,
        sourceId: typeof row.sourceId === "string" ? row.sourceId : null,
        eventHash: typeof row.eventHash === "string" ? row.eventHash : null
      });
    }
    rows.sort((left, right) => {
      const byKey = String(left.eventKey).localeCompare(String(right.eventKey));
      if (byKey !== 0) return byKey;
      const byType = String(left.eventType).localeCompare(String(right.eventType));
      if (byType !== 0) return byType;
      const byOccurredAt = String(left.occurredAt ?? "").localeCompare(String(right.occurredAt ?? ""));
      if (byOccurredAt !== 0) return byOccurredAt;
      return String(left.eventHash ?? "").localeCompare(String(right.eventHash ?? ""));
    });
    return rows;
  }

  function computeBillingLineItemSourceDigest(rows) {
    const material = (Array.isArray(rows) ? rows : []).map((row) =>
      normalizeForCanonicalJson(
        {
          eventKey: typeof row?.eventKey === "string" ? row.eventKey : "",
          eventType: typeof row?.eventType === "string" ? row.eventType : "",
          amountCents: Number.isSafeInteger(Number(row?.amountCents)) ? Number(row.amountCents) : 0,
          quantity: Number.isSafeInteger(Number(row?.quantity)) ? Number(row.quantity) : 0,
          occurredAt: typeof row?.occurredAt === "string" ? row.occurredAt : null,
          eventHash: typeof row?.eventHash === "string" ? row.eventHash : null
        },
        { path: "$" }
      )
    );
    material.sort(
      (left, right) =>
        String(left.eventKey).localeCompare(String(right.eventKey)) ||
        String(left.eventType).localeCompare(String(right.eventType)) ||
        String(left.occurredAt ?? "").localeCompare(String(right.occurredAt ?? "")) ||
        String(left.eventHash ?? "").localeCompare(String(right.eventHash ?? ""))
    );
    return sha256Hex(canonicalJsonStringify(normalizeForCanonicalJson(material, { path: "$" })));
  }

  function buildBillingPeriodCloseInvoiceDraft({
    summary,
    digestRows,
    period,
    generatedAt,
    eventsDigest
  } = {}) {
    const safeSummary = summary && typeof summary === "object" ? summary : {};
    const plan = safeSummary.plan && typeof safeSummary.plan === "object" ? safeSummary.plan : {};
    const usage = safeSummary.usage && typeof safeSummary.usage === "object" ? safeSummary.usage : {};
    const estimate = safeSummary.estimate && typeof safeSummary.estimate === "object" ? safeSummary.estimate : {};
    const rows = Array.isArray(digestRows) ? digestRows : [];
    const settledRows = rows.filter((row) => String(row?.eventType ?? "").toLowerCase() === BILLABLE_USAGE_EVENT_TYPE.SETTLED_VOLUME);
    const verifiedRows = rows.filter((row) => String(row?.eventType ?? "").toLowerCase() === BILLABLE_USAGE_EVENT_TYPE.VERIFIED_RUN);
    const arbitrationRows = rows.filter(
      (row) => String(row?.eventType ?? "").toLowerCase() === BILLABLE_USAGE_EVENT_TYPE.ARBITRATION_USAGE
    );

    const subscriptionCentsRaw = Number(estimate.subscriptionCents ?? 0);
    const subscriptionCents = Number.isSafeInteger(subscriptionCentsRaw) && subscriptionCentsRaw > 0 ? subscriptionCentsRaw : 0;
    const overageUnitsRaw = Number(estimate.verifiedRunOverageUnits ?? 0);
    const overageUnits = Number.isSafeInteger(overageUnitsRaw) && overageUnitsRaw > 0 ? overageUnitsRaw : 0;
    const overageUnitCentsRaw = Number(estimate.verifiedRunOverageCentsPerUnit ?? 0);
    const overageUnitCents =
      Number.isFinite(overageUnitCentsRaw) && overageUnitCentsRaw >= 0 ? Math.round(overageUnitCentsRaw * 1000) / 1000 : 0;
    const overageCentsRaw = Number(estimate.verifiedRunOverageCents ?? 0);
    const overageCents = Number.isSafeInteger(overageCentsRaw) && overageCentsRaw > 0 ? overageCentsRaw : 0;
    const settledFeeBpsRaw = Number(plan.settledVolumeFeeBps ?? estimate.settledVolumeFeeBps ?? 0);
    const settledFeeBps = Number.isSafeInteger(settledFeeBpsRaw) && settledFeeBpsRaw >= 0 ? settledFeeBpsRaw : 0;
    const settledFeeCentsRaw = Number(estimate.settledVolumeFeeCents ?? 0);
    const settledFeeCents = Number.isSafeInteger(settledFeeCentsRaw) && settledFeeCentsRaw > 0 ? settledFeeCentsRaw : 0;
    const arbitrationUnitsRaw = Number(usage.arbitrationCases ?? 0);
    const arbitrationUnits = Number.isSafeInteger(arbitrationUnitsRaw) && arbitrationUnitsRaw > 0 ? arbitrationUnitsRaw : 0;
    const arbitrationUnitCentsRaw = Number(plan.arbitrationCaseFeeCents ?? estimate.arbitrationCaseFeeCents ?? 0);
    const arbitrationUnitCents =
      Number.isSafeInteger(arbitrationUnitCentsRaw) && arbitrationUnitCentsRaw >= 0 ? arbitrationUnitCentsRaw : 0;
    const arbitrationFeeCentsRaw = Number(estimate.arbitrationFeeCents ?? 0);
    const arbitrationFeeCents =
      Number.isSafeInteger(arbitrationFeeCentsRaw) && arbitrationFeeCentsRaw > 0 ? arbitrationFeeCentsRaw : 0;
    const settledVolumeCentsRaw = Number(usage.settledVolumeCents ?? 0);
    const settledVolumeCents = Number.isSafeInteger(settledVolumeCentsRaw) && settledVolumeCentsRaw >= 0 ? settledVolumeCentsRaw : 0;

    const lineItems = [];
    if (subscriptionCents > 0) {
      lineItems.push(
        normalizeForCanonicalJson(
          {
            code: BILLING_INVOICE_LINE_ITEM_CODE.SUBSCRIPTION_BASE,
            description: `Subscription base fee for ${period}`,
            quantity: 1,
            unitAmountCents: subscriptionCents,
            amountCents: subscriptionCents,
            currency: "USD",
            sourceEventCount: 0,
            sourceEventDigest: null,
            sourceEventKeys: []
          },
          { path: "$" }
        )
      );
    }
    if (overageCents > 0 || overageUnits > 0) {
      lineItems.push(
        normalizeForCanonicalJson(
          {
            code: BILLING_INVOICE_LINE_ITEM_CODE.VERIFIED_RUN_OVERAGE,
            description: `Verified run overage (${overageUnits} units)`,
            quantity: overageUnits,
            unitAmountCents: overageUnitCents,
            amountCents: overageCents,
            currency: "USD",
            sourceEventCount: verifiedRows.length,
            sourceEventDigest: computeBillingLineItemSourceDigest(verifiedRows),
            sourceEventKeys: verifiedRows.map((row) => String(row.eventKey))
          },
          { path: "$" }
        )
      );
    }
    if (settledFeeCents > 0 || settledVolumeCents > 0) {
      lineItems.push(
        normalizeForCanonicalJson(
          {
            code: BILLING_INVOICE_LINE_ITEM_CODE.SETTLED_VOLUME_FEE,
            description: `Settlement volume fee (${settledFeeBps} bps)`,
            quantity: settledVolumeCents,
            unitAmountBps: settledFeeBps,
            amountCents: settledFeeCents,
            currency: "USD",
            sourceEventCount: settledRows.length,
            sourceEventDigest: computeBillingLineItemSourceDigest(settledRows),
            sourceEventKeys: settledRows.map((row) => String(row.eventKey))
          },
          { path: "$" }
        )
      );
    }
    if (arbitrationFeeCents > 0 || arbitrationUnits > 0) {
      lineItems.push(
        normalizeForCanonicalJson(
          {
            code: BILLING_INVOICE_LINE_ITEM_CODE.ARBITRATION_USAGE_FEE,
            description: `Arbitration case fee (${arbitrationUnits} cases)`,
            quantity: arbitrationUnits,
            unitAmountCents: arbitrationUnitCents,
            amountCents: arbitrationFeeCents,
            currency: "USD",
            sourceEventCount: arbitrationRows.length,
            sourceEventDigest: computeBillingLineItemSourceDigest(arbitrationRows),
            sourceEventKeys: arbitrationRows.map((row) => String(row.eventKey))
          },
          { path: "$" }
        )
      );
    }

    lineItems.sort(
      (left, right) =>
        String(left.code ?? "").localeCompare(String(right.code ?? "")) ||
        Number(left.amountCents ?? 0) - Number(right.amountCents ?? 0)
    );
    const subtotalCents = lineItems.reduce((sum, row) => {
      const amount = Number(row?.amountCents ?? 0);
      return sum + (Number.isSafeInteger(amount) ? amount : 0);
    }, 0);
    const totalEstimatedCentsRaw = Number(estimate.totalEstimatedCents ?? subtotalCents);
    const totalEstimatedCents =
      Number.isSafeInteger(totalEstimatedCentsRaw) && totalEstimatedCentsRaw >= 0 ? totalEstimatedCentsRaw : subtotalCents;

    return normalizeForCanonicalJson(
      {
        schemaVersion: BILLING_INVOICE_DRAFT_SCHEMA_VERSION,
        period,
        generatedAt,
        currency: "USD",
        eventCount: rows.length,
        eventsDigest: typeof eventsDigest === "string" ? eventsDigest : null,
        lineItems,
        subtotalCents,
        totalEstimatedCents
      },
      { path: "$" }
    );
  }

  function defaultBillingPeriodCutoffAt(period) {
    const bounds = parseYearMonth(period);
    return bounds.endAt;
  }

  function parseStripeSignatureHeader(value) {
    if (value === null || value === undefined || String(value).trim() === "") {
      throw new TypeError("stripe-signature header is required");
    }
    const pairs = String(value)
      .split(",")
      .map((part) => part.trim())
      .filter(Boolean);
    let timestamp = null;
    const signatures = [];
    for (const pair of pairs) {
      const eq = pair.indexOf("=");
      if (eq <= 0) continue;
      const key = pair.slice(0, eq).trim();
      const val = pair.slice(eq + 1).trim();
      if (!key || !val) continue;
      if (key === "t") {
        const n = Number(val);
        if (!Number.isSafeInteger(n) || n <= 0) throw new TypeError("stripe-signature timestamp is invalid");
        timestamp = n;
      } else if (key === "v1") {
        signatures.push(val.toLowerCase());
      }
    }
    if (!Number.isSafeInteger(timestamp) || timestamp <= 0) throw new TypeError("stripe-signature missing timestamp");
    if (signatures.length === 0) throw new TypeError("stripe-signature missing v1 signature");
    return { timestamp, signatures };
  }

  function timingSafeEqualHexHex(a, b) {
    if (typeof a !== "string" || typeof b !== "string") return false;
    const ax = a.trim().toLowerCase();
    const bx = b.trim().toLowerCase();
    if (!/^[0-9a-f]+$/.test(ax) || !/^[0-9a-f]+$/.test(bx)) return false;
    if (ax.length !== bx.length) return false;
    if (ax.length % 2 !== 0) return false;
    const aBuf = Buffer.from(ax, "hex");
    const bBuf = Buffer.from(bx, "hex");
    if (aBuf.length !== bBuf.length) return false;
    return crypto.timingSafeEqual(aBuf, bBuf);
  }

  function verifyStripeWebhookSignature({
    signatureHeader,
    rawBody,
    secret,
    toleranceSeconds = 300,
    nowAt = nowIso()
  } = {}) {
    const { timestamp, signatures } = parseStripeSignatureHeader(signatureHeader);
    const payload = `${String(timestamp)}.${String(rawBody ?? "")}`;
    const expected = crypto.createHmac("sha256", String(secret)).update(payload, "utf8").digest("hex");
    const matched = signatures.some((candidate) => timingSafeEqualHexHex(candidate, expected));
    if (!matched) throw new TypeError("stripe-signature digest mismatch");
    const tolerance = Number(toleranceSeconds);
    if (Number.isFinite(tolerance) && tolerance > 0) {
      const nowSeconds = Math.floor(Date.parse(nowAt) / 1000);
      if (!Number.isFinite(nowSeconds)) throw new TypeError("invalid clock");
      if (Math.abs(nowSeconds - timestamp) > tolerance) {
        throw new TypeError("stripe-signature timestamp outside tolerance window");
      }
    }
    return true;
  }

  async function applyStripeBillingProviderEvent({ tenantId, body }) {
    const cfg = getTenantConfig(tenantId);
    if (!cfg || typeof cfg !== "object") {
      const err = new Error("tenant config unavailable");
      err.code = "TENANT_CONFIG_UNAVAILABLE";
      throw err;
    }

    const billingCfg = await getTenantBillingConfig(tenantId);
    const existingBilling =
      billingCfg && typeof billingCfg === "object" && !Array.isArray(billingCfg)
        ? { ...billingCfg }
        : {
            plan: BILLING_PLAN_ID.FREE,
            planOverrides: null,
            hardLimitEnforced: true
          };

    const parsed = normalizeStripeSubscriptionWebhookEvent(body);
    const dedupKey = `stripe:${parsed.eventId}`;
    const dedupList = normalizeBillingProviderEventDedupList(existingBilling.providerEventDedupKeys ?? []);

    if (dedupList.includes(dedupKey)) {
      return {
        tenantId,
        provider: "stripe",
        duplicate: true,
        eventId: parsed.eventId,
        eventType: parsed.eventType,
        occurredAt: parsed.occurredAt,
        subscription: normalizeBillingSubscriptionRecord(existingBilling.subscription ?? null, {
          allowNull: true,
          strictPlan: false
        }),
        resolvedPlan: resolveTenantBillingPlan({ tenantId })
      };
    }

    if (!parsed.eventType.startsWith("customer.subscription.")) {
      const nextBilling = {
        ...existingBilling,
        providerEventDedupKeys: normalizeBillingProviderEventDedupList([...dedupList, dedupKey]).slice(-500)
      };
      await putTenantBillingConfig(tenantId, nextBilling);
      return {
        tenantId,
        provider: "stripe",
        duplicate: false,
        ignored: true,
        eventId: parsed.eventId,
        eventType: parsed.eventType,
        occurredAt: parsed.occurredAt,
        reason: "unsupported_event_type",
        subscription: normalizeBillingSubscriptionRecord(nextBilling.subscription ?? null, {
          allowNull: true,
          strictPlan: false
        }),
        resolvedPlan: resolveTenantBillingPlan({ tenantId })
      };
    }

    const previousPlan = normalizeBillingPlanId(existingBilling.plan ?? BILLING_PLAN_ID.FREE, {
      allowNull: false,
      defaultPlan: BILLING_PLAN_ID.FREE
    });
    const nextPlan = parsed.subscription.plan ?? previousPlan;
    const nextBilling = {
      ...existingBilling,
      plan: nextPlan,
      subscription: parsed.subscription,
      providerEventDedupKeys: normalizeBillingProviderEventDedupList([...dedupList, dedupKey]).slice(-500)
    };
    await putTenantBillingConfig(tenantId, nextBilling);

    const planChanged = previousPlan !== nextPlan;

    return {
      tenantId,
      provider: "stripe",
      duplicate: false,
      ignored: false,
      eventId: parsed.eventId,
      eventType: parsed.eventType,
      occurredAt: parsed.occurredAt,
      applied: {
        planChanged,
        previousPlan,
        nextPlan
      },
      subscription: parsed.subscription,
      resolvedPlan: resolveTenantBillingPlan({ tenantId })
    };
  }

  function computeBillingStripeReplayDelaySeconds({ failedAttempts }) {
    const attempts = Number.isSafeInteger(failedAttempts) ? failedAttempts : 0;
    if (attempts <= 0) return 0;
    const base = Math.max(0, effectiveBillingStripeSyncMinRetrySeconds);
    if (base === 0) return 0;
    const max = Math.max(base, effectiveBillingStripeSyncMaxRetrySeconds);
    const computed = base * Math.pow(2, Math.max(0, attempts - 1));
    return Math.min(max, computed);
  }

  async function tickBillingStripeSync({
    tenantId = DEFAULT_TENANT_ID,
    maxRows = effectiveBillingStripeSyncBatchSize,
    force = false
  } = {}) {
    const normalizedTenantId = normalizeTenantId(tenantId ?? DEFAULT_TENANT_ID);
    const startedAt = nowIso();
    const startedAtMs = Date.parse(startedAt);
    const normalizedMaxRows = Number.isSafeInteger(maxRows) && maxRows > 0 ? Math.min(1000, maxRows) : effectiveBillingStripeSyncBatchSize;

    if (!effectiveBillingStripeSyncEnabled) {
      return {
        ok: true,
        tenantId: normalizedTenantId,
        skipped: true,
        reason: "disabled"
      };
    }
    if (typeof store.listOpsAudit !== "function") {
      return {
        ok: false,
        tenantId: normalizedTenantId,
        code: "OPS_AUDIT_UNSUPPORTED",
        message: "ops audit not supported for this store"
      };
    }
    if (billingStripeSyncState.inFlight) {
      return {
        ok: false,
        tenantId: normalizedTenantId,
        code: "MAINTENANCE_ALREADY_RUNNING",
        message: "billing stripe sync is already running"
      };
    }
    if (
      force !== true &&
      effectiveBillingStripeSyncIntervalSeconds > 0 &&
      Number.isFinite(billingStripeSyncState.nextEligibleAtMs) &&
      billingStripeSyncState.nextEligibleAtMs > startedAtMs
    ) {
      return {
        ok: true,
        tenantId: normalizedTenantId,
        skipped: true,
        reason: "interval_not_elapsed",
        nextEligibleAt: new Date(billingStripeSyncState.nextEligibleAtMs).toISOString()
      };
    }

    billingStripeSyncState.inFlight = true;
    billingStripeSyncState.lastRunAt = startedAt;
    billingStripeSyncState.nextEligibleAtMs =
      effectiveBillingStripeSyncIntervalSeconds > 0
        ? startedAtMs + effectiveBillingStripeSyncIntervalSeconds * 1000
        : startedAtMs;
    try {
      const audits = await store.listOpsAudit({
        tenantId: normalizedTenantId,
        limit: effectiveBillingStripeSyncAuditScanLimit,
        offset: 0
      });
      const rows = Array.isArray(audits) ? audits : [];
      const scoped = rows.filter((row) => {
        const action = String(row?.action ?? "");
        return action === "BILLING_PROVIDER_EVENT_REJECTED" || action === "BILLING_PROVIDER_EVENT_INGEST";
      });
      const replaySucceededByAuditId = new Set();
      const replayFailedByAuditId = new Map();
      const replayFailedLastAtByAuditId = new Map();
      for (const row of scoped) {
        const action = String(row?.action ?? "");
        const details = normalizeAuditDetailsObject(row?.details);
        const replayAuditId = Number(details.replayAuditId);
        if (!Number.isSafeInteger(replayAuditId) || replayAuditId <= 0) continue;
        if (action === "BILLING_PROVIDER_EVENT_INGEST" && details.replayed === true) {
          replaySucceededByAuditId.add(replayAuditId);
          continue;
        }
        if (action === "BILLING_PROVIDER_EVENT_REJECTED" && String(details.reason ?? "") === "dead_letter_replay_apply_failed") {
          replayFailedByAuditId.set(replayAuditId, (replayFailedByAuditId.get(replayAuditId) ?? 0) + 1);
          const atMs = row?.at ? Date.parse(String(row.at)) : Number.NaN;
          if (Number.isFinite(atMs)) {
            const prev = replayFailedLastAtByAuditId.get(replayAuditId);
            if (!Number.isFinite(prev) || atMs > prev) replayFailedLastAtByAuditId.set(replayAuditId, atMs);
          }
        }
      }

      const rejectedRows = scoped
        .filter((row) => String(row?.action ?? "") === "BILLING_PROVIDER_EVENT_REJECTED")
        .map((row) => ({ row, details: normalizeAuditDetailsObject(row?.details) }))
        .filter(({ details }) => (details.provider ?? "stripe") === "stripe")
        .filter(({ details }) => details.replayable === true && details.event && typeof details.event === "object" && !Array.isArray(details.event))
        .filter(({ details }) => effectiveBillingStripeSyncReplayReasons.has(String(details.reason ?? "")))
        .filter(({ details }) => String(details.source ?? "webhook") !== "dead_letter_replay")
        .filter(({ row }) => !replaySucceededByAuditId.has(Number(row?.id)))
        .sort((a, b) => Number(a.row?.id ?? 0) - Number(b.row?.id ?? 0));

      const selected = [];
      let skippedBackoff = 0;
      let skippedMaxAttempts = 0;
      for (const candidate of rejectedRows) {
        const auditId = Number(candidate.row?.id ?? 0);
        if (!Number.isSafeInteger(auditId) || auditId <= 0) continue;
        const failedAttempts = replayFailedByAuditId.get(auditId) ?? 0;
        if (failedAttempts >= effectiveBillingStripeSyncMaxReplayAttempts) {
          skippedMaxAttempts += 1;
          continue;
        }
        const lastFailedAtMs = replayFailedLastAtByAuditId.get(auditId);
        const retryDelaySeconds = computeBillingStripeReplayDelaySeconds({ failedAttempts });
        const nextRetryAtMs =
          Number.isFinite(lastFailedAtMs) && retryDelaySeconds > 0
            ? lastFailedAtMs + retryDelaySeconds * 1000
            : Number.NaN;
        if (Number.isFinite(nextRetryAtMs) && nextRetryAtMs > startedAtMs) {
          skippedBackoff += 1;
          continue;
        }
        selected.push(candidate);
        if (selected.length >= normalizedMaxRows) break;
      }

      const results = [];
      for (const candidate of selected) {
        const replayEvent = candidate.details.event;
        const replayAuditId = Number(candidate.row?.id ?? 0);
        try {
          // eslint-disable-next-line no-await-in-loop
          const applied = await applyStripeBillingProviderEvent({ tenantId: normalizedTenantId, body: replayEvent });
          // eslint-disable-next-line no-await-in-loop
          await appendSystemBillingProviderIngestAudit(applied, {
            tenantId: normalizedTenantId,
            source: "dead_letter_replay",
            replayed: true,
            replayAuditId,
            captureDuplicate: true
          });
          results.push({
            ok: true,
            replayAuditId,
            eventId: applied?.eventId ?? replayEvent?.id ?? null,
            eventType: applied?.eventType ?? replayEvent?.type ?? null,
            duplicate: applied?.duplicate === true,
            ignored: applied?.ignored === true
          });
        } catch (err) {
          // eslint-disable-next-line no-await-in-loop
          await appendSystemBillingProviderRejectedAudit({
            tenantId: normalizedTenantId,
            provider: "stripe",
            eventId: replayEvent?.id ?? candidate.row?.targetId ?? null,
            eventType: replayEvent?.type ?? candidate.details.eventType ?? null,
            reason: "dead_letter_replay_apply_failed",
            message: err?.message ?? "unknown error",
            source: "dead_letter_replay",
            event: replayEvent,
            details: {
              replayAuditId,
              originalReason: candidate.details.reason ?? null
            }
          });
          results.push({
            ok: false,
            replayAuditId,
            eventId: replayEvent?.id ?? candidate.row?.targetId ?? null,
            eventType: replayEvent?.type ?? candidate.details.eventType ?? null,
            error: err?.message ?? "unknown error"
          });
        }
      }

      const summary = {
        scanned: rejectedRows.length,
        selected: selected.length,
        applied: results.filter((row) => row.ok === true && row.duplicate !== true && row.ignored !== true).length,
        duplicate: results.filter((row) => row.ok === true && row.duplicate === true).length,
        ignored: results.filter((row) => row.ok === true && row.ignored === true).length,
        failed: results.filter((row) => row.ok !== true).length,
        skippedBackoff,
        skippedMaxAttempts
      };
      const completedAt = nowIso();
      billingStripeSyncState.lastSuccessAt = completedAt;
      billingStripeSyncState.lastResult = {
        ok: true,
        tenantId: normalizedTenantId,
        startedAt,
        completedAt,
        summary
      };
      try {
        store.__billingStripeSyncLastRunAt = startedAt;
        store.__billingStripeSyncLastSuccessAt = completedAt;
        store.__billingStripeSyncLastResult = billingStripeSyncState.lastResult;
      } catch {}
      if (typeof store.appendOpsAudit === "function") {
        await store.appendOpsAudit({
          tenantId: normalizedTenantId,
          audit: makeSystemOpsAuditRecord({
            tenantId: normalizedTenantId,
            action: "MAINTENANCE_BILLING_STRIPE_SYNC_RUN",
            targetType: "maintenance",
            targetId: "billing_stripe_sync",
            at: completedAt,
            details: {
              outcome: "ok",
              summary
            }
          })
        });
      }
      return billingStripeSyncState.lastResult;
    } catch (err) {
      const completedAt = nowIso();
      const failure = {
        ok: false,
        tenantId: normalizedTenantId,
        startedAt,
        completedAt,
        error: err?.message ?? "unknown error"
      };
      billingStripeSyncState.lastResult = failure;
      try {
        store.__billingStripeSyncLastRunAt = startedAt;
        store.__billingStripeSyncLastResult = failure;
      } catch {}
      if (typeof store.appendOpsAudit === "function") {
        await store.appendOpsAudit({
          tenantId: normalizedTenantId,
          audit: makeSystemOpsAuditRecord({
            tenantId: normalizedTenantId,
            action: "MAINTENANCE_BILLING_STRIPE_SYNC_RUN",
            targetType: "maintenance",
            targetId: "billing_stripe_sync",
            at: completedAt,
            details: {
              outcome: "error",
              error: err?.message ?? "unknown error"
            }
          })
        });
      }
      return failure;
    } finally {
      billingStripeSyncState.inFlight = false;
    }
  }

  async function listBillableUsageEventsAll({
    tenantId,
    period = null,
    eventType = null,
    pageSize = 1000
  } = {}) {
    if (typeof store.listBillableUsageEvents !== "function") return [];
    const normalizedPageSize =
      Number.isSafeInteger(pageSize) && pageSize > 0 ? Math.min(1000, pageSize) : 1000;
    const all = [];
    let offset = 0;
    while (true) {
      const chunk = await store.listBillableUsageEvents({
        tenantId,
        period,
        eventType,
        limit: normalizedPageSize,
        offset
      });
      const rows = Array.isArray(chunk) ? chunk : [];
      if (!rows.length) break;
      all.push(...rows);
      if (rows.length < normalizedPageSize) break;
      offset += normalizedPageSize;
    }
    return all;
  }

  function summarizeBillableUsageEvents(events) {
    const rows = Array.isArray(events) ? events : [];
    const eventTypeCounts = {
      [BILLABLE_USAGE_EVENT_TYPE.VERIFIED_RUN]: 0,
      [BILLABLE_USAGE_EVENT_TYPE.SETTLED_VOLUME]: 0,
      [BILLABLE_USAGE_EVENT_TYPE.ARBITRATION_USAGE]: 0
    };
    let verifiedRuns = 0;
    let settledVolumeCents = 0;
    let arbitrationCases = 0;
    for (const row of rows) {
      if (!row || typeof row !== "object") continue;
      const eventType = String(row.eventType ?? "").toLowerCase();
      const quantityRaw = Number(row.quantity ?? 0);
      const quantity = Number.isSafeInteger(quantityRaw) && quantityRaw > 0 ? quantityRaw : 1;
      if (eventType in eventTypeCounts) {
        eventTypeCounts[eventType] += quantity;
      }
      if (eventType === BILLABLE_USAGE_EVENT_TYPE.VERIFIED_RUN) {
        verifiedRuns += quantity;
      } else if (eventType === BILLABLE_USAGE_EVENT_TYPE.SETTLED_VOLUME) {
        const amountRaw = Number(row.amountCents ?? 0);
        const amount = Number.isSafeInteger(amountRaw) && amountRaw > 0 ? amountRaw : 0;
        settledVolumeCents += amount;
      } else if (eventType === BILLABLE_USAGE_EVENT_TYPE.ARBITRATION_USAGE) {
        arbitrationCases += quantity;
      }
    }
    return {
      eventCount: rows.length,
      eventTypeCounts,
      verifiedRuns,
      settledVolumeCents,
      arbitrationCases
    };
  }

  async function computeTenantBillingPeriodSummary({
    tenantId,
    period
  } = {}) {
    const normalizedPeriod = normalizeBillingPeriodInput(period, { defaultToNow: true });
    await getTenantBillingConfig(tenantId);
    const billingPlan = resolveTenantBillingPlan({ tenantId });
    const events = await listBillableUsageEventsAll({
      tenantId,
      period: normalizedPeriod,
      eventType: null
    });
    const usage = summarizeBillableUsageEvents(events);
    const estimate = computeBillingEstimate({
      plan: billingPlan,
      usage
    });
    const hardLimit = Number.isSafeInteger(billingPlan.hardLimitVerifiedRunsPerMonth)
      ? billingPlan.hardLimitVerifiedRunsPerMonth
      : 0;
    const hardLimitRemaining =
      hardLimit > 0 ? Math.max(0, hardLimit - usage.verifiedRuns) : null;
    return {
      tenantId: normalizeTenant(tenantId),
      period: normalizedPeriod,
      plan: {
        ...billingPlan
      },
      usage,
      estimate,
      enforcement: {
        hardLimitVerifiedRunsPerMonth: hardLimit,
        hardLimitEnforced: billingPlan.hardLimitEnforced === true,
        hardLimitRemainingVerifiedRuns: hardLimitRemaining,
        wouldBlockNextVerifiedRun:
          billingPlan.hardLimitEnforced === true &&
          hardLimit > 0 &&
          usage.verifiedRuns >= hardLimit
      }
    };
  }

  async function listBillingPeriodCloseArtifacts({
    tenantId,
    period,
    limit = 200,
    offset = 0
  } = {}) {
    if (typeof store.listArtifacts !== "function") return [];
    const rows = await store.listArtifacts({
      tenantId,
      artifactType: BILLING_PERIOD_CLOSE_ARTIFACT_TYPE,
      limit: Math.min(1000, Math.max(1, Number(limit) || 200)),
      offset: Math.max(0, Number(offset) || 0)
    });
    const filtered = (Array.isArray(rows) ? rows : []).filter(
      (artifact) => String(artifact?.period ?? "") === String(period)
    );
    filtered.sort((left, right) => {
      const leftAt = Date.parse(String(left?.generatedAt ?? ""));
      const rightAt = Date.parse(String(right?.generatedAt ?? ""));
      if (Number.isFinite(leftAt) && Number.isFinite(rightAt) && rightAt !== leftAt) return rightAt - leftAt;
      return String(right?.artifactId ?? "").localeCompare(String(left?.artifactId ?? ""));
    });
    return filtered;
  }

  async function assertTenantVerifiedRunAllowance({
    tenantId,
    occurredAt = nowIso(),
    quantity = 1
  } = {}) {
    if (!effectiveBillingPlanEnforcementEnabled) return;
    const normalizedQuantityRaw = Number(quantity);
    const normalizedQuantity =
      Number.isSafeInteger(normalizedQuantityRaw) && normalizedQuantityRaw > 0
        ? normalizedQuantityRaw
        : 1;
    await getTenantBillingConfig(tenantId);
    const billingPlan = resolveTenantBillingPlan({ tenantId });
    const hardLimit = Number.isSafeInteger(billingPlan.hardLimitVerifiedRunsPerMonth)
      ? billingPlan.hardLimitVerifiedRunsPerMonth
      : 0;
    if (billingPlan.hardLimitEnforced !== true || hardLimit <= 0) return;
    const period = deriveBillablePeriod(occurredAt);
    const events = await listBillableUsageEventsAll({
      tenantId,
      period,
      eventType: BILLABLE_USAGE_EVENT_TYPE.VERIFIED_RUN
    });
    const usage = summarizeBillableUsageEvents(events);
    const projected = usage.verifiedRuns + normalizedQuantity;
    if (projected <= hardLimit) return;
    const err = new Error("verified run hard limit reached for billing plan");
    err.code = "BILLING_PLAN_LIMIT_EXCEEDED";
    err.detail = {
      period,
      plan: billingPlan.planId,
      hardLimitVerifiedRunsPerMonth: hardLimit,
      usedVerifiedRuns: usage.verifiedRuns,
      attemptedQuantity: normalizedQuantity,
      projectedVerifiedRuns: projected
    };
    throw err;
  }

  async function emitBillableUsageEvent({
    tenantId,
    eventKey,
    eventType,
    occurredAt = nowIso(),
    quantity = 1,
    amountCents = null,
    currency = null,
    runId = null,
    settlementId = null,
    disputeId = null,
    arbitrationCaseId = null,
    sourceType = null,
    sourceId = null,
    sourceEventId = null,
    audit = null
  } = {}) {
    if (typeof store.appendBillableUsageEvent !== "function") return null;
    const normalizedEventKey = typeof eventKey === "string" && eventKey.trim() !== "" ? eventKey.trim() : null;
    if (!normalizedEventKey) throw new TypeError("eventKey is required");
    const normalizedEventType = typeof eventType === "string" && eventType.trim() !== "" ? eventType.trim().toLowerCase() : null;
    if (!normalizedEventType) throw new TypeError("eventType is required");
    const normalizedOccurredAt = Number.isFinite(Date.parse(occurredAt)) ? new Date(occurredAt).toISOString() : nowIso();
    const normalizedQuantityRaw = Number(quantity);
    const normalizedQuantity = Number.isSafeInteger(normalizedQuantityRaw) && normalizedQuantityRaw >= 0 ? normalizedQuantityRaw : 1;
    const normalizedAmountRaw = amountCents === null || amountCents === undefined ? null : Number(amountCents);
    const normalizedAmountCents = normalizedAmountRaw === null ? null : Number.isSafeInteger(normalizedAmountRaw) ? normalizedAmountRaw : null;
    const normalizedCurrency =
      currency === null || currency === undefined || String(currency).trim() === "" ? null : String(currency).trim().toUpperCase();

    const canonicalEvent = normalizeForCanonicalJson(
      {
        schemaVersion: BILLABLE_USAGE_EVENT_SCHEMA_VERSION,
        tenantId: normalizeTenant(tenantId),
        eventKey: normalizedEventKey,
        eventType: normalizedEventType,
        period: deriveBillablePeriod(normalizedOccurredAt),
        occurredAt: normalizedOccurredAt,
        quantity: normalizedQuantity,
        amountCents: normalizedAmountCents,
        currency: normalizedCurrency,
        runId: runId ?? null,
        settlementId: settlementId ?? null,
        disputeId: disputeId ?? null,
        arbitrationCaseId: arbitrationCaseId ?? null,
        sourceType: sourceType ?? null,
        sourceId: sourceId ?? null,
        sourceEventId: sourceEventId ?? null,
        audit: audit && typeof audit === "object" && !Array.isArray(audit) ? audit : null
      },
      { path: "$" }
    );
    const eventHash = sha256Hex(canonicalJsonStringify(canonicalEvent));
    return store.appendBillableUsageEvent({
      tenantId,
      event: {
        ...canonicalEvent,
        eventHash,
        createdAt: nowIso()
      }
    });
  }

  async function emitBillableUsageEventBestEffort(input, { context = null } = {}) {
    try {
      return await emitBillableUsageEvent(input);
    } catch (err) {
      logger.warn("billing.event.emit_failed", {
        tenantId: input?.tenantId ?? null,
        eventType: input?.eventType ?? null,
        eventKey: input?.eventKey ?? null,
        runId: input?.runId ?? null,
        settlementId: input?.settlementId ?? null,
        disputeId: input?.disputeId ?? null,
        arbitrationCaseId: input?.arbitrationCaseId ?? null,
        context,
        err
      });
      return null;
    }
  }

  function normalizeReputationFactsWindowInput(value) {
    const window = parseReputationWindow(value ?? AGENT_REPUTATION_WINDOW.THIRTY_DAYS);
    if (window !== AGENT_REPUTATION_WINDOW.SEVEN_DAYS && window !== AGENT_REPUTATION_WINDOW.THIRTY_DAYS && window !== AGENT_REPUTATION_WINDOW.ALL_TIME) {
      throw new TypeError("window must be one of 7d|30d|allTime");
    }
    return window;
  }

  function reputationWindowStartAt({ window, at = nowIso() } = {}) {
    const nowMs = Date.parse(at);
    if (!Number.isFinite(nowMs)) return null;
    if (window === AGENT_REPUTATION_WINDOW.ALL_TIME) return null;
    const days = window === AGENT_REPUTATION_WINDOW.SEVEN_DAYS ? 7 : 30;
    return new Date(nowMs - days * 24 * 60 * 60 * 1000).toISOString();
  }

  function toSafeNonNegativeInt(value) {
    const n = Number(value);
    if (!Number.isSafeInteger(n) || n < 0) return null;
    return n;
  }

  function computePercentile(values, percentile) {
    if (!Array.isArray(values) || values.length === 0) return null;
    const sorted = [...values].sort((a, b) => a - b);
    const rank = Math.max(0, Math.ceil((Number(percentile) / 100) * sorted.length) - 1);
    return sorted[Math.min(sorted.length - 1, rank)];
  }

  function computeReputationFactsAggregate({ events = [] } = {}) {
    const totals = {
      eventCount: 0,
      decisions: { total: 0, approved: 0, rejected: 0 },
      disputes: { opened: 0, payerWin: 0, payeeWin: 0, partial: 0, rate: null },
      slaBreaches: { count: 0, rate: null },
      economics: {
        settledCents: 0,
        refundedCents: 0,
        penalizedCents: 0,
        autoReleasedCents: 0,
        adjustmentAppliedCents: 0
      }
    };
    const latencies = [];

    for (const event of events) {
      if (!event || typeof event !== "object" || Array.isArray(event)) continue;
      totals.eventCount += 1;
      const eventKind = String(event.eventKind ?? "").toLowerCase();
      const facts = event.facts && typeof event.facts === "object" && !Array.isArray(event.facts) ? event.facts : {};

      if (eventKind === REPUTATION_EVENT_KIND.DECISION_APPROVED) {
        totals.decisions.total += 1;
        totals.decisions.approved += 1;
      } else if (eventKind === REPUTATION_EVENT_KIND.DECISION_REJECTED) {
        totals.decisions.total += 1;
        totals.decisions.rejected += 1;
      } else if (eventKind === REPUTATION_EVENT_KIND.DISPUTE_OPENED) {
        totals.disputes.opened += 1;
      } else if (eventKind === REPUTATION_EVENT_KIND.VERDICT_ISSUED) {
        const outcome = String(facts.verdictOutcome ?? "").toLowerCase();
        if (outcome === "payer_win") totals.disputes.payerWin += 1;
        else if (outcome === "payee_win") totals.disputes.payeeWin += 1;
        else if (outcome === "partial") totals.disputes.partial += 1;
      } else if (eventKind === REPUTATION_EVENT_KIND.HOLDBACK_AUTO_RELEASED) {
        const autoReleasedCents = toSafeNonNegativeInt(facts.autoReleasedCents ?? facts.amountCents);
        if (autoReleasedCents !== null) totals.economics.autoReleasedCents += autoReleasedCents;
      } else if (eventKind === REPUTATION_EVENT_KIND.ADJUSTMENT_APPLIED) {
        const adjustmentAmountCents = toSafeNonNegativeInt(facts.amountCents);
        if (adjustmentAmountCents !== null) totals.economics.adjustmentAppliedCents += adjustmentAmountCents;
      }

      const settledCents = toSafeNonNegativeInt(facts.amountSettledCents);
      if (settledCents !== null) totals.economics.settledCents += settledCents;
      const refundedCents = toSafeNonNegativeInt(facts.amountRefundedCents);
      if (refundedCents !== null) totals.economics.refundedCents += refundedCents;
      const penalizedCents = toSafeNonNegativeInt(facts.amountPenalizedCents);
      if (penalizedCents !== null) totals.economics.penalizedCents += penalizedCents;

      const latencyMs = toSafeNonNegativeInt(facts.latencyMs);
      if (latencyMs !== null) latencies.push(latencyMs);
      if (facts.slaBreached === true) totals.slaBreaches.count += 1;
    }

    totals.disputes.rate = totals.decisions.total > 0 ? Number((totals.disputes.opened / totals.decisions.total).toFixed(6)) : null;
    totals.slaBreaches.rate = totals.decisions.total > 0 ? Number((totals.slaBreaches.count / totals.decisions.total).toFixed(6)) : null;
    return {
      totals,
      latencyMs: {
        count: latencies.length,
        p50: computePercentile(latencies, 50),
        p95: computePercentile(latencies, 95)
      }
    };
  }

  async function listReputationEventArtifactsAll({ tenantId, pageSize = 1000 } = {}) {
    if (typeof store.listArtifacts !== "function") return [];
    const safePageSize = Number.isSafeInteger(pageSize) && pageSize > 0 ? Math.min(1000, pageSize) : 1000;
    if (store.kind !== "pg") {
      const rows = await store.listArtifacts({ tenantId, artifactType: REPUTATION_EVENT_SCHEMA_VERSION });
      return Array.isArray(rows) ? rows : [];
    }
    let offset = 0;
    const out = [];
    while (true) {
      const chunk = await store.listArtifacts({
        tenantId,
        artifactType: REPUTATION_EVENT_SCHEMA_VERSION,
        limit: safePageSize,
        offset
      });
      if (!Array.isArray(chunk) || chunk.length === 0) break;
      out.push(...chunk);
      if (chunk.length < safePageSize) break;
      offset += chunk.length;
    }
    return out;
  }

  async function listReputationEventArtifactsBySubject({
    tenantId,
    agentId,
    toolId = null,
    occurredAtGte = null,
    occurredAtLte = null,
    pageSize = 1000
  } = {}) {
    if (typeof store.listReputationEvents === "function") {
      return await store.listReputationEvents({
        tenantId,
        agentId,
        toolId,
        occurredAtGte,
        occurredAtLte,
        limit: pageSize,
        offset: 0
      });
    }
    return listReputationEventArtifactsAll({ tenantId, pageSize });
  }

  async function emitReputationEvent({
    tenantId,
    eventId,
    occurredAt = nowIso(),
    eventKind,
    subject,
    sourceRef,
    facts = {},
    priority = 72
  } = {}) {
    if (typeof store.putArtifact !== "function") return null;
    const body = buildReputationEventV1({
      eventId,
      tenantId,
      occurredAt,
      eventKind,
      subject,
      sourceRef,
      facts
    });
    validateReputationEventV1(body);

    let artifact = null;
    const proposed = { ...body, artifactHash: computeArtifactHash(body) };
    try {
      artifact = await store.putArtifact({ tenantId, artifact: proposed });
    } catch (err) {
      if (err?.code !== "ARTIFACT_HASH_MISMATCH") throw err;
      if (typeof store.getArtifact !== "function") throw err;
      artifact = await store.getArtifact({ tenantId, artifactId: proposed.artifactId });
      if (!artifact) throw err;
    }

    if (typeof store.createDelivery !== "function") {
      return {
        artifactId: artifact.artifactId,
        artifactHash: artifact.artifactHash,
        deliveriesCreated: 0
      };
    }

    const destinations = listDestinationsForTenant(tenantId).filter((destination) => {
      const allowed = Array.isArray(destination?.artifactTypes) && destination.artifactTypes.length ? destination.artifactTypes : null;
      return !allowed || allowed.includes(REPUTATION_EVENT_SCHEMA_VERSION);
    });
    let deliveriesCreated = 0;
    for (const destination of destinations) {
      const dedupeKey = `${tenantId}:${destination.destinationId}:${REPUTATION_EVENT_SCHEMA_VERSION}:${artifact.artifactId}:${artifact.artifactHash}`;
      const scopeKey =
        String(sourceRef?.runId ?? "") ||
        String(sourceRef?.agreementHash ?? "") ||
        String(sourceRef?.settlementId ?? "") ||
        String(subject?.agentId ?? "") ||
        String(artifact.artifactId ?? "");
      const orderSeq = Date.parse(String(occurredAt ?? nowIso())) || 0;
      const orderKey = `${scopeKey}\n${String(orderSeq)}\n${String(priority)}\n${artifact.artifactId}`;
      try {
        await store.createDelivery({
          tenantId,
          delivery: {
            destinationId: destination.destinationId,
            artifactType: REPUTATION_EVENT_SCHEMA_VERSION,
            artifactId: artifact.artifactId,
            artifactHash: artifact.artifactHash,
            dedupeKey,
            scopeKey,
            orderSeq,
            priority,
            orderKey
          }
        });
        deliveriesCreated += 1;
      } catch (err) {
        if (err?.code === "DELIVERY_DEDUPE_CONFLICT") continue;
        throw err;
      }
    }
    return {
      artifactId: artifact.artifactId,
      artifactHash: artifact.artifactHash,
      deliveriesCreated
    };
  }

  async function emitReputationEventBestEffort(input, { context = null } = {}) {
    try {
      return await emitReputationEvent(input);
    } catch (err) {
      logger.warn("reputation.event.emit_failed", {
        tenantId: input?.tenantId ?? null,
        eventId: input?.eventId ?? null,
        eventKind: input?.eventKind ?? null,
        context,
        err
      });
      return null;
    }
  }

  function normalizePercentIntOrNull(value) {
    if (value === null || value === undefined) return null;
    const n = Number(value);
    if (!Number.isSafeInteger(n) || n < 0 || n > 100) return null;
    return n;
  }

  function resolveRunSettlementReleaseRatePct({ run, verification }) {
    const metricPct = normalizePercentIntOrNull(run?.metrics?.settlementReleaseRatePct);
    if (metricPct !== null) return metricPct;
    const verificationStatus = String(verification?.verificationStatus ?? "").toLowerCase();
    if (verificationStatus === "green") return 100;
    if (verificationStatus === "red") return 0;
    return 50;
  }

  function parseVerificationMethodInput(input) {
    try {
      const raw = input && typeof input === "object" && !Array.isArray(input) ? input : {};
      const expectedHash =
        typeof raw.verificationMethodHash === "string" && raw.verificationMethodHash.trim() !== ""
          ? raw.verificationMethodHash.trim().toLowerCase()
          : null;
      const normalized = normalizeVerificationMethod(raw);
      const computedHash = computeVerificationMethodHash(normalized);
      if (expectedHash && expectedHash !== computedHash) {
        throw new TypeError("verificationMethodHash does not match canonical verificationMethod");
      }
      return normalized;
    } catch (err) {
      const wrapped = new TypeError(`invalid verificationMethod: ${err?.message ?? "unknown error"}`);
      wrapped.cause = err;
      throw wrapped;
    }
  }

  function parseSettlementPolicyInput(input) {
    try {
      const raw = input && typeof input === "object" && !Array.isArray(input) ? input : {};
      const expectedHash =
        typeof raw.policyHash === "string" && raw.policyHash.trim() !== ""
          ? raw.policyHash.trim().toLowerCase()
          : null;
      const normalized = normalizeSettlementPolicy(raw);
      const computedHash = computeSettlementPolicyHash(normalized);
      if (expectedHash && expectedHash !== computedHash) {
        throw new TypeError("policyHash does not match canonical policy");
      }
      return {
        ...normalized,
        policyHash: computedHash
      };
    } catch (err) {
      const wrapped = new TypeError(`invalid policy: ${err?.message ?? "unknown error"}`);
      wrapped.cause = err;
      throw wrapped;
    }
  }

  function normalizeMarketplaceBidNoteInput(value, { allowNull = true } = {}) {
    if (value === undefined) return undefined;
    if (value === null) return allowNull ? null : "";
    const text = String(value).trim();
    if (!text) return allowNull ? null : "";
    return text;
  }

  function normalizeMarketplaceBidMetadataInput(value, { fieldPath = "metadata", allowUndefined = true } = {}) {
    if (value === undefined) return allowUndefined ? undefined : null;
    if (value === null) return null;
    if (typeof value !== "object" || Array.isArray(value)) {
      throw new TypeError(`${fieldPath} must be an object or null`);
    }
    return { ...value };
  }

  function normalizeMarketplaceCounterOfferPolicyInput(input, { fieldPath = "counterOfferPolicy" } = {}) {
    const raw = input && typeof input === "object" && !Array.isArray(input) ? input : {};
    const readBoolean = (value, path, defaultValue) => {
      if (value === undefined || value === null || value === "") return defaultValue;
      if (typeof value !== "boolean") throw new TypeError(`${path} must be boolean`);
      return value;
    };
    const readInt = ({ value, path, min = 0, defaultValue }) => {
      if (value === undefined || value === null || value === "") return defaultValue;
      const parsed = Number(value);
      if (!Number.isSafeInteger(parsed) || parsed < min) throw new TypeError(`${path} must be an integer >= ${min}`);
      return parsed;
    };

    const allowPosterCounterOffers = readBoolean(
      raw.allowPosterCounterOffers ?? raw.allowPoster,
      `${fieldPath}.allowPosterCounterOffers`,
      true
    );
    const allowBidderCounterOffers = readBoolean(
      raw.allowBidderCounterOffers ?? raw.allowBidder,
      `${fieldPath}.allowBidderCounterOffers`,
      true
    );
    if (!allowPosterCounterOffers && !allowBidderCounterOffers) {
      throw new TypeError(`${fieldPath} must allow at least one proposer role`);
    }

    const maxRevisions = readInt({
      value: raw.maxRevisions,
      path: `${fieldPath}.maxRevisions`,
      min: 1,
      defaultValue: 6
    });
    const timeoutSeconds = readInt({
      value: raw.timeoutSeconds,
      path: `${fieldPath}.timeoutSeconds`,
      min: 1,
      defaultValue: 86400
    });

    return normalizeForCanonicalJson(
      {
        schemaVersion: "MarketplaceCounterOfferPolicy.v1",
        allowPosterCounterOffers,
        allowBidderCounterOffers,
        maxRevisions,
        timeoutSeconds
      },
      { path: "$" }
    );
  }

  function resolveMarketplaceBidCounterOfferRole({ rfq, bid, proposerAgentId }) {
    const safeProposerAgentId = typeof proposerAgentId === "string" ? proposerAgentId.trim() : "";
    if (!safeProposerAgentId) return null;
    const bidderAgentId = typeof bid?.bidderAgentId === "string" ? bid.bidderAgentId.trim() : "";
    if (safeProposerAgentId === bidderAgentId) return "bidder";
    const posterAgentId = typeof rfq?.posterAgentId === "string" ? rfq.posterAgentId.trim() : "";
    if (safeProposerAgentId === posterAgentId) return "poster";
    return null;
  }

  function resolveMarketplaceCounterOfferPolicy({ rfq, bid } = {}) {
    const candidates = [
      bid?.counterOfferPolicy,
      bid?.negotiation?.counterOfferPolicy,
      rfq?.counterOfferPolicy,
      null
    ];
    for (const candidate of candidates) {
      if (candidate === undefined || candidate === null) continue;
      try {
        return normalizeMarketplaceCounterOfferPolicyInput(candidate);
      } catch {
        // Continue and fall back to defaults.
      }
    }
    return normalizeMarketplaceCounterOfferPolicyInput(null);
  }

  function computeMarketplaceNegotiationExpiresAt({ createdAt, timeoutSeconds }) {
    const createdMs = typeof createdAt === "string" ? Date.parse(createdAt) : Number.NaN;
    const timeout = Number(timeoutSeconds);
    if (!Number.isFinite(createdMs) || !Number.isSafeInteger(timeout) || timeout <= 0) return null;
    return new Date(createdMs + timeout * 1000).toISOString();
  }

  function applyMarketplaceBidNegotiationPolicy({
    negotiation,
    counterOfferPolicy,
    at = nowIso(),
    expireIfTimedOut = false
  } = {}) {
    if (!negotiation || typeof negotiation !== "object" || Array.isArray(negotiation)) {
      return {
        negotiation: null,
        counterOfferPolicy: normalizeMarketplaceCounterOfferPolicyInput(counterOfferPolicy ?? null),
        expiresAt: null,
        expired: false,
        justExpired: false
      };
    }
    const policy = normalizeMarketplaceCounterOfferPolicyInput(counterOfferPolicy ?? negotiation?.counterOfferPolicy ?? null);
    const createdAt =
      typeof negotiation?.createdAt === "string" && Number.isFinite(Date.parse(negotiation.createdAt))
        ? new Date(Date.parse(negotiation.createdAt)).toISOString()
        : at;
    const expiresAt = computeMarketplaceNegotiationExpiresAt({ createdAt, timeoutSeconds: policy.timeoutSeconds });
    const nowMs = Date.parse(at);
    const expiresMs = expiresAt ? Date.parse(expiresAt) : Number.NaN;
    const state = String(negotiation?.state ?? "open").trim().toLowerCase();
    const shouldExpire =
      expireIfTimedOut &&
      state === "open" &&
      Number.isFinite(nowMs) &&
      Number.isFinite(expiresMs) &&
      nowMs >= expiresMs;

    let nextNegotiation = normalizeForCanonicalJson(
      {
        ...negotiation,
        createdAt,
        updatedAt:
          typeof negotiation?.updatedAt === "string" && Number.isFinite(Date.parse(negotiation.updatedAt))
            ? negotiation.updatedAt
            : createdAt,
        counterOfferPolicy: policy,
        expiresAt,
        expiredAt:
          typeof negotiation?.expiredAt === "string" && Number.isFinite(Date.parse(negotiation.expiredAt))
            ? negotiation.expiredAt
            : null
      },
      { path: "$" }
    );
    if (shouldExpire) {
      nextNegotiation = updateMarketplaceBidNegotiationState({
        negotiation: nextNegotiation,
        state: "expired",
        at
      });
    }
    const nextState = String(nextNegotiation?.state ?? "").trim().toLowerCase();
    return {
      negotiation: nextNegotiation,
      counterOfferPolicy: policy,
      expiresAt,
      expired: nextState === "expired",
      justExpired: shouldExpire
    };
  }

  function buildMarketplaceBidNegotiationProposal({
    rfq,
    bidId,
    revision,
    proposerAgentId,
    amountCents,
    currency,
    etaSeconds = null,
    note = null,
    verificationMethodInput = null,
    settlementPolicyInput = null,
    policyRefInput = null,
    prevProposalHashInput = null,
    metadataInput = null,
    proposalIdInput = null,
    proposedAt = nowIso()
  }) {
    const safeBidId = typeof bidId === "string" && bidId.trim() !== "" ? bidId.trim() : null;
    if (!safeBidId) throw new TypeError("bidId is required");
    const safeRevision = Number(revision);
    if (!Number.isSafeInteger(safeRevision) || safeRevision <= 0) {
      throw new TypeError("negotiation revision must be a positive safe integer");
    }
    const safeProposerAgentId = typeof proposerAgentId === "string" && proposerAgentId.trim() !== "" ? proposerAgentId.trim() : null;
    if (!safeProposerAgentId) throw new TypeError("proposerAgentId is required");

    const safeAmountCents = Number(amountCents);
    if (!Number.isSafeInteger(safeAmountCents) || safeAmountCents <= 0) {
      throw new TypeError("amountCents must be a positive safe integer");
    }

    const rfqCurrency = typeof rfq?.currency === "string" && rfq.currency.trim() !== "" ? rfq.currency.trim().toUpperCase() : null;
    const safeCurrency = typeof currency === "string" && currency.trim() !== "" ? currency.trim().toUpperCase() : rfqCurrency ?? "USD";
    if (!safeCurrency) throw new TypeError("currency must be a non-empty string");
    if (rfqCurrency && safeCurrency !== rfqCurrency) {
      throw new TypeError("proposal currency must match rfq currency");
    }

    let safeEtaSeconds = null;
    if (etaSeconds !== null && etaSeconds !== undefined && etaSeconds !== "") {
      const parsedEta = Number(etaSeconds);
      if (!Number.isSafeInteger(parsedEta) || parsedEta <= 0) {
        throw new TypeError("etaSeconds must be a positive safe integer");
      }
      safeEtaSeconds = parsedEta;
    }

    const safeNote = normalizeMarketplaceBidNoteInput(note, { allowNull: true });
    const safeMetadata = normalizeMarketplaceBidMetadataInput(metadataInput, {
      fieldPath: "proposal.metadata",
      allowUndefined: false
    });
    const safeProposalId =
      typeof proposalIdInput === "string" && proposalIdInput.trim() !== ""
        ? proposalIdInput.trim()
        : `ofr_${safeBidId}_${safeRevision}`;
    const prevProposalHash = normalizeSha256HashInput(prevProposalHashInput, "proposal.prevProposalHash", {
      allowNull: true
    });
    if (safeRevision === 1 && prevProposalHash !== null) {
      throw new TypeError("proposal.prevProposalHash must be null for revision 1");
    }
    if (safeRevision > 1 && prevProposalHash === null) {
      throw new TypeError("proposal.prevProposalHash is required for revision > 1");
    }
    const normalizedProposedAt =
      typeof proposedAt === "string" && Number.isFinite(Date.parse(proposedAt)) ? new Date(Date.parse(proposedAt)).toISOString() : nowIso();

    const verificationMethod = parseVerificationMethodInput(verificationMethodInput ?? null);
    const policy = parseSettlementPolicyInput(settlementPolicyInput ?? null);
    const verificationMethodHash = computeVerificationMethodHash(verificationMethod);
    const policyRef =
      policyRefInput && typeof policyRefInput === "object" && !Array.isArray(policyRefInput)
        ? normalizeForCanonicalJson(
            {
              schemaVersion: MARKETPLACE_POLICY_REF_SCHEMA_VERSION,
              source:
                typeof policyRefInput.source === "string" && policyRefInput.source.trim() !== ""
                  ? String(policyRefInput.source).trim().toLowerCase()
                  : "tenant_registry",
              policyId:
                policyRefInput.policyId === null || policyRefInput.policyId === undefined || String(policyRefInput.policyId).trim() === ""
                  ? null
                  : String(policyRefInput.policyId).trim(),
              policyVersion: Number(policyRefInput.policyVersion ?? policy.policyVersion ?? 1),
              policyHash: policy.policyHash,
              verificationMethodHash
            },
            { path: "$" }
          )
        : normalizeForCanonicalJson(
            {
              schemaVersion: MARKETPLACE_POLICY_REF_SCHEMA_VERSION,
              source: "inline",
              policyId: null,
              policyVersion: Number(policy.policyVersion ?? 1),
              policyHash: policy.policyHash,
              verificationMethodHash
            },
            { path: "$" }
          );
    const policyRefHash = sha256Hex(canonicalJsonStringify(policyRef));

    const proposalCore = normalizeForCanonicalJson(
      {
        schemaVersion: "MarketplaceBidProposal.v1",
        proposalId: safeProposalId,
        bidId: safeBidId,
        revision: safeRevision,
        proposerAgentId: safeProposerAgentId,
        amountCents: safeAmountCents,
        currency: safeCurrency,
        etaSeconds: safeEtaSeconds,
        note: safeNote === undefined ? null : safeNote,
        verificationMethod,
        policy,
        policyRef,
        policyRefHash,
        prevProposalHash,
        metadata: safeMetadata ?? null,
        proposedAt: normalizedProposedAt
      },
      { path: "$" }
    );
    const proposalHash = sha256Hex(canonicalJsonStringify(proposalCore));

    return normalizeForCanonicalJson(
      {
        ...proposalCore,
        proposalHash
      },
      { path: "$" }
    );
  }

  function buildMarketplaceBidNegotiation({ bidId, initialProposal, counterOfferPolicy = null, at = nowIso() }) {
    if (!initialProposal || typeof initialProposal !== "object" || Array.isArray(initialProposal)) {
      throw new TypeError("initial negotiation proposal is required");
    }
    const policy = normalizeMarketplaceCounterOfferPolicyInput(counterOfferPolicy ?? null, {
      fieldPath: "counterOfferPolicy"
    });
    const expiresAt = computeMarketplaceNegotiationExpiresAt({ createdAt: at, timeoutSeconds: policy.timeoutSeconds });
    return normalizeForCanonicalJson(
      {
        schemaVersion: "MarketplaceBidNegotiation.v1",
        bidId: String(bidId),
        state: "open",
        latestRevision: Number(initialProposal.revision),
        acceptedRevision: null,
        acceptedProposalId: null,
        acceptedAt: null,
        acceptance: null,
        createdAt: at,
        updatedAt: at,
        counterOfferPolicy: policy,
        expiresAt,
        expiredAt: null,
        proposals: [initialProposal]
      },
      { path: "$" }
    );
  }

  function getLatestMarketplaceBidProposal(negotiation) {
    if (!negotiation || typeof negotiation !== "object" || Array.isArray(negotiation)) return null;
    const proposals = Array.isArray(negotiation.proposals) ? negotiation.proposals : [];
    for (let i = proposals.length - 1; i >= 0; i -= 1) {
      const candidate = proposals[i];
      if (candidate && typeof candidate === "object" && !Array.isArray(candidate)) return candidate;
    }
    return null;
  }

  function deriveMarketplaceProposalHash(proposal) {
    if (!proposal || typeof proposal !== "object" || Array.isArray(proposal)) return null;
    let providedHash = null;
    try {
      providedHash = normalizeSha256HashInput(proposal.proposalHash, "proposal.proposalHash", { allowNull: true });
    } catch {
      providedHash = null;
    }
    if (providedHash) return providedHash;
    try {
      const copy = { ...proposal };
      delete copy.proposalHash;
      return sha256Hex(canonicalJsonStringify(normalizeForCanonicalJson(copy, { path: "$" })));
    } catch {
      return null;
    }
  }

  function bootstrapMarketplaceBidNegotiation({ rfq, bid, counterOfferPolicy = null, at = nowIso() }) {
    const bidId = typeof bid?.bidId === "string" && bid.bidId.trim() !== "" ? bid.bidId.trim() : null;
    if (!bidId) throw new TypeError("bid.bidId is required");
    const proposerAgentId = typeof bid?.bidderAgentId === "string" && bid.bidderAgentId.trim() !== "" ? bid.bidderAgentId.trim() : null;
    if (!proposerAgentId) throw new TypeError("bid.bidderAgentId is required for negotiation bootstrap");
    const proposal = buildMarketplaceBidNegotiationProposal({
      rfq,
      bidId,
      revision: 1,
      proposerAgentId,
      amountCents: bid?.amountCents,
      currency: bid?.currency ?? rfq?.currency ?? "USD",
      etaSeconds: bid?.etaSeconds ?? null,
      note: bid?.note ?? null,
      verificationMethodInput: bid?.verificationMethod ?? null,
      settlementPolicyInput: bid?.policy ?? null,
      policyRefInput: bid?.policyRef ?? null,
      metadataInput: bid?.metadata ?? null,
      proposalIdInput: null,
      proposedAt: bid?.createdAt ?? at
    });
    return buildMarketplaceBidNegotiation({
      bidId,
      initialProposal: proposal,
      counterOfferPolicy: counterOfferPolicy ?? bid?.counterOfferPolicy ?? rfq?.counterOfferPolicy ?? null,
      at
    });
  }

  function appendMarketplaceBidNegotiationProposal({ negotiation, proposal, at = nowIso() }) {
    if (!negotiation || typeof negotiation !== "object" || Array.isArray(negotiation)) {
      throw new TypeError("negotiation is required");
    }
    if (!proposal || typeof proposal !== "object" || Array.isArray(proposal)) {
      throw new TypeError("proposal is required");
    }
    const current = Array.isArray(negotiation.proposals) ? negotiation.proposals : [];
    return normalizeForCanonicalJson(
      {
        ...negotiation,
        state: "open",
        latestRevision: Number(proposal.revision),
        acceptedRevision: null,
        acceptedProposalId: null,
        acceptedAt: null,
        acceptance: null,
        updatedAt: at,
        expiredAt: null,
        proposals: [...current, proposal]
      },
      { path: "$" }
    );
  }

  function updateMarketplaceBidNegotiationState({
    negotiation,
    state,
    at = nowIso(),
    acceptedByAgentId = null,
    acceptedProposalId = null,
    acceptedRevision = null
  }) {
    if (!negotiation || typeof negotiation !== "object" || Array.isArray(negotiation)) return null;
    const safeState = String(state ?? "").trim().toLowerCase();
    if (
      safeState !== "open" &&
      safeState !== "accepted" &&
      safeState !== "rejected" &&
      safeState !== "cancelled" &&
      safeState !== "expired"
    ) {
      throw new TypeError("unsupported negotiation state");
    }
    return normalizeForCanonicalJson(
      {
        ...negotiation,
        state: safeState,
        acceptedProposalId: safeState === "accepted" ? acceptedProposalId ?? null : null,
        acceptedRevision:
          safeState === "accepted" && Number.isSafeInteger(Number(acceptedRevision)) && Number(acceptedRevision) > 0
            ? Number(acceptedRevision)
            : null,
        acceptedAt: safeState === "accepted" ? at : null,
        acceptance:
          safeState === "accepted"
            ? normalizeForCanonicalJson(
                {
                  schemaVersion: MARKETPLACE_BID_ACCEPTANCE_SCHEMA_VERSION,
                  acceptedAt: at,
                  acceptedByAgentId: acceptedByAgentId ?? null,
                  acceptedProposalId: acceptedProposalId ?? null,
                  acceptedRevision:
                    Number.isSafeInteger(Number(acceptedRevision)) && Number(acceptedRevision) > 0 ? Number(acceptedRevision) : null
                },
                { path: "$" }
              )
            : null,
        expiredAt:
          safeState === "expired"
            ? typeof negotiation?.expiredAt === "string" && Number.isFinite(Date.parse(negotiation.expiredAt))
              ? negotiation.expiredAt
              : at
            : null,
        updatedAt: at
      },
      { path: "$" }
    );
  }

  function summarizeMarketplaceBidNegotiationForAgreement(negotiation) {
    if (!negotiation || typeof negotiation !== "object" || Array.isArray(negotiation)) {
      return {
        negotiation: null,
        offerChainHash: null,
        proposalCount: null,
        acceptedProposalId: null,
        acceptedRevision: null,
        acceptedProposalHash: null,
        acceptedProposal: null,
        acceptance: null
      };
    }
    const proposals = Array.isArray(negotiation.proposals)
      ? negotiation.proposals.filter((row) => row && typeof row === "object" && !Array.isArray(row))
      : [];
    if (!proposals.length) {
      return {
        negotiation: null,
        offerChainHash: null,
        proposalCount: null,
        acceptedProposalId: null,
        acceptedRevision: null,
        acceptedProposalHash: null,
        acceptedProposal: null,
        acceptance: null
      };
    }
    const latest = proposals[proposals.length - 1];
    const acceptedProposalId =
      typeof negotiation?.acceptedProposalId === "string" && negotiation.acceptedProposalId.trim() !== ""
        ? negotiation.acceptedProposalId.trim()
        : typeof latest?.proposalId === "string"
          ? latest.proposalId
          : null;
    const acceptedRevisionCandidate =
      negotiation?.acceptedRevision !== null && negotiation?.acceptedRevision !== undefined
        ? Number(negotiation.acceptedRevision)
        : Number(latest?.revision);
    const acceptedRevision =
      Number.isSafeInteger(acceptedRevisionCandidate) && acceptedRevisionCandidate > 0 ? acceptedRevisionCandidate : null;
    const acceptedProposal =
      proposals.find((row) => String(row?.proposalId ?? "") === String(acceptedProposalId ?? "")) ??
      (acceptedRevision !== null ? proposals.find((row) => Number(row?.revision) === acceptedRevision) : null) ??
      latest;
    const acceptedProposalHash =
      deriveMarketplaceProposalHash(acceptedProposal);
    const acceptance = normalizeForCanonicalJson(
      {
        schemaVersion: MARKETPLACE_AGREEMENT_ACCEPTANCE_SCHEMA_VERSION,
        acceptedAt:
          typeof negotiation?.acceptedAt === "string" && Number.isFinite(Date.parse(negotiation.acceptedAt))
            ? negotiation.acceptedAt
            : null,
        acceptedByAgentId:
          negotiation?.acceptance &&
          typeof negotiation.acceptance === "object" &&
          !Array.isArray(negotiation.acceptance) &&
          typeof negotiation.acceptance.acceptedByAgentId === "string" &&
          negotiation.acceptance.acceptedByAgentId.trim() !== ""
            ? negotiation.acceptance.acceptedByAgentId.trim()
            : null,
        acceptedProposalId,
        acceptedRevision,
        acceptedProposalHash,
        offerChainHash: sha256Hex(canonicalJsonStringify(normalizeForCanonicalJson(proposals, { path: "$" }))),
        proposalCount: proposals.length
      },
      { path: "$" }
    );
    const summary = normalizeForCanonicalJson(
      {
        schemaVersion: "MarketplaceAgreementNegotiation.v1",
        state: String(negotiation?.state ?? "open").trim().toLowerCase(),
        latestRevision: Number.isSafeInteger(Number(negotiation?.latestRevision)) ? Number(negotiation.latestRevision) : acceptedRevision ?? 1,
        acceptedRevision,
        acceptedProposalId,
        proposalCount: proposals.length
      },
      { path: "$" }
    );
    return {
      negotiation: summary,
      offerChainHash: acceptance.offerChainHash,
      proposalCount: proposals.length,
      acceptedProposalId,
      acceptedRevision,
      acceptedProposalHash,
      acceptedProposal: acceptedProposal ?? null,
      acceptance
    };
  }

  function isValidIsoDateTime(value) {
    return typeof value === "string" && value.trim() !== "" && Number.isFinite(Date.parse(value.trim()));
  }

  function normalizeDelegationScope(value) {
    if (value === null || value === undefined) return null;
    const text = String(value).trim();
    if (text === "") return null;
    return text.toLowerCase();
  }

  function delegationScopeAllows({ grantedScope, requiredScope }) {
    if (!requiredScope) return true;
    const required = String(requiredScope).trim().toLowerCase();
    if (!required) return true;
    const granted = normalizeDelegationScope(grantedScope);
    if (!granted) return true;
    if (granted === "*" || granted === required) return true;
    if (granted.endsWith("*")) {
      const prefix = granted.slice(0, -1);
      return prefix !== "" && required.startsWith(prefix);
    }
    return false;
  }

  function normalizeDelegationLinkCore({ tenantId, delegationLinkInput, path = "actingOnBehalfOf.delegationChain[]", allowNullExpiry = true } = {}) {
    if (
      !delegationLinkInput ||
      typeof delegationLinkInput !== "object" ||
      Array.isArray(delegationLinkInput)
    ) {
      throw new TypeError(`${path} must contain objects`);
    }
    const schemaVersionRaw = delegationLinkInput.schemaVersion;
    if (schemaVersionRaw !== null && schemaVersionRaw !== undefined) {
      const schemaVersion = String(schemaVersionRaw).trim();
      if (schemaVersion !== AGENT_DELEGATION_LINK_SCHEMA_VERSION) {
        throw new TypeError(`${path}.schemaVersion must be ${AGENT_DELEGATION_LINK_SCHEMA_VERSION}`);
      }
    }
    const delegationId =
      typeof delegationLinkInput.delegationId === "string" && delegationLinkInput.delegationId.trim() !== ""
        ? delegationLinkInput.delegationId.trim()
        : null;
    if (!delegationId) throw new TypeError(`${path}.delegationId is required`);
    const linkTenantId =
      typeof delegationLinkInput.tenantId === "string" && delegationLinkInput.tenantId.trim() !== ""
        ? delegationLinkInput.tenantId.trim()
        : normalizeTenant(tenantId);
    if (linkTenantId !== normalizeTenant(tenantId)) {
      throw new TypeError(`${path}.tenantId must match tenant`);
    }
    const principalAgentId =
      typeof delegationLinkInput.principalAgentId === "string" && delegationLinkInput.principalAgentId.trim() !== ""
        ? delegationLinkInput.principalAgentId.trim()
        : null;
    if (!principalAgentId) throw new TypeError(`${path}.principalAgentId is required`);
    const delegateAgentId =
      typeof delegationLinkInput.delegateAgentId === "string" && delegationLinkInput.delegateAgentId.trim() !== ""
        ? delegationLinkInput.delegateAgentId.trim()
        : null;
    if (!delegateAgentId) throw new TypeError(`${path}.delegateAgentId is required`);
    if (delegateAgentId === principalAgentId) {
      throw new TypeError(`${path}.delegateAgentId must differ from principalAgentId`);
    }
    const issuedAtRaw = delegationLinkInput.issuedAt;
    const issuedAt = typeof issuedAtRaw === "string" && issuedAtRaw.trim() !== "" ? issuedAtRaw.trim() : null;
    if (!isValidIsoDateTime(issuedAt)) {
      throw new TypeError(`${path}.issuedAt must be an ISO date-time`);
    }
    const expiresAtRaw = delegationLinkInput.expiresAt;
    const expiresAt =
      expiresAtRaw === null || expiresAtRaw === undefined || expiresAtRaw === ""
        ? null
        : typeof expiresAtRaw === "string" && expiresAtRaw.trim() !== ""
          ? expiresAtRaw.trim()
          : null;
    if (!allowNullExpiry && !expiresAt) {
      throw new TypeError(`${path}.expiresAt is required`);
    }
    if (expiresAt !== null && !isValidIsoDateTime(expiresAt)) {
      throw new TypeError(`${path}.expiresAt must be an ISO date-time`);
    }
    if (expiresAt !== null && Date.parse(expiresAt) <= Date.parse(issuedAt)) {
      throw new TypeError(`${path}.expiresAt must be later than issuedAt`);
    }
    const scope = normalizeDelegationScope(delegationLinkInput.scope);
    return normalizeForCanonicalJson(
      {
        schemaVersion: AGENT_DELEGATION_LINK_SCHEMA_VERSION,
        delegationId,
        tenantId: linkTenantId,
        principalAgentId,
        delegateAgentId,
        scope,
        issuedAt,
        expiresAt
      },
      { path: "$" }
    );
  }

  async function parseActingOnBehalfOf({
    tenantId,
    acceptedByAgentId,
    signerAgentId,
    signedAt,
    actingOnBehalfOfInput,
    requiredScope,
    enforceActiveAgents = true
  } = {}) {
    if (actingOnBehalfOfInput === null || actingOnBehalfOfInput === undefined) return null;
    if (
      !actingOnBehalfOfInput ||
      typeof actingOnBehalfOfInput !== "object" ||
      Array.isArray(actingOnBehalfOfInput)
    ) {
      throw new TypeError("acceptanceSignature.actingOnBehalfOf must be an object");
    }
    const schemaVersionRaw = actingOnBehalfOfInput.schemaVersion;
    if (schemaVersionRaw !== null && schemaVersionRaw !== undefined) {
      const schemaVersion = String(schemaVersionRaw).trim();
      if (schemaVersion !== AGENT_ACTING_ON_BEHALF_OF_SCHEMA_VERSION) {
        throw new TypeError(
          `acceptanceSignature.actingOnBehalfOf.schemaVersion must be ${AGENT_ACTING_ON_BEHALF_OF_SCHEMA_VERSION}`
        );
      }
    }
    const principalAgentId =
      typeof actingOnBehalfOfInput.principalAgentId === "string" &&
      actingOnBehalfOfInput.principalAgentId.trim() !== ""
        ? actingOnBehalfOfInput.principalAgentId.trim()
        : null;
    if (!principalAgentId) {
      throw new TypeError("acceptanceSignature.actingOnBehalfOf.principalAgentId is required");
    }
    if (principalAgentId !== acceptedByAgentId) {
      throw new TypeError("acceptanceSignature.actingOnBehalfOf.principalAgentId must match acceptedByAgentId");
    }
    const delegationChainInput = Array.isArray(actingOnBehalfOfInput.delegationChain)
      ? actingOnBehalfOfInput.delegationChain
      : null;
    if (!delegationChainInput || delegationChainInput.length === 0) {
      throw new TypeError("acceptanceSignature.actingOnBehalfOf.delegationChain must be a non-empty array");
    }
    const signedAtIso = typeof signedAt === "string" && signedAt.trim() !== "" ? signedAt.trim() : null;
    if (!isValidIsoDateTime(signedAtIso)) {
      throw new TypeError("acceptanceSignature.signedAt must be an ISO date-time");
    }
    const signedAtMs = Date.parse(signedAtIso);
    const normalizedChain = [];
    let expectedPrincipalAgentId = principalAgentId;
    for (let index = 0; index < delegationChainInput.length; index += 1) {
      const path = `acceptanceSignature.actingOnBehalfOf.delegationChain[${index}]`;
      const rawLink = delegationChainInput[index];
      const core = normalizeDelegationLinkCore({ tenantId, delegationLinkInput: rawLink, path });
      if (core.principalAgentId !== expectedPrincipalAgentId) {
        throw new TypeError(`${path}.principalAgentId must continue the delegation chain`);
      }
      if (!delegationScopeAllows({ grantedScope: core.scope, requiredScope })) {
        throw new TypeError(`${path}.scope does not allow ${requiredScope}`);
      }
      if (signedAtMs < Date.parse(core.issuedAt)) {
        throw new TypeError(`${path} is not active at acceptanceSignature.signedAt`);
      }
      if (core.expiresAt !== null && signedAtMs > Date.parse(core.expiresAt)) {
        throw new TypeError(`${path} expired before acceptanceSignature.signedAt`);
      }
      const signerKeyId =
        typeof rawLink?.signerKeyId === "string" && rawLink.signerKeyId.trim() !== ""
          ? rawLink.signerKeyId.trim()
          : null;
      const signature =
        typeof rawLink?.signature === "string" && rawLink.signature.trim() !== ""
          ? rawLink.signature.trim()
          : null;
      if (!signerKeyId || !signature) {
        throw new TypeError(`${path}.signerKeyId and ${path}.signature are required`);
      }
      const providedDelegationHash = normalizeSha256HashInput(rawLink?.delegationHash, `${path}.delegationHash`, {
        allowNull: true
      });
      if (!providedDelegationHash) {
        throw new TypeError(`${path}.delegationHash is required`);
      }
      const expectedDelegationHash = sha256Hex(canonicalJsonStringify(core));
      if (providedDelegationHash !== expectedDelegationHash) {
        throw new TypeError(`${path}.delegationHash does not match canonical delegation payload`);
      }
      const principalIdentity = await getAgentIdentityRecord({ tenantId, agentId: core.principalAgentId });
      if (!principalIdentity) throw new TypeError(`${path}.principalAgentId identity not found`);
      const principalStatus = String(principalIdentity?.status ?? "active").toLowerCase();
      if (enforceActiveAgents && principalStatus !== "active") {
        throw new TypeError(`${path}.principalAgentId must be active`);
      }
      const expectedAgentKeyId = String(principalIdentity?.keys?.keyId ?? "");
      if (expectedAgentKeyId && signerKeyId !== expectedAgentKeyId) {
        throw new TypeError(`${path}.signerKeyId does not match principal agent key`);
      }
      const publicKeyPem = await loadSignerPublicKeyPem({ tenantId, signerKeyId });
      const isValidSignature = verifyHashHexEd25519({
        hashHex: providedDelegationHash,
        signatureBase64: signature,
        publicKeyPem
      });
      if (!isValidSignature) {
        throw new TypeError(`${path}.signature is invalid`);
      }
      const normalizedLink = normalizeForCanonicalJson(
        {
          ...core,
          signerKeyId,
          delegationHash: providedDelegationHash,
          signature
        },
        { path: "$" }
      );
      normalizedChain.push(normalizedLink);
      expectedPrincipalAgentId = core.delegateAgentId;
    }
    const delegateAgentId = expectedPrincipalAgentId;
    if (delegateAgentId !== signerAgentId) {
      throw new TypeError("acceptanceSignature.signerAgentId must match actingOnBehalfOf delegated agent");
    }
    const delegateIdentity = await getAgentIdentityRecord({ tenantId, agentId: delegateAgentId });
    if (!delegateIdentity) throw new TypeError("acceptanceSignature.actingOnBehalfOf.delegateAgentId identity not found");
    const delegateStatus = String(delegateIdentity?.status ?? "active").toLowerCase();
    if (enforceActiveAgents && delegateStatus !== "active") {
      throw new TypeError("acceptanceSignature.actingOnBehalfOf.delegateAgentId must be active");
    }
    const computedChainHash = sha256Hex(canonicalJsonStringify(normalizedChain));
    const chainHashRaw = actingOnBehalfOfInput.chainHash;
    if (chainHashRaw !== null && chainHashRaw !== undefined && chainHashRaw !== "") {
      const providedChainHash = normalizeSha256HashInput(
        chainHashRaw,
        "acceptanceSignature.actingOnBehalfOf.chainHash",
        { allowNull: true }
      );
      if (providedChainHash && providedChainHash !== computedChainHash) {
        throw new TypeError("acceptanceSignature.actingOnBehalfOf.chainHash mismatch");
      }
    }
    return normalizeForCanonicalJson(
      {
        schemaVersion: AGENT_ACTING_ON_BEHALF_OF_SCHEMA_VERSION,
        principalAgentId,
        delegateAgentId,
        delegationChain: normalizedChain,
        chainHash: computedChainHash
      },
      { path: "$" }
    );
  }

  function buildMarketplaceAgreementAcceptanceSignatureCore({ agreement, actingOnBehalfOf = null } = {}) {
    const agreementObj = agreement && typeof agreement === "object" && !Array.isArray(agreement) ? agreement : null;
    if (!agreementObj) throw new TypeError("agreement is required for acceptance signature");
    const acceptanceObj =
      agreementObj.acceptance && typeof agreementObj.acceptance === "object" && !Array.isArray(agreementObj.acceptance)
        ? agreementObj.acceptance
        : null;
    const acceptedByAgentId =
      typeof agreementObj.acceptedByAgentId === "string" && agreementObj.acceptedByAgentId.trim() !== ""
        ? agreementObj.acceptedByAgentId.trim()
        : typeof acceptanceObj?.acceptedByAgentId === "string" && acceptanceObj.acceptedByAgentId.trim() !== ""
          ? acceptanceObj.acceptedByAgentId.trim()
          : null;
    if (!acceptedByAgentId) throw new TypeError("agreement.acceptedByAgentId is required for acceptance signature");
    const acceptedProposalId =
      typeof acceptanceObj?.acceptedProposalId === "string" && acceptanceObj.acceptedProposalId.trim() !== ""
        ? acceptanceObj.acceptedProposalId.trim()
        : typeof agreementObj.acceptedProposalId === "string" && agreementObj.acceptedProposalId.trim() !== ""
          ? agreementObj.acceptedProposalId.trim()
          : null;
    const acceptedRevisionRaw =
      acceptanceObj?.acceptedRevision !== null && acceptanceObj?.acceptedRevision !== undefined
        ? Number(acceptanceObj.acceptedRevision)
        : Number(agreementObj.acceptedRevision);
    const acceptedRevision =
      Number.isSafeInteger(acceptedRevisionRaw) && acceptedRevisionRaw > 0 ? acceptedRevisionRaw : null;
    const acceptedProposalHash = normalizeSha256HashInput(
      acceptanceObj?.acceptedProposalHash ?? agreementObj.acceptedProposalHash ?? null,
      "agreement.acceptedProposalHash",
      { allowNull: true }
    );
    const offerChainHash = normalizeSha256HashInput(
      acceptanceObj?.offerChainHash ?? agreementObj.offerChainHash ?? null,
      "agreement.offerChainHash",
      { allowNull: true }
    );
    const proposalCountRaw = acceptanceObj?.proposalCount;
    const proposalCount =
      Number.isSafeInteger(Number(proposalCountRaw)) && Number(proposalCountRaw) > 0 ? Number(proposalCountRaw) : null;
    return normalizeForCanonicalJson(
      {
        schemaVersion: MARKETPLACE_AGREEMENT_ACCEPTANCE_SIGNATURE_SCHEMA_VERSION,
        agreementId: String(agreementObj.agreementId ?? ""),
        tenantId: String(agreementObj.tenantId ?? ""),
        rfqId: String(agreementObj.rfqId ?? ""),
        runId: String(agreementObj.runId ?? ""),
        bidId: String(agreementObj.bidId ?? ""),
        acceptedByAgentId,
        acceptedProposalId,
        acceptedRevision,
        acceptedProposalHash,
        offerChainHash,
        proposalCount,
        actingOnBehalfOfPrincipalAgentId:
          actingOnBehalfOf && typeof actingOnBehalfOf === "object" ? actingOnBehalfOf.principalAgentId ?? null : null,
        actingOnBehalfOfDelegateAgentId:
          actingOnBehalfOf && typeof actingOnBehalfOf === "object" ? actingOnBehalfOf.delegateAgentId ?? null : null,
        actingOnBehalfOfChainHash:
          actingOnBehalfOf && typeof actingOnBehalfOf === "object" ? actingOnBehalfOf.chainHash ?? null : null
      },
      { path: "$" }
    );
  }

  async function parseSignedMarketplaceAgreementAcceptance({
    tenantId,
    agreement,
    acceptedByAgentId = null,
    acceptedByIdentity = null,
    acceptanceSignatureInput
  } = {}) {
    if (!acceptanceSignatureInput || typeof acceptanceSignatureInput !== "object" || Array.isArray(acceptanceSignatureInput)) {
      throw new TypeError("acceptanceSignature must be an object");
    }
    const acceptedByNormalized =
      typeof acceptedByAgentId === "string" && acceptedByAgentId.trim() !== "" ? acceptedByAgentId.trim() : null;
    const signerAgentIdRaw = acceptanceSignatureInput.signerAgentId;
    const signerAgentId =
      typeof signerAgentIdRaw === "string" && signerAgentIdRaw.trim() !== ""
        ? signerAgentIdRaw.trim()
        : acceptedByNormalized;
    if (!signerAgentId) throw new TypeError("acceptanceSignature.signerAgentId is required");
    const signedAtRaw = acceptanceSignatureInput.signedAt;
    const signedAt =
      typeof signedAtRaw === "string" && signedAtRaw.trim() !== "" ? signedAtRaw.trim() : nowIso();
    if (!Number.isFinite(Date.parse(signedAt))) throw new TypeError("acceptanceSignature.signedAt must be an ISO date-time");
    const actingOnBehalfOf = await parseActingOnBehalfOf({
      tenantId,
      acceptedByAgentId: acceptedByNormalized,
      signerAgentId,
      signedAt,
      actingOnBehalfOfInput: acceptanceSignatureInput.actingOnBehalfOf,
      requiredScope: MARKETPLACE_DELEGATION_SCOPE_AGREEMENT_ACCEPT
    });
    if (!actingOnBehalfOf && acceptedByNormalized && signerAgentId !== acceptedByNormalized) {
      throw new TypeError("acceptanceSignature.signerAgentId must match acceptedByAgentId");
    }

    const signerIdentity =
      acceptedByIdentity && signerAgentId === acceptedByNormalized
        ? acceptedByIdentity
        : await getAgentIdentityRecord({ tenantId, agentId: signerAgentId });
    if (!signerIdentity) throw new TypeError("acceptanceSignature signer agent not found");
    if (String(signerIdentity?.status ?? "active").toLowerCase() !== "active") {
      throw new TypeError("acceptanceSignature signer agent must be active");
    }

    const signerKeyId =
      typeof acceptanceSignatureInput.signerKeyId === "string" && acceptanceSignatureInput.signerKeyId.trim() !== ""
        ? acceptanceSignatureInput.signerKeyId.trim()
        : null;
    const signature =
      typeof acceptanceSignatureInput.signature === "string" && acceptanceSignatureInput.signature.trim() !== ""
        ? acceptanceSignatureInput.signature.trim()
        : null;
    if (!signerKeyId || !signature) {
      throw new TypeError("acceptanceSignature.signerKeyId and acceptanceSignature.signature are required");
    }
    const expectedAgentKeyId = String(signerIdentity?.keys?.keyId ?? "");
    if (expectedAgentKeyId && signerKeyId !== expectedAgentKeyId) {
      throw new TypeError("acceptanceSignature.signerKeyId does not match signer agent key");
    }

    const core = buildMarketplaceAgreementAcceptanceSignatureCore({ agreement, actingOnBehalfOf });
    const expectedSignerAgentId = actingOnBehalfOf?.delegateAgentId ?? core.acceptedByAgentId;
    if (expectedSignerAgentId && expectedSignerAgentId !== signerAgentId) {
      throw new TypeError("acceptanceSignature.signerAgentId must match agreement.acceptedByAgentId");
    }
    const acceptanceHash = sha256Hex(canonicalJsonStringify(core));
    const publicKeyPem = await loadSignerPublicKeyPem({ tenantId, signerKeyId });
    const isValid = verifyHashHexEd25519({
      hashHex: acceptanceHash,
      signatureBase64: signature,
      publicKeyPem
    });
    if (!isValid) throw new TypeError("invalid acceptanceSignature signature");

    return normalizeForCanonicalJson(
      {
        ...core,
        signerAgentId,
        signerKeyId,
        signedAt,
        actingOnBehalfOf: actingOnBehalfOf ?? null,
        acceptanceHash,
        signature
      },
      { path: "$" }
    );
  }

  async function loadSignerPublicKeyPem({ tenantId, signerKeyId }) {
    const keyId = typeof signerKeyId === "string" ? signerKeyId.trim() : "";
    if (!keyId) throw new TypeError("signerKeyId is required");
    const fromCache = store.publicKeyByKeyId instanceof Map ? store.publicKeyByKeyId.get(keyId) ?? null : null;
    if (typeof fromCache === "string" && fromCache.trim() !== "") return fromCache;
    if (typeof store.getSignerKey === "function") {
      const signerKey = await store.getSignerKey({ tenantId, keyId });
      if (signerKey?.publicKeyPem) {
        if (store.publicKeyByKeyId instanceof Map) {
          store.publicKeyByKeyId.set(keyId, signerKey.publicKeyPem);
        }
        return signerKey.publicKeyPem;
      }
    }
    throw new TypeError("unknown signerKeyId");
  }

  async function parseSignedDisputeVerdict({
    tenantId,
    runId,
    settlement,
    disputeId,
    verdictInput
  } = {}) {
    if (!verdictInput || typeof verdictInput !== "object" || Array.isArray(verdictInput)) {
      throw new TypeError("verdict must be an object");
    }
    const normalizedDisputeId = typeof disputeId === "string" && disputeId.trim() !== "" ? disputeId.trim() : null;
    if (!normalizedDisputeId) throw new TypeError("disputeId is required for verdict signing");
    const verdictIdRaw = verdictInput.verdictId ?? createId("vrd");
    const verdictId = typeof verdictIdRaw === "string" && verdictIdRaw.trim() !== "" ? verdictIdRaw.trim() : null;
    if (!verdictId) throw new TypeError("verdict.verdictId must be a non-empty string");
    const arbiterAgentId = typeof verdictInput.arbiterAgentId === "string" && verdictInput.arbiterAgentId.trim() !== ""
      ? verdictInput.arbiterAgentId.trim()
      : null;
    if (!arbiterAgentId) throw new TypeError("verdict.arbiterAgentId is required");
    const arbiterIdentity = await getAgentIdentityRecord({ tenantId, agentId: arbiterAgentId });
    if (!arbiterIdentity) throw new TypeError("verdict.arbiterAgentId not found");

    const outcome = typeof verdictInput.outcome === "string" ? verdictInput.outcome.trim().toLowerCase() : "";
    if (outcome !== "accepted" && outcome !== "rejected" && outcome !== "partial") {
      throw new TypeError("verdict.outcome must be accepted|rejected|partial");
    }
    const issuedAt = typeof verdictInput.issuedAt === "string" && verdictInput.issuedAt.trim() !== ""
      ? verdictInput.issuedAt.trim()
      : nowIso();
    if (!Number.isFinite(Date.parse(issuedAt))) throw new TypeError("verdict.issuedAt must be an ISO date-time");

    const releaseRatePctRaw = verdictInput.releaseRatePct;
    const releaseRatePct =
      releaseRatePctRaw === null || releaseRatePctRaw === undefined || releaseRatePctRaw === ""
        ? null
        : Number(releaseRatePctRaw);
    if (releaseRatePct !== null && (!Number.isSafeInteger(releaseRatePct) || releaseRatePct < 0 || releaseRatePct > 100)) {
      throw new TypeError("verdict.releaseRatePct must be an integer within 0..100");
    }
    const rationale =
      typeof verdictInput.rationale === "string" && verdictInput.rationale.trim() !== ""
        ? verdictInput.rationale.trim()
        : null;
    const signerKeyId = typeof verdictInput.signerKeyId === "string" && verdictInput.signerKeyId.trim() !== ""
      ? verdictInput.signerKeyId.trim()
      : null;
    const signature = typeof verdictInput.signature === "string" && verdictInput.signature.trim() !== ""
      ? verdictInput.signature.trim()
      : null;
    if (!signerKeyId || !signature) throw new TypeError("verdict.signerKeyId and verdict.signature are required");
    const expectedAgentKeyId = String(arbiterIdentity?.keys?.keyId ?? "");
    if (expectedAgentKeyId && signerKeyId !== expectedAgentKeyId) {
      throw new TypeError("verdict.signerKeyId does not match arbiter agent key");
    }

    const core = normalizeForCanonicalJson(
      {
        schemaVersion: "DisputeVerdict.v1",
        verdictId,
        tenantId: normalizeTenant(tenantId),
        runId: String(runId),
        settlementId: String(settlement?.settlementId ?? ""),
        disputeId: normalizedDisputeId,
        arbiterAgentId,
        outcome,
        releaseRatePct,
        rationale,
        issuedAt
      },
      { path: "$" }
    );
    const verdictHash = sha256Hex(canonicalJsonStringify(core));
    const publicKeyPem = await loadSignerPublicKeyPem({ tenantId, signerKeyId });
    const isValid = verifyHashHexEd25519({
      hashHex: verdictHash,
      signatureBase64: signature,
      publicKeyPem
    });
    if (!isValid) throw new TypeError("invalid verdict signature");
    return {
      ...core,
      signerKeyId,
      signature,
      verdictHash
    };
  }

  function normalizeUniqueNonEmptyStringArray(value, { fieldName }) {
    if (!Array.isArray(value)) throw new TypeError(`${fieldName} must be an array`);
    const out = [];
    const seen = new Set();
    for (let index = 0; index < value.length; index += 1) {
      const item = value[index];
      if (typeof item !== "string" || item.trim() === "") {
        throw new TypeError(`${fieldName}[${index}] must be a non-empty string`);
      }
      const normalized = item.trim();
      if (seen.has(normalized)) continue;
      seen.add(normalized);
      out.push(normalized);
    }
    return out;
  }

  async function parseSignedArbitrationVerdict({
    tenantId,
    runId,
    settlement,
    disputeId,
    arbitrationVerdictInput
  } = {}) {
    if (!arbitrationVerdictInput || typeof arbitrationVerdictInput !== "object" || Array.isArray(arbitrationVerdictInput)) {
      throw new TypeError("arbitrationVerdict must be an object");
    }
    const normalizedDisputeId = typeof disputeId === "string" && disputeId.trim() !== "" ? disputeId.trim() : null;
    if (!normalizedDisputeId) throw new TypeError("disputeId is required for arbitrationVerdict signing");

    const caseIdRaw = arbitrationVerdictInput.caseId ?? `arb_case_${normalizedDisputeId}`;
    const caseId = typeof caseIdRaw === "string" && caseIdRaw.trim() !== "" ? caseIdRaw.trim() : null;
    if (!caseId) throw new TypeError("arbitrationVerdict.caseId must be a non-empty string");
    const verdictIdRaw = arbitrationVerdictInput.verdictId ?? createId("avd");
    const verdictId = typeof verdictIdRaw === "string" && verdictIdRaw.trim() !== "" ? verdictIdRaw.trim() : null;
    if (!verdictId) throw new TypeError("arbitrationVerdict.verdictId must be a non-empty string");

    const arbiterAgentId =
      typeof arbitrationVerdictInput.arbiterAgentId === "string" && arbitrationVerdictInput.arbiterAgentId.trim() !== ""
        ? arbitrationVerdictInput.arbiterAgentId.trim()
        : null;
    if (!arbiterAgentId) throw new TypeError("arbitrationVerdict.arbiterAgentId is required");
    const arbiterIdentity = await getAgentIdentityRecord({ tenantId, agentId: arbiterAgentId });
    if (!arbiterIdentity) throw new TypeError("arbitrationVerdict.arbiterAgentId not found");

    const outcome = typeof arbitrationVerdictInput.outcome === "string" ? arbitrationVerdictInput.outcome.trim().toLowerCase() : "";
    if (outcome !== "accepted" && outcome !== "rejected" && outcome !== "partial") {
      throw new TypeError("arbitrationVerdict.outcome must be accepted|rejected|partial");
    }
    const releaseRatePct = Number(arbitrationVerdictInput.releaseRatePct);
    if (!Number.isSafeInteger(releaseRatePct) || releaseRatePct < 0 || releaseRatePct > 100) {
      throw new TypeError("arbitrationVerdict.releaseRatePct must be an integer within 0..100");
    }
    const rationale =
      typeof arbitrationVerdictInput.rationale === "string" && arbitrationVerdictInput.rationale.trim() !== ""
        ? arbitrationVerdictInput.rationale.trim()
        : null;
    if (!rationale) throw new TypeError("arbitrationVerdict.rationale is required");
    const evidenceRefs = normalizeUniqueNonEmptyStringArray(arbitrationVerdictInput.evidenceRefs, {
      fieldName: "arbitrationVerdict.evidenceRefs"
    });
    const issuedAt =
      typeof arbitrationVerdictInput.issuedAt === "string" && arbitrationVerdictInput.issuedAt.trim() !== ""
        ? arbitrationVerdictInput.issuedAt.trim()
        : nowIso();
    if (!Number.isFinite(Date.parse(issuedAt))) throw new TypeError("arbitrationVerdict.issuedAt must be an ISO date-time");

    let appealRef = null;
    if (arbitrationVerdictInput.appealRef !== undefined && arbitrationVerdictInput.appealRef !== null) {
      if (typeof arbitrationVerdictInput.appealRef !== "object" || Array.isArray(arbitrationVerdictInput.appealRef)) {
        throw new TypeError("arbitrationVerdict.appealRef must be an object");
      }
      const appealCaseId =
        typeof arbitrationVerdictInput.appealRef.appealCaseId === "string" && arbitrationVerdictInput.appealRef.appealCaseId.trim() !== ""
          ? arbitrationVerdictInput.appealRef.appealCaseId.trim()
          : null;
      const parentVerdictId =
        typeof arbitrationVerdictInput.appealRef.parentVerdictId === "string" &&
        arbitrationVerdictInput.appealRef.parentVerdictId.trim() !== ""
          ? arbitrationVerdictInput.appealRef.parentVerdictId.trim()
          : null;
      if (!appealCaseId || !parentVerdictId) {
        throw new TypeError("arbitrationVerdict.appealRef.appealCaseId and arbitrationVerdict.appealRef.parentVerdictId are required");
      }
      const appealReason =
        arbitrationVerdictInput.appealRef.reason === undefined || arbitrationVerdictInput.appealRef.reason === null
          ? null
          : typeof arbitrationVerdictInput.appealRef.reason === "string" && arbitrationVerdictInput.appealRef.reason.trim() !== ""
            ? arbitrationVerdictInput.appealRef.reason.trim()
            : null;
      if (arbitrationVerdictInput.appealRef.reason !== undefined && arbitrationVerdictInput.appealRef.reason !== null && !appealReason) {
        throw new TypeError("arbitrationVerdict.appealRef.reason must be a non-empty string when provided");
      }
      appealRef = {
        appealCaseId,
        parentVerdictId,
        reason: appealReason
      };
    }

    const signerKeyId =
      typeof arbitrationVerdictInput.signerKeyId === "string" && arbitrationVerdictInput.signerKeyId.trim() !== ""
        ? arbitrationVerdictInput.signerKeyId.trim()
        : null;
    const signature =
      typeof arbitrationVerdictInput.signature === "string" && arbitrationVerdictInput.signature.trim() !== ""
        ? arbitrationVerdictInput.signature.trim()
        : null;
    if (!signerKeyId || !signature) {
      throw new TypeError("arbitrationVerdict.signerKeyId and arbitrationVerdict.signature are required");
    }
    const expectedAgentKeyId = String(arbiterIdentity?.keys?.keyId ?? "");
    if (expectedAgentKeyId && signerKeyId !== expectedAgentKeyId) {
      throw new TypeError("arbitrationVerdict.signerKeyId does not match arbiter agent key");
    }

    const core = normalizeForCanonicalJson(
      {
        schemaVersion: "ArbitrationVerdict.v1",
        verdictId,
        caseId,
        tenantId: normalizeTenant(tenantId),
        runId: String(runId),
        settlementId: String(settlement?.settlementId ?? ""),
        disputeId: normalizedDisputeId,
        arbiterAgentId,
        outcome,
        releaseRatePct,
        rationale,
        evidenceRefs,
        issuedAt,
        appealRef
      },
      { path: "$" }
    );
    const verdictHash = sha256Hex(canonicalJsonStringify(core));
    const publicKeyPem = await loadSignerPublicKeyPem({ tenantId, signerKeyId });
    const isValid = verifyHashHexEd25519({
      hashHex: verdictHash,
      signatureBase64: signature,
      publicKeyPem
    });
    if (!isValid) throw new TypeError("invalid arbitrationVerdict signature");
    return {
      ...core,
      signerKeyId,
      signature,
      verdictHash,
      signatureEnvelope: {
        algorithm: "ed25519",
        signerKeyId,
        verdictHash,
        signature
      }
    };
  }

  async function parseSignedDisputeOpenEnvelope({
    tenantId,
    disputeOpenEnvelopeInput,
    expectedCaseId,
    expectedAgreementHash,
    expectedReceiptHash,
    expectedHoldHash
  } = {}) {
    if (!disputeOpenEnvelopeInput || typeof disputeOpenEnvelopeInput !== "object" || Array.isArray(disputeOpenEnvelopeInput)) {
      throw new TypeError("disputeOpenEnvelope must be an object");
    }
    validateDisputeOpenEnvelopeV1(disputeOpenEnvelopeInput);
    const envelope = normalizeForCanonicalJson(disputeOpenEnvelopeInput, { path: "$" });
    if (String(envelope.schemaVersion ?? "") !== DISPUTE_OPEN_ENVELOPE_SCHEMA_VERSION) {
      throw new TypeError(`disputeOpenEnvelope.schemaVersion must be ${DISPUTE_OPEN_ENVELOPE_SCHEMA_VERSION}`);
    }
    if (String(envelope.tenantId ?? "") !== String(normalizeTenant(tenantId))) {
      throw new TypeError("disputeOpenEnvelope.tenantId must match tenant");
    }

    const caseId = typeof envelope.caseId === "string" && envelope.caseId.trim() !== "" ? envelope.caseId.trim() : null;
    if (!caseId) throw new TypeError("disputeOpenEnvelope.caseId is required");
    if (expectedCaseId && caseId !== String(expectedCaseId)) {
      throw new TypeError("disputeOpenEnvelope.caseId does not match deterministic case id");
    }

    if (expectedAgreementHash && String(envelope.agreementHash ?? "").toLowerCase() !== String(expectedAgreementHash).toLowerCase()) {
      throw new TypeError("disputeOpenEnvelope.agreementHash mismatch");
    }
    if (expectedReceiptHash && String(envelope.receiptHash ?? "").toLowerCase() !== String(expectedReceiptHash).toLowerCase()) {
      throw new TypeError("disputeOpenEnvelope.receiptHash mismatch");
    }
    if (expectedHoldHash && String(envelope.holdHash ?? "").toLowerCase() !== String(expectedHoldHash).toLowerCase()) {
      throw new TypeError("disputeOpenEnvelope.holdHash mismatch");
    }

    const openedByAgentId =
      typeof envelope.openedByAgentId === "string" && envelope.openedByAgentId.trim() !== ""
        ? envelope.openedByAgentId.trim()
        : null;
    if (!openedByAgentId) throw new TypeError("disputeOpenEnvelope.openedByAgentId is required");
    const openerIdentity = await getAgentIdentityRecord({ tenantId, agentId: openedByAgentId });
    if (!openerIdentity) throw new TypeError("disputeOpenEnvelope.openedByAgentId not found");

    const signerKeyId =
      typeof envelope.signerKeyId === "string" && envelope.signerKeyId.trim() !== "" ? envelope.signerKeyId.trim() : null;
    if (!signerKeyId) throw new TypeError("disputeOpenEnvelope.signerKeyId is required");
    const expectedAgentKeyId = String(openerIdentity?.keys?.keyId ?? "");
    if (expectedAgentKeyId && signerKeyId !== expectedAgentKeyId) {
      throw new TypeError("disputeOpenEnvelope.signerKeyId does not match openedByAgentId key");
    }

    const envelopeHash = normalizeSha256HashInput(envelope.envelopeHash, "disputeOpenEnvelope.envelopeHash", {
      allowNull: false
    });
    const signature =
      typeof envelope.signature === "string" && envelope.signature.trim() !== "" ? envelope.signature.trim() : null;
    if (!signature) throw new TypeError("disputeOpenEnvelope.signature is required");
    const publicKeyPem = await loadSignerPublicKeyPem({ tenantId, signerKeyId });
    const isValid = verifyHashHexEd25519({
      hashHex: envelopeHash,
      signatureBase64: signature,
      publicKeyPem
    });
    if (!isValid) throw new TypeError("invalid disputeOpenEnvelope signature");
    return envelope;
  }

  function assertArbitrationVerdictEvidenceBoundToDisputeContext({ settlement, arbitrationVerdict } = {}) {
    if (!arbitrationVerdict || typeof arbitrationVerdict !== "object" || Array.isArray(arbitrationVerdict)) return;
    const disputeContextEvidenceRefs = Array.isArray(settlement?.disputeContext?.evidenceRefs) ? settlement.disputeContext.evidenceRefs : [];
    const allowedEvidenceRefs = new Set(disputeContextEvidenceRefs.map((value) => String(value)));
    const verdictEvidenceRefs = Array.isArray(arbitrationVerdict.evidenceRefs) ? arbitrationVerdict.evidenceRefs : [];
    for (let index = 0; index < verdictEvidenceRefs.length; index += 1) {
      const evidenceRef = String(verdictEvidenceRefs[index]);
      if (!allowedEvidenceRefs.has(evidenceRef)) {
        throw new TypeError("arbitrationVerdict.evidenceRefs must be a subset of settlement.disputeContext.evidenceRefs");
      }
    }
  }

  const ARBITRATION_CASE_STATUS = Object.freeze({
    OPEN: "open",
    UNDER_REVIEW: "under_review",
    VERDICT_ISSUED: "verdict_issued",
    CLOSED: "closed"
  });
  const ARBITRATION_CASE_PRIORITY_VALUES = Object.freeze(Object.values(AGENT_RUN_SETTLEMENT_DISPUTE_PRIORITY));
  const ARBITRATION_CASE_PRIORITY_SET = new Set(ARBITRATION_CASE_PRIORITY_VALUES);

  const ARBITRATION_CASE_STATUS_RANK = new Map([
    [ARBITRATION_CASE_STATUS.OPEN, 1],
    [ARBITRATION_CASE_STATUS.UNDER_REVIEW, 2],
    [ARBITRATION_CASE_STATUS.VERDICT_ISSUED, 3],
    [ARBITRATION_CASE_STATUS.CLOSED, 4]
  ]);

  function normalizeArbitrationCaseStatus(value, { fieldName = "status" } = {}) {
    const normalized = typeof value === "string" ? value.trim().toLowerCase() : "";
    if (!ARBITRATION_CASE_STATUS_RANK.has(normalized)) {
      throw new TypeError(`${fieldName} must be one of: ${Array.from(ARBITRATION_CASE_STATUS_RANK.keys()).join("|")}`);
    }
    return normalized;
  }

  function normalizeArbitrationCasePriority(value, { fieldName = "priority", allowNull = false } = {}) {
    if (value === undefined || value === null || String(value).trim() === "") {
      if (allowNull) return null;
      throw new TypeError(`${fieldName} must be one of: ${ARBITRATION_CASE_PRIORITY_VALUES.join("|")}`);
    }
    const normalized = String(value).trim().toLowerCase();
    if (!ARBITRATION_CASE_PRIORITY_SET.has(normalized)) {
      throw new TypeError(`${fieldName} must be one of: ${ARBITRATION_CASE_PRIORITY_VALUES.join("|")}`);
    }
    return normalized;
  }

  function normalizeArbitrationCaseEvidenceRefs(value, { fieldName = "evidenceRefs" } = {}) {
    if (!Array.isArray(value)) throw new TypeError(`${fieldName} must be an array`);
    return normalizeUniqueNonEmptyStringArray(value, { fieldName });
  }

  function assertArbitrationCaseEvidenceBoundToDisputeContext({ settlement, evidenceRefs } = {}) {
    const disputeContextEvidenceRefs = Array.isArray(settlement?.disputeContext?.evidenceRefs) ? settlement.disputeContext.evidenceRefs : [];
    const allowedEvidenceRefs = new Set(disputeContextEvidenceRefs.map((value) => String(value)));
    for (let index = 0; index < evidenceRefs.length; index += 1) {
      const evidenceRef = String(evidenceRefs[index]);
      if (!allowedEvidenceRefs.has(evidenceRef)) {
        throw new TypeError("arbitration case evidenceRefs must be a subset of settlement.disputeContext.evidenceRefs");
      }
    }
  }

  function assertArbitrationVerdictEvidenceBoundToCase({ arbitrationCase, arbitrationVerdict } = {}) {
    if (!arbitrationCase || typeof arbitrationCase !== "object" || Array.isArray(arbitrationCase)) {
      throw new TypeError("arbitrationCase is required");
    }
    if (!arbitrationVerdict || typeof arbitrationVerdict !== "object" || Array.isArray(arbitrationVerdict)) {
      throw new TypeError("arbitrationVerdict is required");
    }
    const caseEvidenceRefs = Array.isArray(arbitrationCase.evidenceRefs) ? arbitrationCase.evidenceRefs : [];
    const allowedEvidenceRefs = new Set(caseEvidenceRefs.map((value) => String(value)));
    const verdictEvidenceRefs = Array.isArray(arbitrationVerdict.evidenceRefs) ? arbitrationVerdict.evidenceRefs : [];
    for (let index = 0; index < verdictEvidenceRefs.length; index += 1) {
      const evidenceRef = String(verdictEvidenceRefs[index]);
      if (!allowedEvidenceRefs.has(evidenceRef)) {
        throw new TypeError("arbitrationVerdict.evidenceRefs must be a subset of arbitration case evidenceRefs");
      }
    }
  }

  function mergeUniqueStringArrays(...arrays) {
    const out = [];
    const seen = new Set();
    for (const arr of arrays) {
      if (!Array.isArray(arr)) continue;
      for (let index = 0; index < arr.length; index += 1) {
        const value = arr[index];
        if (typeof value !== "string" || value.trim() === "") continue;
        const normalized = value.trim();
        if (seen.has(normalized)) continue;
        seen.add(normalized);
        out.push(normalized);
      }
    }
    return out;
  }

  async function assignDeterministicArbiterAgentId({ tenantId, runId, disputeId, panelCandidateAgentIds } = {}) {
    if (!Array.isArray(panelCandidateAgentIds) || panelCandidateAgentIds.length === 0) {
      throw new TypeError("panelCandidateAgentIds must be a non-empty array");
    }
    const normalizedCandidates = [];
    const seenCandidates = new Set();
    for (let index = 0; index < panelCandidateAgentIds.length; index += 1) {
      const candidate = panelCandidateAgentIds[index];
      if (typeof candidate !== "string" || candidate.trim() === "") {
        throw new TypeError(`panelCandidateAgentIds[${index}] must be a non-empty string`);
      }
      const normalizedCandidate = candidate.trim();
      if (seenCandidates.has(normalizedCandidate)) continue;
      const identity = await getAgentIdentityRecord({ tenantId, agentId: normalizedCandidate });
      if (!identity) throw new TypeError(`arbiter panel candidate not found: ${normalizedCandidate}`);
      seenCandidates.add(normalizedCandidate);
      normalizedCandidates.push(normalizedCandidate);
    }
    if (!normalizedCandidates.length) throw new TypeError("panelCandidateAgentIds must include at least one existing agent");
    normalizedCandidates.sort((left, right) => left.localeCompare(right));
    const assignmentSeed = normalizeForCanonicalJson(
      {
        tenantId: normalizeTenant(tenantId),
        runId: String(runId),
        disputeId: String(disputeId),
        panelCandidateAgentIds: normalizedCandidates
      },
      { path: "$" }
    );
    const assignmentHash = sha256Hex(canonicalJsonStringify(assignmentSeed));
    const assignmentIndex = Number.parseInt(assignmentHash.slice(0, 8), 16) % normalizedCandidates.length;
    return {
      arbiterAgentId: normalizedCandidates[assignmentIndex],
      assignmentHash,
      panelCandidateAgentIds: normalizedCandidates
    };
  }

  function ensureArbitrationCaseStatusTransition({ currentStatus, nextStatus }) {
    const current = normalizeArbitrationCaseStatus(currentStatus, { fieldName: "arbitrationCase.status" });
    const next = normalizeArbitrationCaseStatus(nextStatus, { fieldName: "next arbitration case status" });
    const currentRank = ARBITRATION_CASE_STATUS_RANK.get(current) ?? 0;
    const nextRank = ARBITRATION_CASE_STATUS_RANK.get(next) ?? 0;
    if (nextRank < currentRank) {
      throw new TypeError("arbitration case status cannot regress");
    }
    return next;
  }

  function settlementDisputeWindowEndsAtMs(settlement) {
    const windowDays = Number(settlement?.disputeWindowDays ?? 0);
    if (!Number.isSafeInteger(windowDays) || windowDays <= 0) return Number.NaN;
    const explicitEndsAtMs =
      settlement?.disputeWindowEndsAt && Number.isFinite(Date.parse(String(settlement.disputeWindowEndsAt)))
        ? Date.parse(String(settlement.disputeWindowEndsAt))
        : Number.NaN;
    if (Number.isFinite(explicitEndsAtMs)) return explicitEndsAtMs;
    const resolvedAtMs =
      settlement?.resolvedAt && Number.isFinite(Date.parse(String(settlement.resolvedAt)))
        ? Date.parse(String(settlement.resolvedAt))
        : Number.NaN;
    if (!Number.isFinite(resolvedAtMs)) return Number.NaN;
    return resolvedAtMs + windowDays * 24 * 60 * 60_000;
  }

  function normalizeAgreementMilestoneStatusGate(value, { defaultValue = "any", allowAny = true } = {}) {
    const fallback = allowAny ? "any" : "green";
    const normalizedDefault = allowAny && defaultValue === "any" ? "any" : "green";
    if (value === null || value === undefined) return normalizedDefault;
    const text = String(value).trim().toLowerCase();
    if (text === "green" || text === "amber" || text === "red") return text;
    if (allowAny && text === "any") return "any";
    return fallback;
  }

  function normalizeAgreementMilestonesInput(input) {
    const source = Array.isArray(input) ? input : [];
    if (!source.length) return [];

    const seen = new Set();
    const milestones = [];
    let totalRate = 0;
    for (const row of source) {
      if (!row || typeof row !== "object" || Array.isArray(row)) {
        throw new TypeError("agreementTerms.milestones entries must be objects");
      }
      const milestoneId = typeof row.milestoneId === "string" && row.milestoneId.trim() !== ""
        ? row.milestoneId.trim()
        : null;
      if (!milestoneId) throw new TypeError("agreementTerms.milestones[].milestoneId is required");
      if (seen.has(milestoneId)) throw new TypeError(`duplicate milestoneId: ${milestoneId}`);
      seen.add(milestoneId);

      const releaseRatePct = Number(row.releaseRatePct);
      if (!Number.isSafeInteger(releaseRatePct) || releaseRatePct < 0 || releaseRatePct > 100) {
        throw new TypeError("agreementTerms.milestones[].releaseRatePct must be an integer within 0..100");
      }
      totalRate += releaseRatePct;

      const requiredEvidenceCountRaw = row.requiredEvidenceCount;
      const requiredEvidenceCount =
        requiredEvidenceCountRaw === null || requiredEvidenceCountRaw === undefined || requiredEvidenceCountRaw === ""
          ? null
          : Number(requiredEvidenceCountRaw);
      if (
        requiredEvidenceCount !== null &&
        (!Number.isSafeInteger(requiredEvidenceCount) || requiredEvidenceCount < 0)
      ) {
        throw new TypeError("agreementTerms.milestones[].requiredEvidenceCount must be a non-negative integer");
      }

      milestones.push({
        milestoneId,
        label: typeof row.label === "string" && row.label.trim() !== "" ? row.label.trim() : null,
        releaseRatePct,
        statusGate: normalizeAgreementMilestoneStatusGate(row.statusGate, { defaultValue: "any", allowAny: true }),
        requiredEvidenceCount
      });
    }
    if (totalRate !== 100) {
      throw new TypeError("agreementTerms.milestones releaseRatePct sum must equal 100");
    }
    return milestones;
  }

  function normalizeAgreementCancellationInput(input) {
    const raw = input && typeof input === "object" && !Array.isArray(input) ? input : {};
    const killFeeRatePctRaw = raw.killFeeRatePct;
    const killFeeRatePct =
      killFeeRatePctRaw === null || killFeeRatePctRaw === undefined || killFeeRatePctRaw === ""
        ? 0
        : Number(killFeeRatePctRaw);
    if (!Number.isSafeInteger(killFeeRatePct) || killFeeRatePct < 0 || killFeeRatePct > 100) {
      throw new TypeError("agreementTerms.cancellation.killFeeRatePct must be an integer within 0..100");
    }
    return {
      allowCancellationBeforeStart: raw.allowCancellationBeforeStart !== false,
      killFeeRatePct,
      requireEvidenceOnCancellation: raw.requireEvidenceOnCancellation === true,
      requireCounterpartyAcceptance: raw.requireCounterpartyAcceptance === true
    };
  }

  function normalizeAgreementChangeOrderPolicyInput(input) {
    const raw = input && typeof input === "object" && !Array.isArray(input) ? input : {};
    const enabled = raw.enabled === true;
    const maxChangeOrdersRaw = raw.maxChangeOrders;
    const maxChangeOrders =
      maxChangeOrdersRaw === null || maxChangeOrdersRaw === undefined || maxChangeOrdersRaw === ""
        ? 0
        : Number(maxChangeOrdersRaw);
    if (!Number.isSafeInteger(maxChangeOrders) || maxChangeOrders < 0) {
      throw new TypeError("agreementTerms.changeOrderPolicy.maxChangeOrders must be a non-negative integer");
    }
    return {
      enabled,
      maxChangeOrders: enabled ? maxChangeOrders : 0,
      requireCounterpartyAcceptance: raw.requireCounterpartyAcceptance !== false
    };
  }

  function buildMarketplaceAgreementTerms({
    rfq,
    bid,
    agreementTermsInput = null
  }) {
    const raw = agreementTermsInput && typeof agreementTermsInput === "object" && !Array.isArray(agreementTermsInput)
      ? agreementTermsInput
      : {};
    return normalizeForCanonicalJson(
      {
        title: rfq?.title ?? null,
        capability: rfq?.capability ?? null,
        deadlineAt: rfq?.deadlineAt ?? null,
        etaSeconds: bid?.etaSeconds ?? null,
        milestones: normalizeAgreementMilestonesInput(raw?.milestones),
        cancellation: normalizeAgreementCancellationInput(raw?.cancellation),
        changeOrderPolicy: normalizeAgreementChangeOrderPolicyInput(raw?.changeOrderPolicy ?? raw?.changeOrder ?? null),
        changeOrders: []
      },
      { path: "$" }
    );
  }

  function listCompletedMilestoneIdsFromRun(run) {
    const input = run?.metrics?.completedMilestoneIds;
    if (!Array.isArray(input)) return [];
    const out = [];
    const seen = new Set();
    for (const raw of input) {
      if (typeof raw !== "string") continue;
      const value = raw.trim();
      if (!value || seen.has(value)) continue;
      seen.add(value);
      out.push(value);
    }
    return out;
  }

  function applyAgreementMilestoneRelease({
    policyDecision,
    agreement,
    run,
    verification,
    amountCents
  }) {
    const milestones = Array.isArray(agreement?.terms?.milestones) ? agreement.terms.milestones : null;
    if (!milestones || milestones.length === 0) {
      return { decision: policyDecision, milestoneEvaluation: null };
    }
    const completedMilestoneIds = listCompletedMilestoneIdsFromRun(run);
    const completedSet = new Set(completedMilestoneIds);
    const verificationStatus = String(run?.status === "failed" ? "red" : verification?.verificationStatus ?? "amber").trim().toLowerCase();
    const evidenceCount = Number(verification?.evidenceCount ?? 0);

    let milestoneRatePct = 0;
    const appliedMilestoneIds = [];
    for (const milestone of milestones) {
      const milestoneId = typeof milestone?.milestoneId === "string" ? milestone.milestoneId.trim() : "";
      if (!milestoneId || !completedSet.has(milestoneId)) continue;
      const statusGate = normalizeAgreementMilestoneStatusGate(milestone?.statusGate, { defaultValue: "any", allowAny: true });
      if (statusGate !== "any" && statusGate !== verificationStatus) continue;
      const requiredEvidenceCount =
        milestone?.requiredEvidenceCount === null || milestone?.requiredEvidenceCount === undefined
          ? null
          : Number(milestone.requiredEvidenceCount);
      if (requiredEvidenceCount !== null && Number.isSafeInteger(requiredEvidenceCount) && evidenceCount < requiredEvidenceCount) {
        continue;
      }
      const releaseRatePct = Number(milestone?.releaseRatePct);
      if (!Number.isSafeInteger(releaseRatePct) || releaseRatePct < 0 || releaseRatePct > 100) continue;
      milestoneRatePct += releaseRatePct;
      appliedMilestoneIds.push(milestoneId);
    }
    milestoneRatePct = Math.min(100, Math.max(0, milestoneRatePct));
    const baseRatePct = Number(policyDecision?.releaseRatePct ?? 0);
    const effectiveRatePct = Number.isSafeInteger(baseRatePct) ? Math.min(baseRatePct, milestoneRatePct) : milestoneRatePct;
    const safeAmountCents = Number(amountCents);
    const releaseAmountCents =
      effectiveRatePct <= 0 ? 0 : Math.min(safeAmountCents, Math.floor((safeAmountCents * effectiveRatePct) / 100));
    const refundAmountCents = safeAmountCents - releaseAmountCents;

    const reasonCodes = Array.isArray(policyDecision?.reasonCodes) ? [...policyDecision.reasonCodes] : [];
    if (effectiveRatePct !== baseRatePct) reasonCodes.push("milestone_release_cap_applied");
    const nextDecision = {
      ...policyDecision,
      reasonCodes,
      releaseRatePct: effectiveRatePct,
      releaseAmountCents,
      refundAmountCents,
      settlementStatus: releaseAmountCents > 0 ? "released" : "refunded",
      milestoneEvaluation: {
        completedMilestoneIds,
        appliedMilestoneIds,
        milestoneRatePct,
        effectiveRatePct,
        verificationStatus
      }
    };
    return { decision: nextDecision, milestoneEvaluation: nextDecision.milestoneEvaluation };
  }

  function buildMarketplaceAgreementPolicyBindingCore({ agreement }) {
    const agreementObj = agreement && typeof agreement === "object" && !Array.isArray(agreement) ? agreement : null;
    if (!agreementObj) throw new TypeError("agreement is required for policy binding");
    const policyRef =
      agreementObj.policyRef && typeof agreementObj.policyRef === "object" && !Array.isArray(agreementObj.policyRef)
        ? normalizeForCanonicalJson(agreementObj.policyRef, { path: "$" })
        : null;
    if (!policyRef) throw new TypeError("agreement.policyRef is required for policy binding");
    const policyRefHash = sha256Hex(canonicalJsonStringify(policyRef));
    return normalizeForCanonicalJson(
      {
        schemaVersion: MARKETPLACE_AGREEMENT_POLICY_BINDING_SCHEMA_VERSION,
        agreementId: String(agreementObj.agreementId ?? ""),
        tenantId: String(agreementObj.tenantId ?? ""),
        rfqId: String(agreementObj.rfqId ?? ""),
        runId: String(agreementObj.runId ?? ""),
        bidId: String(agreementObj.bidId ?? ""),
        acceptedAt:
          typeof agreementObj.acceptedAt === "string" && Number.isFinite(Date.parse(agreementObj.acceptedAt))
            ? agreementObj.acceptedAt
            : null,
        acceptedByAgentId:
          typeof agreementObj.acceptedByAgentId === "string" && agreementObj.acceptedByAgentId.trim() !== ""
            ? agreementObj.acceptedByAgentId.trim()
            : null,
        offerChainHash: normalizeSha256HashInput(agreementObj.offerChainHash, "agreement.offerChainHash", { allowNull: true }),
        acceptedProposalId:
          typeof agreementObj.acceptedProposalId === "string" && agreementObj.acceptedProposalId.trim() !== ""
            ? agreementObj.acceptedProposalId.trim()
            : null,
        acceptedRevision:
          Number.isSafeInteger(Number(agreementObj.acceptedRevision)) && Number(agreementObj.acceptedRevision) > 0
            ? Number(agreementObj.acceptedRevision)
            : null,
        acceptedProposalHash: normalizeSha256HashInput(agreementObj.acceptedProposalHash, "agreement.acceptedProposalHash", {
          allowNull: true
        }),
        termsHash: normalizeSha256HashInput(agreementObj.termsHash, "agreement.termsHash", { allowNull: false }),
        policyHash: normalizeSha256HashInput(agreementObj.policyHash, "agreement.policyHash", { allowNull: false }),
        verificationMethodHash: normalizeSha256HashInput(agreementObj.verificationMethodHash, "agreement.verificationMethodHash", {
          allowNull: false
        }),
        policyRefHash,
        policyRef
      },
      { path: "$" }
    );
  }

  function buildMarketplaceAgreementPolicyBinding({
    agreement,
    signedAt = nowIso(),
    signer = serverSigner
  } = {}) {
    if (!signer || typeof signer !== "object") throw new TypeError("policy binding signer is required");
    if (typeof signer.keyId !== "string" || signer.keyId.trim() === "") throw new TypeError("policy binding signer.keyId is required");
    if (typeof signer.privateKeyPem !== "string" || signer.privateKeyPem.trim() === "") {
      throw new TypeError("policy binding signer.privateKeyPem is required");
    }
    const core = buildMarketplaceAgreementPolicyBindingCore({ agreement });
    const bindingHash = sha256Hex(canonicalJsonStringify(core));
    const signature = signHashHexEd25519(bindingHash, signer.privateKeyPem);
    return normalizeForCanonicalJson(
      {
        ...core,
        signerKeyId: signer.keyId,
        signedAt: typeof signedAt === "string" && Number.isFinite(Date.parse(signedAt)) ? signedAt : nowIso(),
        bindingHash,
        signature
      },
      { path: "$" }
    );
  }

  async function verifyMarketplaceAgreementPolicyBinding({
    tenantId,
    agreement
  } = {}) {
    const agreementObj = agreement && typeof agreement === "object" && !Array.isArray(agreement) ? agreement : null;
    if (!agreementObj) {
      return { present: false, valid: false, reason: "agreement_missing" };
    }
    const binding =
      agreementObj.policyBinding && typeof agreementObj.policyBinding === "object" && !Array.isArray(agreementObj.policyBinding)
        ? agreementObj.policyBinding
        : null;
    if (!binding) {
      return { present: false, valid: false, reason: "policy_binding_missing" };
    }
    let expectedCore = null;
    try {
      expectedCore = buildMarketplaceAgreementPolicyBindingCore({ agreement: agreementObj });
    } catch (err) {
      return {
        present: true,
        valid: false,
        reason: "binding_core_invalid",
        message: err?.message ?? "unable to canonicalize policy binding core"
      };
    }
    const expectedHash = sha256Hex(canonicalJsonStringify(expectedCore));
    let bindingHash = null;
    try {
      bindingHash = normalizeSha256HashInput(binding.bindingHash, "agreement.policyBinding.bindingHash", { allowNull: true });
    } catch (err) {
      return {
        present: true,
        valid: false,
        reason: "binding_hash_invalid",
        expectedHash,
        message: err?.message ?? "invalid binding hash"
      };
    }
    if (!bindingHash) {
      return { present: true, valid: false, reason: "binding_hash_missing", expectedHash };
    }
    if (bindingHash !== expectedHash) {
      return { present: true, valid: false, reason: "binding_hash_mismatch", expectedHash, bindingHash };
    }
    const signerKeyId =
      typeof binding.signerKeyId === "string" && binding.signerKeyId.trim() !== "" ? binding.signerKeyId.trim() : null;
    const signature =
      typeof binding.signature === "string" && binding.signature.trim() !== "" ? binding.signature.trim() : null;
    if (!signerKeyId || !signature) {
      return { present: true, valid: false, reason: "binding_signature_missing", expectedHash, bindingHash };
    }
    let publicKeyPem = null;
    try {
      publicKeyPem =
        signerKeyId === String(store.serverSigner?.keyId ?? "")
          ? String(store.serverSigner?.publicKeyPem ?? "")
          : await loadSignerPublicKeyPem({ tenantId, signerKeyId });
    } catch (err) {
      return {
        present: true,
        valid: false,
        reason: "binding_signer_unknown",
        expectedHash,
        bindingHash,
        signerKeyId,
        message: err?.message ?? "unable to resolve signer key"
      };
    }
    const signatureValid = verifyHashHexEd25519({
      hashHex: bindingHash,
      signatureBase64: signature,
      publicKeyPem
    });
    if (!signatureValid) {
      return {
        present: true,
        valid: false,
        reason: "binding_signature_invalid",
        expectedHash,
        bindingHash,
        signerKeyId
      };
    }
    return {
      present: true,
      valid: true,
      reason: null,
      expectedHash,
      bindingHash,
      signerKeyId
    };
  }

  async function verifyMarketplaceAgreementAcceptanceSignature({
    tenantId,
    agreement
  } = {}) {
    const agreementObj = agreement && typeof agreement === "object" && !Array.isArray(agreement) ? agreement : null;
    if (!agreementObj) {
      return { present: false, valid: false, reason: "agreement_missing" };
    }
    const acceptanceSignature =
      agreementObj.acceptanceSignature && typeof agreementObj.acceptanceSignature === "object" && !Array.isArray(agreementObj.acceptanceSignature)
        ? agreementObj.acceptanceSignature
        : null;
    if (!acceptanceSignature) {
      return { present: false, valid: false, reason: "acceptance_signature_missing" };
    }
    const signerAgentId =
      typeof acceptanceSignature.signerAgentId === "string" && acceptanceSignature.signerAgentId.trim() !== ""
        ? acceptanceSignature.signerAgentId.trim()
        : null;
    if (!signerAgentId) {
      return {
        present: true,
        valid: false,
        reason: "acceptance_signature_signer_agent_missing"
      };
    }
    const signedAt =
      typeof acceptanceSignature.signedAt === "string" && acceptanceSignature.signedAt.trim() !== ""
        ? acceptanceSignature.signedAt.trim()
        : null;
    if (!isValidIsoDateTime(signedAt)) {
      return {
        present: true,
        valid: false,
        reason: "acceptance_signature_signed_at_invalid",
        signerAgentId
      };
    }
    let actingOnBehalfOf = null;
    try {
      actingOnBehalfOf = await parseActingOnBehalfOf({
        tenantId,
        acceptedByAgentId:
          typeof agreementObj.acceptedByAgentId === "string" && agreementObj.acceptedByAgentId.trim() !== ""
            ? agreementObj.acceptedByAgentId.trim()
            : null,
        signerAgentId,
        signedAt,
        actingOnBehalfOfInput: acceptanceSignature.actingOnBehalfOf,
        requiredScope: MARKETPLACE_DELEGATION_SCOPE_AGREEMENT_ACCEPT,
        enforceActiveAgents: false
      });
    } catch (err) {
      return {
        present: true,
        valid: false,
        reason: "acceptance_signature_delegation_invalid",
        signerAgentId,
        message: err?.message ?? "invalid acceptance signature delegation chain"
      };
    }
    let expectedCore = null;
    try {
      expectedCore = buildMarketplaceAgreementAcceptanceSignatureCore({ agreement: agreementObj, actingOnBehalfOf });
    } catch (err) {
      return {
        present: true,
        valid: false,
        reason: "acceptance_signature_core_invalid",
        message: err?.message ?? "unable to canonicalize acceptance signature core"
      };
    }
    const expectedHash = sha256Hex(canonicalJsonStringify(expectedCore));
    let acceptanceHash = null;
    try {
      acceptanceHash = normalizeSha256HashInput(acceptanceSignature.acceptanceHash, "agreement.acceptanceSignature.acceptanceHash", {
        allowNull: true
      });
    } catch (err) {
      return {
        present: true,
        valid: false,
        reason: "acceptance_signature_hash_invalid",
        expectedHash,
        message: err?.message ?? "invalid acceptance signature hash"
      };
    }
    if (!acceptanceHash) {
      return {
        present: true,
        valid: false,
        reason: "acceptance_signature_hash_missing",
        expectedHash
      };
    }
    if (acceptanceHash !== expectedHash) {
      return {
        present: true,
        valid: false,
        reason: "acceptance_signature_hash_mismatch",
        expectedHash,
        acceptanceHash
      };
    }
    const expectedSignerAgentId = actingOnBehalfOf?.delegateAgentId ?? expectedCore.acceptedByAgentId;
    if (expectedSignerAgentId && signerAgentId !== expectedSignerAgentId) {
      return {
        present: true,
        valid: false,
        reason: "acceptance_signature_signer_agent_mismatch",
        expectedHash,
        acceptanceHash,
        signerAgentId,
        acceptedByAgentId: expectedCore.acceptedByAgentId,
        expectedSignerAgentId
      };
    }
    let signerIdentity = null;
    try {
      signerIdentity = await getAgentIdentityRecord({ tenantId, agentId: signerAgentId });
    } catch (err) {
      return {
        present: true,
        valid: false,
        reason: "acceptance_signature_signer_agent_lookup_failed",
        expectedHash,
        acceptanceHash,
        signerAgentId,
        message: err?.message ?? "unable to resolve signer agent"
      };
    }
    if (!signerIdentity) {
      return {
        present: true,
        valid: false,
        reason: "acceptance_signature_signer_agent_unknown",
        expectedHash,
        acceptanceHash,
        signerAgentId
      };
    }
    const signerKeyId =
      typeof acceptanceSignature.signerKeyId === "string" && acceptanceSignature.signerKeyId.trim() !== ""
        ? acceptanceSignature.signerKeyId.trim()
        : null;
    const signature =
      typeof acceptanceSignature.signature === "string" && acceptanceSignature.signature.trim() !== ""
        ? acceptanceSignature.signature.trim()
        : null;
    if (!signerKeyId || !signature) {
      return {
        present: true,
        valid: false,
        reason: "acceptance_signature_signature_missing",
        expectedHash,
        acceptanceHash,
        signerAgentId
      };
    }
    const expectedAgentKeyId = String(signerIdentity?.keys?.keyId ?? "");
    if (expectedAgentKeyId && signerKeyId !== expectedAgentKeyId) {
      return {
        present: true,
        valid: false,
        reason: "acceptance_signature_signer_key_mismatch",
        expectedHash,
        acceptanceHash,
        signerAgentId,
        signerKeyId,
        expectedAgentKeyId
      };
    }
    let publicKeyPem = null;
    try {
      publicKeyPem = await loadSignerPublicKeyPem({ tenantId, signerKeyId });
    } catch (err) {
      return {
        present: true,
        valid: false,
        reason: "acceptance_signature_signer_unknown",
        expectedHash,
        acceptanceHash,
        signerAgentId,
        signerKeyId,
        message: err?.message ?? "unable to resolve signer key"
      };
    }
    const signatureValid = verifyHashHexEd25519({
      hashHex: acceptanceHash,
      signatureBase64: signature,
      publicKeyPem
    });
    if (!signatureValid) {
      return {
        present: true,
        valid: false,
        reason: "acceptance_signature_signature_invalid",
        expectedHash,
        acceptanceHash,
        signerAgentId,
        signerKeyId
      };
    }
    return {
      present: true,
      valid: true,
      reason: null,
      expectedHash,
      acceptanceHash,
      signerAgentId,
      signerKeyId,
      actingOnBehalfOf: actingOnBehalfOf
        ? {
            principalAgentId: actingOnBehalfOf.principalAgentId,
            delegateAgentId: actingOnBehalfOf.delegateAgentId,
            chainHash: actingOnBehalfOf.chainHash
          }
        : null
    };
  }

  function buildMarketplaceAgreementChangeOrderAcceptanceSignatureCore({
    tenantId,
    runId,
    agreement,
    changeOrder,
    nextMilestones,
    nextCancellation,
    actingOnBehalfOf = null
  } = {}) {
    const agreementObj = agreement && typeof agreement === "object" && !Array.isArray(agreement) ? agreement : null;
    if (!agreementObj) throw new TypeError("agreement is required for change order acceptance signature");
    const changeOrderObj = changeOrder && typeof changeOrder === "object" && !Array.isArray(changeOrder) ? changeOrder : null;
    if (!changeOrderObj) throw new TypeError("changeOrder is required for change order acceptance signature");
    const acceptedByAgentId =
      typeof changeOrderObj.acceptedByAgentId === "string" && changeOrderObj.acceptedByAgentId.trim() !== ""
        ? changeOrderObj.acceptedByAgentId.trim()
        : null;
    if (!acceptedByAgentId) throw new TypeError("change order acceptedByAgentId is required for acceptance signature");
    const milestones = Array.isArray(nextMilestones) ? normalizeForCanonicalJson(nextMilestones, { path: "$" }) : [];
    const cancellation = normalizeForCanonicalJson(nextCancellation ?? {}, { path: "$" });
    return normalizeForCanonicalJson(
      {
        schemaVersion: MARKETPLACE_AGREEMENT_CHANGE_ORDER_ACCEPTANCE_SIGNATURE_SCHEMA_VERSION,
        tenantId: normalizeTenant(tenantId),
        runId: String(runId ?? ""),
        agreementId: String(agreementObj.agreementId ?? ""),
        rfqId: String(agreementObj.rfqId ?? ""),
        bidId: String(agreementObj.bidId ?? ""),
        changeOrderId: String(changeOrderObj.changeOrderId ?? ""),
        requestedByAgentId: String(changeOrderObj.requestedByAgentId ?? ""),
        acceptedByAgentId,
        reason: String(changeOrderObj.reason ?? ""),
        note: typeof changeOrderObj.note === "string" ? changeOrderObj.note : null,
        previousTermsHash: normalizeSha256HashInput(changeOrderObj.previousTermsHash, "changeOrder.previousTermsHash", { allowNull: true }),
        milestonesHash: sha256Hex(canonicalJsonStringify(milestones)),
        cancellationHash: sha256Hex(canonicalJsonStringify(cancellation)),
        actingOnBehalfOfPrincipalAgentId:
          actingOnBehalfOf && typeof actingOnBehalfOf === "object" ? actingOnBehalfOf.principalAgentId ?? null : null,
        actingOnBehalfOfDelegateAgentId:
          actingOnBehalfOf && typeof actingOnBehalfOf === "object" ? actingOnBehalfOf.delegateAgentId ?? null : null,
        actingOnBehalfOfChainHash:
          actingOnBehalfOf && typeof actingOnBehalfOf === "object" ? actingOnBehalfOf.chainHash ?? null : null
      },
      { path: "$" }
    );
  }

  async function parseSignedMarketplaceAgreementChangeOrderAcceptance({
    tenantId,
    runId,
    agreement,
    changeOrder,
    nextMilestones,
    nextCancellation,
    acceptanceSignatureInput,
    acceptedByAgentId = null,
    acceptedByIdentity = null
  } = {}) {
    if (!acceptanceSignatureInput || typeof acceptanceSignatureInput !== "object" || Array.isArray(acceptanceSignatureInput)) {
      throw new TypeError("acceptanceSignature must be an object");
    }
    const acceptedByNormalized =
      typeof acceptedByAgentId === "string" && acceptedByAgentId.trim() !== "" ? acceptedByAgentId.trim() : null;
    if (!acceptedByNormalized) throw new TypeError("acceptedByAgentId is required for acceptanceSignature");
    const signerAgentIdRaw = acceptanceSignatureInput.signerAgentId;
    const signerAgentId =
      typeof signerAgentIdRaw === "string" && signerAgentIdRaw.trim() !== ""
        ? signerAgentIdRaw.trim()
        : acceptedByNormalized;
    const signedAtRaw = acceptanceSignatureInput.signedAt;
    const signedAt = typeof signedAtRaw === "string" && signedAtRaw.trim() !== "" ? signedAtRaw.trim() : nowIso();
    if (!Number.isFinite(Date.parse(signedAt))) throw new TypeError("acceptanceSignature.signedAt must be an ISO date-time");
    const actingOnBehalfOf = await parseActingOnBehalfOf({
      tenantId,
      acceptedByAgentId: acceptedByNormalized,
      signerAgentId,
      signedAt,
      actingOnBehalfOfInput: acceptanceSignatureInput.actingOnBehalfOf,
      requiredScope: MARKETPLACE_DELEGATION_SCOPE_AGREEMENT_CHANGE_ORDER
    });
    if (!actingOnBehalfOf && signerAgentId !== acceptedByNormalized) {
      throw new TypeError("acceptanceSignature.signerAgentId must match acceptedByAgentId");
    }
    const signerIdentity =
      acceptedByIdentity && signerAgentId === acceptedByNormalized
        ? acceptedByIdentity
        : await getAgentIdentityRecord({ tenantId, agentId: signerAgentId });
    if (!signerIdentity) throw new TypeError("acceptanceSignature signer agent not found");
    if (String(signerIdentity?.status ?? "active").toLowerCase() !== "active") {
      throw new TypeError("acceptanceSignature signer agent must be active");
    }

    const signerKeyId =
      typeof acceptanceSignatureInput.signerKeyId === "string" && acceptanceSignatureInput.signerKeyId.trim() !== ""
        ? acceptanceSignatureInput.signerKeyId.trim()
        : null;
    const signature =
      typeof acceptanceSignatureInput.signature === "string" && acceptanceSignatureInput.signature.trim() !== ""
        ? acceptanceSignatureInput.signature.trim()
        : null;
    if (!signerKeyId || !signature) {
      throw new TypeError("acceptanceSignature.signerKeyId and acceptanceSignature.signature are required");
    }
    const expectedAgentKeyId = String(signerIdentity?.keys?.keyId ?? "");
    if (expectedAgentKeyId && signerKeyId !== expectedAgentKeyId) {
      throw new TypeError("acceptanceSignature.signerKeyId does not match signer agent key");
    }

    const core = buildMarketplaceAgreementChangeOrderAcceptanceSignatureCore({
      tenantId,
      runId,
      agreement,
      changeOrder,
      nextMilestones,
      nextCancellation,
      actingOnBehalfOf
    });
    const expectedSignerAgentId = actingOnBehalfOf?.delegateAgentId ?? core.acceptedByAgentId;
    if (expectedSignerAgentId && expectedSignerAgentId !== signerAgentId) {
      throw new TypeError("acceptanceSignature.signerAgentId must match changeOrder.acceptedByAgentId");
    }
    const acceptanceHash = sha256Hex(canonicalJsonStringify(core));
    const publicKeyPem = await loadSignerPublicKeyPem({ tenantId, signerKeyId });
    const isValid = verifyHashHexEd25519({
      hashHex: acceptanceHash,
      signatureBase64: signature,
      publicKeyPem
    });
    if (!isValid) throw new TypeError("invalid acceptanceSignature signature");

    return normalizeForCanonicalJson(
      {
        ...core,
        signerAgentId,
        signerKeyId,
        signedAt,
        actingOnBehalfOf: actingOnBehalfOf ?? null,
        acceptanceHash,
        signature
      },
      { path: "$" }
    );
  }

  async function verifyMarketplaceAgreementChangeOrderAcceptanceSignature({
    tenantId,
    runId,
    agreement,
    changeOrder,
    nextMilestones,
    nextCancellation
  } = {}) {
    const signatureObj =
      changeOrder?.acceptanceSignature &&
      typeof changeOrder.acceptanceSignature === "object" &&
      !Array.isArray(changeOrder.acceptanceSignature)
        ? changeOrder.acceptanceSignature
        : null;
    if (!signatureObj) return { present: false, valid: false, reason: "acceptance_signature_missing" };
    const signerAgentId =
      typeof signatureObj.signerAgentId === "string" && signatureObj.signerAgentId.trim() !== ""
        ? signatureObj.signerAgentId.trim()
        : null;
    if (!signerAgentId) {
      return { present: true, valid: false, reason: "acceptance_signature_signer_agent_missing" };
    }
    const signedAt =
      typeof signatureObj.signedAt === "string" && signatureObj.signedAt.trim() !== ""
        ? signatureObj.signedAt.trim()
        : null;
    if (!isValidIsoDateTime(signedAt)) {
      return { present: true, valid: false, reason: "acceptance_signature_signed_at_invalid", signerAgentId };
    }
    const acceptedByAgentId =
      typeof changeOrder?.acceptedByAgentId === "string" && changeOrder.acceptedByAgentId.trim() !== ""
        ? changeOrder.acceptedByAgentId.trim()
        : null;
    let actingOnBehalfOf = null;
    try {
      actingOnBehalfOf = await parseActingOnBehalfOf({
        tenantId,
        acceptedByAgentId,
        signerAgentId,
        signedAt,
        actingOnBehalfOfInput: signatureObj.actingOnBehalfOf,
        requiredScope: MARKETPLACE_DELEGATION_SCOPE_AGREEMENT_CHANGE_ORDER,
        enforceActiveAgents: false
      });
    } catch (err) {
      return {
        present: true,
        valid: false,
        reason: "acceptance_signature_delegation_invalid",
        signerAgentId,
        message: err?.message
      };
    }
    let expectedCore = null;
    try {
      expectedCore = buildMarketplaceAgreementChangeOrderAcceptanceSignatureCore({
        tenantId,
        runId,
        agreement,
        changeOrder,
        nextMilestones,
        nextCancellation,
        actingOnBehalfOf
      });
    } catch (err) {
      return { present: true, valid: false, reason: "acceptance_signature_core_invalid", message: err?.message };
    }
    const expectedHash = sha256Hex(canonicalJsonStringify(expectedCore));
    let acceptanceHash = null;
    try {
      acceptanceHash = normalizeSha256HashInput(signatureObj.acceptanceHash, "changeOrder.acceptanceSignature.acceptanceHash", {
        allowNull: true
      });
    } catch (err) {
      return { present: true, valid: false, reason: "acceptance_signature_hash_invalid", expectedHash, message: err?.message };
    }
    if (!acceptanceHash) return { present: true, valid: false, reason: "acceptance_signature_hash_missing", expectedHash };
    if (acceptanceHash !== expectedHash) {
      return { present: true, valid: false, reason: "acceptance_signature_hash_mismatch", expectedHash, acceptanceHash };
    }
    const expectedSignerAgentId = actingOnBehalfOf?.delegateAgentId ?? expectedCore.acceptedByAgentId;
    if (expectedSignerAgentId && signerAgentId !== expectedSignerAgentId) {
      return {
        present: true,
        valid: false,
        reason: "acceptance_signature_signer_agent_mismatch",
        expectedHash,
        acceptanceHash,
        signerAgentId,
        acceptedByAgentId: expectedCore.acceptedByAgentId,
        expectedSignerAgentId
      };
    }
    const signerKeyId =
      typeof signatureObj.signerKeyId === "string" && signatureObj.signerKeyId.trim() !== ""
        ? signatureObj.signerKeyId.trim()
        : null;
    const signature =
      typeof signatureObj.signature === "string" && signatureObj.signature.trim() !== ""
        ? signatureObj.signature.trim()
        : null;
    if (!signerKeyId || !signature) {
      return {
        present: true,
        valid: false,
        reason: "acceptance_signature_signature_missing",
        expectedHash,
        acceptanceHash,
        signerAgentId
      };
    }
    let signerIdentity = null;
    try {
      signerIdentity = await getAgentIdentityRecord({ tenantId, agentId: signerAgentId });
    } catch (err) {
      return { present: true, valid: false, reason: "acceptance_signature_signer_agent_lookup_failed", expectedHash, acceptanceHash, signerAgentId, message: err?.message };
    }
    if (!signerIdentity) {
      return { present: true, valid: false, reason: "acceptance_signature_signer_agent_unknown", expectedHash, acceptanceHash, signerAgentId };
    }
    const expectedAgentKeyId = String(signerIdentity?.keys?.keyId ?? "");
    if (expectedAgentKeyId && signerKeyId !== expectedAgentKeyId) {
      return {
        present: true,
        valid: false,
        reason: "acceptance_signature_signer_key_mismatch",
        expectedHash,
        acceptanceHash,
        signerAgentId,
        signerKeyId,
        expectedAgentKeyId
      };
    }
    let publicKeyPem = null;
    try {
      publicKeyPem = await loadSignerPublicKeyPem({ tenantId, signerKeyId });
    } catch (err) {
      return { present: true, valid: false, reason: "acceptance_signature_signer_unknown", expectedHash, acceptanceHash, signerAgentId, signerKeyId, message: err?.message };
    }
    const signatureValid = verifyHashHexEd25519({
      hashHex: acceptanceHash,
      signatureBase64: signature,
      publicKeyPem
    });
    if (!signatureValid) {
      return { present: true, valid: false, reason: "acceptance_signature_signature_invalid", expectedHash, acceptanceHash, signerAgentId, signerKeyId };
    }
    return {
      present: true,
      valid: true,
      reason: null,
      expectedHash,
      acceptanceHash,
      signerAgentId,
      signerKeyId,
      actingOnBehalfOf: actingOnBehalfOf
        ? {
            principalAgentId: actingOnBehalfOf.principalAgentId,
            delegateAgentId: actingOnBehalfOf.delegateAgentId,
            chainHash: actingOnBehalfOf.chainHash
          }
        : null
    };
  }

  function buildMarketplaceAgreementCancellationAcceptanceSignatureCore({
    tenantId,
    runId,
    agreement,
    cancellation,
    actingOnBehalfOf = null
  } = {}) {
    const agreementObj = agreement && typeof agreement === "object" && !Array.isArray(agreement) ? agreement : null;
    if (!agreementObj) throw new TypeError("agreement is required for cancellation acceptance signature");
    const cancellationObj = cancellation && typeof cancellation === "object" && !Array.isArray(cancellation) ? cancellation : null;
    if (!cancellationObj) throw new TypeError("cancellation is required for cancellation acceptance signature");
    const acceptedByAgentId =
      typeof cancellationObj.acceptedByAgentId === "string" && cancellationObj.acceptedByAgentId.trim() !== ""
        ? cancellationObj.acceptedByAgentId.trim()
        : null;
    if (!acceptedByAgentId) throw new TypeError("cancellation acceptedByAgentId is required for acceptance signature");
    return normalizeForCanonicalJson(
      {
        schemaVersion: MARKETPLACE_AGREEMENT_CANCELLATION_ACCEPTANCE_SIGNATURE_SCHEMA_VERSION,
        tenantId: normalizeTenant(tenantId),
        runId: String(runId ?? ""),
        agreementId: String(agreementObj.agreementId ?? ""),
        rfqId: String(agreementObj.rfqId ?? ""),
        bidId: String(agreementObj.bidId ?? ""),
        cancellationId: String(cancellationObj.cancellationId ?? ""),
        cancelledByAgentId: String(cancellationObj.cancelledByAgentId ?? ""),
        acceptedByAgentId,
        reason: String(cancellationObj.reason ?? ""),
        evidenceRef: typeof cancellationObj.evidenceRef === "string" && cancellationObj.evidenceRef.trim() !== "" ? cancellationObj.evidenceRef.trim() : null,
        termsHash: normalizeSha256HashInput(agreementObj.termsHash, "agreement.termsHash", { allowNull: false }),
        killFeeRatePct:
          Number.isSafeInteger(Number(cancellationObj.killFeeRatePct)) && Number(cancellationObj.killFeeRatePct) >= 0
            ? Number(cancellationObj.killFeeRatePct)
            : 0,
        actingOnBehalfOfPrincipalAgentId:
          actingOnBehalfOf && typeof actingOnBehalfOf === "object" ? actingOnBehalfOf.principalAgentId ?? null : null,
        actingOnBehalfOfDelegateAgentId:
          actingOnBehalfOf && typeof actingOnBehalfOf === "object" ? actingOnBehalfOf.delegateAgentId ?? null : null,
        actingOnBehalfOfChainHash:
          actingOnBehalfOf && typeof actingOnBehalfOf === "object" ? actingOnBehalfOf.chainHash ?? null : null
      },
      { path: "$" }
    );
  }

  async function parseSignedMarketplaceAgreementCancellationAcceptance({
    tenantId,
    runId,
    agreement,
    cancellation,
    acceptanceSignatureInput,
    acceptedByAgentId = null,
    acceptedByIdentity = null
  } = {}) {
    if (!acceptanceSignatureInput || typeof acceptanceSignatureInput !== "object" || Array.isArray(acceptanceSignatureInput)) {
      throw new TypeError("acceptanceSignature must be an object");
    }
    const acceptedByNormalized =
      typeof acceptedByAgentId === "string" && acceptedByAgentId.trim() !== "" ? acceptedByAgentId.trim() : null;
    if (!acceptedByNormalized) throw new TypeError("acceptedByAgentId is required for acceptanceSignature");
    const signerAgentIdRaw = acceptanceSignatureInput.signerAgentId;
    const signerAgentId =
      typeof signerAgentIdRaw === "string" && signerAgentIdRaw.trim() !== ""
        ? signerAgentIdRaw.trim()
        : acceptedByNormalized;
    const signedAtRaw = acceptanceSignatureInput.signedAt;
    const signedAt = typeof signedAtRaw === "string" && signedAtRaw.trim() !== "" ? signedAtRaw.trim() : nowIso();
    if (!Number.isFinite(Date.parse(signedAt))) throw new TypeError("acceptanceSignature.signedAt must be an ISO date-time");
    const actingOnBehalfOf = await parseActingOnBehalfOf({
      tenantId,
      acceptedByAgentId: acceptedByNormalized,
      signerAgentId,
      signedAt,
      actingOnBehalfOfInput: acceptanceSignatureInput.actingOnBehalfOf,
      requiredScope: MARKETPLACE_DELEGATION_SCOPE_AGREEMENT_CANCEL
    });
    if (!actingOnBehalfOf && signerAgentId !== acceptedByNormalized) {
      throw new TypeError("acceptanceSignature.signerAgentId must match acceptedByAgentId");
    }
    const signerIdentity =
      acceptedByIdentity && signerAgentId === acceptedByNormalized
        ? acceptedByIdentity
        : await getAgentIdentityRecord({ tenantId, agentId: signerAgentId });
    if (!signerIdentity) throw new TypeError("acceptanceSignature signer agent not found");
    if (String(signerIdentity?.status ?? "active").toLowerCase() !== "active") {
      throw new TypeError("acceptanceSignature signer agent must be active");
    }

    const signerKeyId =
      typeof acceptanceSignatureInput.signerKeyId === "string" && acceptanceSignatureInput.signerKeyId.trim() !== ""
        ? acceptanceSignatureInput.signerKeyId.trim()
        : null;
    const signature =
      typeof acceptanceSignatureInput.signature === "string" && acceptanceSignatureInput.signature.trim() !== ""
        ? acceptanceSignatureInput.signature.trim()
        : null;
    if (!signerKeyId || !signature) {
      throw new TypeError("acceptanceSignature.signerKeyId and acceptanceSignature.signature are required");
    }
    const expectedAgentKeyId = String(signerIdentity?.keys?.keyId ?? "");
    if (expectedAgentKeyId && signerKeyId !== expectedAgentKeyId) {
      throw new TypeError("acceptanceSignature.signerKeyId does not match signer agent key");
    }

    const core = buildMarketplaceAgreementCancellationAcceptanceSignatureCore({
      tenantId,
      runId,
      agreement,
      cancellation,
      actingOnBehalfOf
    });
    const expectedSignerAgentId = actingOnBehalfOf?.delegateAgentId ?? core.acceptedByAgentId;
    if (expectedSignerAgentId && expectedSignerAgentId !== signerAgentId) {
      throw new TypeError("acceptanceSignature.signerAgentId must match cancellation.acceptedByAgentId");
    }
    const acceptanceHash = sha256Hex(canonicalJsonStringify(core));
    const publicKeyPem = await loadSignerPublicKeyPem({ tenantId, signerKeyId });
    const isValid = verifyHashHexEd25519({
      hashHex: acceptanceHash,
      signatureBase64: signature,
      publicKeyPem
    });
    if (!isValid) throw new TypeError("invalid acceptanceSignature signature");

    return normalizeForCanonicalJson(
      {
        ...core,
        signerAgentId,
        signerKeyId,
        signedAt,
        actingOnBehalfOf: actingOnBehalfOf ?? null,
        acceptanceHash,
        signature
      },
      { path: "$" }
    );
  }

  async function verifyMarketplaceAgreementCancellationAcceptanceSignature({
    tenantId,
    runId,
    agreement,
    cancellation
  } = {}) {
    const signatureObj =
      cancellation?.acceptanceSignature &&
      typeof cancellation.acceptanceSignature === "object" &&
      !Array.isArray(cancellation.acceptanceSignature)
        ? cancellation.acceptanceSignature
        : null;
    if (!signatureObj) return { present: false, valid: false, reason: "acceptance_signature_missing" };
    const signerAgentId =
      typeof signatureObj.signerAgentId === "string" && signatureObj.signerAgentId.trim() !== ""
        ? signatureObj.signerAgentId.trim()
        : null;
    if (!signerAgentId) {
      return { present: true, valid: false, reason: "acceptance_signature_signer_agent_missing" };
    }
    const signedAt =
      typeof signatureObj.signedAt === "string" && signatureObj.signedAt.trim() !== ""
        ? signatureObj.signedAt.trim()
        : null;
    if (!isValidIsoDateTime(signedAt)) {
      return { present: true, valid: false, reason: "acceptance_signature_signed_at_invalid", signerAgentId };
    }
    const acceptedByAgentId =
      typeof cancellation?.acceptedByAgentId === "string" && cancellation.acceptedByAgentId.trim() !== ""
        ? cancellation.acceptedByAgentId.trim()
        : null;
    let actingOnBehalfOf = null;
    try {
      actingOnBehalfOf = await parseActingOnBehalfOf({
        tenantId,
        acceptedByAgentId,
        signerAgentId,
        signedAt,
        actingOnBehalfOfInput: signatureObj.actingOnBehalfOf,
        requiredScope: MARKETPLACE_DELEGATION_SCOPE_AGREEMENT_CANCEL,
        enforceActiveAgents: false
      });
    } catch (err) {
      return {
        present: true,
        valid: false,
        reason: "acceptance_signature_delegation_invalid",
        signerAgentId,
        message: err?.message
      };
    }
    let expectedCore = null;
    try {
      expectedCore = buildMarketplaceAgreementCancellationAcceptanceSignatureCore({
        tenantId,
        runId,
        agreement,
        cancellation,
        actingOnBehalfOf
      });
    } catch (err) {
      return { present: true, valid: false, reason: "acceptance_signature_core_invalid", message: err?.message };
    }
    const expectedHash = sha256Hex(canonicalJsonStringify(expectedCore));
    let acceptanceHash = null;
    try {
      acceptanceHash = normalizeSha256HashInput(signatureObj.acceptanceHash, "cancellation.acceptanceSignature.acceptanceHash", {
        allowNull: true
      });
    } catch (err) {
      return { present: true, valid: false, reason: "acceptance_signature_hash_invalid", expectedHash, message: err?.message };
    }
    if (!acceptanceHash) return { present: true, valid: false, reason: "acceptance_signature_hash_missing", expectedHash };
    if (acceptanceHash !== expectedHash) {
      return { present: true, valid: false, reason: "acceptance_signature_hash_mismatch", expectedHash, acceptanceHash };
    }
    const expectedSignerAgentId = actingOnBehalfOf?.delegateAgentId ?? expectedCore.acceptedByAgentId;
    if (expectedSignerAgentId && signerAgentId !== expectedSignerAgentId) {
      return {
        present: true,
        valid: false,
        reason: "acceptance_signature_signer_agent_mismatch",
        expectedHash,
        acceptanceHash,
        signerAgentId,
        acceptedByAgentId: expectedCore.acceptedByAgentId,
        expectedSignerAgentId
      };
    }
    const signerKeyId =
      typeof signatureObj.signerKeyId === "string" && signatureObj.signerKeyId.trim() !== ""
        ? signatureObj.signerKeyId.trim()
        : null;
    const signature =
      typeof signatureObj.signature === "string" && signatureObj.signature.trim() !== ""
        ? signatureObj.signature.trim()
        : null;
    if (!signerKeyId || !signature) {
      return {
        present: true,
        valid: false,
        reason: "acceptance_signature_signature_missing",
        expectedHash,
        acceptanceHash,
        signerAgentId
      };
    }
    let signerIdentity = null;
    try {
      signerIdentity = await getAgentIdentityRecord({ tenantId, agentId: signerAgentId });
    } catch (err) {
      return { present: true, valid: false, reason: "acceptance_signature_signer_agent_lookup_failed", expectedHash, acceptanceHash, signerAgentId, message: err?.message };
    }
    if (!signerIdentity) {
      return { present: true, valid: false, reason: "acceptance_signature_signer_agent_unknown", expectedHash, acceptanceHash, signerAgentId };
    }
    const expectedAgentKeyId = String(signerIdentity?.keys?.keyId ?? "");
    if (expectedAgentKeyId && signerKeyId !== expectedAgentKeyId) {
      return {
        present: true,
        valid: false,
        reason: "acceptance_signature_signer_key_mismatch",
        expectedHash,
        acceptanceHash,
        signerAgentId,
        signerKeyId,
        expectedAgentKeyId
      };
    }
    let publicKeyPem = null;
    try {
      publicKeyPem = await loadSignerPublicKeyPem({ tenantId, signerKeyId });
    } catch (err) {
      return { present: true, valid: false, reason: "acceptance_signature_signer_unknown", expectedHash, acceptanceHash, signerAgentId, signerKeyId, message: err?.message };
    }
    const signatureValid = verifyHashHexEd25519({
      hashHex: acceptanceHash,
      signatureBase64: signature,
      publicKeyPem
    });
    if (!signatureValid) {
      return { present: true, valid: false, reason: "acceptance_signature_signature_invalid", expectedHash, acceptanceHash, signerAgentId, signerKeyId };
    }
    return {
      present: true,
      valid: true,
      reason: null,
      expectedHash,
      acceptanceHash,
      signerAgentId,
      signerKeyId,
      actingOnBehalfOf: actingOnBehalfOf
        ? {
            principalAgentId: actingOnBehalfOf.principalAgentId,
            delegateAgentId: actingOnBehalfOf.delegateAgentId,
            chainHash: actingOnBehalfOf.chainHash
          }
        : null
    };
  }

  function buildMarketplaceRfqAgreement({
    tenantId,
    rfq,
    bid,
    runId,
    acceptedAt,
    acceptedByAgentId,
    payerAgentId,
    fromType = "agent",
    toType = "agent",
    disputeWindowDays = 3,
    verificationMethodInput = null,
    settlementPolicyInput = null,
    policyRefInput = null,
    agreementTermsInput = null
  }) {
    const rfqId = String(rfq?.rfqId ?? "");
    const bidId = String(bid?.bidId ?? "");
    if (!rfqId || !bidId) throw new TypeError("rfqId and bid.bidId are required");
    const agreedCurrency = typeof bid?.currency === "string" && bid.currency.trim() !== ""
      ? String(bid.currency).trim().toUpperCase()
      : String(rfq?.currency ?? "USD").trim().toUpperCase();
    const agreedAmountCents = Number(bid?.amountCents);
    if (!Number.isSafeInteger(agreedAmountCents) || agreedAmountCents <= 0) {
      throw new TypeError("bid.amountCents must be a positive safe integer");
    }
    const normalizedDisputeWindowDays = Number.isSafeInteger(Number(disputeWindowDays)) && Number(disputeWindowDays) >= 0
      ? Number(disputeWindowDays)
      : 0;
    const direction = parseInteractionDirection({ fromTypeRaw: fromType, toTypeRaw: toType });
    const verificationMethod = parseVerificationMethodInput(verificationMethodInput ?? bid?.verificationMethod ?? null);
    const policyWithHash = parseSettlementPolicyInput(settlementPolicyInput ?? bid?.policy ?? null);
    const settlementPolicy = {
      ...policyWithHash,
      policyHash: policyWithHash.policyHash
    };
    const verificationMethodHash = computeVerificationMethodHash(verificationMethod);
    const normalizedPolicyRefInput =
      policyRefInput && typeof policyRefInput === "object" && !Array.isArray(policyRefInput)
        ? parseSettlementPolicyRefInput(policyRefInput, { allowNull: true })
        : null;
    const policyRef = normalizeForCanonicalJson(
      {
        schemaVersion: MARKETPLACE_POLICY_REF_SCHEMA_VERSION,
        source: normalizedPolicyRefInput?.source ?? "inline",
        policyId: normalizedPolicyRefInput?.policyId ?? null,
        policyVersion:
          normalizedPolicyRefInput?.policyVersion !== null && normalizedPolicyRefInput?.policyVersion !== undefined
            ? Number(normalizedPolicyRefInput.policyVersion)
            : Number(settlementPolicy.policyVersion ?? 1),
        policyHash: settlementPolicy.policyHash,
        verificationMethodHash
      },
      { path: "$" }
    );
    const negotiationSummary = summarizeMarketplaceBidNegotiationForAgreement(bid?.negotiation ?? null);
    const proposalCount =
      Number.isSafeInteger(Number(negotiationSummary?.proposalCount)) && Number(negotiationSummary?.proposalCount) > 0
        ? Number(negotiationSummary.proposalCount)
        : Number.isSafeInteger(Number(negotiationSummary?.negotiation?.proposalCount)) &&
            Number(negotiationSummary?.negotiation?.proposalCount) > 0
          ? Number(negotiationSummary?.negotiation?.proposalCount)
          : 1;
    const offer =
      negotiationSummary.acceptedProposal &&
      typeof negotiationSummary.acceptedProposal === "object" &&
      !Array.isArray(negotiationSummary.acceptedProposal)
        ? buildMarketplaceOffer({
            tenantId: String(tenantId),
            rfqId,
            runId: String(runId),
            bidId,
            proposal: negotiationSummary.acceptedProposal,
            offerChainHash: negotiationSummary.offerChainHash,
            proposalCount,
            createdAt: acceptedAt
          })
        : null;
    const offerAcceptance = buildMarketplaceAcceptance({
      tenantId: String(tenantId),
      rfqId,
      runId: String(runId),
      bidId,
      agreementId: `agr_${rfqId}_${bidId}`,
      acceptedAt,
      acceptedByAgentId: acceptedByAgentId ?? null,
      acceptedProposalId: negotiationSummary.acceptedProposalId,
      acceptedRevision: negotiationSummary.acceptedRevision,
      acceptedProposalHash: negotiationSummary.acceptedProposalHash,
      offerChainHash: negotiationSummary.offerChainHash,
      proposalCount,
      offer,
      createdAt: acceptedAt
    });
    const agreement = {
      schemaVersion: "MarketplaceTaskAgreement.v2",
      agreementId: `agr_${rfqId}_${bidId}`,
      tenantId: String(tenantId),
      rfqId,
      runId: String(runId),
      bidId,
      payerAgentId: String(payerAgentId),
      payeeAgentId: String(bid?.bidderAgentId ?? ""),
      fromType: direction.fromType,
      toType: direction.toType,
      amountCents: agreedAmountCents,
      currency: agreedCurrency,
      acceptedAt,
      acceptedByAgentId: acceptedByAgentId ?? null,
      disputeWindowDays: normalizedDisputeWindowDays,
      offerChainHash: negotiationSummary.offerChainHash,
      acceptedProposalId: negotiationSummary.acceptedProposalId,
      acceptedRevision: negotiationSummary.acceptedRevision,
      acceptedProposalHash: negotiationSummary.acceptedProposalHash,
      offer,
      offerHash: offer?.offerHash ?? null,
      offerAcceptance,
      offerAcceptanceHash: offerAcceptance?.acceptanceHash ?? null,
      negotiation: negotiationSummary.negotiation,
      acceptance:
        negotiationSummary.acceptance ??
        normalizeForCanonicalJson(
          {
            schemaVersion: MARKETPLACE_AGREEMENT_ACCEPTANCE_SCHEMA_VERSION,
            acceptedAt,
            acceptedByAgentId: acceptedByAgentId ?? null,
            acceptedProposalId: negotiationSummary.acceptedProposalId,
            acceptedRevision: negotiationSummary.acceptedRevision,
            acceptedProposalHash: negotiationSummary.acceptedProposalHash,
            offerChainHash: negotiationSummary.offerChainHash,
            proposalCount
          },
          { path: "$" }
        ),
      verificationMethod,
      policy: settlementPolicy,
      policyRef,
      terms: buildMarketplaceAgreementTerms({
        rfq,
        bid,
        agreementTermsInput
      })
    };
    agreement.termsHash = sha256Hex(canonicalJsonStringify(agreement.terms));
    agreement.verificationMethodHash = policyRef.verificationMethodHash;
    agreement.policyHash = policyRef.policyHash;
    agreement.policyBinding = buildMarketplaceAgreementPolicyBinding({
      agreement,
      signedAt: acceptedAt,
      signer: serverSigner
    });
    return agreement;
  }

  function makeLifecycleArtifactId({ eventType, sourceEventId, runId, rfqId }) {
    const sanitize = (value) =>
      String(value ?? "")
        .trim()
        .replaceAll(/[^a-zA-Z0-9_-]/g, "_");
    const eventSeg = sanitize(eventType).toLowerCase() || "event";
    const sourceSeg = sanitize(sourceEventId) || sanitize(runId) || sanitize(rfqId) || createId("evt");
    return `lifecycle_${eventSeg}_${sourceSeg}`;
  }

  async function emitMarketplaceLifecycleArtifact({
    tenantId,
    eventType,
    rfqId = null,
    runId = null,
    sourceEventId = null,
    actorAgentId = null,
    agreement = null,
    settlement = null,
    details = null
  } = {}) {
    if (typeof store.putArtifact !== "function" || typeof store.createDelivery !== "function") return null;
    const artifactType = "MarketplaceLifecycle.v1";
    const generatedAt = nowIso();
    const artifactId = makeLifecycleArtifactId({ eventType, sourceEventId, runId, rfqId });
    const body = {
      schemaVersion: artifactType,
      artifactType,
      artifactId,
      tenantId: normalizeTenant(tenantId),
      rfqId: rfqId ?? null,
      runId: runId ?? null,
      sourceEventId: sourceEventId ?? null,
      eventType,
      actorAgentId: actorAgentId ?? null,
      agreementId: agreement?.agreementId ?? null,
      settlementId: settlement?.settlementId ?? null,
      generatedAt,
      payload: {
        agreement: agreement ?? null,
        settlement: settlement ?? null,
        details: details ?? null
      }
    };
    const artifactHash = computeArtifactHash(body);
    const artifact = { ...body, artifactHash };
    try {
      await store.putArtifact({ tenantId, artifact });
    } catch (err) {
      if (err?.code !== "ARTIFACT_HASH_MISMATCH") throw err;
    }
    const destinations = listDestinationsForTenant(tenantId).filter((destination) => {
      const allowed = Array.isArray(destination?.artifactTypes) && destination.artifactTypes.length ? destination.artifactTypes : null;
      return !allowed || allowed.includes(artifactType);
    });
    let deliveriesCreated = 0;
    for (const destination of destinations) {
      const dedupeKey = `${tenantId}:${destination.destinationId}:${artifactType}:${artifactId}:${artifactHash}`;
      const scopeKey = String(runId ?? rfqId ?? sourceEventId ?? eventType);
      const orderSeq = Date.parse(generatedAt) || 0;
      const priority = 90;
      const orderKey = `${scopeKey}\n${String(orderSeq)}\n${String(priority)}\n${artifactId}`;
      try {
        await store.createDelivery({
          tenantId,
          delivery: {
            destinationId: destination.destinationId,
            artifactType,
            artifactId,
            artifactHash,
            dedupeKey,
            scopeKey,
            orderSeq,
            priority,
            orderKey
          }
        });
        deliveriesCreated += 1;
      } catch (err) {
        if (err?.code === "DELIVERY_DEDUPE_CONFLICT") continue;
        throw err;
      }
    }
    return { artifactId, artifactHash, deliveriesCreated };
  }

  async function emitDisputeVerdictArtifact({
    tenantId,
    runId,
    settlement,
    verdict
  } = {}) {
    if (!verdict || typeof verdict !== "object" || Array.isArray(verdict)) return null;
    if (typeof store.putArtifact !== "function" || typeof store.createDelivery !== "function") return null;
    const artifactType = "DisputeVerdict.v1";
    const artifactId = `dispute_verdict_${String(verdict.verdictId ?? createId("vrd"))}`;
    const body = {
      schemaVersion: artifactType,
      artifactType,
      artifactId,
      tenantId: normalizeTenant(tenantId),
      runId: String(runId),
      settlementId: settlement?.settlementId ?? null,
      disputeId: settlement?.disputeId ?? null,
      verdict
    };
    const artifactHash = computeArtifactHash(body);
    const artifact = { ...body, artifactHash };
    try {
      await store.putArtifact({ tenantId, artifact });
    } catch (err) {
      if (err?.code !== "ARTIFACT_HASH_MISMATCH") throw err;
    }
    const destinations = listDestinationsForTenant(tenantId).filter((destination) => {
      const allowed = Array.isArray(destination?.artifactTypes) && destination.artifactTypes.length ? destination.artifactTypes : null;
      return !allowed || allowed.includes(artifactType);
    });
    let deliveriesCreated = 0;
    for (const destination of destinations) {
      const dedupeKey = `${tenantId}:${destination.destinationId}:${artifactType}:${artifactId}:${artifactHash}`;
      const scopeKey = String(runId ?? settlement?.settlementId ?? verdict?.disputeId ?? artifactId);
      const orderSeq = Date.parse(nowIso()) || 0;
      const priority = 80;
      const orderKey = `${scopeKey}\n${String(orderSeq)}\n${String(priority)}\n${artifactId}`;
      try {
        await store.createDelivery({
          tenantId,
          delivery: {
            destinationId: destination.destinationId,
            artifactType,
            artifactId,
            artifactHash,
            dedupeKey,
            scopeKey,
            orderSeq,
            priority,
            orderKey
          }
        });
        deliveriesCreated += 1;
      } catch (err) {
        if (err?.code === "DELIVERY_DEDUPE_CONFLICT") continue;
        throw err;
      }
    }
    return { artifactId, artifactHash, deliveriesCreated, verdictHash: verdict.verdictHash ?? null };
  }

  async function emitDisputeOpenEnvelopeArtifact({
    tenantId,
    runId,
    settlement,
    disputeOpenEnvelope
  } = {}) {
    if (!disputeOpenEnvelope || typeof disputeOpenEnvelope !== "object" || Array.isArray(disputeOpenEnvelope)) return null;
    if (typeof store.putArtifact !== "function" || typeof store.createDelivery !== "function") return null;
    validateDisputeOpenEnvelopeV1(disputeOpenEnvelope);
    const artifactType = DISPUTE_OPEN_ENVELOPE_SCHEMA_VERSION;
    const artifactId = typeof disputeOpenEnvelope.artifactId === "string" ? disputeOpenEnvelope.artifactId.trim() : "";
    if (!artifactId) return null;
    const body = normalizeForCanonicalJson(
      {
        ...disputeOpenEnvelope,
        schemaVersion: artifactType,
        artifactType,
        artifactId
      },
      { path: "$" }
    );
    const artifactHash = computeArtifactHash(body);
    const artifact = { ...body, artifactHash };
    try {
      await store.putArtifact({ tenantId, artifact });
    } catch (err) {
      if (err?.code !== "ARTIFACT_HASH_MISMATCH") throw err;
    }
    const destinations = listDestinationsForTenant(tenantId).filter((destination) => {
      const allowed = Array.isArray(destination?.artifactTypes) && destination.artifactTypes.length ? destination.artifactTypes : null;
      return !allowed || allowed.includes(artifactType);
    });
    let deliveriesCreated = 0;
    for (const destination of destinations) {
      const dedupeKey = `${tenantId}:${destination.destinationId}:${artifactType}:${artifactId}:${artifactHash}`;
      const scopeKey = String(runId ?? settlement?.settlementId ?? disputeOpenEnvelope.caseId ?? artifactId);
      const orderSeq = Date.parse(disputeOpenEnvelope.openedAt ?? nowIso()) || 0;
      const priority = 76;
      const orderKey = `${scopeKey}\n${String(orderSeq)}\n${String(priority)}\n${artifactId}`;
      try {
        await store.createDelivery({
          tenantId,
          delivery: {
            destinationId: destination.destinationId,
            artifactType,
            artifactId,
            artifactHash,
            dedupeKey,
            scopeKey,
            orderSeq,
            priority,
            orderKey
          }
        });
        deliveriesCreated += 1;
      } catch (err) {
        if (err?.code === "DELIVERY_DEDUPE_CONFLICT") continue;
        throw err;
      }
    }
    return { artifactId, artifactHash, deliveriesCreated, envelopeHash: disputeOpenEnvelope.envelopeHash ?? null };
  }

  async function emitArbitrationCaseArtifact({
    tenantId,
    runId,
    settlement,
    arbitrationVerdict,
    arbitrationCase = null,
    at = nowIso()
  } = {}) {
    const hasArbitrationCase = arbitrationCase && typeof arbitrationCase === "object" && !Array.isArray(arbitrationCase);
    const hasArbitrationVerdict = arbitrationVerdict && typeof arbitrationVerdict === "object" && !Array.isArray(arbitrationVerdict);
    if (!hasArbitrationCase && !hasArbitrationVerdict) return null;
    if (typeof store.putArtifact !== "function" || typeof store.createDelivery !== "function") return null;
    const artifactType = "ArbitrationCase.v1";
    const caseId = hasArbitrationCase
      ? (typeof arbitrationCase.caseId === "string" && arbitrationCase.caseId.trim() !== "" ? arbitrationCase.caseId.trim() : null)
      : typeof arbitrationVerdict.caseId === "string" && arbitrationVerdict.caseId.trim() !== ""
        ? arbitrationVerdict.caseId.trim()
        : null;
    if (!caseId) return null;
    const revisionRaw = hasArbitrationCase ? Number(arbitrationCase.revision ?? 1) : 1;
    const revision = Number.isSafeInteger(revisionRaw) && revisionRaw > 0 ? revisionRaw : 1;
    const artifactId = revision > 1 ? `arbitration_case_${caseId}_r${revision}` : `arbitration_case_${caseId}`;
    const openedAt = hasArbitrationCase ? arbitrationCase.openedAt ?? at : settlement?.disputeOpenedAt ?? at;
    const closedAt = hasArbitrationCase ? arbitrationCase.closedAt ?? null : settlement?.disputeClosedAt ?? at;
    const createdAt = hasArbitrationCase ? arbitrationCase.createdAt ?? openedAt : openedAt;
    const updatedAt = hasArbitrationCase ? arbitrationCase.updatedAt ?? at : closedAt ?? at;
    const evidenceRefs = hasArbitrationCase
      ? (Array.isArray(arbitrationCase.evidenceRefs) ? arbitrationCase.evidenceRefs : [])
      : Array.isArray(settlement?.disputeContext?.evidenceRefs)
        ? settlement.disputeContext.evidenceRefs
        : Array.isArray(arbitrationVerdict.evidenceRefs)
          ? arbitrationVerdict.evidenceRefs
          : [];
    const appealRef = hasArbitrationCase
      ? arbitrationCase.appealRef ?? null
      : arbitrationVerdict?.appealRef && typeof arbitrationVerdict.appealRef === "object" && !Array.isArray(arbitrationVerdict.appealRef)
        ? {
            parentCaseId: arbitrationVerdict.appealRef.appealCaseId ?? null,
            parentVerdictId: arbitrationVerdict.appealRef.parentVerdictId ?? null,
            reason: arbitrationVerdict.appealRef.reason ?? null
          }
        : null;
    const normalizedStatus = hasArbitrationCase
      ? normalizeArbitrationCaseStatus(arbitrationCase.status ?? ARBITRATION_CASE_STATUS.OPEN, { fieldName: "arbitrationCase.status" })
      : ARBITRATION_CASE_STATUS.CLOSED;
    const body = normalizeForCanonicalJson(
      {
        schemaVersion: artifactType,
        artifactType,
        artifactId,
        caseId,
        tenantId: normalizeTenant(tenantId),
        runId: String((hasArbitrationCase ? arbitrationCase.runId : runId) ?? ""),
        settlementId: String((hasArbitrationCase ? arbitrationCase.settlementId : settlement?.settlementId) ?? ""),
        disputeId: String((hasArbitrationCase ? arbitrationCase.disputeId : settlement?.disputeId ?? arbitrationVerdict?.disputeId) ?? ""),
        claimantAgentId: String(
          (hasArbitrationCase ? arbitrationCase.claimantAgentId : settlement?.payerAgentId ?? settlement?.disputeContext?.openedByAgentId) ?? ""
        ),
        respondentAgentId: String((hasArbitrationCase ? arbitrationCase.respondentAgentId : settlement?.agentId) ?? ""),
        arbiterAgentId: hasArbitrationCase ? arbitrationCase.arbiterAgentId ?? null : arbitrationVerdict.arbiterAgentId ?? null,
        status: normalizedStatus,
        openedAt,
        closedAt: closedAt ?? null,
        summary: hasArbitrationCase ? arbitrationCase.summary ?? null : settlement?.disputeResolution?.summary ?? arbitrationVerdict?.rationale ?? null,
        evidenceRefs,
        verdictId: hasArbitrationCase ? arbitrationCase.verdictId ?? null : arbitrationVerdict.verdictId ?? null,
        verdictHash: hasArbitrationCase ? arbitrationCase.verdictHash ?? null : arbitrationVerdict.verdictHash ?? null,
        appealRef: appealRef?.parentCaseId ? appealRef : null,
        revision,
        createdAt,
        updatedAt
      },
      { path: "$" }
    );
    const artifactHash = computeArtifactHash(body);
    const artifact = { ...body, artifactHash };
    try {
      await store.putArtifact({ tenantId, artifact });
    } catch (err) {
      if (err?.code !== "ARTIFACT_HASH_MISMATCH") throw err;
    }
    const destinations = listDestinationsForTenant(tenantId).filter((destination) => {
      const allowed = Array.isArray(destination?.artifactTypes) && destination.artifactTypes.length ? destination.artifactTypes : null;
      return !allowed || allowed.includes(artifactType);
    });
    let deliveriesCreated = 0;
    for (const destination of destinations) {
      const dedupeKey = `${tenantId}:${destination.destinationId}:${artifactType}:${artifactId}:${artifactHash}`;
      const scopeKey = String((hasArbitrationCase ? arbitrationCase.runId : runId) ?? settlement?.settlementId ?? caseId ?? artifactId);
      const orderSeq = Date.parse(updatedAt) || 0;
      const priority = 75;
      const orderKey = `${scopeKey}\n${String(orderSeq)}\n${String(priority)}\n${artifactId}`;
      try {
        await store.createDelivery({
          tenantId,
          delivery: {
            destinationId: destination.destinationId,
            artifactType,
            artifactId,
            artifactHash,
            dedupeKey,
            scopeKey,
            orderSeq,
            priority,
            orderKey
          }
        });
        deliveriesCreated += 1;
      } catch (err) {
        if (err?.code === "DELIVERY_DEDUPE_CONFLICT") continue;
        throw err;
      }
    }
    return { artifactId, artifactHash, deliveriesCreated, caseId };
  }

  async function emitArbitrationVerdictArtifact({
    tenantId,
    runId,
    settlement,
    arbitrationVerdict
  } = {}) {
    if (!arbitrationVerdict || typeof arbitrationVerdict !== "object" || Array.isArray(arbitrationVerdict)) return null;
    if (typeof store.putArtifact !== "function" || typeof store.createDelivery !== "function") return null;
    const artifactType = "ArbitrationVerdict.v1";
    const verdictId = typeof arbitrationVerdict.verdictId === "string" && arbitrationVerdict.verdictId.trim() !== ""
      ? arbitrationVerdict.verdictId.trim()
      : null;
    if (!verdictId) return null;
    const artifactId = `arbitration_verdict_${verdictId}`;
    const issuedAt = arbitrationVerdict.issuedAt ?? nowIso();
    const signatureEnvelope =
      arbitrationVerdict?.signatureEnvelope && typeof arbitrationVerdict.signatureEnvelope === "object"
        ? arbitrationVerdict.signatureEnvelope
        : null;
    const body = normalizeForCanonicalJson(
      {
        schemaVersion: artifactType,
        artifactType,
        artifactId,
        verdictId,
        caseId: arbitrationVerdict.caseId ?? null,
        tenantId: normalizeTenant(tenantId),
        runId: String(runId),
        settlementId: String(settlement?.settlementId ?? arbitrationVerdict.settlementId ?? ""),
        disputeId: String(settlement?.disputeId ?? arbitrationVerdict.disputeId ?? ""),
        arbiterAgentId: arbitrationVerdict.arbiterAgentId ?? null,
        outcome: arbitrationVerdict.outcome ?? null,
        releaseRatePct: arbitrationVerdict.releaseRatePct ?? null,
        rationale: arbitrationVerdict.rationale ?? null,
        evidenceRefs: Array.isArray(arbitrationVerdict.evidenceRefs) ? arbitrationVerdict.evidenceRefs : [],
        issuedAt,
        appealRef: arbitrationVerdict.appealRef ?? null,
        signature:
          signatureEnvelope ??
          {
            algorithm: "ed25519",
            signerKeyId: arbitrationVerdict.signerKeyId ?? null,
            verdictHash: arbitrationVerdict.verdictHash ?? null,
            signature: arbitrationVerdict.signature ?? null
          },
        revision: 1,
        createdAt: issuedAt,
        updatedAt: issuedAt
      },
      { path: "$" }
    );
    const artifactHash = computeArtifactHash(body);
    const artifact = { ...body, artifactHash };
    try {
      await store.putArtifact({ tenantId, artifact });
    } catch (err) {
      if (err?.code !== "ARTIFACT_HASH_MISMATCH") throw err;
    }
    const destinations = listDestinationsForTenant(tenantId).filter((destination) => {
      const allowed = Array.isArray(destination?.artifactTypes) && destination.artifactTypes.length ? destination.artifactTypes : null;
      return !allowed || allowed.includes(artifactType);
    });
    let deliveriesCreated = 0;
    for (const destination of destinations) {
      const dedupeKey = `${tenantId}:${destination.destinationId}:${artifactType}:${artifactId}:${artifactHash}`;
      const scopeKey = String(runId ?? settlement?.settlementId ?? verdictId ?? artifactId);
      const orderSeq = Date.parse(issuedAt) || 0;
      const priority = 74;
      const orderKey = `${scopeKey}\n${String(orderSeq)}\n${String(priority)}\n${artifactId}`;
      try {
        await store.createDelivery({
          tenantId,
          delivery: {
            destinationId: destination.destinationId,
            artifactType,
            artifactId,
            artifactHash,
            dedupeKey,
            scopeKey,
            orderSeq,
            priority,
            orderKey
          }
        });
        deliveriesCreated += 1;
      } catch (err) {
        if (err?.code === "DELIVERY_DEDUPE_CONFLICT") continue;
        throw err;
      }
    }
    return { artifactId, artifactHash, deliveriesCreated, verdictHash: arbitrationVerdict.verdictHash ?? null };
  }

  function getMonthEvents(tenantId, monthId) {
    return store.monthEvents?.get?.(monthStoreKey(tenantId, monthId)) ?? [];
  }

  function setMonthEvents(tenantId, monthId, events) {
    if (store.monthEvents?.set) store.monthEvents.set(monthStoreKey(tenantId, monthId), events);
  }

  function assertNonEmptyString(value, name) {
    if (typeof value !== "string" || value.trim() === "") throw new TypeError(`${name} must be a non-empty string`);
  }

  function assertActor(actor) {
    if (!actor || typeof actor !== "object") throw new TypeError("actor must be an object");
    assertNonEmptyString(actor.type, "actor.type");
    assertNonEmptyString(actor.id, "actor.id");
  }

  function assertIsoDate(value, name) {
    assertNonEmptyString(value, name);
    const t = Date.parse(value);
    if (!Number.isFinite(t)) throw new TypeError(`${name} must be an ISO date string`);
  }

  function computeUtcDayBoundsIso(atIso) {
    const ms = Date.parse(atIso);
    if (!Number.isFinite(ms)) throw new TypeError("at must be an ISO date string");
    const d = new Date(ms);
    const startMs = Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate(), 0, 0, 0, 0);
    const endMs = startMs + 86_400_000;
    return { dayStartIso: new Date(startMs).toISOString(), dayEndIso: new Date(endMs).toISOString() };
  }

  async function assertSettlementWithinWalletPolicy({ tenantId, agentIdentity, amountCents, at = null }) {
    if (!agentIdentity || typeof agentIdentity !== "object") return;
    const walletPolicy = agentIdentity.walletPolicy;
    if (!walletPolicy || typeof walletPolicy !== "object" || Array.isArray(walletPolicy)) return;

    const maxPerTx = Number(walletPolicy.maxPerTransactionCents);
    if (Number.isSafeInteger(maxPerTx) && maxPerTx >= 0 && amountCents > maxPerTx) {
      const err = new Error("amount exceeds wallet maxPerTransactionCents");
      err.code = "WALLET_POLICY_MAX_PER_TX";
      throw err;
    }

    const requireApprovalAbove = Number(walletPolicy.requireApprovalAboveCents);
    if (Number.isSafeInteger(requireApprovalAbove) && requireApprovalAbove >= 0 && amountCents > requireApprovalAbove) {
      const err = new Error("amount requires out-of-band approval");
      err.code = "WALLET_POLICY_APPROVAL_REQUIRED";
      throw err;
    }

    const maxDaily = Number(walletPolicy.maxDailyCents);
    if (Number.isSafeInteger(maxDaily) && maxDaily >= 0) {
      const atIso = at ?? nowIso();
      const { dayStartIso, dayEndIso } = computeUtcDayBoundsIso(atIso);
      const agentId = typeof agentIdentity.agentId === "string" && agentIdentity.agentId.trim() !== "" ? agentIdentity.agentId.trim() : null;
      if (agentId) {
        let spentCents = 0;
        if (typeof store.sumWalletPolicySpendCentsForDay === "function") {
          spentCents = await store.sumWalletPolicySpendCentsForDay({ tenantId, agentId, dayStartIso, dayEndIso });
        } else {
          const normalizedTenantId = normalizeTenantId(tenantId ?? DEFAULT_TENANT_ID);
          const startMs = Date.parse(dayStartIso);
          const endMs = Date.parse(dayEndIso);
          if (store.agentRunSettlements instanceof Map) {
            for (const row of store.agentRunSettlements.values()) {
              if (!row || typeof row !== "object") continue;
              if (normalizeTenantId(row.tenantId ?? DEFAULT_TENANT_ID) !== normalizedTenantId) continue;
              if (String(row.payerAgentId ?? "") !== agentId) continue;
              const lockedAt = row.lockedAt ?? null;
              const lockedMs = typeof lockedAt === "string" ? Date.parse(lockedAt) : NaN;
              if (!Number.isFinite(lockedMs) || lockedMs < startMs || lockedMs >= endMs) continue;
              const n = Number(row.amountCents ?? 0);
              if (!Number.isSafeInteger(n) || n <= 0) continue;
              spentCents += n;
            }
          }
          if (store.toolCallHolds instanceof Map) {
            for (const row of store.toolCallHolds.values()) {
              if (!row || typeof row !== "object") continue;
              if (normalizeTenantId(row.tenantId ?? DEFAULT_TENANT_ID) !== normalizedTenantId) continue;
              if (String(row.payerAgentId ?? "") !== agentId) continue;
              const createdAt = row.createdAt ?? null;
              const createdMs = typeof createdAt === "string" ? Date.parse(createdAt) : NaN;
              if (!Number.isFinite(createdMs) || createdMs < startMs || createdMs >= endMs) continue;
              const n = Number(row.heldAmountCents ?? 0);
              if (!Number.isSafeInteger(n) || n <= 0) continue;
              spentCents += n;
            }
          }
        }
        if (!Number.isSafeInteger(spentCents) || spentCents < 0) spentCents = 0;
        if (spentCents + amountCents > maxDaily) {
          const err = new Error("amount exceeds wallet maxDailyCents");
          err.code = "WALLET_POLICY_MAX_DAILY";
          throw err;
        }
      }
    }
  }

  function parseExpectedPrevChainHashHeader(req) {
    const raw = req.headers["x-proxy-expected-prev-chain-hash"];
    if (raw === undefined) return { ok: false, expectedPrevChainHash: null };
    const value = String(raw).trim();
    if (value === "" || value.toLowerCase() === "null") return { ok: true, expectedPrevChainHash: null };
    return { ok: true, expectedPrevChainHash: value };
  }

  function getCurrentPrevChainHash(existingEvents) {
    return existingEvents.length ? existingEvents[existingEvents.length - 1].chainHash : null;
  }

  function computeIdempotencyRequestHash({ method, path, expectedPrevChainHash, body }) {
    return sha256Hex(canonicalJsonStringify({ method, path, expectedPrevChainHash, body }));
  }

  function assertJobPayloadId(payloadJobId, jobId) {
    if (payloadJobId !== jobId) throw new TypeError("payload.jobId must match job id");
  }

  function assertNotTerminal(job) {
    if (!job) throw new TypeError("job is required");
    if (job.status === "COMPLETED" || job.status === "ABORTED" || job.status === "SETTLED") {
      throw new TypeError("job is terminal");
    }
  }

  function validateDomainEvent({ jobBefore, event, eventsBefore }) {
    if (!jobBefore) throw new TypeError("jobBefore is required");
    if (!event || typeof event !== "object") throw new TypeError("event is required");

    const type = event.type;
    const payload = event.payload ?? null;
    const jobTenantId = normalizeTenant(jobBefore.tenantId ?? DEFAULT_TENANT_ID);

    const findIncidentById = (incidentId) => {
      for (let i = eventsBefore.length - 1; i >= 0; i -= 1) {
        const e = eventsBefore[i];
        if (e.type !== "INCIDENT_REPORTED" && e.type !== "INCIDENT_DETECTED") continue;
        if (e.payload?.incidentId === incidentId) return e.payload ?? null;
      }
      return null;
    };

    const incidentIdExists = (incidentId) => Boolean(findIncidentById(incidentId));

    const getClaimState = (claimId) => {
      let state = {
        exists: false,
        status: "NONE",
        incidentId: null,
        approved: null,
        adjusted: false
      };

      for (const e of eventsBefore) {
        const p = e.payload ?? null;
        if (!p || p.claimId !== claimId) continue;
        if (e.type === "CLAIM_OPENED") {
          state = { ...state, exists: true, status: "OPEN", incidentId: p.incidentId ?? null };
        }
        if (e.type === "CLAIM_TRIAGED" && state.exists && state.status !== "APPROVED" && state.status !== "DENIED" && state.status !== "PAID") {
          state = { ...state, status: "TRIAGED" };
        }
        if (e.type === "CLAIM_APPROVED") {
          state = {
            ...state,
            exists: true,
            status: "APPROVED",
            approved: { amounts: p.amounts ?? null, currency: p.currency ?? null }
          };
        }
        if (e.type === "CLAIM_DENIED") {
          state = { ...state, exists: true, status: "DENIED", approved: null };
        }
        if (e.type === "JOB_ADJUSTED") {
          state = { ...state, adjusted: true };
        }
        if (e.type === "CLAIM_PAID") {
          state = { ...state, status: "PAID" };
        }
      }

      return state;
    };

    // Access
    if (type === "ACCESS_PLAN_ISSUED") {
      validateAccessPlanIssuedPayload(payload);
      assertJobPayloadId(payload.jobId, jobBefore.id);
      assertNotTerminal(jobBefore);
      if (jobBefore.status === "EXECUTING" || jobBefore.status === "ASSISTED") {
        throw new TypeError("cannot issue access plan after execution start");
      }
    }

    if (type === "ACCESS_GRANTED" || type === "ACCESS_DENIED") {
      validateAccessResultPayload(payload, { name: type });
      assertJobPayloadId(payload.jobId, jobBefore.id);
      const plan = jobBefore.accessPlan;
      if (!plan) throw new TypeError("access plan is required before access can be granted/denied");
      if (payload.accessPlanId !== plan.accessPlanId) throw new TypeError("payload.accessPlanId does not match current access plan");
      if (!isWithinAccessWindow({ at: event.at, validFrom: plan.validFrom, validTo: plan.validTo })) {
        throw new TypeError("access event is outside access plan window");
      }
      if (jobBefore.access.status === "revoked" || jobBefore.access.status === "expired") {
        throw new TypeError("access is revoked/expired");
      }
    }

    if (type === "ACCESS_REVOKED" || type === "ACCESS_EXPIRED") {
      validateAccessRevokedPayload(payload);
      assertJobPayloadId(payload.jobId, jobBefore.id);
      const plan = jobBefore.accessPlan;
      if (!plan) throw new TypeError("access plan is required before access can be revoked/expired");
      if (payload.accessPlanId !== plan.accessPlanId) throw new TypeError("payload.accessPlanId does not match current access plan");
      if (type === "ACCESS_REVOKED" && plan.revocable === false) throw new TypeError("access plan is not revocable");
    }

    // Skills
    // Booking / matching / reservation
    if (type === "BOOKED") {
      validateBookedPayload(payload ?? {});
      assertNotTerminal(jobBefore);
    }

    if (type === "ZONE_COVERAGE_REPORTED") {
      validateZoneCoverageReportedPayload(payload ?? {});
      assertJobPayloadId(payload.jobId, jobBefore.id);
      // Coverage facts are evidence; accept even after settlement (late evidence feeds disputes/claims),
      // but post-settlement re-proof is governed separately.
      if (jobBefore.status !== "EXECUTING" && jobBefore.status !== "ASSISTED" && jobBefore.status !== "COMPLETED" && jobBefore.status !== "SETTLED") {
        throw new TypeError("zone coverage can only be reported during/after execution");
      }
      const requiredZones = jobBefore.booking?.requiredZones ?? null;
      if (requiredZones && typeof requiredZones === "object") {
        try {
          validateZoneSetV1(requiredZones);
        } catch {
          // If booking requiredZones is invalid, don't accept coverage facts (dispute-resistant).
          throw new TypeError("job requiredZones is invalid");
        }
        const allowedZoneIds = new Set(requiredZones.zones.map((z) => String(z.zoneId)));
        if (!allowedZoneIds.has(payload.zoneId)) {
          throw new TypeError("payload.zoneId is not in requiredZones");
        }
      }
    }

    if (type === "PROOF_EVALUATED") {
      validateProofEvaluatedPayload(payload ?? {});
      assertJobPayloadId(payload.jobId, jobBefore.id);
      // Proof is evaluated against completed work; allow evaluation after completion.
      // (We allow SETTLED here to avoid races where settlement is appended before the proof worker ticks.)
      if (jobBefore.status !== "COMPLETED" && jobBefore.status !== "SETTLED") {
        throw new TypeError("proof can only be evaluated after completion");
      }

      if (payload.evaluatedAt !== event.at) throw new TypeError("payload.evaluatedAt must match event.at");
      const booking = jobBefore.booking ?? null;
      const expectedCustomerPolicyHash = booking?.policyHash ?? null;
      if (expectedCustomerPolicyHash && payload.customerPolicyHash !== expectedCustomerPolicyHash) {
        throw new TypeError("payload.customerPolicyHash must match booking.policyHash");
      }
      const expectedOperatorPolicyHash = jobBefore.operatorPolicyHash ?? null;
      if (expectedOperatorPolicyHash && payload.operatorPolicyHash !== expectedOperatorPolicyHash) {
        throw new TypeError("payload.operatorPolicyHash must match pinned operatorPolicyHash");
      }

      const requiredZones = booking?.requiredZones ?? null;
      const requiredZonesHash = booking?.requiredZonesHash ?? null;
      if (requiredZones && typeof requiredZones === "object") {
        const computed = computeZoneSetHash(requiredZones);
        if (requiredZonesHash && computed !== requiredZonesHash) throw new TypeError("booking.requiredZonesHash mismatch");
        if (payload.requiredZonesHash !== computed) throw new TypeError("payload.requiredZonesHash must match booking.requiredZonesHash");
      }

      // Allow re-evaluation for the same completion anchor as evidence arrives,
      // but prevent exact duplicates (same evaluatedAtChainHash + customerPolicyHash + factsHash).
      const existsExact = eventsBefore.some(
        (e) =>
          e?.type === "PROOF_EVALUATED" &&
          e?.payload?.evaluatedAtChainHash === payload.evaluatedAtChainHash &&
          e?.payload?.customerPolicyHash === payload.customerPolicyHash &&
          e?.payload?.factsHash !== null &&
          e?.payload?.factsHash !== undefined &&
          e?.payload?.factsHash === payload.factsHash
      );
      if (existsExact) {
        const err = new Error("proof already exists for evaluatedAtChainHash+customerPolicyHash+factsHash");
        err.code = "PROOF_ALREADY_EXISTS_FOR_FACTS";
        throw err;
      }
    }

	    function findHoldState(events, holdId) {
	      if (!Array.isArray(events)) return { exists: false, status: "NONE" };
	      const hid = typeof holdId === "string" ? holdId : "";
	      if (!hid.trim()) return { exists: false, status: "NONE" };
	      let state = {
	        exists: false,
	        status: "NONE",
	        heldEvent: null,
	        heldFactsHash: null,
	        releasedEvent: null,
	        forfeitedEvent: null
	      };
	      for (const e of events) {
	        const p = e?.payload ?? null;
	        if (!p || p.holdId !== hid) continue;
	        if (e.type === "SETTLEMENT_HELD") {
	          state = {
	            ...state,
	            exists: true,
	            status: "HELD",
	            heldEvent: e ?? state.heldEvent,
	            heldFactsHash: typeof p.factsHash === "string" ? p.factsHash : state.heldFactsHash
	          };
	        }
	        if (e.type === "SETTLEMENT_RELEASED") state = { ...state, exists: true, status: "RELEASED", releasedEvent: e ?? state.releasedEvent };
	        if (e.type === "SETTLEMENT_FORFEITED") state = { ...state, exists: true, status: "FORFEITED", forfeitedEvent: e ?? state.forfeitedEvent };
	      }
	      return state;
	    }

    if (type === "SETTLEMENT_HELD") {
      if (!payload || typeof payload !== "object") throw new TypeError("payload is required");
      assertJobPayloadId(payload.jobId, jobBefore.id);
      if (payload.heldAt !== event.at) throw new TypeError("payload.heldAt must match event.at");
      assertNonEmptyString(payload.holdId, "payload.holdId");
      assertNonEmptyString(payload.evaluatedAtChainHash, "payload.evaluatedAtChainHash");
      assertNonEmptyString(payload.factsHash, "payload.factsHash");
      if (!/^[a-f0-9]{64}$/i.test(String(payload.factsHash).trim())) throw new TypeError("payload.factsHash must be 64-hex");

      if (jobBefore.status !== "COMPLETED") throw new TypeError("settlement hold can only be created after completion");
      const proofPolicy = jobBefore.booking?.policySnapshot?.proofPolicy ?? null;
      const gateModeRaw = typeof proofPolicy?.gateMode === "string" ? proofPolicy.gateMode : "warn";
      const gateMode = gateModeRaw === "strict" || gateModeRaw === "holdback" ? gateModeRaw : "warn";
      if (gateMode === "warn") throw new TypeError("settlement hold requires strict/holdback proof gating");

      const completionChainHash = findLatestCompletionChainHash(eventsBefore);
      if (!completionChainHash) throw new TypeError("settlement hold requires a completion anchor");
      if (payload.evaluatedAtChainHash !== completionChainHash) throw new TypeError("payload.evaluatedAtChainHash must match latest completion anchor");

      const current = computeCurrentProofFactsHash({ completionChainHash });
      if (!current?.factsHash) throw new TypeError("settlement hold requires a current factsHash");
      if (payload.factsHash !== current.factsHash) throw new TypeError("payload.factsHash must match current factsHash");

      const proofEvent = findMatchingProofEvaluatedEvent({
        events: eventsBefore,
        evaluatedAtChainHash: completionChainHash,
        customerPolicyHash: current?.customerPolicyHash ?? null,
        factsHash: current.factsHash
      });
	      if (!proofEvent) throw new TypeError("settlement hold requires a matching PROOF_EVALUATED");
	      const proofStatus = proofEvent?.payload?.status === null || proofEvent?.payload?.status === undefined ? null : String(proofEvent.payload.status).trim();
	      if (proofStatus !== "INSUFFICIENT_EVIDENCE") throw new TypeError("settlement hold requires INSUFFICIENT_EVIDENCE proof");

	      if (!payload.triggeringProofRef || typeof payload.triggeringProofRef !== "object") throw new TypeError("payload.triggeringProofRef is required");
	      const expectedRef = proofRefFromProofEvent(proofEvent);
	      if (!expectedRef || !proofRefMatches({ expected: expectedRef, actual: payload.triggeringProofRef })) {
	        throw new TypeError("payload.triggeringProofRef must match PROOF_EVALUATED");
	      }

	      // Holds must copy canonical missingEvidence/reasonCodes directly from the triggering proof.
	      const proofPayload = proofEvent?.payload ?? null;
	      const expectedMissing = Array.isArray(proofPayload?.missingEvidence) ? proofPayload.missingEvidence : [];
	      const actualMissing = Array.isArray(payload.missingEvidence) ? payload.missingEvidence : [];
	      if (expectedMissing.length !== actualMissing.length || expectedMissing.some((v, i) => actualMissing[i] !== v)) {
	        throw new TypeError("payload.missingEvidence must match triggering PROOF_EVALUATED.missingEvidence");
	      }
	      const expectedReasons = Array.isArray(proofPayload?.reasonCodes) ? proofPayload.reasonCodes : [];
	      const actualReasons = Array.isArray(payload.reasonCodes) ? payload.reasonCodes : [];
	      if (expectedReasons.length !== actualReasons.length || expectedReasons.some((v, i) => actualReasons[i] !== v)) {
	        throw new TypeError("payload.reasonCodes must match triggering PROOF_EVALUATED.reasonCodes");
	      }

	      // Controller-grade holds must include a stable pricing anchor and deterministic exposure snapshot.
	      if (!payload.pricingAnchor || typeof payload.pricingAnchor !== "object") throw new TypeError("payload.pricingAnchor is required");
	      if (payload.pricingAnchor.evaluatedAtChainHash !== completionChainHash) {
	        throw new TypeError("payload.pricingAnchor.evaluatedAtChainHash must match latest completion anchor");
	      }
	      if (payload.pricingAnchor.customerPolicyHash !== (current?.customerPolicyHash ?? null)) {
	        throw new TypeError("payload.pricingAnchor.customerPolicyHash must match current customerPolicyHash");
	      }
	      if (payload.pricingAnchor.operatorPolicyHash !== (current?.operatorPolicyHash ?? null)) {
	        throw new TypeError("payload.pricingAnchor.operatorPolicyHash must match current operatorPolicyHash");
	      }
	      const expectedHoldId =
	        typeof completionChainHash === "string" &&
	        completionChainHash.trim() &&
	        typeof current?.customerPolicyHash === "string" &&
	        String(current.customerPolicyHash).trim()
	          ? `hold_${sha256Hex(`${completionChainHash}\n${String(current.customerPolicyHash).trim()}`)}`
	          : null;
	      if (expectedHoldId && payload.holdId !== expectedHoldId) throw new TypeError("payload.holdId must match expected hold identity");
	      const qid = payload.pricingAnchor.quoteEventId ?? null;
	      if (qid !== null && qid !== undefined) {
	        assertNonEmptyString(qid, "payload.pricingAnchor.quoteEventId");
	        const quoteEvent = eventsBefore.find((e) => e?.id === qid) ?? null;
	        if (!quoteEvent || quoteEvent.type !== "QUOTE_PROPOSED") throw new TypeError("payload.pricingAnchor.quoteEventId must reference QUOTE_PROPOSED");
	      }

	      if (!payload.exposure || typeof payload.exposure !== "object") throw new TypeError("payload.exposure is required");
	      const exp = payload.exposure.expected ?? null;
	      if (!exp || typeof exp !== "object") throw new TypeError("payload.exposure.expected is required");
	      assertNonEmptyString(exp.currency ?? "", "payload.exposure.expected.currency");
	      if (!Number.isSafeInteger(exp.amountGrossCents)) throw new TypeError("payload.exposure.expected.amountGrossCents must be a safe integer");
	      if (!Number.isSafeInteger(exp.amountNetCents)) throw new TypeError("payload.exposure.expected.amountNetCents must be a safe integer");
	      if (!Number.isSafeInteger(exp.coverageFeeCents)) throw new TypeError("payload.exposure.expected.coverageFeeCents must be a safe integer");
	      if (Number.isSafeInteger(jobBefore.quote?.amountCents) && exp.amountGrossCents !== jobBefore.quote.amountCents) {
	        throw new TypeError("payload.exposure.expected.amountGrossCents must match quote amountCents");
	      }

	      const existingHold = findHoldState(eventsBefore, payload.holdId);
      if (existingHold.status === "HELD" && existingHold.heldFactsHash === payload.factsHash) {
        const err = new Error("settlement hold already active");
        err.code = "SETTLEMENT_HOLD_ALREADY_ACTIVE";
        throw err;
      }
    }

	    if (type === "SETTLEMENT_RELEASED") {
      if (!payload || typeof payload !== "object") throw new TypeError("payload is required");
      assertJobPayloadId(payload.jobId, jobBefore.id);
      if (payload.releasedAt !== event.at) throw new TypeError("payload.releasedAt must match event.at");
      assertNonEmptyString(payload.holdId, "payload.holdId");

      if (jobBefore.status !== "COMPLETED") throw new TypeError("settlement hold release can only happen before settlement");

      const hold = findHoldState(eventsBefore, payload.holdId);
      if (hold.status !== "HELD") throw new TypeError("settlement hold must be active to release");

      const proofPolicy = jobBefore.booking?.policySnapshot?.proofPolicy ?? null;
      const gateModeRaw = typeof proofPolicy?.gateMode === "string" ? proofPolicy.gateMode : "warn";
      const gateMode = gateModeRaw === "strict" || gateModeRaw === "holdback" ? gateModeRaw : "warn";
      if (gateMode === "warn") throw new TypeError("settlement hold release requires strict/holdback proof gating");

      const completionChainHash = findLatestCompletionChainHash(eventsBefore);
      if (!completionChainHash) throw new TypeError("settlement hold release requires a completion anchor");

      const current = computeCurrentProofFactsHash({ completionChainHash });
      if (!current?.factsHash) throw new TypeError("settlement hold release requires a current factsHash");

      const proofEvent = findMatchingProofEvaluatedEvent({
        events: eventsBefore,
        evaluatedAtChainHash: completionChainHash,
        customerPolicyHash: current?.customerPolicyHash ?? null,
        factsHash: current.factsHash
      });
	      if (!proofEvent) throw new TypeError("settlement hold release requires a matching PROOF_EVALUATED");
	      const status = proofEvent?.payload?.status === null || proofEvent?.payload?.status === undefined ? null : String(proofEvent.payload.status).trim();
		      if (status !== "PASS" && status !== "FAIL") throw new TypeError("settlement hold release requires PASS or FAIL proof");

	      if (!payload.releasingProofRef || typeof payload.releasingProofRef !== "object") throw new TypeError("payload.releasingProofRef is required");
	      const expectedRef = proofRefFromProofEvent(proofEvent);
	      if (!expectedRef || !proofRefMatches({ expected: expectedRef, actual: payload.releasingProofRef })) {
	        throw new TypeError("payload.releasingProofRef must match PROOF_EVALUATED");
	      }
		    }

	    if (type === "SETTLEMENT_FORFEITED") {
	      if (!payload || typeof payload !== "object") throw new TypeError("payload is required");
	      assertJobPayloadId(payload.jobId, jobBefore.id);
	      if (payload.forfeitedAt !== event.at) throw new TypeError("payload.forfeitedAt must match event.at");
	      assertNonEmptyString(payload.holdId, "payload.holdId");
	      assertNonEmptyString(payload.forfeitureReason, "payload.forfeitureReason");
	      if (payload.decisionRef !== undefined && payload.decisionRef !== null) assertNonEmptyString(payload.decisionRef, "payload.decisionRef");
	      if (payload.decisionEventRef !== undefined && payload.decisionEventRef !== null && (typeof payload.decisionEventRef !== "object" || Array.isArray(payload.decisionEventRef))) {
	        throw new TypeError("payload.decisionEventRef must be an object");
	      }
	      assertNonEmptyString(payload.evaluatedAtChainHash, "payload.evaluatedAtChainHash");
	      assertNonEmptyString(payload.factsHash, "payload.factsHash");
	      if (!/^[a-f0-9]{64}$/i.test(String(payload.factsHash).trim())) throw new TypeError("payload.factsHash must be 64-hex");

	      if (jobBefore.status !== "COMPLETED") throw new TypeError("settlement hold forfeiture can only happen before settlement");

	      const proofPolicy = jobBefore.booking?.policySnapshot?.proofPolicy ?? null;
	      const gateModeRaw = typeof proofPolicy?.gateMode === "string" ? proofPolicy.gateMode : "warn";
	      const gateMode = gateModeRaw === "strict" || gateModeRaw === "holdback" ? gateModeRaw : "warn";
	      if (gateMode === "warn") throw new TypeError("settlement hold forfeiture requires strict/holdback proof gating");

	      const completionChainHash = findLatestCompletionChainHash(eventsBefore);
	      if (!completionChainHash) throw new TypeError("settlement hold forfeiture requires a completion anchor");
	      if (payload.evaluatedAtChainHash !== completionChainHash) throw new TypeError("payload.evaluatedAtChainHash must match latest completion anchor");

	      const current = computeCurrentProofFactsHash({ completionChainHash });
	      if (!current?.factsHash) throw new TypeError("settlement hold forfeiture requires a current factsHash");
	      if (payload.factsHash !== current.factsHash) throw new TypeError("payload.factsHash must match current factsHash");

	      const proofEvent = findMatchingProofEvaluatedEvent({
	        events: eventsBefore,
	        evaluatedAtChainHash: completionChainHash,
	        customerPolicyHash: current?.customerPolicyHash ?? null,
	        factsHash: current.factsHash
	      });
	      if (!proofEvent) throw new TypeError("settlement hold forfeiture requires a matching PROOF_EVALUATED");
	      const proofStatus = proofEvent?.payload?.status === null || proofEvent?.payload?.status === undefined ? null : String(proofEvent.payload.status).trim();
	      if (proofStatus !== "INSUFFICIENT_EVIDENCE") throw new TypeError("settlement hold forfeiture requires INSUFFICIENT_EVIDENCE proof");

	      const hold = findHoldState(eventsBefore, payload.holdId);
	      if (hold.status !== "HELD") throw new TypeError("settlement hold must be active to forfeit");
	      if (hold.heldFactsHash && hold.heldFactsHash !== payload.factsHash) throw new TypeError("settlement hold forfeiture requires matching held factsHash");

	      // Governance: forfeits should be backed by an auditable decision record.
	      const decisionEventRef = payload.decisionEventRef ?? null;
	      const decisionRef = payload.decisionRef ?? null;
	      if (!decisionEventRef && !decisionRef) throw new TypeError("payload.decisionEventRef or payload.decisionRef is required");
	      if (decisionEventRef) {
	        const decisionEventId = typeof decisionEventRef.decisionEventId === "string" ? decisionEventRef.decisionEventId : null;
	        const decisionEvent = decisionEventId ? eventsBefore.find((e) => e?.id === decisionEventId) ?? null : null;
	        if (!decisionEvent || decisionEvent.type !== "DECISION_RECORDED") throw new TypeError("payload.decisionEventRef must reference DECISION_RECORDED");
	        const expected = decisionEventRefFromDecisionEvent(decisionEvent);
	        if (!expected || !decisionEventRefMatches({ expected, actual: decisionEventRef })) {
	          throw new TypeError("payload.decisionEventRef must match referenced DECISION_RECORDED");
	        }
	        if (expected.kind !== "SETTLEMENT_FORFEIT") throw new TypeError("referenced decision kind must be SETTLEMENT_FORFEIT");
	        if (expected.holdId !== payload.holdId) throw new TypeError("referenced decision holdId must match payload.holdId");
	        if (expected.forfeitureReason !== payload.forfeitureReason) throw new TypeError("referenced decision forfeitureReason must match payload.forfeitureReason");
	      }
	    }

	    if (type === "DECISION_RECORDED") {
	      if (!payload || typeof payload !== "object") throw new TypeError("payload is required");
	      assertJobPayloadId(payload.jobId, jobBefore.id);
	      if (payload.decidedAt !== event.at) throw new TypeError("payload.decidedAt must match event.at");
	      assertNonEmptyString(payload.decisionId, "payload.decisionId");
	      assertNonEmptyString(payload.kind, "payload.kind");

	      if (jobBefore.status !== "COMPLETED") throw new TypeError("decision can only be recorded after completion and before settlement");

	      const allowedKinds = new Set(["SETTLEMENT_FORFEIT"]);
	      if (!allowedKinds.has(String(payload.kind))) throw new TypeError("payload.kind is not supported");

	      const already = eventsBefore.some((e) => e?.type === "DECISION_RECORDED" && e?.payload?.decisionId === payload.decisionId);
	      if (already) {
	        const err = new Error("decision already recorded");
	        err.code = "DECISION_ALREADY_RECORDED";
	        throw err;
	      }

	      if (payload.kind === "SETTLEMENT_FORFEIT") {
	        assertNonEmptyString(payload.holdId, "payload.holdId");
	        assertNonEmptyString(payload.forfeitureReason, "payload.forfeitureReason");
	        const hold = findHoldState(eventsBefore, payload.holdId);
	        if (hold.status !== "HELD") throw new TypeError("forfeit decision requires an active hold");
	      }

	      if (payload.reasonCodes !== undefined && payload.reasonCodes !== null) {
	        if (!Array.isArray(payload.reasonCodes)) throw new TypeError("payload.reasonCodes must be an array");
	        for (const r of payload.reasonCodes) assertNonEmptyString(r, "payload.reasonCodes[]");
	      }
	      if (payload.evidenceRefs !== undefined && payload.evidenceRefs !== null) {
	        if (!Array.isArray(payload.evidenceRefs)) throw new TypeError("payload.evidenceRefs must be an array");
	        for (const r of payload.evidenceRefs) assertNonEmptyString(r, "payload.evidenceRefs[]");
	      }
	      if (payload.policyHash !== undefined && payload.policyHash !== null) assertNonEmptyString(payload.policyHash, "payload.policyHash");
	    }

	    if (type === "DISPUTE_OPENED") {
	      if (!payload || typeof payload !== "object") throw new TypeError("payload is required");
	      assertJobPayloadId(payload.jobId, jobBefore.id);
	      if (payload.openedAt !== event.at) throw new TypeError("payload.openedAt must match event.at");
      assertNonEmptyString(payload.disputeId, "payload.disputeId");
      if (jobBefore.status !== "SETTLED") throw new TypeError("dispute can only be opened after settlement");
      const alreadyOpen = eventsBefore.some((e) => e?.type === "DISPUTE_OPENED" && e?.payload?.disputeId === payload.disputeId) &&
        !eventsBefore.some((e) => e?.type === "DISPUTE_CLOSED" && e?.payload?.disputeId === payload.disputeId);
      if (alreadyOpen) {
        const err = new Error("dispute already open");
        err.code = "DISPUTE_ALREADY_OPEN";
        throw err;
      }
    }

    if (type === "DISPUTE_CLOSED") {
      if (!payload || typeof payload !== "object") throw new TypeError("payload is required");
      assertJobPayloadId(payload.jobId, jobBefore.id);
      if (payload.closedAt !== event.at) throw new TypeError("payload.closedAt must match event.at");
      assertNonEmptyString(payload.disputeId, "payload.disputeId");
      if (jobBefore.status !== "SETTLED") throw new TypeError("dispute close can only occur after settlement");
      const isOpen =
        eventsBefore.some((e) => e?.type === "DISPUTE_OPENED" && e?.payload?.disputeId === payload.disputeId) &&
        !eventsBefore.some((e) => e?.type === "DISPUTE_CLOSED" && e?.payload?.disputeId === payload.disputeId);
      if (!isOpen) throw new TypeError("dispute is not open");
    }

    // Risk (v1.6)
    if (type === "RISK_SCORED") {
      validateRiskScoredPayload(payload ?? {});
      assertJobPayloadId(payload.jobId, jobBefore.id);
      if (payload.scoredAt !== event.at) throw new TypeError("payload.scoredAt must match event.at");

      const basis = payload.basis;
      const sourceEventId = payload.sourceEventId;
      const exists = eventsBefore.some((e) => e?.type === "RISK_SCORED" && e.payload?.basis === basis && e.payload?.sourceEventId === sourceEventId);
      if (exists) throw new TypeError("risk already scored for this source event");

      const expectedTemplateId = jobBefore.templateId ?? null;
      if (expectedTemplateId && payload.features?.templateId !== expectedTemplateId) {
        throw new TypeError("payload.features.templateId must match job.templateId");
      }

      if (basis === RISK_BASIS.QUOTE) {
        if (!jobBefore.quote) throw new TypeError("risk scoring requires a quote");
        if (jobBefore.status !== "QUOTED") throw new TypeError("risk scoring (QUOTE) requires QUOTED status");

        const expectedEnvTier = jobBefore.quote?.inputs?.environmentTier ?? null;
        if (expectedEnvTier && payload.features?.environmentTier !== expectedEnvTier) {
          throw new TypeError("payload.features.environmentTier must match quote environmentTier");
        }
        const expectedCoverage = jobBefore.quote?.inputs?.requiresOperatorCoverage;
        if (typeof expectedCoverage === "boolean" && payload.features?.requiresOperatorCoverage !== expectedCoverage) {
          throw new TypeError("payload.features.requiresOperatorCoverage must match quote requiresOperatorCoverage");
        }
        const expectedZoneId = jobBefore.quote?.inputs?.zoneId ?? null;
        if (expectedZoneId && payload.features?.zoneId !== expectedZoneId) {
          throw new TypeError("payload.features.zoneId must match quote zoneId");
        }
        const expectedSiteId = jobBefore.quote?.inputs?.siteId ?? null;
        if (expectedSiteId && payload.features?.siteId !== expectedSiteId) {
          throw new TypeError("payload.features.siteId must match quote siteId");
        }

        let lastQuoteEventId = null;
        for (let i = eventsBefore.length - 1; i >= 0; i -= 1) {
          const e = eventsBefore[i];
          if (e?.type === "QUOTE_PROPOSED") {
            lastQuoteEventId = e.id ?? null;
            break;
          }
        }
        if (!lastQuoteEventId) throw new TypeError("risk scoring requires a prior QUOTE_PROPOSED event");
        if (sourceEventId !== lastQuoteEventId) throw new TypeError("payload.sourceEventId must match last QUOTE_PROPOSED event id");
      }

      if (basis === RISK_BASIS.BOOK) {
        if (!jobBefore.booking) throw new TypeError("risk scoring (BOOK) requires a booking");
        if (jobBefore.status !== "BOOKED") throw new TypeError("risk scoring (BOOK) requires BOOKED status");

        const expectedEnvTier = jobBefore.booking?.environmentTier ?? null;
        if (expectedEnvTier && payload.features?.environmentTier !== expectedEnvTier) {
          throw new TypeError("payload.features.environmentTier must match booking environmentTier");
        }
        const expectedCoverage = jobBefore.booking?.requiresOperatorCoverage;
        if (typeof expectedCoverage === "boolean" && payload.features?.requiresOperatorCoverage !== expectedCoverage) {
          throw new TypeError("payload.features.requiresOperatorCoverage must match booking requiresOperatorCoverage");
        }
        const expectedZoneId = jobBefore.booking?.zoneId ?? null;
        if (expectedZoneId && payload.features?.zoneId !== expectedZoneId) {
          throw new TypeError("payload.features.zoneId must match booking zoneId");
        }
        const expectedSiteId = jobBefore.booking?.siteId ?? null;
        if (expectedSiteId && payload.features?.siteId !== expectedSiteId) {
          throw new TypeError("payload.features.siteId must match booking siteId");
        }
        const expectedPolicyHash = jobBefore.booking?.policyHash ?? null;
        if (expectedPolicyHash && payload.policyHash !== expectedPolicyHash) {
          throw new TypeError("payload.policyHash must match booking.policyHash");
        }

        let lastBookedEventId = null;
        for (let i = eventsBefore.length - 1; i >= 0; i -= 1) {
          const e = eventsBefore[i];
          if (e?.type === "BOOKED") {
            lastBookedEventId = e.id ?? null;
            break;
          }
        }
        if (!lastBookedEventId) throw new TypeError("risk scoring requires a prior BOOKED event");
        if (sourceEventId !== lastBookedEventId) throw new TypeError("payload.sourceEventId must match last BOOKED event id");
      }
    }

    // Dispatch
    if (type === "DISPATCH_REQUESTED") {
      validateDispatchRequestedPayload(payload ?? {});
      assertJobPayloadId(payload.jobId, jobBefore.id);
      if (payload.requestedAt !== event.at) throw new TypeError("payload.requestedAt must match event.at");
      if (!jobBefore.booking) throw new TypeError("dispatch requires a booking");
      if (jobBefore.status !== "BOOKED") throw new TypeError("dispatch can only be requested from BOOKED");
    }

    if (type === "DISPATCH_EVALUATED") {
      validateDispatchEvaluatedPayload(payload ?? {});
      assertJobPayloadId(payload.jobId, jobBefore.id);
      if (payload.evaluatedAt !== event.at) throw new TypeError("payload.evaluatedAt must match event.at");
      if (!jobBefore.booking) throw new TypeError("dispatch evaluation requires a booking");
      if (jobBefore.status !== "BOOKED") throw new TypeError("dispatch evaluation requires BOOKED status");
    }

    if (type === "DISPATCH_CONFIRMED") {
      validateDispatchConfirmedPayload(payload ?? {});
      assertJobPayloadId(payload.jobId, jobBefore.id);
      if (payload.confirmedAt !== event.at) throw new TypeError("payload.confirmedAt must match event.at");
      if (!jobBefore.reservation) throw new TypeError("dispatch confirmation requires a robot reservation");
      if (jobBefore.booking?.requiresOperatorCoverage && jobBefore.operatorCoverage?.status !== "reserved") {
        throw new TypeError("dispatch confirmation requires operator coverage reservation");
      }
    }

    if (type === "DISPATCH_FAILED") {
      validateDispatchFailedPayload(payload ?? {});
      assertJobPayloadId(payload.jobId, jobBefore.id);
      if (payload.failedAt !== event.at) throw new TypeError("payload.failedAt must match event.at");
      if (!jobBefore.booking) throw new TypeError("dispatch failure requires a booking");
      if (jobBefore.status !== "BOOKED") throw new TypeError("dispatch failure requires BOOKED status");
    }

	    if (type === "MATCHED") {
	      if (!payload || typeof payload !== "object") throw new TypeError("payload is required");
	      const robotId = payload.robotId;
	      assertNonEmptyString(robotId, "payload.robotId");
	      if (!jobBefore.booking) throw new TypeError("cannot match before booking");
	      const robot = store.robots.get(robotStoreKey(jobTenantId, robotId));
	      if (!robot) throw new TypeError("unknown robotId");
	      if (robot.status && robot.status !== "active") throw new TypeError("robot is not active");
	      if (jobBefore.booking) {
	        const jobZoneId = normalizeZoneId(jobBefore.booking.zoneId ?? jobBefore.constraints?.zoneId);
	        const robotZoneId = normalizeZoneId(robot.currentZoneId ?? robot.homeZoneId);
	        if (robotZoneId !== jobZoneId) throw new TypeError("robot is not in the job zone");
	      }

	      const operatorContractHash = payload.operatorContractHash ?? null;
	      const operatorPolicyHash = payload.operatorPolicyHash ?? null;
	      const operatorCompilerId = payload.operatorCompilerId ?? null;
	      if (operatorContractHash !== null || operatorPolicyHash !== null || operatorCompilerId !== null) {
	        if (operatorContractHash === null || operatorPolicyHash === null) {
	          throw new TypeError("payload.operatorContractHash and payload.operatorPolicyHash must be provided together");
	        }
	        if (typeof operatorContractHash !== "string" || !/^[a-f0-9]{64}$/i.test(operatorContractHash)) {
	          throw new TypeError("payload.operatorContractHash must be a 64-byte hex sha256");
	        }
	        if (typeof operatorPolicyHash !== "string" || !/^[a-f0-9]{64}$/i.test(operatorPolicyHash)) {
	          throw new TypeError("payload.operatorPolicyHash must be a 64-byte hex sha256");
	        }
	        if (operatorCompilerId !== null) {
	          if (typeof operatorCompilerId !== "string" || operatorCompilerId.trim() === "") {
	            throw new TypeError("payload.operatorCompilerId must be a non-empty string");
	          }
	        }
	      }
	    }

    if (type === "RESERVED") {
      validateReservedPayload(payload ?? {});
      assertNotTerminal(jobBefore);
      const robotId = payload.robotId;

      const booked = jobBefore.booking;
      if (!booked) throw new TypeError("cannot reserve robot before booking");
      if (Date.parse(payload.startAt) < Date.parse(booked.startAt) || Date.parse(payload.endAt) > Date.parse(booked.endAt)) {
        throw new TypeError("reservation window must be within booked window");
      }

      const matchedRobotId = jobBefore.match?.robotId ?? null;
      if (matchedRobotId && matchedRobotId !== robotId) {
        throw new TypeError("reservation robotId must match matched robotId");
      }

      const robot = store.robots.get(robotStoreKey(jobTenantId, robotId));
      if (!robot) throw new TypeError("unknown robotId");
      if (!robotIsAvailableForWindow(robot, { startAt: payload.startAt, endAt: payload.endAt })) {
        throw new TypeError("robot is not available for reservation window");
      }

      for (const other of store.jobs.values()) {
        if (!other?.id || other.id === jobBefore.id) continue;
        const otherTenant = normalizeTenant(other.tenantId ?? DEFAULT_TENANT_ID);
        if (otherTenant !== jobTenantId) continue;
        const resv = other.reservation;
        if (!resv || resv.robotId !== robotId) continue;
        if (other.status === "ABORTED" || other.status === "SETTLED") continue;
        if (bookingWindowsOverlap(resv, payload)) {
          throw new TypeError("robot is already reserved for an overlapping window");
        }
      }
    }

    if (type === "OPERATOR_COVERAGE_RESERVED") {
      validateOperatorCoverageReservedPayload(payload ?? {});
      assertJobPayloadId(payload.jobId, jobBefore.id);
      assertNotTerminal(jobBefore);

      if (!jobBefore.booking) throw new TypeError("operator coverage requires a booking");
      if (jobBefore.booking.requiresOperatorCoverage !== true) throw new TypeError("operator coverage reservation is not required for this job");
      if (jobBefore.status !== "RESERVED") throw new TypeError("operator coverage reservation requires RESERVED status");
      if (!jobBefore.reservation) throw new TypeError("operator coverage reservation requires a robot reservation");

      if (payload.startAt !== jobBefore.reservation.startAt || payload.endAt !== jobBefore.reservation.endAt) {
        throw new TypeError("operator coverage window must match robot reservation window");
      }

      const operatorId = payload.operatorId;
      const operator = store.operators.get(operatorStoreKey(jobTenantId, operatorId));
      if (!operator) throw new TypeError("unknown operatorId");
      if (operator.shift?.status !== "open") throw new TypeError("operator is not on shift");

      const jobZoneId = normalizeZoneId(jobBefore.booking.zoneId ?? jobBefore.constraints?.zoneId);
      const operatorZoneId = normalizeZoneId(operator.shift?.zoneId);
      if (operatorZoneId !== jobZoneId) throw new TypeError("operator is not on shift for the job zone");

      const window = { startAt: payload.startAt, endAt: payload.endAt };
      const maxConcurrentJobs = operator.shift?.maxConcurrentJobs ?? 1;
      let activeCoverageCount = 0;
      for (const other of store.jobs.values()) {
        if (!other?.id || other.id === jobBefore.id) continue;
        const otherTenant = normalizeTenant(other.tenantId ?? DEFAULT_TENANT_ID);
        if (otherTenant !== jobTenantId) continue;
        if (other.status === "ABORTED" || other.status === "SETTLED") continue;
        const cov = other.operatorCoverage;
        if (!cov || cov.status !== "reserved") continue;
        if (cov.operatorId !== operatorId) continue;
        if (bookingWindowsOverlap({ startAt: cov.startAt, endAt: cov.endAt }, window)) activeCoverageCount += 1;
      }
      if (activeCoverageCount >= maxConcurrentJobs) throw new TypeError("operator has no remaining coverage capacity for this window");
    }

    if (type === "OPERATOR_COVERAGE_RELEASED") {
      validateOperatorCoverageReleasedPayload(payload ?? {});
      assertJobPayloadId(payload.jobId, jobBefore.id);
      if (payload.releasedAt !== event.at) throw new TypeError("payload.releasedAt must match event.at");
      if (jobBefore.operatorCoverage?.reservationId !== payload.reservationId) {
        throw new TypeError("operator coverage release reservationId does not match current reservation");
      }
    }

    if (type === "SKILL_LICENSED") {
      validateSkillLicensedPayload(payload);
      assertJobPayloadId(payload.jobId, jobBefore.id);
      assertNotTerminal(jobBefore);
      if (jobBefore.status === "EXECUTING" || jobBefore.status === "ASSISTED") {
        throw new TypeError("cannot license skills after execution start");
      }
      const licenseId = payload.licenseId;
      if (jobBefore.skillLicenses.some((l) => l.licenseId === licenseId)) {
        throw new TypeError("licenseId already exists for this job");
      }
    }

    if (type === "SKILL_USED") {
      validateSkillUsedPayload(payload);
      assertJobPayloadId(payload.jobId, jobBefore.id);
      if (jobBefore.status !== "EXECUTING" && jobBefore.status !== "ASSISTED") {
        throw new TypeError("skill usage is only allowed during execution");
      }
      const licenseId = payload.licenseId;
      const license = jobBefore.skillLicenses.find((l) => l.licenseId === licenseId);
      if (!license) throw new TypeError("skill used without license");
    }

    // Rescheduling
    if (type === "JOB_RESCHEDULED") {
      validateJobRescheduledPayload(payload ?? {});
      assertJobPayloadId(payload.jobId, jobBefore.id);

      const allowedStatuses = new Set(["BOOKED", "MATCHED", "RESERVED"]);
      if (!allowedStatuses.has(jobBefore.status)) throw new TypeError("job is not reschedulable");
      if (!jobBefore.booking) throw new TypeError("job booking is required for reschedule");

      if (jobBefore.booking.startAt !== payload.oldWindow.startAt || jobBefore.booking.endAt !== payload.oldWindow.endAt) {
        throw new TypeError("payload.oldWindow must match current booking window");
      }

      if (payload.requiresRequote === true) {
        throw new TypeError("requiresRequote is not supported in v0.6");
      }
    }

    // Cancellation
    if (type === "JOB_CANCELLED") {
      validateJobCancelledPayload(payload ?? {});
      assertJobPayloadId(payload.jobId, jobBefore.id);
      if (payload.cancelledAt !== event.at) throw new TypeError("payload.cancelledAt must match event.at");
      assertNotTerminal(jobBefore);
    }

    // Incidents
    if (type === "INCIDENT_REPORTED") {
      validateIncidentReportedPayload(payload);
      assertJobPayloadId(payload.jobId, jobBefore.id);
      if (jobBefore.status === "CREATED" || jobBefore.status === "QUOTED") {
        throw new TypeError("cannot report incident before job is booked");
      }
      if (incidentIdExists(payload.incidentId)) throw new TypeError("incidentId already exists for this job");
      if (event.actor.type !== "operator" && payload.reportedBy === undefined) {
        throw new TypeError("payload.reportedBy is required for server-side incident reports");
      }
    }

    if (type === "INCIDENT_DETECTED") {
      validateIncidentDetectedPayload(payload);
      assertJobPayloadId(payload.jobId, jobBefore.id);
      const allowedStatuses = new Set(["EN_ROUTE", "ACCESS_GRANTED", "EXECUTING", "ASSISTED", "ABORTING_SAFE_EXIT"]);
      if (!allowedStatuses.has(jobBefore.status)) throw new TypeError("incident detection is only allowed once the job is en route");
      if (incidentIdExists(payload.incidentId)) throw new TypeError("incidentId already exists for this job");
    }

    // Evidence
    if (type === "EVIDENCE_CAPTURED") {
      validateEvidenceCapturedPayload(payload);
      assertJobPayloadId(payload.jobId, jobBefore.id);
      if (!incidentIdExists(payload.incidentId)) throw new TypeError("evidence must reference an existing incidentId");
      const exists = eventsBefore.some((e) => e.type === "EVIDENCE_CAPTURED" && e.payload?.evidenceId === payload.evidenceId);
      if (exists) throw new TypeError("evidenceId already exists for this job");

      const privacyMode = jobBefore.constraints?.privacyMode ?? null;
      if (privacyMode === "minimal" && payload.kind === "VIDEO_CLIP") {
        const incident = findIncidentById(payload.incidentId);
        const sev = incident?.severity ?? null;
        if (!Number.isSafeInteger(sev) || sev < 4) {
          throw new TypeError("video evidence is not allowed in privacyMode=minimal unless incident severity >= 4");
        }
      }

      if (evidenceContentTypeAllowlist) {
        const ct = payload.contentType ?? null;
        if (typeof ct !== "string" || ct.trim() === "" || !evidenceContentTypeAllowlist.has(ct)) {
          const err = new Error("evidence contentType is not allowed");
          err.code = "EVIDENCE_CONTENT_TYPE_FORBIDDEN";
          throw err;
        }
      }

      if (evidenceRequireSizeBytes && (payload.sizeBytes === null || payload.sizeBytes === undefined)) {
        const err = new Error("payload.sizeBytes is required");
        err.code = "EVIDENCE_SIZE_REQUIRED";
        throw err;
      }

      if (Number.isSafeInteger(evidenceMaxSizeBytes) && evidenceMaxSizeBytes > 0 && Number.isSafeInteger(payload.sizeBytes) && payload.sizeBytes > evidenceMaxSizeBytes) {
        const err = new Error("payload.sizeBytes exceeds maximum");
        err.code = "EVIDENCE_TOO_LARGE";
        throw err;
      }

      const cfg = getTenantConfig(jobTenantId) ?? {};
      const requestedLimit = cfg?.quotas?.maxEvidenceRefsPerJob ?? 0;
      const limit = clampQuota({ tenantLimit: Number.isSafeInteger(requestedLimit) ? requestedLimit : 0, defaultLimit: 0, maxLimit: quotaPlatformMaxEvidenceRefsPerJob });
      if (limit > 0) {
        const evidence = Array.isArray(jobBefore.evidence) ? jobBefore.evidence : [];
        const activeCount = evidence.filter((e) => e && typeof e === "object" && !e.expiredAt).length;
        if (isQuotaExceeded({ current: activeCount, limit })) {
          const err = new Error("tenant quota exceeded");
          err.code = "TENANT_QUOTA_EXCEEDED";
          err.quota = { kind: "evidence_refs_per_job", limit, current: activeCount };
          throw err;
        }
      }
    }

    if (type === "EVIDENCE_VIEWED") {
      validateEvidenceViewedPayload(payload);
      assertJobPayloadId(payload.jobId, jobBefore.id);
      if (payload.viewedAt !== event.at) throw new TypeError("payload.viewedAt must match event.at");

      const captured = eventsBefore.find((e) => e.type === "EVIDENCE_CAPTURED" && e.payload?.evidenceId === payload.evidenceId) ?? null;
      if (!captured) throw new TypeError("evidenceId not found for this job");
      if ((captured.payload?.evidenceRef ?? null) !== payload.evidenceRef) {
        throw new TypeError("payload.evidenceRef does not match captured evidenceRef");
      }
    }

    if (type === "EVIDENCE_EXPIRED") {
      validateEvidenceExpiredPayload(payload);
      assertJobPayloadId(payload.jobId, jobBefore.id);
      if (payload.expiredAt !== event.at) throw new TypeError("payload.expiredAt must match event.at");

      const captured = eventsBefore.find((e) => e.type === "EVIDENCE_CAPTURED" && e.payload?.evidenceId === payload.evidenceId) ?? null;
      if (!captured) throw new TypeError("evidenceId not found for this job");
      if ((captured.payload?.evidenceRef ?? null) !== payload.evidenceRef) {
        throw new TypeError("payload.evidenceRef does not match captured evidenceRef");
      }

      const already = eventsBefore.some((e) => e.type === "EVIDENCE_EXPIRED" && e.payload?.evidenceId === payload.evidenceId);
      if (already) throw new TypeError("evidence already expired");

      const expectedPolicyHash = jobBefore.booking?.policyHash ?? null;
      if (expectedPolicyHash && payload.policyHash !== expectedPolicyHash) {
        throw new TypeError("payload.policyHash must match booking.policyHash");
      }
    }

    // Claims
    if (type === "CLAIM_OPENED") {
      validateClaimOpenedPayload(payload);
      assertJobPayloadId(payload.jobId, jobBefore.id);
      if (jobBefore.status === "CREATED" || jobBefore.status === "QUOTED") {
        throw new TypeError("cannot open claim before job is booked");
      }
      if (!incidentIdExists(payload.incidentId)) throw new TypeError("claim must reference an existing incidentId");
      const openedAlready = eventsBefore.some((e) => e.type === "CLAIM_OPENED" && e.payload?.claimId === payload.claimId);
      if (openedAlready) throw new TypeError("claimId already exists for this job");
    }

    if (type === "CLAIM_TRIAGED") {
      validateClaimTriagedPayload(payload);
      assertJobPayloadId(payload.jobId, jobBefore.id);
      const claim = getClaimState(payload.claimId);
      if (!claim.exists) throw new TypeError("unknown claimId");
      if (claim.status === "APPROVED" || claim.status === "DENIED" || claim.status === "PAID") {
        throw new TypeError("cannot triage a decided claim");
      }
    }

    if (type === "CLAIM_APPROVED") {
      validateClaimApprovedPayload(payload);
      assertJobPayloadId(payload.jobId, jobBefore.id);
      const claim = getClaimState(payload.claimId);
      if (!claim.exists) throw new TypeError("unknown claimId");
      if (claim.status === "APPROVED" || claim.status === "DENIED" || claim.status === "PAID") {
        throw new TypeError("claim is already decided");
      }

      if (jobBefore.status !== "COMPLETED" && jobBefore.status !== "ABORTED" && jobBefore.status !== "SETTLED") {
        throw new TypeError("claim approval is only allowed after the job is completed/aborted");
      }

      const incidentId = claim.incidentId;
      if (!incidentId) throw new TypeError("claim is missing incidentId");
      const incident = findIncidentById(incidentId);
      if (!incident) throw new TypeError("claim incidentId not found");
      const requiresExecution = incident.type !== "ACCESS_FAILURE";
      if (requiresExecution && !eventsBefore.some((e) => e.type === "EXECUTION_STARTED" || e.type === "JOB_EXECUTION_STARTED")) {
        throw new TypeError("cannot approve claim: job never reached execution");
      }

      const payoutCents = payload.amounts?.payoutCents ?? 0;
      const refundCents = payload.amounts?.refundCents ?? 0;
      const total = computeClaimTotalCents({ payoutCents, refundCents });
      const maxAutoApproveCents = 10_000;
      const isElevated = event.actor?.type === "system" && event.actor?.id === "proxy_admin";
      if (total > maxAutoApproveCents && !isElevated) throw new TypeError("claim approval exceeds policy max without elevated actor");

      if (refundCents) {
        const jobAmount = jobBefore.quote?.amountCents;
        if (!Number.isSafeInteger(jobAmount) || jobAmount <= 0) throw new TypeError("job quote is required for refund adjustments");
        if (refundCents > jobAmount) throw new TypeError("refundCents exceeds job amount");
      }
    }

    if (type === "CLAIM_DENIED") {
      validateClaimDeniedPayload(payload);
      assertJobPayloadId(payload.jobId, jobBefore.id);
      const claim = getClaimState(payload.claimId);
      if (!claim.exists) throw new TypeError("unknown claimId");
      if (claim.status === "APPROVED" || claim.status === "DENIED" || claim.status === "PAID") {
        throw new TypeError("claim is already decided");
      }
      if (jobBefore.status !== "COMPLETED" && jobBefore.status !== "ABORTED" && jobBefore.status !== "SETTLED") {
        throw new TypeError("claim denial is only allowed after the job is completed/aborted");
      }
    }

    if (type === "JOB_ADJUSTED") {
      validateJobAdjustedPayload(payload);
      assertJobPayloadId(payload.jobId, jobBefore.id);
      const claim = getClaimState(payload.claimId);
      if (!claim.exists) throw new TypeError("unknown claimId");
      if (claim.status !== "APPROVED") throw new TypeError("job adjustment requires an approved claim");
      if (claim.adjusted) throw new TypeError("claim is already adjusted");
      if (jobBefore.status !== "SETTLED") throw new TypeError("job adjustment is only allowed after settlement");
    }

    if (type === "CLAIM_PAID") {
      validateClaimPaidPayload(payload);
      assertJobPayloadId(payload.jobId, jobBefore.id);
      const claim = getClaimState(payload.claimId);
      if (!claim.exists) throw new TypeError("unknown claimId");
      if (claim.status !== "APPROVED") throw new TypeError("claim must be approved before it can be paid");
      if (!claim.adjusted) throw new TypeError("claim must be adjusted before it can be paid");
      const approvedAmounts = claim.approved?.amounts ?? null;
      const payoutCents = approvedAmounts?.payoutCents ?? 0;
      const refundCents = approvedAmounts?.refundCents ?? 0;
      const expected = computeClaimTotalCents({ payoutCents, refundCents });
      if (payload.amountCents !== expected) throw new TypeError("payload.amountCents must equal approved total");
    }

    // Execution gating
    if (type === "EXECUTION_STARTED" || type === "JOB_EXECUTION_STARTED") {
      if (type === "JOB_EXECUTION_STARTED") {
        validateJobExecutionStartedPayload(payload ?? {});
        assertJobPayloadId(payload.jobId, jobBefore.id);
        if (payload.startedAt !== event.at) throw new TypeError("payload.startedAt must match event.at");
        if (event.actor.type === "robot" && payload.robotId !== event.actor.id) {
          throw new TypeError("payload.robotId must match event.actor.id");
        }
      }

      const plan = jobBefore.accessPlan;
      if (!plan) throw new TypeError("cannot start execution without an access plan");
      if (jobBefore.access.status !== "granted") throw new TypeError("cannot start execution without access granted");
      if (!isWithinAccessWindow({ at: event.at, validFrom: plan.validFrom, validTo: plan.validTo })) {
        throw new TypeError("execution start is outside access plan window");
      }
    }

    if (type === "JOB_HEARTBEAT") {
      validateJobHeartbeatPayload(payload ?? {});
      assertJobPayloadId(payload.jobId, jobBefore.id);
      if (payload.t !== event.at) throw new TypeError("payload.t must match event.at");
      if (event.actor.type !== "robot") throw new TypeError("job heartbeat requires actor.type=robot");
      if (payload.robotId !== event.actor.id) throw new TypeError("payload.robotId must match event.actor.id");

      const allowedStatuses = new Set(["EXECUTING", "ASSISTED", "STALLED", "ABORTING_SAFE_EXIT"]);
      if (!allowedStatuses.has(jobBefore.status)) throw new TypeError("job heartbeat is only allowed during execution/safe-exit");

      const expectedRobotId = jobBefore.reservation?.robotId ?? jobBefore.match?.robotId ?? jobBefore.execution?.robotId ?? null;
      if (expectedRobotId && expectedRobotId !== event.actor.id) throw new TypeError("heartbeat rejected: robotId does not match job robotId");
    }

    if (type === "JOB_EXECUTION_STALLED") {
      validateJobExecutionStalledPayload(payload ?? {});
      assertJobPayloadId(payload.jobId, jobBefore.id);
      if (payload.detectedAt !== event.at) throw new TypeError("payload.detectedAt must match event.at");

      const allowedStatuses = new Set(["EXECUTING", "ASSISTED"]);
      if (!allowedStatuses.has(jobBefore.status)) throw new TypeError("stall is only allowed during execution");

      const { heartbeatIntervalMs, stallAfterMs } = computeLivenessPolicy({ environmentTier: jobBefore.booking?.environmentTier });
      if (payload.policy?.heartbeatIntervalMs !== heartbeatIntervalMs) throw new TypeError("payload.policy.heartbeatIntervalMs mismatch");
      if (payload.policy?.stallAfterMs !== stallAfterMs) throw new TypeError("payload.policy.stallAfterMs mismatch");

      const startedAt = jobBefore.execution?.startedAt ?? null;
      if (!startedAt) throw new TypeError("stall requires execution startedAt");
      const lastHeartbeatAt = jobBefore.execution?.lastHeartbeatAt ?? startedAt;
      if (payload.lastHeartbeatAt !== lastHeartbeatAt) throw new TypeError("payload.lastHeartbeatAt must match projected last heartbeat");

      const nowMs = Date.parse(event.at);
      const lastMs = Date.parse(lastHeartbeatAt);
      if (!Number.isFinite(nowMs) || !Number.isFinite(lastMs)) throw new TypeError("stall timing is invalid");
      if (nowMs - lastMs <= stallAfterMs) throw new TypeError("stall rejected: heartbeat is not past stall threshold");

      const expectedRobotId = jobBefore.execution?.robotId ?? jobBefore.reservation?.robotId ?? null;
      if (expectedRobotId && payload.robotId !== expectedRobotId) throw new TypeError("payload.robotId must match execution robotId");
    }

    if (type === "JOB_EXECUTION_RESUMED") {
      validateJobExecutionResumedPayload(payload ?? {});
      assertJobPayloadId(payload.jobId, jobBefore.id);
      if (payload.resumedAt !== event.at) throw new TypeError("payload.resumedAt must match event.at");

      if (jobBefore.status !== "STALLED") throw new TypeError("resume is only allowed from STALLED");
      const expectedRobotId = jobBefore.execution?.robotId ?? jobBefore.reservation?.robotId ?? null;
      if (expectedRobotId && payload.robotId !== expectedRobotId) throw new TypeError("payload.robotId must match execution robotId");

      if (event.actor.type === "robot" && payload.robotId !== event.actor.id) {
        throw new TypeError("payload.robotId must match event.actor.id");
      }

      // If the server resumes a job, require evidence the robot is alive again.
      if (event.actor.type !== "robot") {
        const stalledAt = jobBefore.execution?.stalledAt ?? null;
        const lastHeartbeatAt = jobBefore.execution?.lastHeartbeatAt ?? null;
        if (!stalledAt) throw new TypeError("server resume requires execution.stalledAt");
        if (!lastHeartbeatAt) throw new TypeError("server resume requires a heartbeat");
        if (Date.parse(lastHeartbeatAt) <= Date.parse(stalledAt)) {
          throw new TypeError("server resume requires heartbeat after stall");
        }
      }
    }

    if (type === "JOB_EXECUTION_ABORTED") {
      validateJobExecutionAbortedPayload(payload ?? {});
      assertJobPayloadId(payload.jobId, jobBefore.id);
      if (payload.abortedAt !== event.at) throw new TypeError("payload.abortedAt must match event.at");

      const expectedRobotId = jobBefore.execution?.robotId ?? jobBefore.reservation?.robotId ?? null;
      if (expectedRobotId && payload.robotId !== expectedRobotId) throw new TypeError("payload.robotId must match execution robotId");
      if (event.actor.type === "robot" && payload.robotId !== event.actor.id) {
        throw new TypeError("payload.robotId must match event.actor.id");
      }
    }

    // Assist queue
    if (type === "ASSIST_REQUESTED") {
      validateAssistRequestedPayload(payload ?? {});
      assertJobPayloadId(payload.jobId, jobBefore.id);
      if (payload.requestedAt !== event.at) throw new TypeError("payload.requestedAt must match event.at");
      if (event.actor.type !== "robot") throw new TypeError("assist requests require actor.type=robot");
      if (payload.robotId !== event.actor.id) throw new TypeError("payload.robotId must match event.actor.id");
      const allowedStatuses = new Set(["EXECUTING", "ASSISTED", "STALLED"]);
      if (!allowedStatuses.has(jobBefore.status)) throw new TypeError("assist requests are only allowed during execution/stall");
    }

    if (type === "ASSIST_QUEUED") {
      validateAssistQueuedPayload(payload ?? {});
      assertJobPayloadId(payload.jobId, jobBefore.id);
      if (payload.queuedAt !== event.at) throw new TypeError("payload.queuedAt must match event.at");
    }

    if (type === "ASSIST_ASSIGNED") {
      validateAssistAssignedPayload(payload ?? {});
      assertJobPayloadId(payload.jobId, jobBefore.id);
      if (payload.assignedAt !== event.at) throw new TypeError("payload.assignedAt must match event.at");
      const operator = store.operators.get(operatorStoreKey(jobTenantId, payload.operatorId));
      if (!operator) throw new TypeError("unknown operatorId");
      if (operator.shift?.status !== "open") throw new TypeError("operator is not on shift");
    }

    if (type === "ASSIST_ACCEPTED") {
      validateAssistAcceptedPayload(payload ?? {});
      assertJobPayloadId(payload.jobId, jobBefore.id);
      if (payload.acceptedAt !== event.at) throw new TypeError("payload.acceptedAt must match event.at");
      if (event.actor.type !== "operator") throw new TypeError("assist accepted requires actor.type=operator");
      if (payload.operatorId !== event.actor.id) throw new TypeError("payload.operatorId must match event.actor.id");
    }

    if (type === "ASSIST_DECLINED") {
      validateAssistDeclinedPayload(payload ?? {});
      assertJobPayloadId(payload.jobId, jobBefore.id);
      if (payload.declinedAt !== event.at) throw new TypeError("payload.declinedAt must match event.at");
      if (event.actor.type !== "operator") throw new TypeError("assist declined requires actor.type=operator");
      if (payload.operatorId !== event.actor.id) throw new TypeError("payload.operatorId must match event.actor.id");
    }

    if (type === "ASSIST_TIMEOUT") {
      validateAssistTimeoutPayload(payload ?? {});
      assertJobPayloadId(payload.jobId, jobBefore.id);
      if (payload.timedOutAt !== event.at) throw new TypeError("payload.timedOutAt must match event.at");
    }

    if (type === "CHECKPOINT_REACHED") {
      if (jobBefore.status !== "EXECUTING" && jobBefore.status !== "ASSISTED") {
        throw new TypeError("checkpoint is only allowed during execution");
      }
      if (jobBefore.access.status === "revoked" || jobBefore.access.status === "expired") {
        throw new TypeError("checkpoint rejected: access is revoked/expired");
      }
    }

    if (type === "EXECUTION_COMPLETED" || type === "JOB_EXECUTION_COMPLETED") {
      if (type === "JOB_EXECUTION_COMPLETED") {
        validateJobExecutionCompletedPayload(payload ?? {});
        assertJobPayloadId(payload.jobId, jobBefore.id);
        if (payload.completedAt !== event.at) throw new TypeError("payload.completedAt must match event.at");
        if (event.actor.type === "robot" && payload.robotId !== event.actor.id) {
          throw new TypeError("payload.robotId must match event.actor.id");
        }
      }
      if (jobBefore.access.status === "revoked" || jobBefore.access.status === "expired") {
        throw new TypeError("cannot complete execution after access is revoked/expired");
      }
    }

    if (jobBefore.status === "ABORTING_SAFE_EXIT") {
      const forbiddenDuringSafeExit = new Set(["CHECKPOINT_REACHED", "SKILL_USED", "SKILL_METER_REPORTED", "EXECUTION_COMPLETED", "JOB_EXECUTION_COMPLETED"]);
      if (forbiddenDuringSafeExit.has(type)) {
        throw new TypeError("event rejected during safe-exit");
      }
    }

    const getLastSettledEventId = () => {
      for (let i = eventsBefore.length - 1; i >= 0; i -= 1) {
        const e = eventsBefore[i];
        if (e?.type === "SETTLED") return e.id ?? null;
      }
      return null;
    };

    // Operator cost + SLA (v0.8.1 / v0.8.2)
    if (type === "OPERATOR_COST_RECORDED") {
      validateOperatorCostRecordedPayload(payload ?? {});
      assertJobPayloadId(payload.jobId, jobBefore.id);
      if (jobBefore.status !== "SETTLED") throw new TypeError("operator cost can only be recorded after settlement");

      const lastSettledEventId = getLastSettledEventId();
      if (!lastSettledEventId) throw new TypeError("operator cost requires prior SETTLED event");
      if (payload.settledEventId !== lastSettledEventId) throw new TypeError("payload.settledEventId must match last SETTLED event id");

      const already = eventsBefore.some((e) => e.type === "OPERATOR_COST_RECORDED" && e.payload?.settledEventId === payload.settledEventId);
      if (already) throw new TypeError("operator cost already recorded for this settlement");

      const expectedZoneId = normalizeZoneId(jobBefore.booking?.zoneId ?? jobBefore.constraints?.zoneId);
      if (payload.zoneId !== null && payload.zoneId !== undefined && normalizeZoneId(payload.zoneId) !== expectedZoneId) {
        throw new TypeError("payload.zoneId must match job zone");
      }
    }

    if (type === "SLA_BREACH_DETECTED") {
      validateSlaBreachDetectedPayload(payload ?? {});
      assertJobPayloadId(payload.jobId, jobBefore.id);
      if (jobBefore.status !== "SETTLED") throw new TypeError("SLA breach detection can only be recorded after settlement");
      if (payload.detectedAt !== event.at) throw new TypeError("payload.detectedAt must match event.at");

      const lastSettledEventId = getLastSettledEventId();
      if (!lastSettledEventId) throw new TypeError("SLA breach requires prior SETTLED event");
      if (payload.settledEventId !== lastSettledEventId) throw new TypeError("payload.settledEventId must match last SETTLED event id");

      const already = eventsBefore.some((e) => e.type === "SLA_BREACH_DETECTED" && e.payload?.settledEventId === payload.settledEventId);
      if (already) throw new TypeError("SLA breach already recorded for this settlement");

      const booking = jobBefore.booking;
      if (!booking) throw new TypeError("SLA breach requires a booking");
      if (payload.window.startAt !== booking.startAt || payload.window.endAt !== booking.endAt) {
        throw new TypeError("payload.window must match booking window");
      }
      const expectedPolicy = booking.sla ?? null;
      if (!expectedPolicy) throw new TypeError("SLA breach requires booking.sla");
      if (canonicalJsonStringify(payload.policy) !== canonicalJsonStringify(expectedPolicy)) {
        throw new TypeError("payload.policy must match booking.sla");
      }
      const expectedPolicyHash = booking.policyHash ?? null;
      if (expectedPolicyHash && payload.policyHash !== expectedPolicyHash) {
        throw new TypeError("payload.policyHash must match booking.policyHash");
      }
    }

    if (type === "SLA_CREDIT_ISSUED") {
      validateSlaCreditIssuedPayload(payload ?? {});
      assertJobPayloadId(payload.jobId, jobBefore.id);
      if (jobBefore.status !== "SETTLED") throw new TypeError("SLA credit can only be issued after settlement");
      if (payload.issuedAt !== event.at) throw new TypeError("payload.issuedAt must match event.at");

      const creditPolicy = jobBefore.booking?.creditPolicy ?? null;
      const enabled = creditPolicy?.enabled === true;
      if (!enabled) throw new TypeError("SLA credits are disabled");

      const lastSettledEventId = getLastSettledEventId();
      if (!lastSettledEventId) throw new TypeError("SLA credit requires prior SETTLED event");
      if (payload.settledEventId !== lastSettledEventId) throw new TypeError("payload.settledEventId must match last SETTLED event id");

      const hasBreach = eventsBefore.some((e) => e.type === "SLA_BREACH_DETECTED" && e.payload?.settledEventId === payload.settledEventId);
      if (!hasBreach) throw new TypeError("SLA credit requires a recorded SLA breach");

      const exists = eventsBefore.some((e) => e.type === "SLA_CREDIT_ISSUED" && (e.payload?.creditId === payload.creditId || e.payload?.settledEventId === payload.settledEventId));
      if (exists) throw new TypeError("SLA credit already issued for this settlement");

      const maxCents = creditPolicy?.maxAmountCents;
      if (Number.isSafeInteger(maxCents) && maxCents > 0 && payload.amountCents > maxCents) {
        throw new TypeError("SLA credit exceeds configured maximum");
      }
      const expectedPolicyHash = jobBefore.booking?.policyHash ?? null;
      if (expectedPolicyHash && payload.policyHash !== expectedPolicyHash) {
        throw new TypeError("payload.policyHash must match booking.policyHash");
      }
    }

    function findLatestCompletionChainHash(events) {
      if (!Array.isArray(events)) return null;
      for (let i = events.length - 1; i >= 0; i -= 1) {
        const e = events[i];
        if (e?.type !== "EXECUTION_COMPLETED" && e?.type !== "JOB_EXECUTION_COMPLETED") continue;
        const ch = typeof e?.chainHash === "string" ? e.chainHash.trim() : "";
        if (ch) return ch;
      }
      return null;
    }

    function findMatchingProofEvaluatedEvent({ events, evaluatedAtChainHash, customerPolicyHash, factsHash }) {
      if (!Array.isArray(events)) return null;
      if (typeof evaluatedAtChainHash !== "string" || !evaluatedAtChainHash.trim()) return null;
      if (typeof factsHash !== "string" || !factsHash.trim()) return null;
      for (let i = events.length - 1; i >= 0; i -= 1) {
        const e = events[i];
        if (e?.type !== "PROOF_EVALUATED") continue;
        const p = e.payload ?? null;
        if (!p || typeof p !== "object") continue;
        if (p.evaluatedAtChainHash !== evaluatedAtChainHash) continue;
        if (p.factsHash !== factsHash) continue;
        if (customerPolicyHash && p.customerPolicyHash !== customerPolicyHash) continue;
        return e;
      }
      return null;
    }

    function computeCurrentProofFactsHash({ completionChainHash }) {
      if (!completionChainHash) return null;
      const anchorIdx = eventsBefore.findIndex((e) => e?.chainHash === completionChainHash);
      if (anchorIdx === -1) return null;
      const anchorSlice = eventsBefore.slice(0, anchorIdx + 1);
      const jobAtAnchor = reduceJob(anchorSlice);
      if (!jobAtAnchor) return null;
      const current = verifyZoneCoverageProofV1({
        job: jobAtAnchor,
        events: eventsBefore,
        evaluatedAtChainHash: completionChainHash,
        customerPolicyHash: jobAtAnchor.customerPolicyHash ?? jobAtAnchor.booking?.policyHash ?? null,
        operatorPolicyHash: jobAtAnchor.operatorPolicyHash ?? null
      });
      return {
        factsHash: current?.factsHash ?? null,
        customerPolicyHash: current?.anchors?.customerPolicyHash ?? (jobAtAnchor.customerPolicyHash ?? jobAtAnchor.booking?.policyHash ?? null),
        operatorPolicyHash: current?.anchors?.operatorPolicyHash ?? (jobAtAnchor.operatorPolicyHash ?? null)
      };
    }

	    function proofRefFromProofEvent(proofEvent, { statusOverride = null, forfeit = null } = {}) {
	      if (!proofEvent || typeof proofEvent !== "object") return null;
	      const p = proofEvent.payload ?? null;
	      if (!p || typeof p !== "object") return null;
	      const ref = {
	        proofEventId: proofEvent.id ?? null,
	        proofEventAt: p.evaluatedAt ?? proofEvent.at ?? null,
	        proofEventChainHash: proofEvent.chainHash ?? null,
	        proofEventPayloadHash: proofEvent.payloadHash ?? null,
	        proofEventSignerKeyId: proofEvent.signerKeyId ?? null,
	        proofEventSignature: proofEvent.signature ?? null,
	        evaluationId: p.evaluationId ?? null,
	        evaluatedAtChainHash: p.evaluatedAtChainHash ?? null,
	        status: statusOverride ?? (p.status ?? null),
	        reasonCodes: Array.isArray(p.reasonCodes) ? p.reasonCodes : [],
	        requiredZonesHash: p.requiredZonesHash ?? null,
	        customerPolicyHash: p.customerPolicyHash ?? null,
	        operatorPolicyHash: p.operatorPolicyHash ?? null,
	        factsHash: p.factsHash ?? null,
	        metrics: p.metrics ?? null
	      };
	      if (forfeit && typeof forfeit === "object") ref.forfeit = forfeit;
	      return ref;
	    }

	    function decisionEventRefFromDecisionEvent(decisionEvent) {
	      if (!decisionEvent || typeof decisionEvent !== "object") return null;
	      const p = decisionEvent.payload ?? null;
	      if (!p || typeof p !== "object") return null;
	      return {
	        decisionEventId: decisionEvent.id ?? null,
	        decisionEventAt: p.decidedAt ?? decisionEvent.at ?? null,
	        decisionEventChainHash: decisionEvent.chainHash ?? null,
	        decisionEventPayloadHash: decisionEvent.payloadHash ?? null,
	        decisionEventSignerKeyId: decisionEvent.signerKeyId ?? null,
	        decisionEventSignature: decisionEvent.signature ?? null,
	        decisionId: p.decisionId ?? null,
	        kind: p.kind ?? null,
	        holdId: p.holdId ?? null,
	        forfeitureReason: p.forfeitureReason ?? null,
	        reasonCodes: Array.isArray(p.reasonCodes) ? p.reasonCodes : [],
	        evidenceRefs: Array.isArray(p.evidenceRefs) ? p.evidenceRefs : [],
	        policyHash: p.policyHash ?? null
	      };
	    }

	    function decisionEventRefMatches({ expected, actual }) {
	      if (!expected || typeof expected !== "object") return false;
	      if (!actual || typeof actual !== "object") return false;
	      const keys = ["decisionEventId", "decisionEventChainHash", "decisionEventPayloadHash", "decisionId", "kind", "holdId", "forfeitureReason", "policyHash"];
	      for (const k of keys) {
	        const ev = expected[k] ?? null;
	        const av = actual[k] ?? null;
	        if (ev !== av) return false;
	      }
	      const expReasons = Array.isArray(expected.reasonCodes) ? expected.reasonCodes : [];
	      const actReasons = Array.isArray(actual.reasonCodes) ? actual.reasonCodes : [];
	      if (expReasons.length !== actReasons.length || expReasons.some((v, i) => actReasons[i] !== v)) return false;
	      const expEvidence = Array.isArray(expected.evidenceRefs) ? expected.evidenceRefs : [];
	      const actEvidence = Array.isArray(actual.evidenceRefs) ? actual.evidenceRefs : [];
	      if (expEvidence.length !== actEvidence.length || expEvidence.some((v, i) => actEvidence[i] !== v)) return false;
	      return true;
	    }

		    function settlementProofRefMatches({ expected, actual }) {
	      if (!expected || typeof expected !== "object") return false;
	      if (!actual || typeof actual !== "object") return false;
      const keys = [
        "proofEventId",
        "proofEventChainHash",
        "proofEventPayloadHash",
        "evaluatedAtChainHash",
        "customerPolicyHash",
        "factsHash",
        "status"
      ];
	      for (const k of keys) {
	        const ev = expected[k] ?? null;
	        const av = actual[k] ?? null;
	        if (ev !== av) return false;
	      }
	      const expForfeit = expected.forfeit ?? null;
	      if (expForfeit && typeof expForfeit === "object") {
	        const actForfeit = actual.forfeit ?? null;
	        if (!actForfeit || typeof actForfeit !== "object") return false;
	        const fKeys = ["holdId", "forfeitureReason", "forfeitEventId", "forfeitEventChainHash", "forfeitEventPayloadHash"];
	        for (const k of fKeys) {
	          const ev = expForfeit[k] ?? null;
	          const av = actForfeit[k] ?? null;
	          if (ev !== av) return false;
	        }
	      }
		      return true;
		    }

		    function proofRefMatches({ expected, actual }) {
		      if (!expected || typeof expected !== "object") return false;
		      if (!actual || typeof actual !== "object") return false;
		      const keys = ["proofEventId", "proofEventChainHash", "proofEventPayloadHash", "evaluatedAtChainHash", "customerPolicyHash", "factsHash", "status"];
		      for (const k of keys) {
		        const ev = expected[k] ?? null;
		        const av = actual[k] ?? null;
		        if (ev !== av) return false;
		      }
		      return true;
		    }

    // Settlement safety: must not settle if event stream contains unlicensed usage.
    if (type === "SETTLED") {
      const used = eventsBefore.filter((e) => e.type === "SKILL_USED");
      for (const e of used) {
        const licId = e.payload?.licenseId;
        if (!licId) continue;
        const ok = jobBefore.skillLicenses.some((l) => l.licenseId === licId);
        if (!ok) throw new TypeError("cannot settle: unlicensed skill usage exists");
      }

      // Proof gating: in strict/holdback mode, settlement is a privileged transition that must point at a fresh proof.
      // Semantics:
      // - PASS -> settle as billable
      // - FAIL -> settle as non-billable (no-charge), but still financially final
      // - INSUFFICIENT_EVIDENCE -> do not settle (move into hold state via separate primitive)
      // (ABORTED settlements are refunds and are intentionally exempt.)
      const proofPolicy = jobBefore.booking?.policySnapshot?.proofPolicy ?? null;
      const gateModeRaw = typeof proofPolicy?.gateMode === "string" ? proofPolicy.gateMode : "warn";
      const gateMode = gateModeRaw === "strict" || gateModeRaw === "holdback" ? gateModeRaw : "warn";
      if (jobBefore.status === "COMPLETED" && gateMode !== "warn") {
        const completionChainHash = findLatestCompletionChainHash(eventsBefore);
        if (!completionChainHash) {
          const err = new Error("cannot settle: missing completion anchor");
          err.code = "PROOF_REQUIRED";
          throw err;
        }

        const current = computeCurrentProofFactsHash({ completionChainHash });
        const expectedFactsHash = current?.factsHash ?? null;
        if (!expectedFactsHash) {
          const err = new Error("cannot settle: proof factsHash missing (stale-proof protection)");
          err.code = "PROOF_STALE";
          throw err;
        }

        const expectedCustomerPolicyHash = current?.customerPolicyHash ?? null;
        const proofEvent = findMatchingProofEvaluatedEvent({
          events: eventsBefore,
          evaluatedAtChainHash: completionChainHash,
          customerPolicyHash: expectedCustomerPolicyHash,
          factsHash: expectedFactsHash
        });
        if (!proofEvent) {
          const hasAny = eventsBefore.some((e) => e?.type === "PROOF_EVALUATED" && e?.payload?.evaluatedAtChainHash === completionChainHash);
          const err = new Error(hasAny ? "cannot settle: proof is stale (matching PROOF_EVALUATED missing)" : "cannot settle: proof verdict is required (PROOF_EVALUATED missing)");
          err.code = hasAny ? "PROOF_STALE" : "PROOF_REQUIRED";
          throw err;
        }

        const proofStatus = proofEvent?.payload?.status === null || proofEvent?.payload?.status === undefined ? null : String(proofEvent.payload.status).trim();
        if (!proofStatus) {
          const err = new Error("cannot settle: proof verdict is required (PROOF_EVALUATED missing status)");
          err.code = "PROOF_REQUIRED";
          throw err;
        }
	        let expectedRef = null;
	        if (proofStatus === "INSUFFICIENT_EVIDENCE") {
	          // Strict-mode finality: settlement can only proceed from INSUFFICIENT_EVIDENCE after an explicit forfeiture decision.
	          let holdId = null;
	          for (let i = eventsBefore.length - 1; i >= 0; i -= 1) {
	            const e = eventsBefore[i];
	            if (e?.type !== "SETTLEMENT_HELD") continue;
	            const p = e.payload ?? null;
	            if (!p || typeof p !== "object") continue;
	            if (p.evaluatedAtChainHash !== completionChainHash) continue;
	            if (p.factsHash !== expectedFactsHash) continue;
	            if (typeof p.holdId === "string" && p.holdId.trim()) {
	              holdId = p.holdId;
	              break;
	            }
	          }

	          const forfeitEvent =
	            holdId &&
	            eventsBefore
	              .slice()
	              .reverse()
	              .find((e) => e?.type === "SETTLEMENT_FORFEITED" && e?.payload?.holdId === holdId && e?.payload?.factsHash === expectedFactsHash);

	          if (!forfeitEvent) {
	            const err = new Error("cannot settle: proof verdict is INSUFFICIENT_EVIDENCE");
	            err.code = "PROOF_INSUFFICIENT";
	            err.proofStatus = proofStatus;
	            throw err;
	          }

	          const fp = forfeitEvent.payload ?? null;
	          expectedRef = proofRefFromProofEvent(proofEvent, {
	            statusOverride: "FAIL",
	            forfeit: {
	              holdId,
	              forfeitureReason: fp?.forfeitureReason ?? null,
	              forfeitEventId: forfeitEvent.id ?? null,
	              forfeitEventChainHash: forfeitEvent.chainHash ?? null,
	              forfeitEventPayloadHash: forfeitEvent.payloadHash ?? null
	            }
	          });
	        } else {
	          expectedRef = proofRefFromProofEvent(proofEvent);
	        }

	        const actualRef = event.payload?.settlementProofRef ?? null;
	        if (!settlementProofRefMatches({ expected: expectedRef, actual: actualRef })) {
	          const err = new Error("cannot settle: settlementProofRef must reference the fresh proof used for settlement");
	          err.code = "SETTLEMENT_PROOF_REF_REQUIRED";
	          throw err;
	        }
	      }

      // Month-close immutability: prevent posting settlement into a closed month unless reopened.
      try {
        const t = Date.parse(event.at);
        if (Number.isFinite(t) && store.months instanceof Map) {
          const d = new Date(t);
          const y = d.getUTCFullYear();
          const m = String(d.getUTCMonth() + 1).padStart(2, "0");
          const settledMonth = `${y}-${m}`;
          const monthId = makeMonthCloseStreamId({ month: settledMonth, basis: MONTH_CLOSE_BASIS.SETTLED_AT });
          const monthClose = store.months.get(monthStoreKey(jobTenantId, monthId)) ?? null;
          if (monthClose?.status === "CLOSED") throw new TypeError("cannot settle: month is closed");
        }
      } catch (err) {
        if (err?.message === "cannot settle: month is closed") throw err;
      }
    }
  }

  function parseRequestId(req) {
    const header = req?.headers?.["x-request-id"] ?? req?.headers?.["X-Request-Id"] ?? null;
    const raw = header === null || header === undefined ? "" : String(header).trim();
    if (raw && raw.length <= 128 && /^[a-zA-Z0-9._-]+$/.test(raw)) return raw;
    return createId("req");
  }

  function routeLabelFor({ method, path }) {
    const m = String(method ?? "").toUpperCase();
    const p = String(path ?? "");
    if (m === "GET" && p === "/health") return "/health";
    if (m === "GET" && p === "/healthz") return "/healthz";
    if (m === "GET" && p === "/metrics") return "/metrics";
    if (m === "GET" && p === "/capabilities") return "/capabilities";
    if (m === "GET" && p === "/openapi.json") return "/openapi.json";
    if (m === "POST" && p === "/ingest/proxy") return "/ingest/proxy";
    if (m === "POST" && p === "/exports/ack") return "/exports/ack";
    if (m === "GET" && p === "/evidence/download") return "/evidence/download";
    if (p === "/jobs") return "/jobs";
    if (/^\/jobs\/[^/]+\/events$/.test(p)) return "/jobs/:jobId/events";
    if (/^\/jobs\/[^/]+\/audit$/.test(p)) return "/jobs/:jobId/audit";
    if (/^\/jobs\/[^/]+$/.test(p)) return "/jobs/:jobId";
    if (/^\/robots\/[^/]+\/events$/.test(p)) return "/robots/:robotId/events";
    if (/^\/robots\/[^/]+$/.test(p)) return "/robots/:robotId";
    if (/^\/operators\/[^/]+\/events$/.test(p)) return "/operators/:operatorId/events";
    if (p.startsWith("/ops")) return "/ops/*";
    return "other";
  }

  function logLevelForStatus(statusCode) {
    if (!Number.isFinite(statusCode) || statusCode <= 0) return "error";
    if (statusCode >= 500) return "error";
    if (statusCode >= 400) return "warn";
    return "info";
  }

  async function handle(req, res) {
    const url = new URL(req.url ?? "/", "http://localhost");
    const path = url.pathname;
    const requestId = parseRequestId(req);
    const route = routeLabelFor({ method: req.method, path });
    try {
      res.setHeader("x-request-id", requestId);
    } catch {
      // ignore
    }
    setProtocolResponseHeaders(res);

    return withLogContext({ requestId, route, method: req.method, path }, async () => {
      const startedMs = Date.now();
      let tenantId = "tenant_default";
      let principalId = "anon";
      try {
        if (
          path === "/ops/arbitration/workspace" ||
          path === "/ops/finance/reconciliation/workspace" ||
          path === "/ops/kernel/workspace" ||
          path === "/ops/marketplace/workspace" ||
          path === "/ops/policy/workspace"
        ) {
          const queryTenantId = url.searchParams.get("tenantId");
          const queryOpsToken = url.searchParams.get("opsToken");
          if (!req.headers?.["x-proxy-tenant-id"] && typeof queryTenantId === "string" && queryTenantId.trim() !== "") {
            req.headers["x-proxy-tenant-id"] = queryTenantId.trim();
          }
          if (!req.headers?.["x-proxy-ops-token"] && typeof queryOpsToken === "string" && queryOpsToken.trim() !== "") {
            req.headers["x-proxy-ops-token"] = queryOpsToken.trim();
          }
        }
        try {
          tenantId = normalizeTenantId(req.headers?.["x-proxy-tenant-id"]);
        } catch (err) {
          return sendError(res, 400, "invalid tenant", { message: err?.message }, { code: "SCHEMA_INVALID" });
        }
        if (typeof store.ensureTenant === "function") store.ensureTenant(tenantId);
        try {
          principalId = normalizePrincipalId(req.headers);
        } catch (err) {
          return sendError(res, 400, "invalid principal", { message: err?.message }, { code: "SCHEMA_INVALID" });
        }

        const rateLimitExempt = (req.method === "GET" && path === "/health") || (req.method === "GET" && path === "/healthz");
        if (!rateLimitExempt) {
          const rate = takeRateLimitToken({ tenantId });
          if (!rate.ok) {
            metricInc("rate_limited_total", { scope: "tenant" }, 1);
            try {
              res.setHeader("retry-after", String(rate.retryAfterSeconds));
            } catch {
              // ignore
            }
            return sendError(res, 429, "rate limit exceeded", null, { code: "RATE_LIMITED" });
          }
        }

        const authExempt =
          (req.method === "GET" && path === "/health") ||
          (req.method === "GET" && path === "/healthz") ||
          (req.method === "GET" && path === "/capabilities") ||
          (req.method === "GET" && path === "/.well-known/agent.json") ||
          (req.method === "GET" && path === "/.well-known/settld-keys.json") ||
          (req.method === "GET" && path === "/openapi.json") ||
          (req.method === "POST" && path === "/ingest/proxy") ||
          (req.method === "POST" && path === "/exports/ack");

        const auth = authExempt
          ? { ok: false, tenantId, principalId, scopes: new Set(), method: "exempt" }
          : await authenticateRequest({ req, store, tenantId, legacyTokenScopes: opsTokenScopes, nowIso });
        if (!authExempt && !auth.ok) return sendError(res, 403, "forbidden", null, { code: "FORBIDDEN" });
        if (auth.ok && auth.principalId) principalId = auth.principalId;

        if (!rateLimitExempt && auth.ok && auth.method === "api_key") {
          const keyRate = takeApiKeyRateLimitToken({ tenantId, apiKeyId: auth.keyId ?? null });
          if (!keyRate.ok) {
            metricInc("rate_limited_total", { scope: "api_key" }, 1);
            try {
              res.setHeader("retry-after", String(keyRate.retryAfterSeconds));
            } catch {
              // ignore
            }
            return sendError(res, 429, "rate limit exceeded", null, { code: "RATE_LIMITED" });
          }
        }

        try {
          const ctx = getLogContext();
          if (ctx && typeof ctx === "object") {
            ctx.tenantId = tenantId;
            ctx.principalId = principalId;
            ctx.actorKeyId = auth.ok ? (auth.keyId ?? null) : null;
          }
        } catch {}

        function makeOpsAudit({ action, targetType = null, targetId = null, details = null } = {}) {
          return makeOpsAuditRecord({
            tenantId,
            actorKeyId: auth.ok ? (auth.keyId ?? null) : null,
            actorPrincipalId: principalId,
            requestId,
            action: String(action ?? "OPS_HTTP_WRITE"),
            targetType,
            targetId,
            at: nowIso(),
            details
          });
        }

        function normalizeAuditDetailsObject(value) {
          return value && typeof value === "object" && !Array.isArray(value) ? value : {};
        }

        function cloneJsonLike(value) {
          if (value === null || value === undefined) return null;
          try {
            return JSON.parse(JSON.stringify(value));
          } catch {
            return null;
          }
        }

        async function appendBillingProviderIngestAudit(
          applied,
          { source = "webhook", replayed = false, replayAuditId = null, captureDuplicate = false } = {}
        ) {
          if (typeof store.appendOpsAudit !== "function") return;
          if (!applied || typeof applied !== "object") return;
          if (applied.duplicate === true && captureDuplicate !== true) return;
          await store.appendOpsAudit({
            tenantId,
            audit: makeOpsAudit({
              action: "BILLING_PROVIDER_EVENT_INGEST",
              targetType: "billing_provider_event",
              targetId: applied.eventId ?? null,
              details: {
                provider: applied.provider ?? "stripe",
                eventId: applied.eventId ?? null,
                eventType: applied.eventType ?? null,
                source: typeof source === "string" && source.trim() !== "" ? source.trim() : "webhook",
                replayed: replayed === true,
                replayAuditId: replayAuditId ?? null,
                duplicate: applied.duplicate === true,
                ignored: applied.ignored === true,
                planChanged: applied?.applied?.planChanged === true,
                previousPlan: applied?.applied?.previousPlan ?? null,
                nextPlan: applied?.applied?.nextPlan ?? null,
                subscriptionId: applied?.subscription?.subscriptionId ?? null,
                customerId: applied?.subscription?.customerId ?? null,
                status: applied?.subscription?.status ?? null
              }
            })
          });
        }

        async function appendBillingProviderRejectedAudit({
          provider = "stripe",
          eventId = null,
          eventType = null,
          reason = null,
          message = null,
          source = "webhook",
          event = null,
          details = null
        } = {}) {
          if (typeof store.appendOpsAudit !== "function") return;
          const replayEvent = event && typeof event === "object" && !Array.isArray(event) ? cloneJsonLike(event) : null;
          await store.appendOpsAudit({
            tenantId,
            audit: makeOpsAudit({
              action: "BILLING_PROVIDER_EVENT_REJECTED",
              targetType: "billing_provider_event",
              targetId: eventId ?? null,
              details: {
                provider: provider ?? "stripe",
                eventId: eventId ?? null,
                eventType: eventType ?? null,
                reason: reason ?? null,
                message: message ?? null,
                source: typeof source === "string" && source.trim() !== "" ? source.trim() : "webhook",
                replayable: Boolean(replayEvent),
                event: replayEvent,
                ...(details && typeof details === "object" && !Array.isArray(details) ? details : {})
              }
            })
          });
        }

        function readIdempotency({ method, requestPath, expectedPrevChainHash, body }) {
          const idempotencyKey = req.headers["x-idempotency-key"] ? String(req.headers["x-idempotency-key"]) : null;
          if (!idempotencyKey) return { idempotencyKey: null, idemStoreKey: null, idemRequestHash: null };

          const endpoint = makeIdempotencyEndpoint({ method, path: requestPath });
          const idemStoreKey = makeIdempotencyStoreKey({ tenantId, principalId, endpoint, idempotencyKey });
          const idemRequestHash = computeIdempotencyRequestHash({ method, path: requestPath, expectedPrevChainHash, body });
          return { idempotencyKey, idemStoreKey, idemRequestHash };
        }

        if (req.method === "GET" && path === "/health") {
          return sendJson(res, 200, { ok: true });
        }

        if (req.method === "GET" && path === "/capabilities") {
          return sendJson(res, 200, {
            ok: true,
            protocol: {
              current: protocolPolicy.current,
              supported: protocolPolicy.supported,
              min: protocolPolicy.min,
              max: protocolPolicy.max,
              requireHeader: protocolPolicy.requireHeader
            },
            contracts: {
              apis: [
                {
                  id: "legacy-v1",
                  basePath: "/ops/contracts",
                  semantics: "mutable policy upsert (back-compat)"
                },
                {
                  id: "contracts-v2",
                  basePath: "/ops/contracts-v2",
                  semantics: "contracts-as-code (hash-addressed docs + compile/activate)"
                }
              ],
              documents: { supported: [CONTRACT_DOCUMENT_TYPE_V1] },
              compilers: { supported: [CONTRACT_COMPILER_ID] }
            },
            connect: {
              supported: true,
              allocations: true,
              splitPlanVersions: ["SplitPlan.v1"],
              partyRoles: ["platform", "operator", "customer", "subcontractor", "insurer"]
            },
            events: {
              envelopeVersion: 1,
              schemaVersionsByType: Object.fromEntries(listKnownEventTypes().map((t) => [t, [1]]))
            },
            artifacts: {
              supportedTypes: Object.values(ARTIFACT_TYPE).sort()
            }
          });
        }

        if (req.method === "GET" && path === "/openapi.json") {
          return sendJson(res, 200, buildOpenApiSpec());
        }

        if (req.method === "GET" && path === "/.well-known/agent.json") {
          const baseUrl = deriveRequestBaseUrl(req) ?? "https://settld.local";
          const version = typeof process !== "undefined" ? (process.env.SETTLD_VERSION ?? null) : null;
          const card = buildSettldAgentCard({ baseUrl, version });
          return sendJson(res, 200, card);
        }

        if (req.method === "GET" && path === "/.well-known/settld-keys.json") {
          const keyset = buildSettldPayKeyset();
          try {
            res.setHeader("cache-control", "public, max-age=86400");
          } catch {
            // ignore
          }
          return sendJson(res, 200, keyset);
        }

	      if (req.method === "GET" && path === "/healthz") {
	        const scopedTokenScopes = parseOpsTokens(opsTokensRaw);
	        const scopedTokensConfigured = scopedTokenScopes.size > 0;
	        const legacyTokenConfigured =
	          typeof legacyOpsTokenRaw === "string" && legacyOpsTokenRaw.trim() !== "" && !scopedTokensConfigured;

	        const signals = {
	          ok: true,
	          dbOk: true,
	          dbLatencyMs: null,
	          outboxPending: null,
	          deliveriesPending: null,
	          deliveriesFailed: null,
	          ingestRejected: null,
	          autotickLastTickAt: store?.__autotickLastTickAt ?? null,
	          autotickLastSuccessAt: store?.__autotickLastSuccessAt ?? null,
	          // Non-sensitive deploy/config hints (do not include tokens/secrets).
	          build: {
	            gitSha: typeof process !== "undefined" ? (process.env.GIT_SHA ?? null) : null,
	            version: typeof process !== "undefined" ? (process.env.SETTLD_VERSION ?? null) : null,
	            railwayEnvironment: typeof process !== "undefined" ? (process.env.RAILWAY_ENVIRONMENT_NAME ?? null) : null,
	            railwayService: typeof process !== "undefined" ? (process.env.RAILWAY_SERVICE_NAME ?? null) : null
	          },
	          opsAuth: {
	            mode: scopedTokensConfigured ? "scoped" : legacyTokenConfigured ? "legacy" : "disabled",
	            scopedTokensCount: scopedTokenScopes.size,
	            scopedTokensEmptyScopesCount: Array.from(scopedTokenScopes.values()).filter((s) => (s ? s.size === 0 : true)).length,
	            effectiveTokensCount: opsTokenScopes.size
	          },
            billing: {
              planEnforcementEnabled: effectiveBillingPlanEnforcementEnabled
            }
	        };

        if (store?.kind === "pg" && store?.pg?.pool) {
          const started = Date.now();
          try {
            await store.pg.pool.query("SELECT 1");
            signals.dbOk = true;
            signals.dbLatencyMs = Date.now() - started;
          } catch (err) {
            signals.dbOk = false;
            signals.dbLatencyMs = Date.now() - started;
            logger.error("healthz.db_failed", { err });
          }

          try {
            const outboxRes = await store.pg.pool.query("SELECT COUNT(*)::bigint AS count FROM outbox WHERE processed_at IS NULL");
            const n = Number(outboxRes.rows?.[0]?.count ?? 0);
            signals.outboxPending = Number.isFinite(n) ? n : null;
          } catch {}
          try {
            const deliveriesRes = await store.pg.pool.query(
              "SELECT state, COUNT(*)::bigint AS count FROM deliveries WHERE state IN ('pending','failed') GROUP BY state"
            );
            let pending = 0;
            let failed = 0;
            for (const row of deliveriesRes.rows ?? []) {
              const state = row?.state ? String(row.state) : "";
              const n = Number(row?.count ?? 0);
              const count = Number.isFinite(n) ? n : 0;
              if (state === "pending") pending = count;
              if (state === "failed") failed = count;
            }
            signals.deliveriesPending = pending;
            signals.deliveriesFailed = failed;
          } catch {}
          try {
            const ingestRes = await store.pg.pool.query("SELECT COUNT(*)::bigint AS count FROM ingest_records WHERE status = 'rejected'");
            const n = Number(ingestRes.rows?.[0]?.count ?? 0);
            signals.ingestRejected = Number.isFinite(n) ? n : null;
          } catch {}
        } else {
          const cursor = Number.isSafeInteger(store?.outboxCursor) ? store.outboxCursor : 0;
          signals.outboxPending = Array.isArray(store?.outbox) ? Math.max(0, store.outbox.length - cursor) : 0;

          if (store?.deliveries instanceof Map) {
            let pending = 0;
            let failed = 0;
            for (const d of store.deliveries.values()) {
              if (!d || typeof d !== "object") continue;
              if (d.state === "pending") pending += 1;
              if (d.state === "failed") failed += 1;
            }
            signals.deliveriesPending = pending;
            signals.deliveriesFailed = failed;
          } else {
            signals.deliveriesPending = 0;
            signals.deliveriesFailed = 0;
          }

          if (store?.ingestRecords instanceof Map) {
            let rejected = 0;
            for (const r of store.ingestRecords.values()) {
              if (r?.status === "rejected") rejected += 1;
            }
            signals.ingestRejected = rejected;
          } else {
            signals.ingestRejected = 0;
          }
        }

        signals.ok = Boolean(signals.dbOk);
        return sendJson(res, signals.ok ? 200 : 503, signals);
      }

	      if (!authExempt && !path.startsWith("/ops")) {
	        const isRead = req.method === "GET" || req.method === "HEAD";
	        const isAuditExport = req.method === "GET" && /^\/jobs\/[^/]+\/audit$/.test(path);
	        const requiredScope =
	          path === "/evidence/download"
	            ? OPS_SCOPES.AUDIT_READ
	            : isAuditExport
	              ? OPS_SCOPES.AUDIT_READ
	              : isRead
	                ? OPS_SCOPES.OPS_READ
	                : OPS_SCOPES.OPS_WRITE;

	        // Special-case: selected job mutation endpoints include both ops-facing and finance-facing flows; allow either scope and enforce per-route/per-event below.
	        if (
	          !isRead &&
	          req.method === "POST" &&
	          (/^\/jobs\/[^/]+\/events$/.test(path) || /^\/jobs\/[^/]+\/dispute\/(open|close)$/.test(path))
	        ) {
	          const ok = requireScope(auth.scopes, OPS_SCOPES.OPS_WRITE) || requireScope(auth.scopes, OPS_SCOPES.FINANCE_WRITE);
	          if (!ok) return sendError(res, 403, "forbidden");
	        } else {
	          if (!requireScope(auth.scopes, requiredScope)) return sendError(res, 403, "forbidden");
	        }
	      }

      if (req.method === "GET" && path === "/metrics") {
        await refreshAlertGauges({ tenantId });
        return sendText(res, 200, metrics.renderPrometheusText(), { contentType: "text/plain; version=0.0.4; charset=utf-8" });
      }

      if (req.method === "POST" && path === "/ingest/proxy") {
        if (ingestTokenValue && String(req.headers?.["x-proxy-ingest-token"] ?? "") !== String(ingestTokenValue)) {
          return sendError(res, 403, "forbidden");
        }
        if (!requireProtocolHeaderForWrite(req, res)) return;

        const body = await readJsonBody(req);
        if (!body || typeof body !== "object") return sendError(res, 400, "json body is required");

        const source = body?.source ? String(body.source) : null;
        if (!source) return sendError(res, 400, "source is required");

        const { idempotencyKey, idemStoreKey, idemRequestHash } = readIdempotency({
          method: "POST",
          requestPath: path,
          expectedPrevChainHash: null,
          body
        });
        if (!idempotencyKey) return sendError(res, 400, "x-idempotency-key is required");

        if (idemStoreKey) {
          const existingIdem = store.idempotency.get(idemStoreKey);
          if (existingIdem) {
            if (existingIdem.requestHash !== idemRequestHash) {
              return sendError(res, 409, "idempotency key conflict", "request differs from initial use of this key");
            }
            return sendJson(res, existingIdem.statusCode, existingIdem.body);
          }
        }

        const siteId = body?.siteId ?? null;
        const correlationKey = body?.correlationKey ?? null;
        let jobId = body?.jobId ?? null;

        if (!jobId) {
          if (!siteId || !correlationKey) return sendError(res, 400, "jobId or (siteId + correlationKey) is required");
          if (typeof store.lookupCorrelation !== "function") return sendError(res, 501, "correlation lookup not supported");
          const hit = await store.lookupCorrelation({ tenantId, siteId: String(siteId), correlationKey: String(correlationKey) });
          if (!hit?.jobId) return sendError(res, 404, "correlationKey not found");
          jobId = hit.jobId;
        }

        if (typeof jobId !== "string" || jobId.trim() === "") return sendError(res, 400, "invalid jobId");

        const existing = getJobEvents(tenantId, jobId);
        if (!existing.length) return sendError(res, 404, "job not found");
        const jobBefore = reduceJob(existing);
        if (!jobBefore) return sendError(res, 404, "job not found");

        {
          const cfg = getTenantConfig(tenantId) ?? {};
          const requestedLimit = cfg?.quotas?.maxIngestDlqDepth ?? 0;
          const limit = clampQuota({
            tenantLimit: Number.isSafeInteger(requestedLimit) ? requestedLimit : 0,
            defaultLimit: 0,
            maxLimit: quotaPlatformMaxIngestDlqDepth
          });
          if (limit > 0) {
            let rejected = 0;
            if (store?.kind === "pg" && store?.pg?.pool) {
              try {
                const res = await store.pg.pool.query(
                  "SELECT COUNT(*)::int AS count FROM ingest_records WHERE tenant_id = $1 AND status = 'rejected'",
                  [tenantId]
                );
                rejected = Number(res.rows[0]?.count ?? 0);
              } catch {
                rejected = 0;
              }
            } else if (store?.ingestRecords instanceof Map) {
              for (const r of store.ingestRecords.values()) {
                if (!r || typeof r !== "object") continue;
                if (normalizeTenantId(r.tenantId ?? DEFAULT_TENANT_ID) !== tenantId) continue;
                if (r.status === "rejected") rejected += 1;
              }
            }
            if (isQuotaExceeded({ current: rejected, limit })) {
              return sendError(
                res,
                429,
                "tenant quota exceeded",
                { kind: "ingest_dlq_depth", limit, current: rejected },
                { code: "TENANT_QUOTA_EXCEEDED" }
              );
            }
          }
        }

        const inputEvents = Array.isArray(body?.events) ? body.events : null;
        if (!inputEvents || inputEvents.length === 0) return sendError(res, 400, "events[] is required");
        const ingestMaxEventsRaw = typeof process !== "undefined" ? process.env.PROXY_INGEST_MAX_EVENTS : null;
        const ingestMaxEvents = ingestMaxEventsRaw ? Number(ingestMaxEventsRaw) : 200;
        if (!Number.isFinite(ingestMaxEvents) || ingestMaxEvents <= 0) return sendError(res, 500, "invalid PROXY_INGEST_MAX_EVENTS");
        if (inputEvents.length > ingestMaxEvents) return sendError(res, 413, "too many events in request");

        const receivedAt = nowIso();
        const ingestRetentionDays = clampRetentionDays({
          tenantDays: Number.isSafeInteger(getTenantConfig(tenantId)?.retention?.ingestRecordsDays)
            ? getTenantConfig(tenantId).retention.ingestRecordsDays
            : 0,
          defaultDays: 0,
          maxDays: ingestRecordsRetentionMaxDays
        });
        const ingestExpiresAt = computeExpiresAtIso({ at: receivedAt, retentionDays: ingestRetentionDays });
        const nowMs = Date.parse(receivedAt);
        const maxFutureSkewMs = 5 * 60_000;
        const lateAfterMs = 15 * 60_000;

        let events = existing;
        let workingJob = jobBefore;
        const appended = [];
        const results = [];
        const ingestRecords = [];
        const outboxMessages = [];
        const seenExternalIds = new Set();

        for (const e of inputEvents) {
          const type = e?.type ? String(e.type) : null;
          if (!type) return sendError(res, 400, "event.type is required");

          const externalEventId = e?.externalEventId ? String(e.externalEventId) : null;
          if (!externalEventId) return sendError(res, 400, "event.externalEventId is required");
          if (seenExternalIds.has(externalEventId)) {
            metricInc("ingest_events_total", { result: "duplicate" }, 1);
            results.push({
              externalEventId,
              status: "duplicate",
              acceptedEventId: null,
              reason: "duplicate externalEventId in request",
              reasonCode: null,
              late: null
            });
            continue;
          }
          seenExternalIds.add(externalEventId);

          let prior = null;
          try {
            if (typeof store.getIngestRecord === "function") {
              prior = await store.getIngestRecord({ tenantId, source, externalEventId });
            }
          } catch {
            // Ignore: best-effort dedupe is handled by storage.
          }
          if (prior) {
            metricInc("ingest_events_total", { result: "duplicate" }, 1);
            results.push({
              externalEventId,
              status: "duplicate",
              acceptedEventId: prior.acceptedEventId ?? prior.eventId ?? null,
              reason: null,
              reasonCode: null,
              late: prior.late ?? null
            });
            continue;
          }

          const signerKind = requiredSignerKindForEventType(type);
          if (signerKind !== SIGNER_KIND.SERVER) {
            const reason = `unsupported signerKind=${signerKind}`;
            const reasonCode = inferIngestReasonCode(reason);
            metricInc("ingest_events_total", { result: "rejected" }, 1);
            metricInc("ingest_rejected_total", { reason: reasonCode }, 1);
            results.push({ externalEventId, status: "rejected", acceptedEventId: null, reason, reasonCode, late: null });
            ingestRecords.push({
              tenantId,
              source,
              externalEventId,
              status: "rejected",
              reason,
              reasonCode,
              jobId,
              siteId: siteId ? String(siteId) : null,
              correlationKey: correlationKey ? String(correlationKey) : null,
              type,
              at: e?.at ?? null,
              receivedAt,
              expiresAt: ingestExpiresAt
            });
            continue;
          }

          const actor = e?.actor ?? { type: "ingest", id: principalId };
          if (actor?.type === "robot" || actor?.type === "operator") {
            const reason = "ingest cannot spoof robot/operator actors";
            const reasonCode = inferIngestReasonCode(reason);
            metricInc("ingest_events_total", { result: "rejected" }, 1);
            metricInc("ingest_rejected_total", { reason: reasonCode }, 1);
            results.push({ externalEventId, status: "rejected", acceptedEventId: null, reason, reasonCode, late: null });
            ingestRecords.push({
              tenantId,
              source,
              externalEventId,
              status: "rejected",
              reason,
              reasonCode,
              jobId,
              siteId: siteId ? String(siteId) : null,
              correlationKey: correlationKey ? String(correlationKey) : null,
              type,
              at: e?.at ?? null,
              receivedAt,
              expiresAt: ingestExpiresAt
            });
            continue;
          }

          const at = e?.at ?? nowIso();
          try {
            assertIsoDate(at, "event.at");
          } catch (err) {
            const reason = err?.message ?? "invalid at";
            const reasonCode = inferIngestReasonCode(reason);
            metricInc("ingest_events_total", { result: "rejected" }, 1);
            metricInc("ingest_rejected_total", { reason: reasonCode }, 1);
            results.push({ externalEventId, status: "rejected", acceptedEventId: null, reason, reasonCode, late: null });
            ingestRecords.push({
              tenantId,
              source,
              externalEventId,
              status: "rejected",
              reason,
              reasonCode,
              jobId,
              siteId: siteId ? String(siteId) : null,
              correlationKey: correlationKey ? String(correlationKey) : null,
              type,
              at,
              receivedAt,
              expiresAt: ingestExpiresAt
            });
            continue;
          }

          const atMs = Date.parse(at);
          if (Number.isFinite(atMs) && Number.isFinite(nowMs) && atMs > nowMs + maxFutureSkewMs) {
            const reason = "event.at is too far in the future";
            const reasonCode = inferIngestReasonCode(reason);
            metricInc("ingest_events_total", { result: "rejected" }, 1);
            metricInc("ingest_rejected_total", { reason: reasonCode }, 1);
            results.push({ externalEventId, status: "rejected", acceptedEventId: null, reason, reasonCode, late: null });
            ingestRecords.push({
              tenantId,
              source,
              externalEventId,
              status: "rejected",
              reason,
              reasonCode,
              jobId,
              siteId: siteId ? String(siteId) : null,
              correlationKey: correlationKey ? String(correlationKey) : null,
              type,
              at,
              receivedAt,
              expiresAt: ingestExpiresAt
            });
            continue;
          }

          const late = Number.isFinite(atMs) && Number.isFinite(nowMs) ? atMs < nowMs - lateAfterMs : null;

          const draft = createChainedEvent({
            streamId: jobId,
            type,
            at,
            actor,
            payload: e?.payload ?? null
          });
          const nextEvents = appendChainedEvent({ events, event: draft, signer: serverSigner });
          const event = nextEvents[nextEvents.length - 1];

          try {
            enforceSignaturePolicy({ tenantId, signerKind, event });
            validateDomainEvent({ jobBefore: workingJob, event, eventsBefore: events });
          } catch (err) {
            const reason = err?.message ?? "event rejected";
            const reasonCode = typeof err?.code === "string" && err.code.trim() ? err.code : inferIngestReasonCode(reason);
            metricInc("ingest_events_total", { result: "rejected" }, 1);
            metricInc("ingest_rejected_total", { reason: reasonCode }, 1);
            results.push({ externalEventId, status: "rejected", acceptedEventId: null, reason, reasonCode, late });
            ingestRecords.push({
              tenantId,
              source,
              externalEventId,
              status: "rejected",
              reason,
              reasonCode,
              jobId,
              siteId: siteId ? String(siteId) : null,
              correlationKey: correlationKey ? String(correlationKey) : null,
              type,
              at,
              receivedAt,
              late,
              expiresAt: ingestExpiresAt
            });
            continue;
          }

          events = nextEvents;
          appended.push(event);
          try {
            workingJob = reduceJob(events);
          } catch (err) {
            const reason = err?.message ?? "job transition rejected";
            const reasonCode = inferIngestReasonCode(reason);
            metricInc("ingest_events_total", { result: "rejected" }, 1);
            metricInc("ingest_rejected_total", { reason: reasonCode }, 1);
            results.push({ externalEventId, status: "rejected", acceptedEventId: null, reason, reasonCode, late });
            ingestRecords.push({
              tenantId,
              source,
              externalEventId,
              status: "rejected",
              reason,
              reasonCode,
              jobId,
              siteId: siteId ? String(siteId) : null,
              correlationKey: correlationKey ? String(correlationKey) : null,
              type,
              at,
              receivedAt,
              late,
              expiresAt: ingestExpiresAt
            });
            continue;
          }

          // Ledger posting (best-effort): only for server-signed job events.
          try {
            const eventsBefore = events.slice(0, -1);
            const jobBefore = reduceJob(eventsBefore);
            const entries = ledgerEntriesForJobEvent({ jobBefore, event, eventsBefore });
            for (const entry of entries) {
              if (!entry) continue;
              outboxMessages.push({ type: "LEDGER_ENTRY_APPLY", tenantId, jobId, sourceEventId: event.id, entry });
            }
          } catch {
            // ignore
          }

          metricInc("ingest_events_total", { result: "accepted" }, 1);
          results.push({ externalEventId, status: "accepted", acceptedEventId: event.id, reason: null, reasonCode: null, late });
          ingestRecords.push({
            tenantId,
            source,
            externalEventId,
            status: "accepted",
            reason: null,
            reasonCode: null,
            acceptedEventId: event.id,
            jobId,
            siteId: siteId ? String(siteId) : null,
            correlationKey: correlationKey ? String(correlationKey) : null,
            type,
            at,
            receivedAt,
            late,
            expiresAt: ingestExpiresAt
          });
        }

        try {
          const summary = { accepted: 0, duplicate: 0, rejected: 0 };
          const rejectedByReason = {};
          for (const r of results) {
            if (r?.status === "accepted") summary.accepted += 1;
            else if (r?.status === "duplicate") summary.duplicate += 1;
            else if (r?.status === "rejected") {
              summary.rejected += 1;
              const code = typeof r?.reasonCode === "string" && r.reasonCode.trim() ? r.reasonCode : "UNKNOWN";
              rejectedByReason[code] = (rejectedByReason[code] ?? 0) + 1;
            }
          }
          logger.info("ingest.proxy", { tenantId, principalId, jobId, source, counts: summary, rejectedByReason });
        } catch {
          // ignore
        }

        const responseBody = { job: workingJob, results, events: appended };
        const ops = [];
        if (appended.length) ops.push({ kind: "JOB_EVENTS_APPENDED", tenantId, jobId, events: appended });
        if (outboxMessages.length) ops.push({ kind: "OUTBOX_ENQUEUE", messages: outboxMessages });
        if (idemStoreKey) ops.push({ kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode: 200, body: responseBody } });
        if (ingestRecords.length) ops.push({ kind: "INGEST_RECORDS_PUT", tenantId, records: ingestRecords });

        if (ops.length) await commitTx(ops);
        return sendJson(res, 200, responseBody);
      }

      if (req.method === "POST" && path === "/exports/ack") {
        const destinationId = req.headers["x-proxy-destination-id"] ? String(req.headers["x-proxy-destination-id"]) : null;
        const timestamp = req.headers["x-proxy-timestamp"] ? String(req.headers["x-proxy-timestamp"]) : null;
        const signature = req.headers["x-proxy-signature"] ? String(req.headers["x-proxy-signature"]) : null;
        if (!destinationId || !timestamp || !signature) {
          return sendError(res, 400, "missing required headers", "x-proxy-destination-id, x-proxy-timestamp, x-proxy-signature are required");
        }

        const tsMs = Date.parse(timestamp);
        const nowMs = Date.parse(nowIso());
        const maxSkewMs = 5 * 60_000;
        if (Number.isFinite(tsMs) && Number.isFinite(nowMs) && Math.abs(tsMs - nowMs) > maxSkewMs) {
          return sendError(res, 400, "timestamp skew too large");
        }

        const dest = listDestinationsForTenant(tenantId).find((d) => d.destinationId === destinationId) ?? null;
        if (!dest) return sendError(res, 404, "destination not found");

        const body = await readJsonBody(req);
        if (!body || typeof body !== "object") return sendError(res, 400, "json body is required");

        let destinationSecret = dest.secret ?? null;
        if (!destinationSecret && dest.secretRef) {
          try {
            destinationSecret = (await store.secrets.getSecret({ tenantId, ref: String(dest.secretRef) }))?.value ?? null;
          } catch (err) {
            return sendError(res, 500, "destination secret unavailable", { message: err?.message }, { code: "SECRET_READ_FAILED" });
          }
        }
        if (!destinationSecret) return sendError(res, 500, "destination secret unavailable", null, { code: "SECRET_NOT_FOUND" });

        const expected = hmacSignArtifact({ secret: destinationSecret, timestamp, bodyJson: body });
        if (String(signature) !== expected) return sendError(res, 403, "forbidden");

        const deliveryIdRaw = body?.deliveryId ?? body?.id ?? null;
        const artifactHash = body?.artifactHash ?? null;
        const receivedAt = body?.receivedAt ?? null;
        if (!deliveryIdRaw) return sendError(res, 400, "deliveryId is required");

        if (typeof store.ackDelivery !== "function") return sendError(res, 501, "delivery receipts not supported for this store");

        try {
          if (store.kind === "pg") {
            const id = Number(deliveryIdRaw);
            if (!Number.isSafeInteger(id) || id <= 0) return sendError(res, 400, "invalid deliveryId");
            const result = await store.ackDelivery({ tenantId, id, destinationId, artifactHash: artifactHash ?? null, receivedAt: receivedAt ?? null });
            if (!result) return sendError(res, 404, "delivery not found");
            return sendJson(res, 200, { ok: true, ...result });
          }

          const deliveryId = String(deliveryIdRaw);
          const result = await store.ackDelivery({ tenantId, deliveryId, destinationId, artifactHash: artifactHash ?? null, receivedAt: receivedAt ?? null });
          if (!result) return sendError(res, 404, "delivery not found");
          return sendJson(res, 200, { ok: true, ...result });
        } catch (err) {
          return sendError(res, 400, "invalid ack", { message: err?.message });
        }
      }

      if (req.method === "GET" && path === "/evidence/download") {
        const queryTenantId = url.searchParams.get("tenantId");
        const evidenceTenantId = normalizeTenantId(queryTenantId ?? tenantId);
        if (typeof store.ensureTenant === "function") store.ensureTenant(evidenceTenantId);

        const jobId = url.searchParams.get("jobId");
        const evidenceId = url.searchParams.get("evidenceId");
        const evidenceRef = url.searchParams.get("evidenceRef");
        const expiresAt = url.searchParams.get("expiresAt");
        const sig = url.searchParams.get("sig");

        if (!jobId || !evidenceId || !evidenceRef || !expiresAt || !sig) {
          return sendError(res, 400, "missing required query params");
        }

        const nowMs = Date.parse(nowIso());
        const verify = verifyEvidenceDownload({
          secret: evidenceSigningSecret,
          tenantId: evidenceTenantId,
          jobId,
          evidenceId,
          evidenceRef,
          expiresAt,
          sig,
          nowMs: Number.isFinite(nowMs) ? nowMs : Date.now()
        });
        if (!verify.ok) return sendError(res, 403, "forbidden", verify.error);

        const events = getJobEvents(evidenceTenantId, jobId);
        if (!events.length) return sendError(res, 404, "job not found");

        const jobBefore = reduceJob(events);
        if (!jobBefore) return sendError(res, 404, "job not found");

        const captured = events.find((e) => e?.type === "EVIDENCE_CAPTURED" && e?.payload?.evidenceId === evidenceId) ?? null;
        if (!captured) return sendError(res, 404, "evidence not found");
        if ((captured.payload?.evidenceRef ?? null) !== evidenceRef) return sendError(res, 404, "evidence not found");
        const expired = events.some((e) => e?.type === "EVIDENCE_EXPIRED" && e?.payload?.evidenceId === evidenceId);
        if (expired) return sendError(res, 410, "evidence expired", null, { code: "EVIDENCE_EXPIRED" });

        const refSafety = checkUrlSafetySync(evidenceRef, { allowPrivate: false, allowLoopback: false });
        if (!refSafety.ok) {
          return sendError(res, 400, "unsafe evidenceRef", { code: refSafety.code }, { code: refSafety.code });
        }

        // Audit log is required: evidence retrieval must be view-audited.
        try {
          const viewedAt = nowIso();
          const draft = createChainedEvent({
            streamId: jobId,
            type: "EVIDENCE_VIEWED",
            at: viewedAt,
            actor: { type: "ops", id: principalId },
            payload: { jobId, evidenceId, evidenceRef, viewedAt }
          });
          const nextEvents = appendChainedEvent({ events, event: draft, signer: serverSigner });
          const viewEvent = nextEvents[nextEvents.length - 1];
          enforceSignaturePolicy({ tenantId: evidenceTenantId, signerKind: requiredSignerKindForEventType(viewEvent.type), event: viewEvent });
          validateDomainEvent({ jobBefore, event: viewEvent, eventsBefore: events });
          reduceJob(nextEvents);
          await commitTx([{ kind: "JOB_EVENTS_APPENDED", tenantId: evidenceTenantId, jobId, events: [viewEvent] }]);
        } catch (err) {
          return sendError(res, 500, "failed to audit evidence view", { message: err?.message }, { code: "AUDIT_LOG_FAILED" });
        }

        // External evidence refs (https://...) are redirected after DNS/IP safety checks.
        if (typeof evidenceRef === "string" && (evidenceRef.startsWith("https://") || evidenceRef.startsWith("http://"))) {
          const safe = await checkUrlSafety(evidenceRef, { allowPrivate: false, allowLoopback: false });
          if (!safe.ok) {
            return sendError(res, 400, "unsafe evidenceRef", { code: safe.code, message: safe.message }, { code: safe.code });
          }
          res.statusCode = 302;
          res.setHeader("location", evidenceRef);
          res.setHeader("cache-control", "no-store");
          res.end();
          return;
        }

        if (typeof evidenceRef !== "string" || !evidenceRef.startsWith("obj://")) {
          return sendError(res, 400, "unsupported evidenceRef");
        }
        if (!store.evidenceStore) {
          return sendError(res, 501, "evidence store not configured");
        }

        const expMs = Date.parse(expiresAt);
        const computedExpires = Number.isFinite(expMs) && Number.isFinite(nowMs) ? Math.max(1, Math.ceil((expMs - nowMs) / 1000)) : 60;
        const maxPresignSecondsRaw = typeof process !== "undefined" ? process.env.PROXY_EVIDENCE_PRESIGN_MAX_SECONDS : null;
        const maxPresignSeconds = maxPresignSecondsRaw && String(maxPresignSecondsRaw).trim() !== "" ? Number(maxPresignSecondsRaw) : 300;
        const safeMaxPresignSeconds =
          Number.isFinite(maxPresignSeconds) && maxPresignSeconds > 0 ? Math.min(3600, Math.floor(maxPresignSeconds)) : 300;
        const expiresInSeconds = Math.min(computedExpires, safeMaxPresignSeconds);

        if (typeof store.evidenceStore.getPresignedDownloadUrl === "function") {
          let presigned;
          try {
            presigned = await store.evidenceStore.getPresignedDownloadUrl({ tenantId: evidenceTenantId, evidenceRef, expiresInSeconds });
          } catch (err) {
            return sendError(res, 500, "failed to presign evidence download", { message: err?.message });
          }

          const allowPrivateUrls =
            typeof process !== "undefined" &&
            (process.env.PROXY_ALLOW_PRIVATE_URLS === "1" || process.env.NODE_ENV === "development" || process.env.NODE_ENV === "test");
          const allowLoopbackUrls =
            typeof process !== "undefined" &&
            (process.env.PROXY_ALLOW_LOOPBACK_URLS === "1" || process.env.NODE_ENV === "development" || process.env.NODE_ENV === "test");
          const presignedSafety = await checkUrlSafety(presigned, { allowPrivate: allowPrivateUrls, allowLoopback: allowLoopbackUrls });
          if (!presignedSafety.ok) {
            return sendError(res, 500, "unsafe evidence download URL", { code: presignedSafety.code, message: presignedSafety.message }, { code: presignedSafety.code });
          }

          res.statusCode = 302;
          res.setHeader("location", presigned);
          res.setHeader("cache-control", "no-store");
          res.end();
          return;
        }

        if (typeof store.evidenceStore.readEvidence !== "function") {
          return sendError(res, 501, "evidence store not configured");
        }

        let data;
        try {
          ({ data } = await store.evidenceStore.readEvidence({ tenantId: evidenceTenantId, evidenceRef }));
        } catch (err) {
          if (err?.code === "ENOENT") return sendError(res, 404, "evidence object not found");
          throw err;
        }

        res.statusCode = 200;
        res.setHeader("content-type", String(captured.payload?.contentType ?? "application/octet-stream"));
        res.setHeader("content-disposition", `attachment; filename="evidence_${String(evidenceId).replaceAll(/[^a-zA-Z0-9._-]/g, "_")}"`);
        res.end(data);
        return;
      }

      if (path.startsWith("/ops")) {
        if (!auth.ok) return sendError(res, 403, "forbidden");
        if (store.kind === "pg" && typeof store.refreshFromDb === "function") {
          await store.refreshFromDb();
          if (typeof store.ensureTenant === "function") store.ensureTenant(tenantId);
        }

        const parts = path.split("/").filter(Boolean);
        if (parts.length === 1 && req.method === "GET") {
          if (!requireScope(auth.scopes, OPS_SCOPES.OPS_READ)) return sendError(res, 403, "forbidden");
          return sendJson(res, 200, { ok: true });
        }

        if (parts[1] === "x402" && parts[2] === "wallet-policies" && parts.length === 3 && req.method === "POST") {
          if (!requireScope(auth.scopes, OPS_SCOPES.OPS_WRITE)) return sendError(res, 403, "forbidden");
          if (!requireProtocolHeaderForWrite(req, res)) return;

          const body = (await readJsonBody(req)) ?? {};
          let idemStoreKey = null;
          let idemRequestHash = null;
          try {
            ({ idemStoreKey, idemRequestHash } = readIdempotency({ method: "POST", requestPath: path, expectedPrevChainHash: null, body }));
          } catch (err) {
            return sendError(res, 400, "invalid idempotency key", { message: err?.message });
          }
          if (idemStoreKey) {
            const existingIdem = store.idempotency.get(idemStoreKey);
            if (existingIdem) {
              if (existingIdem.requestHash !== idemRequestHash) {
                return sendError(res, 409, "idempotency key conflict", "request differs from initial use of this key");
              }
              return sendJson(res, existingIdem.statusCode, existingIdem.body);
            }
          }

          const rawPolicy =
            body?.policy && typeof body.policy === "object" && !Array.isArray(body.policy) ? body.policy : body;
          let existingPolicy = null;
          try {
            const sponsorWalletRef = normalizeOptionalX402RefInput(rawPolicy?.sponsorWalletRef, "policy.sponsorWalletRef", {
              allowNull: false,
              max: 200
            });
            const policyRef = normalizeOptionalX402RefInput(rawPolicy?.policyRef, "policy.policyRef", { allowNull: false, max: 200 });
            const policyVersion = normalizeOptionalX402PositiveSafeInt(rawPolicy?.policyVersion, "policy.policyVersion", { allowNull: false });
            existingPolicy = await getX402WalletPolicyRecord({ tenantId, sponsorWalletRef, policyRef, policyVersion });
          } catch (err) {
            return sendError(res, 400, "invalid x402 wallet policy key fields", { message: err?.message }, { code: "SCHEMA_INVALID" });
          }

          let policy = null;
          try {
            policy = normalizeX402WalletPolicyInput(rawPolicy, { fieldPath: "policy", existing: existingPolicy });
          } catch (err) {
            return sendError(res, 400, "invalid x402 wallet policy", { message: err?.message }, { code: "SCHEMA_INVALID" });
          }

          const targetId = `${policy.sponsorWalletRef}::${policy.policyRef}::${policy.policyVersion}`;
          const responseBody = {
            ok: true,
            policy,
            created: existingPolicy ? false : true
          };
          const statusCode = existingPolicy ? 200 : 201;
          const ops = [{ kind: "X402_WALLET_POLICY_UPSERT", tenantId, policy }];
          if (idemStoreKey) {
            ops.push({ kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode, body: responseBody } });
          }
          await commitTx(ops, {
            audit: makeOpsAudit({
              action: "X402_WALLET_POLICY_UPSERT",
              targetType: "x402_wallet_policy",
              targetId,
              details: {
                sponsorRef: policy.sponsorRef ?? null,
                sponsorWalletRef: policy.sponsorWalletRef,
                policyRef: policy.policyRef,
                policyVersion: policy.policyVersion,
                status: policy.status
              }
            })
          });
          return sendJson(res, statusCode, responseBody);
        }

        if (parts[1] === "x402" && parts[2] === "wallet-policies" && parts.length === 3 && req.method === "GET") {
          const hasScope = requireScope(auth.scopes, OPS_SCOPES.OPS_READ) || requireScope(auth.scopes, OPS_SCOPES.OPS_WRITE);
          if (!hasScope) return sendError(res, 403, "forbidden");
          const sponsorWalletRefRaw = url.searchParams.get("sponsorWalletRef");
          const sponsorRefRaw = url.searchParams.get("sponsorRef");
          const policyRefRaw = url.searchParams.get("policyRef");
          const statusRaw = url.searchParams.get("status");
          const limitRaw = url.searchParams.get("limit");
          const offsetRaw = url.searchParams.get("offset");
          const limit = limitRaw === null || limitRaw === "" ? 200 : Number(limitRaw);
          const offset = offsetRaw === null || offsetRaw === "" ? 0 : Number(offsetRaw);
          if (!Number.isSafeInteger(limit) || limit < 1 || limit > 2000) {
            return sendError(res, 400, "invalid list query", { message: "limit must be an integer in range 1..2000" }, { code: "SCHEMA_INVALID" });
          }
          if (!Number.isSafeInteger(offset) || offset < 0) {
            return sendError(res, 400, "invalid list query", { message: "offset must be a non-negative integer" }, { code: "SCHEMA_INVALID" });
          }
          let policies = [];
          try {
            policies = await listX402WalletPolicyRecords({
              tenantId,
              sponsorWalletRef: sponsorWalletRefRaw,
              sponsorRef: sponsorRefRaw,
              policyRef: policyRefRaw,
              status: statusRaw,
              limit,
              offset
            });
          } catch (err) {
            return sendError(res, 400, "invalid x402 wallet policy query", { message: err?.message }, { code: "SCHEMA_INVALID" });
          }
          return sendJson(res, 200, {
            ok: true,
            tenantId,
            limit,
            offset,
            policies
          });
        }

        if (parts[1] === "x402" && parts[2] === "wallet-policies" && parts.length === 6 && req.method === "GET") {
          const hasScope = requireScope(auth.scopes, OPS_SCOPES.OPS_READ) || requireScope(auth.scopes, OPS_SCOPES.OPS_WRITE);
          if (!hasScope) return sendError(res, 403, "forbidden");
          let sponsorWalletRef = null;
          let policyRef = null;
          let policyVersion = null;
          try {
            sponsorWalletRef = normalizeOptionalX402RefInput(decodePathPart(parts[3]), "sponsorWalletRef", { allowNull: false, max: 200 });
            policyRef = normalizeOptionalX402RefInput(decodePathPart(parts[4]), "policyRef", { allowNull: false, max: 200 });
            policyVersion = normalizeOptionalX402PositiveSafeInt(decodePathPart(parts[5]), "policyVersion", { allowNull: false });
          } catch (err) {
            return sendError(res, 400, "invalid x402 wallet policy key", { message: err?.message }, { code: "SCHEMA_INVALID" });
          }
          const policy = await getX402WalletPolicyRecord({ tenantId, sponsorWalletRef, policyRef, policyVersion });
          if (!policy) return sendError(res, 404, "x402 wallet policy not found", null, { code: "NOT_FOUND" });
          return sendJson(res, 200, { ok: true, policy });
        }

        if (parts[1] === "tool-calls" && parts[2] === "holds" && parts[3] === "lock" && parts.length === 4 && req.method === "POST") {
          if (!requireProtocolHeaderForWrite(req, res)) return;
          if (!requireScope(auth.scopes, OPS_SCOPES.OPS_WRITE)) return sendError(res, 403, "forbidden");

          const body = await readJsonBody(req);
          let idemStoreKey = null;
          let idemRequestHash = null;
          try {
            ({ idemStoreKey, idemRequestHash } = readIdempotency({ method: "POST", requestPath: path, expectedPrevChainHash: null, body }));
          } catch (err) {
            return sendError(res, 400, "invalid idempotency key", { message: err?.message });
          }
          if (idemStoreKey) {
            const existing = store.idempotency.get(idemStoreKey);
            if (existing) {
              if (existing.requestHash !== idemRequestHash) {
                return sendError(res, 409, "idempotency key conflict", "request differs from initial use of this key");
              }
              return sendJson(res, existing.statusCode, existing.body);
            }
          }

          const nowAt = nowIso();
          let agreementHash = null;
          let receiptHash = null;
          try {
            agreementHash = normalizeSha256HashInput(body?.agreementHash, "agreementHash", { allowNull: false });
            receiptHash = normalizeSha256HashInput(body?.receiptHash, "receiptHash", { allowNull: false });
          } catch (err) {
            return sendError(res, 400, "invalid hold subject hashes", { message: err?.message }, { code: "SCHEMA_INVALID" });
          }
          const payerAgentId = typeof body?.payerAgentId === "string" && body.payerAgentId.trim() !== "" ? body.payerAgentId.trim() : null;
          const payeeAgentId = typeof body?.payeeAgentId === "string" && body.payeeAgentId.trim() !== "" ? body.payeeAgentId.trim() : null;
          if (!payerAgentId || !payeeAgentId || payerAgentId === payeeAgentId) {
            return sendError(res, 400, "payerAgentId and payeeAgentId are required and must differ", null, { code: "SCHEMA_INVALID" });
          }

          const amountCents = Number(body?.amountCents);
          if (!Number.isSafeInteger(amountCents) || amountCents <= 0) return sendError(res, 400, "amountCents must be a positive safe integer");
          const currency = typeof body?.currency === "string" && body.currency.trim() !== "" ? body.currency.trim() : "USD";

          const holdbackBps = Number(body?.holdbackBps ?? 0);
          if (!Number.isSafeInteger(holdbackBps) || holdbackBps < 0 || holdbackBps > 10_000) {
            return sendError(res, 400, "holdbackBps must be an integer within 0..10000", null, { code: "SCHEMA_INVALID" });
          }
          const challengeWindowMs = Number(body?.challengeWindowMs ?? 0);
          if (!Number.isSafeInteger(challengeWindowMs) || challengeWindowMs < 0 || challengeWindowMs > 365 * 24 * 60 * 60_000) {
            return sendError(res, 400, "challengeWindowMs must be an integer within 0..31536000000", null, { code: "SCHEMA_INVALID" });
	          }
	
	          const heldAmountCents = Math.min(amountCents, Math.floor((amountCents * holdbackBps) / 10_000));
	          if (heldAmountCents > 0) {
	            try {
	              const payerIdentity = await getAgentIdentityRecord({ tenantId, agentId: payerAgentId });
	              if (payerIdentity) {
	                await assertSettlementWithinWalletPolicy({ tenantId, agentIdentity: payerIdentity, amountCents: heldAmountCents, at: nowAt });
	              }
	            } catch (err) {
	              if (err?.code?.startsWith?.("WALLET_POLICY_")) {
	                return sendError(res, 409, "wallet policy blocked settlement", { message: err?.message, code: err?.code ?? null });
	              }
	              // Non-policy errors should still surface as request errors.
	              return sendError(res, 400, "invalid payer agent identity", { message: err?.message });
	            }
	          }
	          let payerWalletExisting = null;
	          try {
	            payerWalletExisting = await getAgentWalletRecord({ tenantId, agentId: payerAgentId });
	          } catch (err) {
	            return sendError(res, 400, "invalid payer wallet query", { message: err?.message });
          }
          let payerWallet = ensureAgentWallet({ wallet: payerWalletExisting, tenantId, agentId: payerAgentId, currency, at: nowAt });
          try {
            if (heldAmountCents > 0) {
              payerWallet = lockAgentWalletEscrow({ wallet: payerWallet, amountCents: heldAmountCents, at: nowAt });
              projectEscrowLedgerOperation({
                tenantId,
                settlement: { currency, payerAgentId, agentId: payeeAgentId },
                operationId: `escrow_hold_tc_${agreementHash}_${receiptHash}`,
                type: ESCROW_OPERATION_TYPE.HOLD,
                amountCents: heldAmountCents,
                at: nowAt,
                payerWalletBefore: payerWalletExisting ?? payerWallet,
                payerWalletAfter: payerWallet,
                memo: `tool_call:${agreementHash}:holdback_lock`
              });
            }
          } catch (err) {
            return sendError(res, 409, "escrow hold rejected", { message: err?.message, code: err?.code ?? null }, { code: err?.code ?? "ESCROW_HOLD_REJECTED" });
          }

          let hold = null;
          try {
            hold = buildFundingHoldV1({
              tenantId,
              agreementHash,
              receiptHash,
              payerAgentId,
              payeeAgentId,
              amountCents,
              heldAmountCents,
              currency,
              holdbackBps,
              challengeWindowMs,
              createdAt: typeof body?.createdAt === "string" && body.createdAt.trim() !== "" ? body.createdAt.trim() : nowAt
            });
          } catch (err) {
            return sendError(res, 400, "invalid hold", { message: err?.message }, { code: "SCHEMA_INVALID" });
          }

          const responseBody = { hold };
          const ops = [
            { kind: "AGENT_WALLET_UPSERT", tenantId, wallet: payerWallet },
            { kind: "TOOL_CALL_HOLD_UPSERT", tenantId, holdHash: hold.holdHash, hold }
          ];
          if (idemStoreKey) {
            ops.push({ kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode: 201, body: responseBody } });
          }
          await commitTx(ops, {
            audit: makeOpsAudit({
              action: "TOOL_CALL_HOLD_LOCK",
              targetType: "tool_call_hold",
              targetId: hold.holdHash,
              details: { agreementHash, receiptHash, payerAgentId, payeeAgentId, amountCents, heldAmountCents, currency, holdbackBps, challengeWindowMs }
            })
          });
          return sendJson(res, 201, responseBody);
        }

        if (parts[1] === "tool-calls" && parts[2] === "holds" && parts.length === 3 && req.method === "GET") {
          if (!requireScope(auth.scopes, OPS_SCOPES.OPS_READ)) return sendError(res, 403, "forbidden");
          let agreementHash = null;
          let status = null;
          let limit = 200;
          let offset = 0;
          try {
            agreementHash = normalizeSha256HashInput(url.searchParams.get("agreementHash"), "agreementHash", { allowNull: true });
          } catch (err) {
            return sendError(res, 400, "invalid agreementHash", { message: err?.message }, { code: "SCHEMA_INVALID" });
          }
          if (typeof url.searchParams.get("status") === "string" && String(url.searchParams.get("status")).trim() !== "") {
            status = String(url.searchParams.get("status")).trim().toLowerCase();
          }
          if (url.searchParams.has("limit")) {
            limit = Number(url.searchParams.get("limit"));
            if (!Number.isSafeInteger(limit) || limit <= 0 || limit > 2000) {
              return sendError(res, 400, "limit must be a positive safe integer within 1..2000", null, { code: "SCHEMA_INVALID" });
            }
          }
          if (url.searchParams.has("offset")) {
            offset = Number(url.searchParams.get("offset"));
            if (!Number.isSafeInteger(offset) || offset < 0) {
              return sendError(res, 400, "offset must be a non-negative safe integer", null, { code: "SCHEMA_INVALID" });
            }
          }
          let holds = [];
          try {
            holds = await listToolCallHoldRecords({ tenantId, agreementHash, status, limit, offset });
          } catch (err) {
            return sendError(res, 501, "tool call holds not supported for this store", { message: err?.message });
          }
          return sendJson(res, 200, {
            ok: true,
            tenantId,
            agreementHash,
            status,
            limit,
            offset,
            holds
          });
        }

        if (parts[1] === "tool-calls" && parts[2] === "replay-evaluate" && parts.length === 3 && req.method === "GET") {
          if (!requireScope(auth.scopes, OPS_SCOPES.OPS_READ)) return sendError(res, 403, "forbidden");
          let agreementHash = null;
          try {
            agreementHash = normalizeSha256HashInput(url.searchParams.get("agreementHash"), "agreementHash", { allowNull: false });
          } catch (err) {
            return sendError(res, 400, "invalid agreementHash", { message: err?.message }, { code: "SCHEMA_INVALID" });
          }

          const nowAt = nowIso();
          const runId = `tc_${agreementHash}`;
          const caseId = `arb_case_tc_${agreementHash}`;
          const adjustmentId = `sadj_agmt_${agreementHash}_holdback`;

          let holds = [];
          try {
            holds = await listToolCallHoldRecords({ tenantId, agreementHash, status: null, limit: 1000, offset: 0 });
          } catch (err) {
            return sendError(res, 501, "tool call holds not supported for this store", { message: err?.message });
          }
          if (!Array.isArray(holds) || holds.length === 0) {
            return sendError(res, 404, "tool call hold not found for agreementHash", null, { code: "TOOL_CALL_HOLD_NOT_FOUND" });
          }
          if (holds.length > 1) {
            return sendError(
              res,
              409,
              "multiple tool-call holds found for agreementHash",
              {
                count: holds.length,
                holdHashes: holds.map((row) => String(row?.holdHash ?? "")).filter(Boolean)
              },
              { code: "TOOL_CALL_REPLAY_HOLD_AMBIGUOUS" }
            );
          }
          const hold = holds[0];

          let holdValid = true;
          let holdValidationError = null;
          try {
            validateFundingHoldV1(hold);
          } catch (err) {
            holdValid = false;
            holdValidationError = err?.message ?? "invalid funding hold";
          }

          let arbitrationCase = null;
          try {
            arbitrationCase = await getArbitrationCaseRecord({ tenantId, caseId });
          } catch (err) {
            return sendError(res, 501, "arbitration cases not supported for this store", { message: err?.message });
          }
          const caseMeta =
            arbitrationCase?.metadata && typeof arbitrationCase.metadata === "object" && !Array.isArray(arbitrationCase.metadata)
              ? arbitrationCase.metadata
              : null;
          const caseBindingsValid = arbitrationCase
            ? Boolean(
                caseMeta &&
                  String(caseMeta.caseType ?? "").toLowerCase() === "tool_call" &&
                  String(caseMeta.agreementHash ?? "").toLowerCase() === agreementHash &&
                  String(caseMeta.receiptHash ?? "").toLowerCase() === String(hold?.receiptHash ?? "").toLowerCase() &&
                  String(caseMeta.holdHash ?? "").toLowerCase() === String(hold?.holdHash ?? "").toLowerCase()
              )
            : true;

          let normalizedCaseStatus = null;
          let caseStatusError = null;
          if (arbitrationCase) {
            try {
              normalizedCaseStatus = normalizeArbitrationCaseStatus(arbitrationCase.status, { fieldName: "arbitrationCase.status" });
            } catch (err) {
              caseStatusError = err?.message ?? "invalid arbitration case status";
            }
          }

          let settlementAdjustment = null;
          try {
            settlementAdjustment = await getSettlementAdjustmentRecord({ tenantId, adjustmentId });
          } catch (err) {
            return sendError(res, 501, "settlement adjustments not supported for this store", { message: err?.message });
          }

          let adjustmentValid = true;
          let adjustmentValidationError = null;
          if (settlementAdjustment) {
            try {
              validateSettlementAdjustmentV1(settlementAdjustment);
            } catch (err) {
              adjustmentValid = false;
              adjustmentValidationError = err?.message ?? "invalid settlement adjustment";
            }
          }
          const adjustmentDeterministicIdMatch = settlementAdjustment ? String(settlementAdjustment.adjustmentId ?? "") === adjustmentId : true;

          const verdictId =
            arbitrationCase && typeof arbitrationCase?.verdictId === "string" && arbitrationCase.verdictId.trim() !== ""
              ? arbitrationCase.verdictId.trim()
              : null;
          const verdictArtifactId = verdictId ? `arbitration_verdict_${verdictId}` : null;
          let arbitrationVerdictArtifact = null;
          let verdictArtifactError = null;
          if (verdictArtifactId) {
            if (typeof store.getArtifact !== "function") {
              verdictArtifactError = "artifacts not supported for this store";
            } else {
              try {
                arbitrationVerdictArtifact = await store.getArtifact({ tenantId, artifactId: verdictArtifactId });
              } catch (err) {
                verdictArtifactError = err?.message ?? "failed to fetch arbitration verdict artifact";
              }
            }
          }
          const verdictArtifactBindingsValid = verdictArtifactId
            ? Boolean(
                arbitrationVerdictArtifact &&
                  String(arbitrationVerdictArtifact?.schemaVersion ?? "") === "ArbitrationVerdict.v1" &&
                  String(arbitrationVerdictArtifact?.caseId ?? "") === String(arbitrationCase?.caseId ?? "") &&
                  String(arbitrationVerdictArtifact?.runId ?? "") === String(arbitrationCase?.runId ?? "") &&
                  String(arbitrationVerdictArtifact?.disputeId ?? "") === String(arbitrationCase?.disputeId ?? "") &&
                  String(arbitrationVerdictArtifact?.settlementId ?? "") === String(arbitrationCase?.settlementId ?? "") &&
                  String(arbitrationVerdictArtifact?.verdictId ?? "") === String(verdictId) &&
                  (!arbitrationCase?.verdictHash ||
                    String(arbitrationVerdictArtifact?.signature?.verdictHash ?? "").toLowerCase() ===
                      String(arbitrationCase?.verdictHash ?? "").toLowerCase())
              )
            : true;

          let stage = "no_dispute";
          if (arbitrationCase) {
            stage = normalizedCaseStatus === ARBITRATION_CASE_STATUS.CLOSED ? "terminal_dispute" : "active_dispute";
          }

          const expected = {
            adjustmentId,
            adjustmentRequired: false,
            adjustmentKind: null,
            adjustmentAmountCents: null,
            holdStatus: null
          };

          if (stage === "active_dispute") {
            expected.adjustmentRequired = false;
            expected.holdStatus = FUNDING_HOLD_STATUS.HELD;
          } else if (stage === "terminal_dispute") {
            const releaseRatePct = Number(arbitrationVerdictArtifact?.releaseRatePct);
            const binaryVerdict = Number.isSafeInteger(releaseRatePct) && (releaseRatePct === 0 || releaseRatePct === 100);
            if (binaryVerdict) {
              expected.adjustmentRequired = true;
              expected.adjustmentKind =
                releaseRatePct === 100 ? SETTLEMENT_ADJUSTMENT_KIND.HOLDBACK_RELEASE : SETTLEMENT_ADJUSTMENT_KIND.HOLDBACK_REFUND;
              expected.adjustmentAmountCents = Number(hold?.heldAmountCents ?? 0);
              expected.holdStatus =
                releaseRatePct === 100 ? FUNDING_HOLD_STATUS.RELEASED : FUNDING_HOLD_STATUS.REFUNDED;
            }
          } else {
            expected.adjustmentRequired = false;
            expected.holdStatus = null;
          }

          const holdStatusMatchesExpected =
            expected.holdStatus === null
              ? true
              : String(hold?.status ?? "").toLowerCase() === String(expected.holdStatus).toLowerCase();

          const adjustmentMatchesExpected = expected.adjustmentRequired
            ? Boolean(
                settlementAdjustment &&
                  String(settlementAdjustment.kind ?? "").toLowerCase() === String(expected.adjustmentKind ?? "").toLowerCase() &&
                  Number(settlementAdjustment.amountCents ?? -1) === Number(expected.adjustmentAmountCents ?? -2) &&
                  String(settlementAdjustment.agreementHash ?? "").toLowerCase() === agreementHash &&
                  String(settlementAdjustment.receiptHash ?? "").toLowerCase() === String(hold?.receiptHash ?? "").toLowerCase() &&
                  String(settlementAdjustment.holdHash ?? "").toLowerCase() === String(hold?.holdHash ?? "").toLowerCase()
              )
            : settlementAdjustment === null;

          const issues = [];
          if (!holdValid) issues.push(`HOLD_INVALID:${holdValidationError ?? "unknown"}`);
          if (!caseBindingsValid) issues.push("CASE_BINDING_INVALID");
          if (caseStatusError) issues.push(`CASE_STATUS_INVALID:${caseStatusError}`);
          if (!adjustmentValid) issues.push(`ADJUSTMENT_INVALID:${adjustmentValidationError ?? "unknown"}`);
          if (!adjustmentDeterministicIdMatch) issues.push("ADJUSTMENT_ID_NOT_DETERMINISTIC");
          if (!verdictArtifactBindingsValid) issues.push("VERDICT_ARTIFACT_BINDING_INVALID");
          if (verdictArtifactError) issues.push(`VERDICT_ARTIFACT_ERROR:${verdictArtifactError}`);
          if (!holdStatusMatchesExpected) issues.push("HOLD_STATUS_MISMATCH");
          if (!adjustmentMatchesExpected) issues.push("ADJUSTMENT_MISMATCH");
          if (stage === "terminal_dispute" && expected.adjustmentRequired !== true) {
            issues.push("TERMINAL_DISPUTE_REPLAY_INCOMPLETE");
          }

          const chainConsistent =
            holdValid &&
            caseBindingsValid &&
            !caseStatusError &&
            adjustmentValid &&
            adjustmentDeterministicIdMatch &&
            verdictArtifactBindingsValid &&
            holdStatusMatchesExpected &&
            adjustmentMatchesExpected &&
            (stage !== "terminal_dispute" || expected.adjustmentRequired === true);

          return sendJson(res, 200, {
            ok: true,
            tenantId,
            agreementHash,
            runId,
            replay: {
              computedAt: nowAt,
              stage,
              expected
            },
            stored: {
              hold,
              arbitrationCase: arbitrationCase ?? null,
              arbitrationVerdictArtifactId: verdictArtifactId,
              arbitrationVerdictArtifact,
              settlementAdjustment
            },
            comparisons: {
              holdValid,
              caseBindingsValid,
              adjustmentValid,
              adjustmentDeterministicIdMatch,
              verdictArtifactBindingsValid,
              holdStatusMatchesExpected,
              adjustmentMatchesExpected,
              chainConsistent
            },
            issues
          });
        }

        if (parts[1] === "tool-calls" && parts[2] === "holds" && parts[3] && parts.length === 4 && req.method === "GET") {
          if (!requireScope(auth.scopes, OPS_SCOPES.OPS_READ)) return sendError(res, 403, "forbidden");
          const holdHash = String(parts[3] ?? "").trim();
          if (!holdHash) return sendError(res, 400, "holdHash is required", null, { code: "SCHEMA_INVALID" });
          let hold = null;
          try {
            hold = await getToolCallHoldRecord({ tenantId, holdHash });
          } catch (err) {
            return sendError(res, 501, "tool call holds not supported for this store", { message: err?.message });
          }
          if (!hold) return sendError(res, 404, "tool call hold not found");
          return sendJson(res, 200, { ok: true, tenantId, hold });
        }

        if (parts[1] === "reputation" && parts[2] === "facts" && parts.length === 3 && req.method === "GET") {
          if (!requireScope(auth.scopes, OPS_SCOPES.OPS_READ)) return sendError(res, 403, "forbidden");
          if (typeof store.listArtifacts !== "function") return sendError(res, 501, "reputation facts not supported for this store");

          const agentIdRaw = typeof url.searchParams.get("agentId") === "string" ? String(url.searchParams.get("agentId")) : "";
          const agentId = agentIdRaw.trim();
          if (!agentId) return sendError(res, 400, "agentId is required", null, { code: "SCHEMA_INVALID" });

          const toolIdRaw = typeof url.searchParams.get("toolId") === "string" ? String(url.searchParams.get("toolId")) : "";
          const toolId = toolIdRaw.trim() !== "" ? toolIdRaw.trim() : null;

          let window = AGENT_REPUTATION_WINDOW.THIRTY_DAYS;
          try {
            window = normalizeReputationFactsWindowInput(url.searchParams.get("window"));
          } catch (err) {
            return sendError(res, 400, "invalid window", { message: err?.message }, { code: "SCHEMA_INVALID" });
          }

          let asOf = nowIso();
          if (typeof url.searchParams.get("asOf") === "string" && String(url.searchParams.get("asOf")).trim() !== "") {
            const parsed = String(url.searchParams.get("asOf")).trim();
            if (!Number.isFinite(Date.parse(parsed))) {
              return sendError(res, 400, "asOf must be an ISO date-time", null, { code: "SCHEMA_INVALID" });
            }
            asOf = new Date(Date.parse(parsed)).toISOString();
          }
          const windowStartAt = reputationWindowStartAt({ window, at: asOf });
          const windowStartMs = windowStartAt ? Date.parse(windowStartAt) : Number.NaN;
          const asOfMs = Date.parse(asOf);
          const includeEvents = String(url.searchParams.get("includeEvents") ?? "").toLowerCase() === "1";

          let records = [];
          try {
            records = await listReputationEventArtifactsBySubject({
              tenantId,
              agentId,
              toolId,
              occurredAtGte: windowStartAt,
              occurredAtLte: asOf,
              pageSize: 5000
            });
          } catch (err) {
            return sendError(res, 500, "failed to list reputation events", { message: err?.message });
          }
          const filtered = [];
          for (const row of records) {
            if (!row || typeof row !== "object" || Array.isArray(row)) continue;
            if (String(row.schemaVersion ?? "") !== REPUTATION_EVENT_SCHEMA_VERSION) continue;
            try {
              validateReputationEventV1(row);
            } catch {
              continue;
            }
            const subject = row.subject && typeof row.subject === "object" && !Array.isArray(row.subject) ? row.subject : null;
            if (!subject) continue;
            if (String(subject.agentId ?? "") !== agentId) continue;
            if (toolId !== null && String(subject.toolId ?? "") !== toolId) continue;
            const occurredAtMs = Date.parse(String(row.occurredAt ?? ""));
            if (!Number.isFinite(occurredAtMs)) continue;
            if (Number.isFinite(asOfMs) && occurredAtMs > asOfMs) continue;
            if (Number.isFinite(windowStartMs) && occurredAtMs < windowStartMs) continue;
            filtered.push(row);
          }
          filtered.sort((left, right) => {
            const leftAtMs = Date.parse(String(left?.occurredAt ?? ""));
            const rightAtMs = Date.parse(String(right?.occurredAt ?? ""));
            if (Number.isFinite(leftAtMs) && Number.isFinite(rightAtMs) && leftAtMs !== rightAtMs) return leftAtMs - rightAtMs;
            return String(left?.eventId ?? "").localeCompare(String(right?.eventId ?? ""));
          });

          const aggregate = computeReputationFactsAggregate({ events: filtered });
          return sendJson(res, 200, {
            ok: true,
            tenantId,
            agentId,
            toolId,
            window,
            asOf,
            windowStartAt,
            facts: aggregate,
            events: includeEvents ? filtered.slice(-200) : undefined
          });
        }

        if (parts[1] === "settlement-adjustments" && parts[2] && parts.length === 3 && req.method === "GET") {
          if (!requireScope(auth.scopes, OPS_SCOPES.OPS_READ)) return sendError(res, 403, "forbidden");
          const adjustmentId = String(parts[2] ?? "").trim();
          if (!adjustmentId) return sendError(res, 400, "adjustmentId is required", null, { code: "SCHEMA_INVALID" });
          let rec = null;
          try {
            rec = await getSettlementAdjustmentRecord({ tenantId, adjustmentId });
          } catch (err) {
            return sendError(res, 500, "failed to fetch settlement adjustment", { message: err?.message });
          }
          if (!rec) return sendError(res, 404, "settlement adjustment not found");
          return sendJson(res, 200, { ok: true, tenantId, adjustment: rec });
        }

        if (parts[1] === "maintenance" && parts[2] === "tool-call-holdback" && parts[3] === "run" && parts.length === 4 && req.method === "POST") {
          if (!requireScope(auth.scopes, OPS_SCOPES.OPS_WRITE)) return sendError(res, 403, "forbidden");
          const body = (await readJsonBody(req)) ?? {};
          const dryRun = body?.dryRun === true;
          const limitRaw = body?.limit ?? body?.maxHolds ?? null;
          const limit = limitRaw === null ? 1000 : Number(limitRaw);
          if (!Number.isSafeInteger(limit) || limit <= 0) return sendError(res, 400, "limit must be a positive safe integer", null, { code: "SCHEMA_INVALID" });

          const nowAt = nowIso();
          let holds = [];
          try {
            holds = await listToolCallHoldRecords({ tenantId, status: FUNDING_HOLD_STATUS.HELD, limit, offset: 0 });
          } catch (err) {
            return sendError(res, 501, "tool call holds not supported for this store", { message: err?.message });
          }

          let attempted = 0;
          let released = 0;
          let blocked = 0;
          let errors = 0;
          const blockedCases = [];

          for (const hold of holds) {
            attempted += 1;
            let parsedHold = hold;
            try {
              validateFundingHoldV1(parsedHold);
            } catch {
              errors += 1;
              continue;
            }
            const createdAtMs = Date.parse(String(parsedHold.createdAt ?? ""));
            const windowMs = Number(parsedHold.challengeWindowMs ?? 0);
            const nowMs = Date.parse(nowAt);
            if (!Number.isFinite(createdAtMs) || !Number.isFinite(nowMs) || nowMs <= createdAtMs + windowMs) continue;

            const runId = `tc_${String(parsedHold.agreementHash ?? "").toLowerCase()}`;
            let cases = [];
            try {
              cases = await listArbitrationCaseRecords({ tenantId, runId, status: null, limit: 1000, offset: 0 });
            } catch {
              cases = [];
            }
            const blocking = (cases ?? []).filter((c) => {
              const meta = c?.metadata && typeof c.metadata === "object" && !Array.isArray(c.metadata) ? c.metadata : null;
              if (!meta) return false;
              if (String(meta.caseType ?? "").toLowerCase() !== "tool_call") return false;
              if (String(c.status ?? "").toLowerCase() === ARBITRATION_CASE_STATUS.CLOSED) return false;
              if (String(meta.holdHash ?? "").toLowerCase() === String(parsedHold.holdHash ?? "").toLowerCase()) return true;
              if (String(meta.receiptHash ?? "").toLowerCase() === String(parsedHold.receiptHash ?? "").toLowerCase()) return true;
              return false;
            });
            if (blocking.length) {
              blocked += 1;
              blockedCases.push({ holdHash: parsedHold.holdHash, caseId: blocking[0]?.caseId ?? null });
              metricInc("tool_call_holdback_auto_release_skipped_total", { reason: "arbitration_case_open" }, 1);
              continue;
            }

            if (dryRun) continue;

            const heldAmountCents = Number(parsedHold.heldAmountCents ?? 0);
            const tenantHoldHash = parsedHold.holdHash;
            if (!Number.isSafeInteger(heldAmountCents) || heldAmountCents < 0) {
              errors += 1;
              continue;
            }

            let payerWalletExisting = null;
            let payeeWalletExisting = null;
            try {
              payerWalletExisting = await getAgentWalletRecord({ tenantId, agentId: parsedHold.payerAgentId });
              payeeWalletExisting = await getAgentWalletRecord({ tenantId, agentId: parsedHold.payeeAgentId });
            } catch {
              errors += 1;
              continue;
            }
            const payerWallet = ensureAgentWallet({
              wallet: payerWalletExisting,
              tenantId,
              agentId: parsedHold.payerAgentId,
              currency: parsedHold.currency,
              at: nowAt
            });
            const payeeWallet = ensureAgentWallet({
              wallet: payeeWalletExisting,
              tenantId,
              agentId: parsedHold.payeeAgentId,
              currency: parsedHold.currency,
              at: nowAt
            });
            let releasedWallets = null;
            try {
              releasedWallets =
                heldAmountCents > 0
                  ? releaseAgentWalletEscrowToPayee({ payerWallet, payeeWallet, amountCents: heldAmountCents, at: nowAt })
                  : { payerWallet, payeeWallet };
            } catch (err) {
              errors += 1;
              logger.warn("tool_call_holdback.auto_release.error", { err: err?.message, code: err?.code ?? null, holdHash: tenantHoldHash });
              continue;
            }
            try {
              if (heldAmountCents > 0) {
                projectEscrowLedgerOperation({
                  tenantId,
                  settlement: { currency: parsedHold.currency, payerAgentId: parsedHold.payerAgentId, agentId: parsedHold.payeeAgentId },
                  operationId: `escrow_release_auto_${tenantHoldHash}`,
                  type: ESCROW_OPERATION_TYPE.RELEASE,
                  amountCents: heldAmountCents,
                  at: nowAt,
                  payerWalletBefore: payerWallet,
                  payerWalletAfter: releasedWallets.payerWallet,
                  payeeWalletBefore: payeeWallet,
                  payeeWalletAfter: releasedWallets.payeeWallet,
                  memo: `tool_call:${parsedHold.agreementHash}:auto_release`
                });
              }
            } catch {}

            const resolvedHold = resolveFundingHoldV1({
              hold: parsedHold,
              status: FUNDING_HOLD_STATUS.RELEASED,
              resolvedAt: nowAt,
              metadata: { autoReleased: true }
            });

            try {
              await commitTx(
                [
                  { kind: "AGENT_WALLET_UPSERT", tenantId, wallet: releasedWallets.payerWallet },
                  { kind: "AGENT_WALLET_UPSERT", tenantId, wallet: releasedWallets.payeeWallet },
                  { kind: "TOOL_CALL_HOLD_UPSERT", tenantId, holdHash: resolvedHold.holdHash, hold: resolvedHold }
                ],
                {
                  audit: makeOpsAudit({
                    action: "TOOL_CALL_HOLD_AUTO_RELEASE",
                    targetType: "tool_call_hold",
                    targetId: resolvedHold.holdHash,
                    details: { agreementHash: resolvedHold.agreementHash, receiptHash: resolvedHold.receiptHash, heldAmountCents }
                  })
                }
              );
              released += 1;
              await emitReputationEventBestEffort(
                {
                  tenantId,
                  eventId: `rep_rel_${String(resolvedHold.agreementHash ?? "").toLowerCase()}`,
                  occurredAt: nowAt,
                  eventKind: REPUTATION_EVENT_KIND.HOLDBACK_AUTO_RELEASED,
                  subject: {
                    agentId: String(resolvedHold.payeeAgentId),
                    toolId: "tool_call",
                    counterpartyAgentId: String(resolvedHold.payerAgentId),
                    role: "payee"
                  },
                  sourceRef: {
                    kind: "funding_hold",
                    sourceId: String(resolvedHold.holdHash ?? ""),
                    hash: String(resolvedHold.holdHash ?? "").trim().toLowerCase() || null,
                    agreementHash: resolvedHold.agreementHash,
                    receiptHash: resolvedHold.receiptHash,
                    holdHash: resolvedHold.holdHash
                  },
                  facts: {
                    amountCents: heldAmountCents,
                    autoReleasedCents: heldAmountCents,
                    amountSettledCents: heldAmountCents
                  }
                },
                { context: "tool_call_holdback.auto_release" }
              );
            } catch (err) {
              errors += 1;
              logger.warn("tool_call_holdback.auto_release.commit_failed", { err: err?.message, code: err?.code ?? null, holdHash: tenantHoldHash });
            }
          }

          return sendJson(res, 200, {
            ok: true,
            tenantId,
            dryRun,
            attempted,
            released,
            blocked,
            errors,
            blockedCases
          });
        }

        if (parts[1] === "arbitration" && parts[2] === "workspace" && parts.length === 3 && req.method === "GET") {
          const hasScope =
            requireScope(auth.scopes, OPS_SCOPES.FINANCE_READ) ||
            requireScope(auth.scopes, OPS_SCOPES.FINANCE_WRITE) ||
            requireScope(auth.scopes, OPS_SCOPES.OPS_READ);
          if (!hasScope) return sendError(res, 403, "forbidden");
          const initialOpsToken = typeof url.searchParams.get("opsToken") === "string" ? url.searchParams.get("opsToken") : "";
          const initialStatus = typeof url.searchParams.get("status") === "string" ? url.searchParams.get("status") : "under_review";
          const initialPriority = typeof url.searchParams.get("priority") === "string" ? url.searchParams.get("priority") : "";
          const initialRunId = typeof url.searchParams.get("runId") === "string" ? url.searchParams.get("runId") : "";
          const initialCaseId = typeof url.searchParams.get("caseId") === "string" ? url.searchParams.get("caseId") : "";
          const initialSlaHours = typeof url.searchParams.get("slaHours") === "string" ? url.searchParams.get("slaHours") : "24";
          const html = [
            "<!doctype html>",
            "<html><head><meta charset=\"utf-8\"/>",
            "<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\"/>",
            "<title>Arbitration Operator Workspace</title>",
            "<style>",
            ":root{--bg:#f4f1ea;--card:#fffaf2;--ink:#1f1300;--muted:#5a5145;--line:#e4d8c4;--warn:#b25e00;--good:#0f766e;--bad:#b42318;--brand:#0f5f8c}",
            "*{box-sizing:border-box} body{margin:0;font:14px/1.5 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;background:linear-gradient(120deg,#fdf8ef,#f4f1ea 45%,#eef6fb);color:var(--ink)}",
            ".wrap{max-width:1300px;margin:0 auto;padding:18px} .row{display:flex;gap:10px;flex-wrap:wrap;align-items:flex-end}",
            ".card{background:var(--card);border:1px solid var(--line);border-radius:14px;padding:14px;box-shadow:0 8px 24px rgba(30,20,0,.06)}",
            "h1{margin:0 0 6px;font-size:26px} h2{margin:0 0 8px;font-size:18px}",
            ".muted{color:var(--muted)} .status{padding:8px 10px;border-radius:10px;background:#f1e7d7;border:1px solid var(--line)}",
            ".status.good{background:#d9f3f0;border-color:#9ed9d2;color:#0a4c46} .status.warn{background:#fff3dc;border-color:#f4cc89;color:#7a4300} .status.bad{background:#ffe2df;border-color:#f2b1a8;color:#8f1f15}",
            ".field{display:flex;flex-direction:column;gap:4px;min-width:160px;flex:1} .field.small{max-width:160px;flex:0 0 160px}",
            "input,select,textarea,button{font:inherit} input,select,textarea{width:100%;padding:8px 10px;border-radius:10px;border:1px solid #c6b79e;background:white;color:var(--ink)}",
            "textarea{min-height:150px;resize:vertical} button{padding:8px 12px;border-radius:10px;border:1px solid #b9a37b;background:#f6dfb8;color:#3f2a00;cursor:pointer}",
            "button.secondary{background:#eef2f7;border-color:#b7c5da;color:#1f3b61} button.warn{background:#ffe8c5;border-color:#efc073;color:#734100} button.danger{background:#ffdeda;border-color:#e8a4a0;color:#7c1f17}",
            "button:disabled{opacity:.55;cursor:not-allowed} .split{display:grid;grid-template-columns:1.1fr .9fr;gap:12px;margin-top:12px}",
            "table{width:100%;border-collapse:collapse} th,td{text-align:left;padding:8px;border-bottom:1px solid #eadfcf;vertical-align:top} tbody tr:hover{background:#f8efe2}",
            ".tag{display:inline-block;padding:2px 8px;border-radius:999px;font-size:12px;border:1px solid #d8c6a8;background:#f9ebd1;color:#4d3500}",
            ".tag.good{background:#d9f3f0;border-color:#9ed9d2;color:#0a4c46} .tag.warn{background:#fff3dc;border-color:#f4cc89;color:#7a4300} .tag.bad{background:#ffe2df;border-color:#f2b1a8;color:#8f1f15}",
            ".list{margin:0;padding-left:18px} .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace} pre{margin:0;background:#fff;border:1px solid #dbcbb2;border-radius:10px;padding:10px;overflow:auto}",
            "@media (max-width: 980px){.split{grid-template-columns:1fr}}",
            "</style></head><body><div class=\"wrap\" id=\"arbitrationWorkspaceRoot\">",
            "<h1>Arbitration Operator Workspace</h1>",
            "<div class=\"muted\">Queue-first arbitration operations with case detail, evidence timeline, and ruling actions.</div>",
            "<div class=\"card\" style=\"margin-top:12px\">",
            "<div class=\"row\">",
            "<div class=\"field\"><div class=\"muted\">Tenant ID</div><input id=\"tenantIdInput\"/></div>",
            "<div class=\"field\"><div class=\"muted\">Ops token</div><input id=\"opsTokenInput\" type=\"password\" placeholder=\"tok_finr or tok_finw\"/></div>",
            "<div class=\"field small\"><div class=\"muted\">Protocol</div><input id=\"protocolInput\"/></div>",
            "<div class=\"field small\"><div class=\"muted\">SLA hours</div><input id=\"slaHoursInput\" type=\"number\" min=\"1\" max=\"8760\"/></div>",
            "</div>",
            "<div class=\"row\" style=\"margin-top:8px\">",
            "<div class=\"field small\"><div class=\"muted\">Status</div><select id=\"statusFilter\"><option value=\"\">all</option><option value=\"open\">open</option><option value=\"under_review\">under_review</option><option value=\"verdict_issued\">verdict_issued</option><option value=\"closed\">closed</option></select></div>",
            "<div class=\"field small\"><div class=\"muted\">Priority</div><select id=\"priorityFilter\"><option value=\"\">all</option><option value=\"high\">high</option><option value=\"normal\">normal</option><option value=\"low\">low</option></select></div>",
            "<div class=\"field\"><div class=\"muted\">Run ID</div><input id=\"runIdFilter\" placeholder=\"run_...\"/></div>",
            "<div class=\"field\"><div class=\"muted\">Case ID</div><input id=\"caseIdFilter\" placeholder=\"arb_case_...\"/></div>",
            "<div class=\"field small\"><label><input id=\"assignedArbiterFilter\" type=\"checkbox\"/> assigned only</label></div>",
            "<div class=\"field small\"><button id=\"refreshQueueBtn\">Refresh queue</button></div>",
            "</div>",
            "<div id=\"queueStatus\" class=\"status\" style=\"margin-top:10px\">Loading queue...</div>",
            "</div>",
            "<div class=\"split\">",
            "<section class=\"card\">",
            "<h2>Queue</h2>",
            "<div style=\"overflow:auto\"><table id=\"arbitrationQueueTable\"><thead><tr><th>Case</th><th>Status</th><th>Priority</th><th>Age</th><th>Due</th><th>Arbiter</th><th>Actions</th></tr></thead><tbody id=\"arbitrationQueueBody\"></tbody></table></div>",
            "</section>",
            "<section class=\"card\" id=\"arbitrationCasePanel\">",
            "<h2>Case Detail</h2>",
            "<div id=\"caseStatus\" class=\"status\">Select a case from the queue.</div>",
            "<div style=\"margin-top:10px\" class=\"row\">",
            "<button class=\"secondary\" id=\"reloadCaseBtn\">Reload case</button>",
            "<button class=\"secondary\" id=\"clearCaseBtn\">Clear selection</button>",
            "</div>",
            "<div style=\"margin-top:10px\"><div class=\"muted\">Overview</div><pre id=\"caseOverview\" class=\"mono\">{}</pre></div>",
            "<div style=\"margin-top:10px\"><div class=\"muted\">Settlement snapshot</div><pre id=\"arbitrationSettlement\" class=\"mono\">{}</pre></div>",
            "<div style=\"margin-top:10px\"><div class=\"muted\">Timeline</div><ul id=\"arbitrationEvidenceTimeline\" class=\"list\"></ul></div>",
            "<div style=\"margin-top:10px\"><div class=\"muted\">Evidence refs</div><ul id=\"arbitrationEvidenceRefs\" class=\"list\"></ul></div>",
            "<div style=\"margin-top:10px\"><div class=\"muted\">Related cases</div><ul id=\"arbitrationRelatedCases\" class=\"list\"></ul></div>",
            "<div style=\"margin-top:10px\"><div class=\"muted\">Appeal chain</div><ul id=\"arbitrationAppealChain\" class=\"list\"></ul></div>",
            "<div style=\"margin-top:10px\"><div class=\"muted\">Audit and export links</div><ul id=\"arbitrationAuditLinks\" class=\"list\"></ul></div>",
            "</section>",
            "</div>",
            "<div class=\"split\" style=\"margin-top:12px\">",
            "<section class=\"card\">",
            "<h2>Ruling Actions</h2>",
            "<div class=\"row\">",
            "<div class=\"field\"><div class=\"muted\">Assign arbiter</div><input id=\"assignArbiterAgentId\" placeholder=\"agt_arbiter\"/></div>",
            "<div class=\"field small\"><button id=\"assignArbiterBtn\">Assign</button></div>",
            "</div>",
            "<div class=\"row\" style=\"margin-top:8px\">",
            "<div class=\"field\"><div class=\"muted\">Add evidence ref</div><input id=\"evidenceRefInput\" placeholder=\"obj://... or evidence://...\"/></div>",
            "<div class=\"field small\"><button id=\"addEvidenceBtn\">Add evidence</button></div>",
            "</div>",
            "<div style=\"margin-top:10px\"><div class=\"muted\">Issue verdict (paste signed arbitrationVerdict JSON)</div><textarea id=\"verdictJson\" class=\"mono\" placeholder='{\"caseId\":\"...\",\"arbiterAgentId\":\"...\",\"outcome\":\"accepted\",\"releaseRatePct\":100,\"rationale\":\"...\",\"evidenceRefs\":[\"...\"],\"signerKeyId\":\"...\",\"signature\":\"...\"}'></textarea></div>",
            "<div class=\"row\" style=\"margin-top:8px\"><button class=\"secondary\" id=\"fillVerdictTemplateBtn\">Fill template</button><button class=\"warn\" id=\"submitVerdictBtn\">Submit verdict</button></div>",
            "<div class=\"row\" style=\"margin-top:10px\">",
            "<div class=\"field\"><div class=\"muted\">Close summary (optional)</div><input id=\"closeSummaryInput\" placeholder=\"finalized after verdict\"/></div>",
            "<div class=\"field small\"><button class=\"danger\" id=\"closeCaseBtn\">Close case</button></div>",
            "</div>",
            "<div class=\"row\" style=\"margin-top:10px\">",
            "<div class=\"field\"><div class=\"muted\">Appeal case ID (optional)</div><input id=\"appealCaseIdInput\" placeholder=\"arb_case_appeal_...\"/></div>",
            "<div class=\"field\"><div class=\"muted\">Appeal reason (optional)</div><input id=\"appealReasonInput\" placeholder=\"why this verdict should be re-reviewed\"/></div>",
            "<div class=\"field small\"><button class=\"warn\" id=\"openAppealBtn\">Open appeal</button></div>",
            "</div>",
            "<div id=\"actionStatus\" class=\"status\" style=\"margin-top:10px\">No action yet.</div>",
            "</section>",
            "<section class=\"card\">",
            "<h2>Usage Notes</h2>",
            "<ul class=\"list\">",
            "<li>Use a token with `finance_write` or `ops_write` for ruling actions.</li>",
            "<li>`Submit verdict` requires a fully signed `arbitrationVerdict` payload.</li>",
            "<li>All write actions include `x-settld-protocol` and unique idempotency keys.</li>",
            "<li>Queue ordering follows over-SLA first, then oldest opened case.</li>",
            "<li>`Open appeal` is available after verdict issuance while dispute window remains open.</li>",
            "</ul>",
            "</section>",
            "</div>",
            "<script>",
            `const INITIAL = ${JSON.stringify({
              tenantId,
              opsToken: initialOpsToken,
              protocol: protocolPolicy.current,
              filters: {
                status: initialStatus,
                priority: initialPriority,
                runId: initialRunId,
                caseId: initialCaseId,
                slaHours: initialSlaHours
              }
            })};`,
            "const state = { queue: [], selectedCase: null, caseDetail: null, settlement: null, workspace: null };",
            "function byId(id){ return document.getElementById(id); }",
            "function setText(id, text){ const el=byId(id); if(el) el.textContent=String(text ?? ''); }",
            "function setStatus(id, text, kind){ const el=byId(id); if(!el) return; el.className='status'+(kind?(' '+kind):''); el.textContent=String(text ?? ''); }",
            "function fmt(v){ return (typeof v==='string' && v.trim()) ? v : 'n/a'; }",
            "function fmtHours(value){ const n = Number(value); return Number.isFinite(n) ? n.toFixed(2) : 'n/a'; }",
            "function headers({ write=false, json=false } = {}){ const h = { 'x-proxy-tenant-id': String(byId('tenantIdInput').value || '').trim() }; const tok = String(byId('opsTokenInput').value || '').trim(); if(tok) h['x-proxy-ops-token'] = tok; if(write) h['x-settld-protocol'] = String(byId('protocolInput').value || '').trim() || INITIAL.protocol; if(json) h['content-type']='application/json'; return h; }",
            "async function requestJson(path, { method='GET', body=null, write=false, idem=null } = {}){ const h = headers({ write, json: body!==null }); if(idem) h['x-idempotency-key']=idem; const res = await fetch(path, { method, headers:h, body: body===null ? undefined : JSON.stringify(body) }); const txt = await res.text(); let j = null; try { j = txt ? JSON.parse(txt) : null; } catch {} if(!res.ok){ const msg = (j && (j.message || j.error)) ? (j.message || j.error) : (txt || ('HTTP '+res.status)); throw new Error(msg); } return j; }",
            "function queueQuery(){ const q = new URLSearchParams(); const status = String(byId('statusFilter').value || '').trim(); const priority = String(byId('priorityFilter').value || '').trim(); const runId = String(byId('runIdFilter').value || '').trim(); const caseId = String(byId('caseIdFilter').value || '').trim(); const slaHours = String(byId('slaHoursInput').value || '').trim(); const assigned = byId('assignedArbiterFilter').checked; if(status) q.set('status', status); if(priority) q.set('priority', priority); if(runId) q.set('runId', runId); if(caseId) q.set('caseId', caseId); if(assigned) q.set('assignedArbiter', 'true'); if(slaHours) q.set('slaHours', slaHours); return q.toString(); }",
            "function renderQueue(){ const body = byId('arbitrationQueueBody'); if(!body) return; body.innerHTML=''; if(!state.queue.length){ body.innerHTML='<tr><td colspan=\"7\" class=\"muted\">No arbitration cases for the selected filters.</td></tr>'; return; } for(const item of state.queue){ const tr = document.createElement('tr'); const statusTag = item.overSla ? '<span class=\"tag bad\">over_sla</span>' : '<span class=\"tag good\">within_sla</span>'; tr.innerHTML = `<td><div class=\\\"mono\\\">${item.caseId || 'n/a'}</div><div class=\\\"muted mono\\\">${item.runId || 'n/a'}</div></td><td><span class=\\\"tag\\\">${item.status || 'n/a'}</span> ${statusTag}</td><td>${item.priority || 'n/a'}</td><td>${fmtHours(item.ageHours)}h</td><td class=\\\"mono\\\">${fmt(item.dueAt)}</td><td class=\\\"mono\\\">${fmt(item.arbiterAgentId)}</td><td><button class=\\\"secondary\\\" type=\\\"button\\\">Open</button></td>`; tr.querySelector('button').addEventListener('click', ()=>openCase(item)); body.appendChild(tr); } }",
            "function roleTag(currentCaseId, currentAppealParentId, row){ const rowCaseId = String(row && row.caseId ? row.caseId : '').trim(); const rowParentCaseId = String(row && row.appealRef && row.appealRef.parentCaseId ? row.appealRef.parentCaseId : '').trim(); if(!rowCaseId) return { label:'related', kind:'' }; if(rowCaseId === currentCaseId) return { label:'current', kind:'good' }; if(currentAppealParentId && rowCaseId === currentAppealParentId) return { label:'parent', kind:'warn' }; if(rowParentCaseId && rowParentCaseId === currentCaseId) return { label:'appeal', kind:'' }; return { label:'related', kind:'' }; }",
	            "function toAuditLinkRows(links){ if(!links || typeof links !== 'object') return []; const specs = [['Run settlement packet', links.runSettlement], ['Settlement policy replay', links.runSettlementPolicyReplay], ['Settlement replay evaluate', links.runSettlementReplayEvaluate], ['Run arbitration cases', links.runArbitrationCases], ['Selected arbitration case', links.selectedArbitrationCase], ['Ops audit stream', links.opsAudit], ['Monthly settlement export (template)', links.settlementsExportTemplate], ['Arbitration case artifact status', links.arbitrationCaseArtifactStatus], ['Arbitration verdict artifact status', links.arbitrationVerdictArtifactStatus]]; return specs.filter((entry)=>typeof entry[1] === 'string' && entry[1].trim() !== ''); }",
            "function renderCase(){",
            "  const ws = state.workspace && typeof state.workspace === 'object' ? state.workspace : null;",
            "  const c = ws && ws.arbitrationCase ? ws.arbitrationCase : (state.caseDetail && state.caseDetail.arbitrationCase ? state.caseDetail.arbitrationCase : null);",
            "  const actionability = ws && ws.actionability && typeof ws.actionability === 'object' ? ws.actionability : null;",
            "  const canWrite = actionability ? actionability.canWrite === true : true;",
            "  if(!c){",
            "    setStatus('caseStatus', 'Select a case from the queue.', '');",
            "    setText('caseOverview', '{}');",
            "    setText('arbitrationSettlement', '{}');",
            "    byId('arbitrationEvidenceTimeline').innerHTML='';",
            "    byId('arbitrationEvidenceRefs').innerHTML='';",
            "    byId('arbitrationRelatedCases').innerHTML='';",
            "    byId('arbitrationAppealChain').innerHTML='';",
            "    byId('arbitrationAuditLinks').innerHTML='';",
            "    byId('assignArbiterBtn').disabled = true;",
            "    byId('addEvidenceBtn').disabled = true;",
            "    byId('submitVerdictBtn').disabled = true;",
            "    byId('closeCaseBtn').disabled = true;",
            "    byId('openAppealBtn').disabled = true;",
            "    return;",
            "  }",
            "  const settlementView = ws && ws.settlement ? ws.settlement : (state.settlement || {});",
            "  setStatus('caseStatus', `Loaded case ${c.caseId} for run ${c.runId}.`, c.status === 'closed' ? 'bad' : (c.status === 'verdict_issued' ? 'warn' : 'good'));",
            "  setText('caseOverview', JSON.stringify(c, null, 2));",
            "  setText('arbitrationSettlement', JSON.stringify(settlementView || {}, null, 2));",
            "  const timeline = byId('arbitrationEvidenceTimeline');",
            "  const timelineRows = Array.isArray(ws && ws.timeline ? ws.timeline : null) ? ws.timeline : [];",
            "  if(timelineRows.length){",
            "    timeline.innerHTML = timelineRows.map((row)=>{ const source = row && row.source ? ` <span class=\\\"tag\\\">${row.source}</span>` : ''; const details = row && row.details && typeof row.details === 'object' ? ` <div class=\\\"mono muted\\\">${JSON.stringify(row.details)}</div>` : ''; return `<li><span class=\\\"mono\\\">${row.eventType || 'event'}</span> <span class=\\\"mono\\\">${fmt(row.at)}</span>${source}${details}</li>`; }).join('');",
            "  } else {",
            "    const fallback = [];",
            "    fallback.push({ eventType:'arbitration.opened', at: c.openedAt });",
            "    fallback.push({ eventType:'arbitration.updated', at: c.updatedAt });",
            "    if(c.closedAt) fallback.push({ eventType:'arbitration.closed', at: c.closedAt });",
            "    if(state.selectedCase && state.selectedCase.dueAt) fallback.push({ eventType:'dispute.window_ends', at: state.selectedCase.dueAt });",
            "    timeline.innerHTML = fallback.map((row)=>`<li><span class=\\\"mono\\\">${row.eventType}</span> <span class=\\\"mono\\\">${fmt(row.at)}</span></li>`).join('');",
            "  }",
            "  const ev = byId('arbitrationEvidenceRefs');",
            "  const refs = ws && ws.evidenceRefs && Array.isArray(ws.evidenceRefs.all) ? ws.evidenceRefs.all : (Array.isArray(c.evidenceRefs) ? c.evidenceRefs : []);",
            "  ev.innerHTML = refs.length ? refs.map((ref)=>`<li class=\\\"mono\\\">${ref}</li>`).join('') : '<li class=\"muted\">No evidence refs.</li>';",
            "  const relatedEl = byId('arbitrationRelatedCases');",
            "  const relatedCases = Array.isArray(ws && ws.relatedCases ? ws.relatedCases : null) ? ws.relatedCases : [];",
            "  const currentCaseId = String(c.caseId || '').trim();",
            "  const currentAppealParentId = String(c && c.appealRef && c.appealRef.parentCaseId ? c.appealRef.parentCaseId : '').trim();",
            "  if(relatedCases.length){",
            "    relatedEl.innerHTML = relatedCases.map((row)=>{ const rowCaseId = String(row.caseId || '').trim(); const role = roleTag(currentCaseId, currentAppealParentId, row); const roleClass = role.kind ? ` ${role.kind}` : ''; const disabled = rowCaseId === currentCaseId ? 'disabled' : ''; const label = rowCaseId === currentCaseId ? 'Selected' : 'Open'; return `<li><span class=\\\"tag${roleClass}\\\">${role.label}</span> <span class=\\\"mono\\\">${row.caseId || 'n/a'}</span> <span class=\\\"muted\\\">${row.status || 'n/a'}  due ${fmt(row.dueAt)}</span> <button class=\\\"secondary\\\" type=\\\"button\\\" data-case-id=\\\"${String(row.caseId || '')}\\\" ${disabled}>${label}</button></li>`; }).join('');",
            "    relatedEl.querySelectorAll('button[data-case-id]').forEach((btn)=>{ btn.addEventListener('click', ()=>{ const targetCaseId = String(btn.getAttribute('data-case-id') || '').trim(); if(!targetCaseId || targetCaseId === currentCaseId) return; const target = relatedCases.find((row)=>String(row.caseId || '') === targetCaseId); if(target) openCase(target); }); });",
            "  } else {",
            "    relatedEl.innerHTML = '<li class=\"muted\">No related cases.</li>';",
            "  }",
            "  const appealChainEl = byId('arbitrationAppealChain');",
            "  const appealChain = ws && ws.appealChain && typeof ws.appealChain === 'object' ? ws.appealChain : null;",
            "  const parentCaseId = String((appealChain && appealChain.parentCaseId) || '').trim();",
            "  const childCaseIds = appealChain && Array.isArray(appealChain.childCaseIds) ? appealChain.childCaseIds.map((value)=>String(value || '').trim()).filter((value)=>value) : [];",
            "  const uniqueChildren = [...new Set(childCaseIds.filter((value)=>value !== currentCaseId))];",
            "  const chainRows = [];",
            "  if(parentCaseId) chainRows.push(`<li><span class=\\\"tag warn\\\">parent</span> <span class=\\\"mono\\\">${parentCaseId}</span></li>`);",
            "  chainRows.push(`<li><span class=\\\"tag good\\\">current</span> <span class=\\\"mono\\\">${currentCaseId || 'n/a'}</span></li>`);",
            "  uniqueChildren.forEach((childCaseId)=>{ chainRows.push(`<li><span class=\\\"tag\\\">appeal</span> <span class=\\\"mono\\\">${childCaseId}</span></li>`); });",
            "  appealChainEl.innerHTML = chainRows.length ? chainRows.join('') : '<li class=\"muted\">No appeal relations.</li>';",
            "  const auditLinksEl = byId('arbitrationAuditLinks');",
            "  const linkRows = toAuditLinkRows(ws && ws.links ? ws.links : null);",
            "  auditLinksEl.innerHTML = linkRows.length ? linkRows.map(([label, href])=>`<li><a class=\\\"mono\\\" href=\\\"${href}\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">${label}</a></li>`).join('') : '<li class=\"muted\">No audit/export links available.</li>';",
            "  byId('assignArbiterBtn').disabled = !(canWrite && (!actionability || actionability.canAssignArbiter === true));",
            "  byId('addEvidenceBtn').disabled = !(canWrite && (!actionability || actionability.canAddEvidence === true));",
            "  byId('submitVerdictBtn').disabled = !(canWrite && (!actionability || actionability.canSubmitVerdict === true));",
            "  byId('closeCaseBtn').disabled = !(canWrite && (!actionability || actionability.canCloseCase === true));",
            "  byId('openAppealBtn').disabled = !(canWrite && (!actionability || actionability.canOpenAppeal === true));",
            "}",
            "async function loadQueue(){ setStatus('queueStatus', 'Loading queue...', ''); try { const query = queueQuery(); const out = await requestJson(`/ops/arbitration/queue${query ? ('?'+query) : ''}`); state.queue = Array.isArray(out.queue) ? out.queue : []; renderQueue(); setStatus('queueStatus', `Loaded ${state.queue.length} case(s); overSla=${Number(out.overSlaCount || 0)}.`, Number(out.overSlaCount || 0) > 0 ? 'warn' : 'good'); if(state.selectedCase){ const next = state.queue.find((row)=>String(row.caseId)===String(state.selectedCase.caseId) && String(row.runId)===String(state.selectedCase.runId)); if(next){ await openCase(next, { silent: true }); } } } catch (err){ setStatus('queueStatus', `Queue load failed: ${err.message}`, 'bad'); } }",
            "async function openCase(item, opts = {}){ state.selectedCase = item || null; if(!item){ state.caseDetail = null; state.settlement = null; state.workspace = null; renderCase(); return; } const caseId = String(item.caseId || '').trim(); if(!caseId){ setStatus('caseStatus', 'Selected row missing caseId.', 'bad'); return; } if(!opts.silent) setStatus('caseStatus', `Loading ${caseId}...`, ''); try { const q = new URLSearchParams(); const slaHours = String(byId('slaHoursInput').value || '').trim(); if(slaHours) q.set('slaHours', slaHours); const ws = await requestJson(`/ops/arbitration/cases/${encodeURIComponent(caseId)}/workspace${q.toString() ? ('?' + q.toString()) : ''}`); state.workspace = ws && typeof ws === 'object' ? ws : null; state.caseDetail = state.workspace && state.workspace.arbitrationCase ? { runId: state.workspace.runId || null, arbitrationCase: state.workspace.arbitrationCase } : null; state.settlement = state.workspace && state.workspace.settlement ? state.workspace.settlement : null; if(state.workspace && state.workspace.queueItem && typeof state.workspace.queueItem === 'object'){ state.selectedCase = state.workspace.queueItem; } renderCase(); } catch (err){ setStatus('caseStatus', `Case load failed: ${err.message}`, 'bad'); } }",
            "function idem(action){ return `arb_ws_${action}_${Date.now()}_${Math.random().toString(16).slice(2,10)}`; }",
            "async function runAction(action, payload){ const ws = state.workspace && typeof state.workspace === 'object' ? state.workspace : null; const c = ws && ws.arbitrationCase ? ws.arbitrationCase : (state.caseDetail && state.caseDetail.arbitrationCase ? state.caseDetail.arbitrationCase : null); const actionability = ws && ws.actionability && typeof ws.actionability === 'object' ? ws.actionability : null; if(!c){ setStatus('actionStatus', 'Select a case first.', 'bad'); return; } if(actionability && actionability.canWrite !== true){ setStatus('actionStatus', 'Current token is read-only for arbitration actions.', 'bad'); return; } const required = action === 'assign' ? 'canAssignArbiter' : action === 'evidence' ? 'canAddEvidence' : action === 'verdict' ? 'canSubmitVerdict' : action === 'close' ? 'canCloseCase' : action === 'appeal' ? 'canOpenAppeal' : null; if(required && actionability && actionability[required] !== true){ setStatus('actionStatus', `${action} is not allowed in current case state.`, 'bad'); return; } const runId = String(c.runId || '').trim(); const caseId = String(c.caseId || '').trim(); if(!runId || !caseId){ setStatus('actionStatus', 'Selected case is missing runId/caseId.', 'bad'); return; } const bodyPayload = payload && typeof payload === 'object' ? payload : {}; const body = action === 'appeal' ? { ...bodyPayload } : { caseId, ...bodyPayload }; setStatus('actionStatus', `${action} in progress...`, ''); try { const out = await requestJson(`/runs/${encodeURIComponent(runId)}/arbitration/${encodeURIComponent(action)}`, { method:'POST', body, write:true, idem: idem(action) }); const status = out && out.arbitrationCase && out.arbitrationCase.status ? out.arbitrationCase.status : 'ok'; setStatus('actionStatus', `${action} success (status=${status}).`, 'good'); await loadQueue(); const targetCaseId = action === 'appeal' ? String(out?.arbitrationCase?.caseId || '').trim() : caseId; const refreshed = state.queue.find((row)=>String(row.caseId)===String(targetCaseId)); await openCase(refreshed || { caseId: targetCaseId || caseId, runId }, { silent: true }); } catch (err){ setStatus('actionStatus', `${action} failed: ${err.message}`, 'bad'); } }",
            "function fillVerdictTemplate(){ const ws = state.workspace && typeof state.workspace === 'object' ? state.workspace : null; const c = ws && ws.arbitrationCase ? ws.arbitrationCase : (state.caseDetail && state.caseDetail.arbitrationCase ? state.caseDetail.arbitrationCase : null); if(!c){ setStatus('actionStatus', 'Select a case before filling verdict template.', 'bad'); return; } const template = { caseId: c.caseId, verdictId: c.verdictId || '', arbiterAgentId: c.arbiterAgentId || '', outcome: 'accepted', releaseRatePct: 100, rationale: c.summary || 'Arbitration decision rationale', evidenceRefs: Array.isArray(c.evidenceRefs) ? c.evidenceRefs : [], signerKeyId: c?.metadata?.verdictSignerKeyId || '', signature: '', issuedAt: new Date().toISOString() }; byId('verdictJson').value = JSON.stringify(template, null, 2); }",
            "byId('tenantIdInput').value = String(INITIAL.tenantId || 'tenant_default');",
            "byId('opsTokenInput').value = String(INITIAL.opsToken || '');",
            "byId('protocolInput').value = String(INITIAL.protocol || '');",
            "byId('statusFilter').value = String(INITIAL.filters.status || '');",
            "byId('priorityFilter').value = String(INITIAL.filters.priority || '');",
            "byId('runIdFilter').value = String(INITIAL.filters.runId || '');",
            "byId('caseIdFilter').value = String(INITIAL.filters.caseId || '');",
            "byId('slaHoursInput').value = String(INITIAL.filters.slaHours || '24');",
            "byId('refreshQueueBtn').addEventListener('click', ()=>loadQueue());",
            "byId('reloadCaseBtn').addEventListener('click', ()=>openCase(state.selectedCase));",
            "byId('clearCaseBtn').addEventListener('click', ()=>{ state.selectedCase=null; state.caseDetail=null; state.settlement=null; state.workspace=null; byId('appealCaseIdInput').value=''; byId('appealReasonInput').value=''; renderCase(); });",
            "byId('assignArbiterBtn').addEventListener('click', ()=>{ const arbiterAgentId = String(byId('assignArbiterAgentId').value || '').trim(); if(!arbiterAgentId){ setStatus('actionStatus','arbiterAgentId is required','bad'); return; } runAction('assign', { arbiterAgentId }); });",
            "byId('addEvidenceBtn').addEventListener('click', ()=>{ const evidenceRef = String(byId('evidenceRefInput').value || '').trim(); if(!evidenceRef){ setStatus('actionStatus','evidenceRef is required','bad'); return; } runAction('evidence', { evidenceRef }); });",
            "byId('fillVerdictTemplateBtn').addEventListener('click', ()=>fillVerdictTemplate());",
            "byId('submitVerdictBtn').addEventListener('click', ()=>{ const raw = String(byId('verdictJson').value || '').trim(); if(!raw){ setStatus('actionStatus','verdict JSON is required','bad'); return; } let verdict = null; try { verdict = JSON.parse(raw); } catch { setStatus('actionStatus','verdict JSON is invalid','bad'); return; } runAction('verdict', { arbitrationVerdict: verdict }); });",
            "byId('closeCaseBtn').addEventListener('click', ()=>{ const summaryRaw = String(byId('closeSummaryInput').value || '').trim(); const payload = summaryRaw ? { summary: summaryRaw } : {}; runAction('close', payload); });",
            "byId('openAppealBtn').addEventListener('click', ()=>{ const ws = state.workspace && typeof state.workspace === 'object' ? state.workspace : null; const c = ws && ws.arbitrationCase ? ws.arbitrationCase : (state.caseDetail && state.caseDetail.arbitrationCase ? state.caseDetail.arbitrationCase : null); if(!c || !c.caseId){ setStatus('actionStatus','Select a case before opening appeal','bad'); return; } const caseIdRaw = String(byId('appealCaseIdInput').value || '').trim(); const reasonRaw = String(byId('appealReasonInput').value || '').trim(); const payload = { parentCaseId: c.caseId }; if(caseIdRaw) payload.caseId = caseIdRaw; if(reasonRaw) payload.reason = reasonRaw; runAction('appeal', payload); });",
            "renderCase();",
            "loadQueue();",
            "</script>",
            "</div></body></html>"
          ].join("\n");
          return sendText(res, 200, html, { contentType: "text/html; charset=utf-8" });
        }

        if (parts[1] === "marketplace" && parts[2] === "workspace" && parts.length === 3 && req.method === "GET") {
          const hasScope = requireScope(auth.scopes, OPS_SCOPES.OPS_READ) || requireScope(auth.scopes, OPS_SCOPES.OPS_WRITE);
          if (!hasScope) return sendError(res, 403, "forbidden");
          const initialOpsToken = typeof url.searchParams.get("opsToken") === "string" ? url.searchParams.get("opsToken") : "";
          const initialRfqStatus = typeof url.searchParams.get("rfqStatus") === "string" ? url.searchParams.get("rfqStatus") : "open";
          const initialCapability = typeof url.searchParams.get("capability") === "string" ? url.searchParams.get("capability") : "";
          const html = [
            "<!doctype html>",
            "<html><head><meta charset=\"utf-8\"/>",
            "<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\"/>",
            "<title>Marketplace Workspace</title>",
            "<style>",
            ":root{--bg:#eef6f6;--card:#ffffff;--ink:#102a34;--muted:#3f5c66;--line:#c9dde2;--accent:#136f8a;--good:#157347;--warn:#9a5a00;--bad:#a92938}",
            "*{box-sizing:border-box} body{margin:0;font:14px/1.5 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;background:radial-gradient(1200px 500px at 0% 0%,#dff2f5,transparent),linear-gradient(150deg,#f7fbfc,#edf5f6);color:var(--ink)}",
            ".wrap{max-width:1450px;margin:0 auto;padding:18px} .row{display:flex;gap:10px;flex-wrap:wrap;align-items:flex-end}",
            ".card{background:var(--card);border:1px solid var(--line);border-radius:14px;padding:14px;box-shadow:0 8px 24px rgba(9,48,61,.06)}",
            "h1{margin:0 0 6px;font-size:28px} h2{margin:0 0 8px;font-size:18px}",
            ".muted{color:var(--muted)} .status{padding:8px 10px;border-radius:10px;background:#edf4f6;border:1px solid var(--line)}",
            ".status.good{background:#ddf3e9;border-color:#9bcdb3;color:#0f5435} .status.warn{background:#fff1de;border-color:#f2c78e;color:#7b4500} .status.bad{background:#ffe2e6;border-color:#efafba;color:#8b1f2c}",
            ".field{display:flex;flex-direction:column;gap:4px;min-width:160px;flex:1} .field.small{max-width:180px;flex:0 0 180px}",
            "input,select,textarea,button{font:inherit} input,select,textarea{width:100%;padding:8px 10px;border-radius:10px;border:1px solid #b9ced5;background:#fff;color:var(--ink)} textarea{min-height:120px;resize:vertical}",
            "button{padding:8px 12px;border-radius:10px;border:1px solid #9ec0ca;background:#e7f3f7;color:#16485b;cursor:pointer} button.secondary{background:#f0f4f6;border-color:#c5d2d8;color:#2a4d59} button.warn{background:#ffe8cc;border-color:#ebb66f;color:#6f4000} button.danger{background:#ffdce1;border-color:#e9a4b0;color:#7b1e2a}",
            ".split{display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-top:12px} table{width:100%;border-collapse:collapse} th,td{text-align:left;padding:8px;border-bottom:1px solid #e2edf0;vertical-align:top} tbody tr:hover{background:#f3f9fa}",
            ".tag{display:inline-block;padding:2px 8px;border-radius:999px;font-size:12px;border:1px solid #b9d0d8;background:#ebf4f7;color:#24576a}",
            ".tag.open,.tag.active{background:#ddf3e9;border-color:#9bcdb3;color:#0f5435} .tag.assigned,.tag.paused{background:#fff1de;border-color:#f2c78e;color:#7b4500} .tag.closed,.tag.retired,.tag.cancelled{background:#ffe2e6;border-color:#efafba;color:#8b1f2c}",
            ".mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace} pre{margin:0;background:#fbfeff;border:1px solid #d7e7eb;border-radius:10px;padding:10px;overflow:auto}",
            "@media (max-width: 1080px){.split{grid-template-columns:1fr}}",
            "</style></head><body><div class=\"wrap\" id=\"marketplaceWorkspaceRoot\">",
            "<h1>Marketplace Operator Workspace</h1>",
            "<div class=\"muted\">Capability listings, RFQ creation, bidding, and acceptance in one operational flow.</div>",
            "<div class=\"card\" style=\"margin-top:12px\">",
            "<div class=\"row\">",
            "<div class=\"field\"><div class=\"muted\">Tenant ID</div><input id=\"tenantIdInput\"/></div>",
            "<div class=\"field\"><div class=\"muted\">Ops token</div><input id=\"opsTokenInput\" type=\"password\" placeholder=\"tok_opsr or tok_opsw\"/></div>",
            "<div class=\"field small\"><div class=\"muted\">Protocol</div><input id=\"protocolInput\"/></div>",
            "<div class=\"field small\"><div class=\"muted\">RFQ status</div><select id=\"rfqStatusFilter\"><option value=\"all\">all</option><option value=\"open\">open</option><option value=\"assigned\">assigned</option><option value=\"closed\">closed</option><option value=\"cancelled\">cancelled</option></select></div>",
            "<div class=\"field\"><div class=\"muted\">Capability filter</div><input id=\"capabilityFilter\" placeholder=\"translate\"/></div>",
            "</div>",
            "<div class=\"row\" style=\"margin-top:10px\">",
            "<button id=\"refreshWorkspaceBtn\">Refresh workspace</button>",
            "<button class=\"secondary\" id=\"refreshListingsBtn\">Refresh listings</button>",
            "<button class=\"secondary\" id=\"refreshRfqsBtn\">Refresh RFQs</button>",
            "<button class=\"secondary\" id=\"refreshBidsBtn\">Refresh bids</button>",
            "</div>",
            "<div id=\"workspaceStatus\" class=\"status\" style=\"margin-top:10px\">Loading workspace...</div>",
            "</div>",
            "<div class=\"split\">",
            "<section class=\"card\">",
            "<h2>Capability Listings</h2>",
            "<div style=\"overflow:auto\"><table id=\"capabilityListingTable\"><thead><tr><th>Listing</th><th>Capability</th><th>Seller</th><th>Status</th><th>Price</th><th>Actions</th></tr></thead><tbody id=\"capabilityListingBody\"></tbody></table></div>",
            "<div id=\"listingStatus\" class=\"status\" style=\"margin-top:10px\">No listing action yet.</div>",
            "</section>",
            "<section class=\"card\">",
            "<h2>Create Capability Listing</h2>",
            "<div class=\"row\">",
            "<div class=\"field\"><div class=\"muted\">Listing ID (optional)</div><input id=\"listingIdInput\" placeholder=\"cap.translate.pro\"/></div>",
            "<div class=\"field\"><div class=\"muted\">Capability</div><input id=\"listingCapabilityInput\" value=\"translate\"/></div>",
            "<div class=\"field\"><div class=\"muted\">Title</div><input id=\"listingTitleInput\" value=\"Premium Translation\"/></div>",
            "</div>",
            "<div class=\"row\" style=\"margin-top:8px\">",
            "<div class=\"field\"><div class=\"muted\">Seller agent ID (optional)</div><input id=\"listingSellerAgentIdInput\" placeholder=\"agt_supplier_1\"/></div>",
            "<div class=\"field small\"><div class=\"muted\">Status</div><select id=\"listingStatusInput\"><option value=\"active\">active</option><option value=\"paused\">paused</option><option value=\"retired\">retired</option></select></div>",
            "<div class=\"field small\"><div class=\"muted\">Price mode</div><select id=\"listingPriceModeInput\"><option value=\"fixed\">fixed</option><option value=\"hourly\">hourly</option><option value=\"per_unit\">per_unit</option><option value=\"quote\">quote</option></select></div>",
            "<div class=\"field small\"><div class=\"muted\">Amount cents</div><input id=\"listingAmountCentsInput\" type=\"number\" min=\"1\" value=\"12000\"/></div>",
            "<div class=\"field small\"><div class=\"muted\">Currency</div><input id=\"listingCurrencyInput\" value=\"USD\"/></div>",
            "</div>",
            "<div style=\"margin-top:8px\"><div class=\"muted\">Description</div><textarea id=\"listingDescriptionInput\" placeholder=\"Coverage, SLAs, and qualification scope\"></textarea></div>",
            "<div class=\"row\" style=\"margin-top:8px\">",
            "<button id=\"createCapabilityListingBtn\">Save capability listing</button>",
            "<button class=\"danger\" id=\"deleteCapabilityListingBtn\">Delete selected listing</button>",
            "</div>",
            "</section>",
            "</div>",
            "<div class=\"split\" style=\"margin-top:12px\">",
            "<section class=\"card\">",
            "<h2>RFQ Queue</h2>",
            "<div style=\"overflow:auto\"><table id=\"marketplaceRfqTable\"><thead><tr><th>RFQ</th><th>Capability</th><th>Status</th><th>Budget</th><th>Poster</th><th>Actions</th></tr></thead><tbody id=\"rfqQueueBody\"></tbody></table></div>",
            "<div id=\"rfqStatus\" class=\"status\" style=\"margin-top:10px\">No RFQ action yet.</div>",
            "</section>",
            "<section class=\"card\">",
            "<h2>Create RFQ</h2>",
            "<div class=\"row\">",
            "<div class=\"field\"><div class=\"muted\">RFQ ID (optional)</div><input id=\"rfqTaskIdInput\" placeholder=\"rfq_001\"/></div>",
            "<div class=\"field\"><div class=\"muted\">Title</div><input id=\"rfqTitleInput\" value=\"Translate supplier compliance packet\"/></div>",
            "<div class=\"field\"><div class=\"muted\">Capability listing</div><select id=\"rfqCapabilityListingSelect\"></select></div>",
            "</div>",
            "<div class=\"row\" style=\"margin-top:8px\">",
            "<div class=\"field\"><div class=\"muted\">Capability override</div><input id=\"rfqCapabilityInput\" placeholder=\"translate\"/></div>",
            "<div class=\"field\"><div class=\"muted\">Poster agent ID</div><input id=\"rfqPosterAgentIdInput\" placeholder=\"agt_buyer_ops\"/></div>",
            "<div class=\"field small\"><div class=\"muted\">Budget cents</div><input id=\"rfqBudgetCentsInput\" type=\"number\" min=\"1\" value=\"15000\"/></div>",
            "<div class=\"field small\"><div class=\"muted\">Currency</div><input id=\"rfqCurrencyInput\" value=\"USD\"/></div>",
            "</div>",
            "<div style=\"margin-top:8px\"><div class=\"muted\">Description</div><textarea id=\"rfqDescriptionInput\" placeholder=\"RFQ scope and acceptance criteria\"></textarea></div>",
            "<div class=\"row\" style=\"margin-top:8px\"><button id=\"createRfqBtn\">Create RFQ</button></div>",
            "</section>",
            "</div>",
            "<div class=\"split\" style=\"margin-top:12px\">",
            "<section class=\"card\">",
            "<h2>Bid Queue</h2>",
            "<div class=\"row\">",
            "<div class=\"field\"><div class=\"muted\">Selected RFQ</div><input id=\"selectedRfqIdInput\" placeholder=\"rfq_...\"/></div>",
            "<div class=\"field\"><div class=\"muted\">Selected bid</div><input id=\"selectedBidIdInput\" placeholder=\"bid_...\"/></div>",
            "</div>",
            "<div style=\"overflow:auto;margin-top:8px\"><table id=\"marketplaceBidTable\"><thead><tr><th>Bid</th><th>Bidder</th><th>Amount</th><th>Status</th><th>ETA</th><th>Actions</th></tr></thead><tbody id=\"bidQueueBody\"></tbody></table></div>",
            "<div id=\"bidStatus\" class=\"status\" style=\"margin-top:10px\">No bid action yet.</div>",
            "</section>",
            "<section class=\"card\">",
            "<h2>Bid Actions</h2>",
            "<div class=\"row\">",
            "<div class=\"field\"><div class=\"muted\">Bid ID (optional)</div><input id=\"bidIdInput\" placeholder=\"bid_offer_1\"/></div>",
            "<div class=\"field\"><div class=\"muted\">Bidder agent ID</div><input id=\"bidderAgentIdInput\" placeholder=\"agt_supplier_1\"/></div>",
            "<div class=\"field small\"><div class=\"muted\">Amount cents</div><input id=\"bidAmountCentsInput\" type=\"number\" min=\"1\" value=\"12000\"/></div>",
            "<div class=\"field small\"><div class=\"muted\">ETA seconds</div><input id=\"bidEtaSecondsInput\" type=\"number\" min=\"1\" value=\"7200\"/></div>",
            "</div>",
            "<div class=\"row\" style=\"margin-top:8px\">",
            "<div class=\"field small\"><div class=\"muted\">Bid currency</div><input id=\"bidCurrencyInput\" value=\"USD\"/></div>",
            "<div class=\"field\"><div class=\"muted\">Bid note</div><input id=\"bidNoteInput\" placeholder=\"Delivery within 2 hours\"/></div>",
            "</div>",
            "<div class=\"row\" style=\"margin-top:8px\">",
            "<button id=\"submitBidBtn\">Submit bid</button>",
            "<button class=\"warn\" id=\"acceptBidBtn\">Accept selected bid</button>",
            "</div>",
            "<div class=\"row\" style=\"margin-top:8px\">",
            "<div class=\"field\"><div class=\"muted\">Payer agent ID</div><input id=\"acceptPayerAgentIdInput\" placeholder=\"agt_buyer_ops\"/></div>",
            "<div class=\"field\"><div class=\"muted\">Accepted by agent ID (optional)</div><input id=\"acceptByAgentIdInput\" placeholder=\"agt_buyer_ops\"/></div>",
            "</div>",
            "<div style=\"margin-top:10px\"><div class=\"muted\">Latest acceptance payload</div><pre id=\"acceptanceDetail\" class=\"mono\">{}</pre></div>",
            "</section>",
            "</div>",
            "<script>",
            `const INITIAL = ${JSON.stringify({
              tenantId,
              opsToken: initialOpsToken,
              protocol: protocolPolicy.current,
              rfqStatus: initialRfqStatus,
              capability: initialCapability
            })};`,
            "const state = { listings: [], rfqs: [], bids: [], selectedListingId: '', selectedRfqId: '', selectedBidId: '' };",
            "function byId(id){ return document.getElementById(id); }",
            "function setText(id, text){ const el = byId(id); if(el) el.textContent = String(text ?? ''); }",
            "function setStatus(id, text, kind){ const el = byId(id); if(!el) return; el.className = 'status' + (kind ? (' ' + kind) : ''); el.textContent = String(text ?? ''); }",
            "function tag(value){ const v = String(value || 'n/a').toLowerCase(); return `<span class=\\\"tag ${v}\\\">${v}</span>`; }",
            "function headers({ write = false, json = false } = {}){ const h = { 'x-proxy-tenant-id': String(byId('tenantIdInput').value || '').trim() }; const tok = String(byId('opsTokenInput').value || '').trim(); if(tok) h['x-proxy-ops-token'] = tok; if(write) h['x-settld-protocol'] = String(byId('protocolInput').value || '').trim() || INITIAL.protocol; if(json) h['content-type'] = 'application/json'; return h; }",
            "async function requestJson(path, { method='GET', body=null, write=false, idem=null } = {}){ const h = headers({ write, json: body !== null }); if(idem) h['x-idempotency-key'] = idem; const res = await fetch(path, { method, headers: h, body: body === null ? undefined : JSON.stringify(body) }); const txt = await res.text(); let j = null; try { j = txt ? JSON.parse(txt) : null; } catch {} if(!res.ok){ throw new Error((j && (j.message || j.error)) ? (j.message || j.error) : (txt || ('HTTP ' + res.status))); } return j; }",
            "function idem(prefix){ return `mkt_ws_${prefix}_${Date.now()}_${Math.random().toString(16).slice(2,10)}`; }",
            "function selectedRfq(){ const id = String(state.selectedRfqId || '').trim(); return state.rfqs.find((row)=>String(row.rfqId||'')===id) || null; }",
            "function selectedBid(){ const id = String(state.selectedBidId || '').trim(); return state.bids.find((row)=>String(row.bidId||'')===id) || null; }",
            "function fillListingSelect(){ const sel = byId('rfqCapabilityListingSelect'); if(!sel) return; sel.innerHTML = ''; const blank = document.createElement('option'); blank.value=''; blank.textContent='(none)'; sel.appendChild(blank); for(const listing of state.listings){ const opt = document.createElement('option'); opt.value = String(listing.listingId || ''); opt.textContent = `${listing.listingId} | ${listing.capability} | ${listing.status}`; sel.appendChild(opt); } if(state.selectedListingId) sel.value = state.selectedListingId; }",
            "function renderListings(){ const body = byId('capabilityListingBody'); body.innerHTML = ''; if(!state.listings.length){ body.innerHTML = '<tr><td colspan=\"6\" class=\"muted\">No capability listings.</td></tr>'; fillListingSelect(); return; } for(const listing of state.listings){ const tr = document.createElement('tr'); const price = listing.priceModel && typeof listing.priceModel === 'object' ? `${listing.priceModel.mode || 'n/a'}:${listing.priceModel.amountCents || 'n/a'} ${listing.priceModel.currency || ''}` : 'n/a'; tr.innerHTML = `<td><div class=\\\"mono\\\">${listing.listingId}</div><div class=\\\"muted\\\">${listing.title || ''}</div></td><td>${listing.capability || 'n/a'}</td><td class=\\\"mono\\\">${listing.sellerAgentId || 'n/a'}</td><td>${tag(listing.status)}</td><td class=\\\"mono\\\">${price}</td><td><button class=\\\"secondary\\\" type=\\\"button\\\">Select</button></td>`; tr.querySelector('button').addEventListener('click', ()=>{ state.selectedListingId = String(listing.listingId || ''); byId('listingIdInput').value = state.selectedListingId; byId('listingCapabilityInput').value = String(listing.capability || ''); byId('listingTitleInput').value = String(listing.title || ''); byId('listingSellerAgentIdInput').value = String(listing.sellerAgentId || ''); byId('listingStatusInput').value = String(listing.status || 'active'); byId('listingDescriptionInput').value = String(listing.description || ''); fillListingSelect(); }); body.appendChild(tr); } fillListingSelect(); }",
            "function renderRfqs(){ const body = byId('rfqQueueBody'); body.innerHTML = ''; if(!state.rfqs.length){ body.innerHTML = '<tr><td colspan=\"6\" class=\"muted\">No RFQs for current filter.</td></tr>'; return; } for(const rfq of state.rfqs){ const tr = document.createElement('tr'); tr.innerHTML = `<td><div class=\\\"mono\\\">${rfq.rfqId}</div><div class=\\\"muted\\\">${rfq.title || ''}</div></td><td>${rfq.capability || 'n/a'}</td><td>${tag(rfq.status)}</td><td class=\\\"mono\\\">${rfq.budgetCents || 'n/a'} ${rfq.currency || ''}</td><td class=\\\"mono\\\">${rfq.posterAgentId || 'n/a'}</td><td><button class=\\\"secondary\\\" type=\\\"button\\\">Open bids</button></td>`; tr.querySelector('button').addEventListener('click', async()=>{ state.selectedRfqId = String(rfq.rfqId || ''); byId('selectedRfqIdInput').value = state.selectedRfqId; await loadBids(); }); body.appendChild(tr); } }",
            "function renderBids(){ const body = byId('bidQueueBody'); body.innerHTML = ''; if(!state.selectedRfqId){ body.innerHTML = '<tr><td colspan=\"6\" class=\"muted\">Select an RFQ first.</td></tr>'; return; } if(!state.bids.length){ body.innerHTML = '<tr><td colspan=\"6\" class=\"muted\">No bids for selected RFQ.</td></tr>'; return; } for(const bid of state.bids){ const tr = document.createElement('tr'); tr.innerHTML = `<td class=\\\"mono\\\">${bid.bidId}</td><td class=\\\"mono\\\">${bid.bidderAgentId || 'n/a'}</td><td class=\\\"mono\\\">${bid.amountCents || 'n/a'} ${bid.currency || ''}</td><td>${tag(bid.status)}</td><td class=\\\"mono\\\">${bid.etaSeconds || 'n/a'}</td><td><button class=\\\"secondary\\\" type=\\\"button\\\">Select</button></td>`; tr.querySelector('button').addEventListener('click', ()=>{ state.selectedBidId = String(bid.bidId || ''); byId('selectedBidIdInput').value = state.selectedBidId; }); body.appendChild(tr); } }",
            "async function loadListings(){ const capability = String(byId('capabilityFilter').value || '').trim(); const q = new URLSearchParams(); q.set('status', 'all'); if(capability) q.set('capability', capability); q.set('limit', '200'); q.set('offset', '0'); const out = await requestJson(`/marketplace/capability-listings?${q.toString()}`); state.listings = Array.isArray(out.listings) ? out.listings : []; renderListings(); return out; }",
            "async function loadRfqs(){ const status = String(byId('rfqStatusFilter').value || '').trim() || 'all'; const capability = String(byId('capabilityFilter').value || '').trim(); const q = new URLSearchParams(); q.set('status', status); if(capability) q.set('capability', capability); q.set('limit', '200'); q.set('offset', '0'); const out = await requestJson(`/marketplace/rfqs?${q.toString()}`); state.rfqs = Array.isArray(out.rfqs) ? out.rfqs : []; renderRfqs(); return out; }",
            "async function loadBids(){ const rfqId = String(state.selectedRfqId || byId('selectedRfqIdInput').value || '').trim(); if(!rfqId){ state.bids = []; renderBids(); return null; } state.selectedRfqId = rfqId; byId('selectedRfqIdInput').value = rfqId; const out = await requestJson(`/marketplace/rfqs/${encodeURIComponent(rfqId)}/bids?status=all&limit=200&offset=0`); state.bids = Array.isArray(out.bids) ? out.bids : []; renderBids(); return out; }",
            "async function loadWorkspace(){ setStatus('workspaceStatus', 'Loading marketplace workspace...', ''); try { await Promise.all([loadListings(), loadRfqs()]); await loadBids(); setStatus('workspaceStatus', `Loaded listings=${state.listings.length}, rfqs=${state.rfqs.length}, bids=${state.bids.length}.`, 'good'); } catch (err) { setStatus('workspaceStatus', `Load failed: ${err.message}`, 'bad'); } }",
            "async function createListing(){ const listingId = String(byId('listingIdInput').value || '').trim(); const body = { listingId: listingId || undefined, capability: String(byId('listingCapabilityInput').value || '').trim(), title: String(byId('listingTitleInput').value || '').trim() || undefined, sellerAgentId: String(byId('listingSellerAgentIdInput').value || '').trim() || null, status: String(byId('listingStatusInput').value || 'active').trim(), description: String(byId('listingDescriptionInput').value || '').trim() || null, priceModel: { mode: String(byId('listingPriceModeInput').value || 'fixed').trim(), amountCents: Number(byId('listingAmountCentsInput').value || 0) || null, currency: String(byId('listingCurrencyInput').value || 'USD').trim().toUpperCase() || 'USD' } }; setStatus('listingStatus', 'Saving capability listing...', ''); try { const out = await requestJson('/marketplace/capability-listings', { method:'POST', body, write:true, idem: idem('listing') }); state.selectedListingId = String(out?.listing?.listingId || listingId || ''); setStatus('listingStatus', `Listing saved: ${state.selectedListingId || 'n/a'}.`, 'good'); await loadListings(); } catch (err) { setStatus('listingStatus', `Save failed: ${err.message}`, 'bad'); } }",
            "async function deleteListing(){ const listingId = String(state.selectedListingId || byId('listingIdInput').value || '').trim(); if(!listingId){ setStatus('listingStatus', 'Select a listing first.', 'bad'); return; } setStatus('listingStatus', `Deleting ${listingId}...`, ''); try { await requestJson(`/marketplace/capability-listings/${encodeURIComponent(listingId)}`, { method:'DELETE', idem: idem('listing_delete') }); state.selectedListingId = ''; byId('listingIdInput').value = ''; setStatus('listingStatus', `Deleted listing ${listingId}.`, 'good'); await loadListings(); } catch (err) { setStatus('listingStatus', `Delete failed: ${err.message}`, 'bad'); } }",
            "async function createRfq(){ const listingId = String(byId('rfqCapabilityListingSelect').value || '').trim(); const listing = listingId ? state.listings.find((row)=>String(row.listingId||'') === listingId) : null; const capability = String(byId('rfqCapabilityInput').value || '').trim() || String(listing?.capability || '').trim(); const body = { rfqId: String(byId('rfqTaskIdInput').value || '').trim() || undefined, title: String(byId('rfqTitleInput').value || '').trim() || capability, description: String(byId('rfqDescriptionInput').value || '').trim() || null, capability, posterAgentId: String(byId('rfqPosterAgentIdInput').value || '').trim() || null, budgetCents: Number(byId('rfqBudgetCentsInput').value || 0) || null, currency: String(byId('rfqCurrencyInput').value || 'USD').trim().toUpperCase() || 'USD', metadata: listingId ? { capabilityListingId: listingId } : null }; setStatus('rfqStatus', 'Creating RFQ...', ''); try { const out = await requestJson('/marketplace/rfqs', { method:'POST', body, write:true, idem: idem('rfq') }); state.selectedRfqId = String(out?.rfq?.rfqId || ''); byId('selectedRfqIdInput').value = state.selectedRfqId; setStatus('rfqStatus', `RFQ created: ${state.selectedRfqId || 'n/a'}.`, 'good'); await loadRfqs(); await loadBids(); } catch (err) { setStatus('rfqStatus', `RFQ create failed: ${err.message}`, 'bad'); } }",
            "async function submitBid(){ const rfqId = String(state.selectedRfqId || byId('selectedRfqIdInput').value || '').trim(); if(!rfqId){ setStatus('bidStatus', 'Select an RFQ first.', 'bad'); return; } state.selectedRfqId = rfqId; const body = { bidId: String(byId('bidIdInput').value || '').trim() || undefined, bidderAgentId: String(byId('bidderAgentIdInput').value || '').trim(), amountCents: Number(byId('bidAmountCentsInput').value || 0), currency: String(byId('bidCurrencyInput').value || 'USD').trim().toUpperCase() || 'USD', etaSeconds: Number(byId('bidEtaSecondsInput').value || 0) || null, note: String(byId('bidNoteInput').value || '').trim() || null }; setStatus('bidStatus', `Submitting bid for ${rfqId}...`, ''); try { const out = await requestJson(`/marketplace/rfqs/${encodeURIComponent(rfqId)}/bids`, { method:'POST', body, write:true, idem: idem('bid') }); state.selectedBidId = String(out?.bid?.bidId || ''); byId('selectedBidIdInput').value = state.selectedBidId; setStatus('bidStatus', `Bid submitted: ${state.selectedBidId || 'n/a'}.`, 'good'); await loadBids(); } catch (err) { setStatus('bidStatus', `Bid submit failed: ${err.message}`, 'bad'); } }",
            "async function acceptBid(){ const rfqId = String(state.selectedRfqId || byId('selectedRfqIdInput').value || '').trim(); const bidId = String(state.selectedBidId || byId('selectedBidIdInput').value || '').trim(); if(!rfqId || !bidId){ setStatus('bidStatus', 'Select both RFQ and bid first.', 'bad'); return; } const payerAgentId = String(byId('acceptPayerAgentIdInput').value || '').trim(); if(!payerAgentId){ setStatus('bidStatus', 'payerAgentId is required for acceptance.', 'bad'); return; } const acceptedByAgentId = String(byId('acceptByAgentIdInput').value || '').trim(); const body = { bidId, payerAgentId, acceptedByAgentId: acceptedByAgentId || null, settlement: { payerAgentId } }; setStatus('bidStatus', `Accepting ${bidId}...`, ''); try { const out = await requestJson(`/marketplace/rfqs/${encodeURIComponent(rfqId)}/accept`, { method:'POST', body, write:true, idem: idem('accept') }); setStatus('bidStatus', `Accepted bid ${bidId}. run=${out?.run?.id || out?.run?.runId || 'n/a'}.`, 'good'); setText('acceptanceDetail', JSON.stringify(out, null, 2)); await loadRfqs(); await loadBids(); } catch (err) { setStatus('bidStatus', `Accept failed: ${err.message}`, 'bad'); } }",
            "byId('tenantIdInput').value = String(INITIAL.tenantId || 'tenant_default');",
            "byId('opsTokenInput').value = String(INITIAL.opsToken || '');",
            "byId('protocolInput').value = String(INITIAL.protocol || '');",
            "byId('rfqStatusFilter').value = String(INITIAL.rfqStatus || 'open');",
            "byId('capabilityFilter').value = String(INITIAL.capability || '');",
            "byId('refreshWorkspaceBtn').addEventListener('click', ()=>loadWorkspace());",
            "byId('refreshListingsBtn').addEventListener('click', async()=>{ try { await loadListings(); setStatus('workspaceStatus', 'Listings refreshed.', 'good'); } catch (err) { setStatus('workspaceStatus', `Refresh failed: ${err.message}`, 'bad'); } });",
            "byId('refreshRfqsBtn').addEventListener('click', async()=>{ try { await loadRfqs(); setStatus('workspaceStatus', 'RFQs refreshed.', 'good'); } catch (err) { setStatus('workspaceStatus', `Refresh failed: ${err.message}`, 'bad'); } });",
            "byId('refreshBidsBtn').addEventListener('click', async()=>{ try { await loadBids(); setStatus('workspaceStatus', 'Bids refreshed.', 'good'); } catch (err) { setStatus('workspaceStatus', `Refresh failed: ${err.message}`, 'bad'); } });",
            "byId('createCapabilityListingBtn').addEventListener('click', ()=>createListing());",
            "byId('deleteCapabilityListingBtn').addEventListener('click', ()=>deleteListing());",
            "byId('createRfqBtn').addEventListener('click', ()=>createRfq());",
            "byId('submitBidBtn').addEventListener('click', ()=>submitBid());",
            "byId('acceptBidBtn').addEventListener('click', ()=>acceptBid());",
            "byId('selectedRfqIdInput').addEventListener('change', async (e)=>{ state.selectedRfqId = String(e.target && e.target.value ? e.target.value : '').trim(); await loadBids(); });",
            "byId('selectedBidIdInput').addEventListener('change', (e)=>{ state.selectedBidId = String(e.target && e.target.value ? e.target.value : '').trim(); });",
            "loadWorkspace();",
            "</script>",
            "</div></body></html>"
          ].join("\n");
          return sendText(res, 200, html, { contentType: "text/html; charset=utf-8" });
        }

        if (parts[1] === "kernel" && parts[2] === "workspace" && parts.length === 3 && req.method === "GET") {
          const hasScope = requireScope(auth.scopes, OPS_SCOPES.OPS_READ) || requireScope(auth.scopes, OPS_SCOPES.OPS_WRITE);
          if (!hasScope) return sendError(res, 403, "forbidden");
          const initialOpsToken = typeof url.searchParams.get("opsToken") === "string" ? url.searchParams.get("opsToken") : "";
          const initialRunId = typeof url.searchParams.get("runId") === "string" ? url.searchParams.get("runId") : "";
          const initialAgreementHash = typeof url.searchParams.get("agreementHash") === "string" ? url.searchParams.get("agreementHash") : "";
          const html = [
            "<!doctype html>",
            "<html><head><meta charset=\"utf-8\"/>",
            "<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\"/>",
            "<title>Kernel Explorer</title>",
            "<style>",
            ":root{--bg:#f6f3ef;--card:#ffffff;--ink:#1c1a17;--muted:#5f554d;--line:#e2d8cf;--accent:#b24b2a;--good:#157347;--warn:#9a5a00;--bad:#a92938}",
            "*{box-sizing:border-box} body{margin:0;font:14px/1.5 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;background:radial-gradient(1000px 480px at 0% 0%,#f7e9df,transparent),linear-gradient(160deg,#fbfaf8,#f4efe9);color:var(--ink)}",
            ".wrap{max-width:1400px;margin:0 auto;padding:18px} .row{display:flex;gap:10px;flex-wrap:wrap;align-items:flex-end}",
            ".card{background:var(--card);border:1px solid var(--line);border-radius:14px;padding:14px;box-shadow:0 10px 28px rgba(20,10,6,.06)}",
            "h1{margin:0 0 6px;font-size:28px} h2{margin:0 0 8px;font-size:18px}",
            ".muted{color:var(--muted)} .status{padding:8px 10px;border-radius:10px;background:#f6f1ec;border:1px solid var(--line)}",
            ".status.good{background:#ddf3e9;border-color:#9bcdb3;color:#0f5435} .status.warn{background:#fff1de;border-color:#f2c78e;color:#7b4500} .status.bad{background:#ffe2e6;border-color:#efafba;color:#8b1f2c}",
            ".field{display:flex;flex-direction:column;gap:4px;min-width:170px;flex:1} .field.small{max-width:200px;flex:0 0 200px}",
            "input,textarea,button{font:inherit} input,textarea{width:100%;padding:8px 10px;border-radius:10px;border:1px solid #d5c7bb;background:#fff;color:var(--ink)} textarea{min-height:80px;resize:vertical}",
            "button{padding:8px 12px;border-radius:10px;border:1px solid #d1b4a8;background:#f7e9e3;color:#5b2a1b;cursor:pointer} button.secondary{background:#f2f1ef;border-color:#d7d0c8;color:#3b312a}",
            ".split{display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-top:12px} pre{margin:0;background:#fffdfb;border:1px solid #eadfd6;border-radius:10px;padding:10px;overflow:auto}",
            ".mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace}",
            "@media (max-width: 1080px){.split{grid-template-columns:1fr}}",
            "</style></head><body><div class=\"wrap\">",
            "<h1>Kernel Explorer</h1>",
            "<div class=\"muted\">Inspect the artifact chain and replay outcomes. This is an ops workspace, not a public UI.</div>",
            "<div class=\"card\" style=\"margin-top:12px\">",
            "<div class=\"row\">",
            "<div class=\"field\"><div class=\"muted\">Tenant ID</div><input id=\"tenantIdInput\"/></div>",
            "<div class=\"field\"><div class=\"muted\">Ops token</div><input id=\"opsTokenInput\" type=\"password\" placeholder=\"tok_opsr or tok_opsw\"/></div>",
            "<div class=\"field small\"><div class=\"muted\">Protocol</div><input id=\"protocolInput\"/></div>",
            "</div>",
            "<div id=\"workspaceStatus\" class=\"status\" style=\"margin-top:10px\">Ready.</div>",
            "</div>",
            "<div class=\"split\">",
            "<section class=\"card\">",
            "<h2>Marketplace Run</h2>",
            "<div class=\"row\">",
            "<div class=\"field\"><div class=\"muted\">runId</div><input id=\"runIdInput\" placeholder=\"run_...\"/></div>",
            "<div class=\"field small\"><button id=\"loadRunBtn\">Load run chain</button></div>",
            "</div>",
            "<div class=\"row\" style=\"margin-top:10px\">",
            "<div class=\"field\"><div class=\"muted\">Agreement</div><pre id=\"runAgreement\" class=\"mono\">{}</pre></div>",
            "</div>",
            "<div class=\"row\" style=\"margin-top:10px\">",
            "<div class=\"field\"><div class=\"muted\">Settlement</div><pre id=\"runSettlement\" class=\"mono\">{}</pre></div>",
            "</div>",
            "<div class=\"row\" style=\"margin-top:10px\">",
            "<div class=\"field\"><div class=\"muted\">Arbitration cases</div><pre id=\"runCases\" class=\"mono\">{}</pre></div>",
            "</div>",
	            "<div class=\"row\" style=\"margin-top:10px\">",
	            "<div class=\"field\"><div class=\"muted\">Policy replay</div><pre id=\"runReplay\" class=\"mono\">{}</pre></div>",
	            "</div>",
	            "<div class=\"row\" style=\"margin-top:10px\">",
	            "<div class=\"field\"><div class=\"muted\">Replay evaluate</div><pre id=\"runReplayEvaluate\" class=\"mono\">{}</pre></div>",
	            "</div>",
	            "</section>",
            "<section class=\"card\">",
            "<h2>Tool Call Agreement</h2>",
            "<div class=\"row\">",
            "<div class=\"field\"><div class=\"muted\">agreementHash (sha256 hex)</div><input id=\"agreementHashInput\" placeholder=\"aabbcc...\"/></div>",
            "<div class=\"field small\"><button id=\"loadToolCallBtn\">Load tool-call chain</button></div>",
            "</div>",
            "<div class=\"row\" style=\"margin-top:10px\">",
            "<div class=\"field\"><div class=\"muted\">Holds</div><pre id=\"toolCallHolds\" class=\"mono\">{}</pre></div>",
            "</div>",
            "<div class=\"row\" style=\"margin-top:10px\">",
            "<div class=\"field\"><div class=\"muted\">Arbitration cases</div><pre id=\"toolCallCases\" class=\"mono\">{}</pre></div>",
            "</div>",
            "<div class=\"row\" style=\"margin-top:10px\">",
            "<div class=\"field\"><div class=\"muted\">Deterministic holdback adjustment (if any)</div><pre id=\"toolCallAdjustment\" class=\"mono\">{}</pre></div>",
            "</div>",
            "<div class=\"row\" style=\"margin-top:10px\">",
            "<div class=\"field\"><div class=\"muted\">Replay evaluate</div><pre id=\"toolCallReplayEvaluate\" class=\"mono\">{}</pre></div>",
            "</div>",
            "<div class=\"row\" style=\"margin-top:10px\">",
            "<div class=\"field\"><div class=\"muted\">Arbitration case artifact</div><pre id=\"toolCallCaseArtifact\" class=\"mono\">{}</pre></div>",
            "</div>",
            "<div class=\"row\" style=\"margin-top:10px\">",
            "<div class=\"field\"><div class=\"muted\">Arbitration verdict artifact</div><pre id=\"toolCallVerdictArtifact\" class=\"mono\">{}</pre></div>",
            "</div>",
            "<div class=\"muted\" style=\"margin-top:10px\">Tool-call replay evaluate must return chainConsistent=true for closed disputes with deterministic holdback adjustments.</div>",
            "</section>",
            "</div>",
            "<script>",
            `const INITIAL = ${JSON.stringify({ tenantId, opsToken: initialOpsToken, protocol: protocolPolicy.current, runId: initialRunId, agreementHash: initialAgreementHash })};`,
            "function byId(id){ return document.getElementById(id); }",
            "function setText(id, text){ const el = byId(id); if(el) el.textContent = String(text ?? ''); }",
            "function setStatus(id, text, kind){ const el = byId(id); if(!el) return; el.className = 'status' + (kind ? (' ' + kind) : ''); el.textContent = String(text ?? ''); }",
            "function headers(){ const h = { 'x-proxy-tenant-id': String(byId('tenantIdInput').value || '').trim() }; const tok = String(byId('opsTokenInput').value || '').trim(); if(tok) h['x-proxy-ops-token'] = tok; return h; }",
            "async function requestJson(path, { method='GET', body=null } = {}){ const res = await fetch(path, { method, headers: { ...headers(), ...(body !== null ? { 'content-type': 'application/json', 'x-settld-protocol': String(byId('protocolInput').value || '').trim() || INITIAL.protocol } : {}) }, body: body === null ? undefined : JSON.stringify(body) }); const txt = await res.text(); let j = null; try { j = txt ? JSON.parse(txt) : null; } catch {} if(!res.ok){ throw new Error((j && (j.message || j.error)) ? (j.message || j.error) : (txt || ('HTTP ' + res.status))); } return j; }",
	            "async function loadRun(){ const runId = String(byId('runIdInput').value || '').trim(); if(!runId){ setStatus('workspaceStatus','runId is required.','bad'); return; } setStatus('workspaceStatus',`Loading run ${runId}...`,''); try { const [ag, st, cs, rp, re] = await Promise.all([ requestJson(`/runs/${encodeURIComponent(runId)}/agreement`), requestJson(`/runs/${encodeURIComponent(runId)}/settlement`), requestJson(`/runs/${encodeURIComponent(runId)}/arbitration/cases`), requestJson(`/runs/${encodeURIComponent(runId)}/settlement/policy-replay`), requestJson(`/runs/${encodeURIComponent(runId)}/settlement/replay-evaluate`) ]); setText('runAgreement', JSON.stringify(ag, null, 2)); setText('runSettlement', JSON.stringify(st, null, 2)); setText('runCases', JSON.stringify(cs, null, 2)); setText('runReplay', JSON.stringify(rp, null, 2)); setText('runReplayEvaluate', JSON.stringify(re, null, 2)); const match = rp && rp.matchesStoredDecision === true; const kernelOk = re && re.comparisons && re.comparisons.kernelBindingsValid === true; setStatus('workspaceStatus', `Loaded run. policyReplay.matchesStoredDecision=${match}; replayEvaluate.kernelBindingsValid=${kernelOk}.`, (match && kernelOk) ? 'good' : 'warn'); } catch (err){ setStatus('workspaceStatus', `Run load failed: ${err.message}`, 'bad'); } }",
            "async function loadToolCall(){ const agreementHash = String(byId('agreementHashInput').value || '').trim(); if(!agreementHash){ setStatus('workspaceStatus','agreementHash is required.','bad'); return; } setStatus('workspaceStatus',`Loading tool-call ${agreementHash}...`,''); try { const qs = new URLSearchParams({ agreementHash }); const [holds, cases, replay] = await Promise.all([ requestJson(`/ops/tool-calls/holds?${qs.toString()}`), requestJson(`/tool-calls/arbitration/cases?${qs.toString()}`), requestJson(`/ops/tool-calls/replay-evaluate?${qs.toString()}`) ]); setText('toolCallHolds', JSON.stringify(holds, null, 2)); setText('toolCallCases', JSON.stringify(cases, null, 2)); setText('toolCallReplayEvaluate', JSON.stringify(replay, null, 2)); const adjustmentId = `sadj_agmt_${agreementHash}_holdback`; try { const adj = await requestJson(`/ops/settlement-adjustments/${encodeURIComponent(adjustmentId)}`); setText('toolCallAdjustment', JSON.stringify(adj, null, 2)); } catch (err){ setText('toolCallAdjustment', JSON.stringify({ ok:false, message: String(err.message || err) }, null, 2)); } const caseRows = cases && Array.isArray(cases.cases) ? cases.cases : []; const closed = caseRows.find((row)=>String(row && row.status ? row.status : '').toLowerCase()==='closed') || caseRows[0] || null; if(closed && closed.caseId){ const revRaw = Number(closed.revision || 1); const rev = Number.isSafeInteger(revRaw) && revRaw > 1 ? revRaw : 1; const caseArtId = rev > 1 ? `arbitration_case_${closed.caseId}_r${rev}` : `arbitration_case_${closed.caseId}`; try { const art = await requestJson(`/artifacts/${encodeURIComponent(caseArtId)}`); setText('toolCallCaseArtifact', JSON.stringify(art, null, 2)); } catch (err){ setText('toolCallCaseArtifact', JSON.stringify({ ok:false, message: String(err.message || err), artifactId: caseArtId }, null, 2)); } const verdictId = closed.verdictId ? String(closed.verdictId) : ''; if(verdictId){ const verdictArtId = `arbitration_verdict_${verdictId}`; try { const art2 = await requestJson(`/artifacts/${encodeURIComponent(verdictArtId)}`); setText('toolCallVerdictArtifact', JSON.stringify(art2, null, 2)); } catch (err){ setText('toolCallVerdictArtifact', JSON.stringify({ ok:false, message: String(err.message || err), artifactId: verdictArtId }, null, 2)); } } else { setText('toolCallVerdictArtifact', JSON.stringify({ ok:false, message:'no verdictId on case (open or missing)' }, null, 2)); } } else { setText('toolCallCaseArtifact', JSON.stringify({ ok:false, message:'no cases found' }, null, 2)); setText('toolCallVerdictArtifact', JSON.stringify({ ok:false, message:'no cases found' }, null, 2)); } const consistent = replay && replay.comparisons && replay.comparisons.chainConsistent === true; setStatus('workspaceStatus', `Loaded tool-call chain. replayEvaluate.chainConsistent=${consistent}.`, consistent ? 'good' : 'warn'); } catch (err){ setStatus('workspaceStatus', `Tool-call load failed: ${err.message}`, 'bad'); } }",
            "byId('tenantIdInput').value = String(INITIAL.tenantId || 'tenant_default');",
            "byId('opsTokenInput').value = String(INITIAL.opsToken || '');",
            "byId('protocolInput').value = String(INITIAL.protocol || '');",
            "byId('runIdInput').value = String(INITIAL.runId || '');",
            "byId('agreementHashInput').value = String(INITIAL.agreementHash || '');",
            "byId('loadRunBtn').addEventListener('click', ()=>loadRun());",
            "byId('loadToolCallBtn').addEventListener('click', ()=>loadToolCall());",
            "</script>",
            "</div></body></html>"
          ].join("\n");
          return sendText(res, 200, html, { contentType: "text/html; charset=utf-8" });
        }

        if (parts[1] === "finance" && parts[2] === "reconciliation" && parts[3] === "workspace" && parts.length === 4 && req.method === "GET") {
          const hasScope = requireScope(auth.scopes, OPS_SCOPES.FINANCE_READ) || requireScope(auth.scopes, OPS_SCOPES.FINANCE_WRITE);
          if (!hasScope) return sendError(res, 403, "forbidden");
          const initialOpsToken = typeof url.searchParams.get("opsToken") === "string" ? url.searchParams.get("opsToken") : "";
          const initialPeriod = normalizeBillingPeriodInput(url.searchParams.get("period"), { defaultToNow: true });
          const initialProviderId = normalizeNonEmptyStringOrNull(url.searchParams.get("providerId")) ?? "stub_default";
          const html = [
            "<!doctype html>",
            "<html><head><meta charset=\"utf-8\"/>",
            "<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\"/>",
            "<title>Finance Reconciliation Workspace</title>",
            "<style>",
            ":root{--bg:#f3f7f3;--card:#ffffff;--ink:#112012;--muted:#49604a;--line:#d1e0d2;--accent:#1d6f42;--warn:#8f5200;--bad:#a61f2d;--good:#0f5f48}",
            "*{box-sizing:border-box} body{margin:0;font:14px/1.5 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;background:radial-gradient(1100px 500px at 0% 0%,#e8f7ee,transparent),linear-gradient(160deg,#f6faf6,#eff5f0);color:var(--ink)}",
            ".wrap{max-width:1400px;margin:0 auto;padding:18px} .row{display:flex;gap:10px;flex-wrap:wrap;align-items:flex-end}",
            ".card{background:var(--card);border:1px solid var(--line);border-radius:14px;padding:14px;box-shadow:0 8px 24px rgba(0,30,8,.05)}",
            "h1{margin:0 0 6px;font-size:26px} h2{margin:0 0 8px;font-size:18px}",
            ".muted{color:var(--muted)} .status{padding:8px 10px;border-radius:10px;background:#edf5ed;border:1px solid var(--line)}",
            ".status.good{background:#d6f3e5;border-color:#9fd3b8;color:#0e5237} .status.warn{background:#fff2df;border-color:#f0cd97;color:#7a4300} .status.bad{background:#ffe1e4;border-color:#f1b3ba;color:#8f1d28}",
            ".field{display:flex;flex-direction:column;gap:4px;min-width:170px;flex:1} .field.small{max-width:180px;flex:0 0 180px}",
            "input,select,textarea,button{font:inherit} input,select,textarea{width:100%;padding:8px 10px;border-radius:10px;border:1px solid #bdd0bf;background:#fff;color:var(--ink)} textarea{min-height:130px;resize:vertical}",
            "button{padding:8px 12px;border-radius:10px;border:1px solid #9bb9a0;background:#e8f4ea;color:#15361d;cursor:pointer} button.secondary{background:#eef2f5;border-color:#bcc9d3;color:#243746} button.warn{background:#ffe7c6;border-color:#efbf79;color:#6a3f00} button.danger{background:#ffdce1;border-color:#eba3ad;color:#7c1b26}",
            ".split{display:grid;grid-template-columns:1.2fr .8fr;gap:12px;margin-top:12px} table{width:100%;border-collapse:collapse} th,td{text-align:left;padding:8px;border-bottom:1px solid #e3ede4;vertical-align:top} tbody tr:hover{background:#f0f8f1}",
            ".tag{display:inline-block;padding:2px 8px;border-radius:999px;font-size:12px;border:1px solid #bed3c0;background:#edf5ef;color:#23442c} .tag.open{background:#fff2df;border-color:#f0cd97;color:#7a4300} .tag.in_progress{background:#e5f3ff;border-color:#b9d7ef;color:#1f4f79} .tag.resolved{background:#d6f3e5;border-color:#9fd3b8;color:#0e5237} .tag.dismissed{background:#f0eef8;border-color:#c8c3dc;color:#4c4568}",
            ".mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace} pre{margin:0;background:#fbfffc;border:1px solid #dae8dc;border-radius:10px;padding:10px;overflow:auto}",
            "@media (max-width: 980px){.split{grid-template-columns:1fr}}",
            "</style></head><body><div class=\"wrap\" id=\"financeReconciliationWorkspaceRoot\">",
            "<h1>Finance Reconciliation Workspace</h1>",
            "<div class=\"muted\">Unified mismatch queue, triage ownership, and close/export controls.</div>",
            "<div class=\"card\" style=\"margin-top:12px\">",
            "<div class=\"row\">",
            "<div class=\"field\"><div class=\"muted\">Tenant ID</div><input id=\"tenantIdInput\"/></div>",
            "<div class=\"field\"><div class=\"muted\">Ops token</div><input id=\"opsTokenInput\" type=\"password\"/></div>",
            "<div class=\"field small\"><div class=\"muted\">Protocol</div><input id=\"protocolInput\"/></div>",
            "<div class=\"field small\"><div class=\"muted\">Period</div><input id=\"periodInput\" placeholder=\"YYYY-MM\"/></div>",
            "<div class=\"field\"><div class=\"muted\">Money rail provider</div><input id=\"providerIdInput\"/></div>",
            "</div>",
            "<div class=\"row\" style=\"margin-top:10px\">",
            "<button id=\"loadAllBtn\">Load full queue</button>",
            "<button class=\"secondary\" id=\"loadCoreBtn\">Load core reconcile</button>",
            "<button class=\"secondary\" id=\"loadMoneyRailBtn\">Load money rail reconcile</button>",
            "<button class=\"secondary\" id=\"refreshTriageBtn\">Refresh triage states</button>",
            "</div>",
            "<div class=\"row\" style=\"margin-top:10px\">",
            "<div class=\"field small\"><div class=\"muted\">Max tenants</div><input id=\"maintenanceMaxTenantsInput\" type=\"number\" min=\"1\" value=\"25\"/></div>",
            "<div class=\"field small\"><div class=\"muted\">Max periods/tenant</div><input id=\"maintenanceMaxPeriodsInput\" type=\"number\" min=\"1\" value=\"2\"/></div>",
            "<button class=\"secondary\" id=\"refreshMaintenanceBtn\">Refresh scheduler status</button>",
            "<button class=\"warn\" id=\"runMaintenanceBtn\">Run scheduled reconcile now</button>",
            "</div>",
            "<div id=\"workspaceStatus\" class=\"status\" style=\"margin-top:10px\">Loading workspace...</div>",
            "<div id=\"maintenanceStatus\" class=\"status\" style=\"margin-top:10px\">No maintenance run yet.</div>",
            "<div style=\"margin-top:10px\"><div class=\"muted\">Maintenance snapshot</div><pre id=\"maintenanceDetail\" class=\"mono\">{}</pre></div>",
            "</div>",
            "<div class=\"split\">",
            "<section class=\"card\">",
            "<h2>Mismatch Queue</h2>",
            "<div style=\"overflow:auto\"><table><thead><tr><th>Source</th><th>Mismatch</th><th>Severity</th><th>Status</th><th>Owner</th><th>Actions</th></tr></thead><tbody id=\"mismatchQueueBody\"></tbody></table></div>",
            "</section>",
            "<section class=\"card\">",
            "<h2>Detail</h2>",
            "<div id=\"detailStatus\" class=\"status\">Select a mismatch from the queue.</div>",
            "<div style=\"margin-top:10px\"><div class=\"muted\">Selected mismatch</div><pre id=\"mismatchDetail\" class=\"mono\">{}</pre></div>",
            "<div style=\"margin-top:10px\"><div class=\"muted\">Current triage</div><pre id=\"triageDetail\" class=\"mono\">{}</pre></div>",
            "</section>",
            "</div>",
            "<div class=\"split\" style=\"margin-top:12px\">",
            "<section class=\"card\">",
            "<h2>Triage Action</h2>",
            "<div class=\"row\">",
            "<div class=\"field small\"><div class=\"muted\">Status</div><select id=\"triageStatus\"><option value=\"open\">open</option><option value=\"acknowledged\">acknowledged</option><option value=\"in_progress\">in_progress</option><option value=\"resolved\">resolved</option><option value=\"dismissed\">dismissed</option></select></div>",
            "<div class=\"field small\"><div class=\"muted\">Severity</div><select id=\"triageSeverity\"><option value=\"\">inherit</option><option value=\"low\">low</option><option value=\"medium\">medium</option><option value=\"high\">high</option><option value=\"critical\">critical</option></select></div>",
            "<div class=\"field\"><div class=\"muted\">Owner principal</div><input id=\"triageOwner\" placeholder=\"ops.user@settld\"/></div>",
            "<div class=\"field\"><div class=\"muted\">Action label</div><input id=\"triageAction\" value=\"triage_update\"/></div>",
            "</div>",
            "<div style=\"margin-top:10px\"><div class=\"muted\">Notes</div><textarea id=\"triageNotes\" placeholder=\"Describe investigation, owner handoff, or closure rationale\"></textarea></div>",
            "<div class=\"row\" style=\"margin-top:10px\"><button id=\"applyTriageBtn\">Apply triage update</button></div>",
            "<div id=\"triageActionStatus\" class=\"status\" style=\"margin-top:10px\">No action yet.</div>",
            "</section>",
            "<section class=\"card\">",
            "<h2>Close and Export</h2>",
            "<div class=\"row\">",
            "<button class=\"secondary\" id=\"persistReconcileBtn\">Persist reconcile artifact</button>",
            "<button class=\"warn\" id=\"dryRunNetCloseBtn\">Dry-run net close</button>",
            "<button class=\"danger\" id=\"executeNetCloseBtn\">Execute net close</button>",
            "</div>",
            "<div id=\"closeOpsStatus\" class=\"status\" style=\"margin-top:10px\">No close/export action yet.</div>",
            "<div style=\"margin-top:10px\"><div class=\"muted\">Action payload</div><pre id=\"closeOpsDetail\" class=\"mono\">{}</pre></div>",
            "</section>",
            "</div>",
            "<script>",
            `const INITIAL = ${JSON.stringify({
              tenantId,
              opsToken: initialOpsToken,
              protocol: protocolPolicy.current,
              period: initialPeriod,
              providerId: initialProviderId
            })};`,
            "const state = { core: null, money: null, triages: [], queue: [], selected: null, maintenance: null };",
            "function byId(id){ return document.getElementById(id); }",
            "function setText(id, text){ const el = byId(id); if(el) el.textContent = String(text ?? ''); }",
            "function setStatus(id, text, kind){ const el = byId(id); if(!el) return; el.className = 'status' + (kind ? (' ' + kind) : ''); el.textContent = String(text ?? ''); }",
            "function headers({ write=false, json=false } = {}){ const h = { 'x-proxy-tenant-id': String(byId('tenantIdInput').value || '').trim() }; const tok = String(byId('opsTokenInput').value || '').trim(); if(tok) h['x-proxy-ops-token'] = tok; if(write) h['x-settld-protocol'] = String(byId('protocolInput').value || '').trim() || INITIAL.protocol; if(json) h['content-type'] = 'application/json'; return h; }",
            "async function requestJson(path, { method='GET', body=null, write=false, idem=null } = {}){ const h = headers({ write, json: body!==null }); if(idem) h['x-idempotency-key'] = idem; const res = await fetch(path, { method, headers: h, body: body === null ? undefined : JSON.stringify(body) }); const txt = await res.text(); let j = null; try { j = txt ? JSON.parse(txt) : null; } catch {} if(!res.ok){ throw new Error((j && (j.message || j.error)) ? (j.message || j.error) : (txt || ('HTTP ' + res.status))); } return j; }",
            "function triageTag(status){ const normalized = String(status || 'open').trim().toLowerCase() || 'open'; return `<span class=\\\"tag ${normalized}\\\">${normalized}</span>`; }",
            "function idem(prefix){ return `fin_recon_ws_${prefix}_${Date.now()}_${Math.random().toString(16).slice(2,10)}`; }",
            "function period(){ return String(byId('periodInput').value || '').trim(); }",
            "function providerId(){ return String(byId('providerIdInput').value || '').trim(); }",
            "function parsePositiveIntInput(id, fallback){ const raw = String(byId(id).value || '').trim(); if(!raw) return fallback; const parsed = Number(raw); if(!Number.isSafeInteger(parsed) || parsed <= 0) return fallback; return parsed; }",
            "function triageByKey(){ const map = new Map(); for(const row of (Array.isArray(state.triages) ? state.triages : [])){ const k = String(row && row.triageKey ? row.triageKey : '').trim(); if(!k) continue; map.set(k, row); } return map; }",
            "function mergeQueue(){ const out = []; const triageMap = triageByKey(); const sources = []; if(state.core && Array.isArray(state.core.triageQueue)) sources.push(...state.core.triageQueue); if(state.money && Array.isArray(state.money.triageQueue)) sources.push(...state.money.triageQueue); for(const item of sources){ const triageKey = String(item && item.triageKey ? item.triageKey : '').trim(); const persisted = triageKey ? (triageMap.get(triageKey) || null) : null; const triage = persisted || item.triage || null; out.push({ ...item, triageKey, triage }); } out.sort((a,b)=>{ const left = String(a?.sourceType || ''); const right = String(b?.sourceType || ''); if(left !== right) return left.localeCompare(right); return String(a?.title || a?.mismatchType || '').localeCompare(String(b?.title || b?.mismatchType || '')); }); state.queue = out; }",
            "function renderQueue(){ const body = byId('mismatchQueueBody'); body.innerHTML = ''; if(!state.queue.length){ body.innerHTML = '<tr><td colspan=\"6\" class=\"muted\">No mismatches in queue.</td></tr>'; return; } for(const item of state.queue){ const triage = item.triage || null; const tr = document.createElement('tr'); tr.innerHTML = `<td><div class=\\\"mono\\\">${item.sourceType || 'n/a'}</div><div class=\\\"muted mono\\\">${item.period || 'n/a'}</div></td><td><div>${item.title || item.mismatchType || 'n/a'}</div><div class=\\\"muted mono\\\">${item.mismatchKey || 'n/a'}</div></td><td>${item.severity || triage?.severity || 'n/a'}</td><td>${triageTag(triage?.status || 'open')}</td><td class=\\\"mono\\\">${triage?.ownerPrincipalId || 'unassigned'}</td><td><button class=\\\"secondary\\\" type=\\\"button\\\">Open</button></td>`; tr.querySelector('button').addEventListener('click', ()=>selectItem(item)); body.appendChild(tr); } }",
            "function selectItem(item){ state.selected = item || null; if(!item){ setStatus('detailStatus','Select a mismatch from the queue.',''); setText('mismatchDetail','{}'); setText('triageDetail','{}'); return; } const triage = item.triage || null; setStatus('detailStatus', `Selected ${item.title || item.mismatchType}.`, triage && (triage.status === 'resolved' || triage.status === 'dismissed') ? 'good' : 'warn'); setText('mismatchDetail', JSON.stringify(item, null, 2)); setText('triageDetail', JSON.stringify(triage || {}, null, 2)); byId('triageStatus').value = String(triage?.status || 'open'); byId('triageSeverity').value = String(triage?.severity || item?.severity || ''); byId('triageOwner').value = String(triage?.ownerPrincipalId || ''); byId('triageNotes').value = String(triage?.notes || ''); }",
            "async function loadCore(){ const p = period(); if(!p){ setStatus('workspaceStatus', 'period is required', 'bad'); return null; } const out = await requestJson(`/ops/finance/reconcile?period=${encodeURIComponent(p)}`); state.core = out; return out; }",
            "async function loadMoney(){ const p = period(); const provider = providerId(); if(!p){ setStatus('workspaceStatus', 'period is required', 'bad'); return null; } const path = `/ops/finance/money-rails/reconcile?period=${encodeURIComponent(p)}${provider ? ('&providerId=' + encodeURIComponent(provider)) : ''}`; const out = await requestJson(path); state.money = out; return out; }",
            "async function loadTriages(){ const p = period(); const provider = providerId(); const path = `/ops/finance/reconciliation/triage?period=${encodeURIComponent(p)}${provider ? ('&providerId=' + encodeURIComponent(provider)) : ''}&limit=1000`; const out = await requestJson(path); state.triages = Array.isArray(out.triages) ? out.triages : []; return out; }",
            "async function loadMaintenance(opts = {}){ const silent = opts && opts.silent === true; try { const out = await requestJson('/ops/status'); const maintenance = out && out.maintenance && out.maintenance.financeReconciliation ? out.maintenance.financeReconciliation : null; state.maintenance = maintenance; if(maintenance && Number.isSafeInteger(Number(maintenance.maxTenants))){ byId('maintenanceMaxTenantsInput').value = String(Number(maintenance.maxTenants)); } if(maintenance && Number.isSafeInteger(Number(maintenance.maxPeriodsPerTenant))){ byId('maintenanceMaxPeriodsInput').value = String(Number(maintenance.maxPeriodsPerTenant)); } const outcome = maintenance && maintenance.outcome ? String(maintenance.outcome) : null; const lastRunAt = maintenance && maintenance.lastRunAt ? String(maintenance.lastRunAt) : 'n/a'; const lastSuccessAt = maintenance && maintenance.lastSuccessAt ? String(maintenance.lastSuccessAt) : 'n/a'; const runtimeMs = maintenance && maintenance.runtimeMs !== undefined && maintenance.runtimeMs !== null ? String(maintenance.runtimeMs) : 'n/a'; const mode = maintenance && maintenance.enabled === true ? 'enabled' : 'disabled'; const kind = outcome === 'ok' ? 'good' : outcome === 'error' ? 'bad' : 'warn'; setStatus('maintenanceStatus', `Scheduler ${mode}; outcome=${outcome || 'n/a'}; lastRun=${lastRunAt}; lastSuccess=${lastSuccessAt}; runtimeMs=${runtimeMs}.`, kind); setText('maintenanceDetail', JSON.stringify(maintenance || {}, null, 2)); return out; } catch (err) { if(!silent){ setStatus('maintenanceStatus', `Scheduler status unavailable: ${err.message}`, 'warn'); setText('maintenanceDetail', '{}'); } return null; } }",
            "async function loadAll(){ setStatus('workspaceStatus', 'Loading reconciliation queue...', ''); try { await Promise.all([loadCore(), loadMoney(), loadTriages(), loadMaintenance({ silent: true })]); mergeQueue(); renderQueue(); if(state.selected && state.selected.triageKey){ const next = state.queue.find((row)=>String(row.triageKey || '') === String(state.selected.triageKey || '')); if(next) selectItem(next); } const total = state.queue.length; const open = state.queue.filter((row)=>{ const status = String(row?.triage?.status || 'open'); return status !== 'resolved' && status !== 'dismissed'; }).length; setStatus('workspaceStatus', `Loaded ${total} mismatch item(s); unresolved=${open}.`, open > 0 ? 'warn' : 'good'); } catch (err) { setStatus('workspaceStatus', `Load failed: ${err.message}`, 'bad'); } }",
            "async function applyTriage(){ const item = state.selected; if(!item){ setStatus('triageActionStatus', 'Select a mismatch first.', 'bad'); return; } const status = String(byId('triageStatus').value || '').trim(); const severity = String(byId('triageSeverity').value || '').trim(); const ownerPrincipalId = String(byId('triageOwner').value || '').trim(); const notes = String(byId('triageNotes').value || '').trim(); const action = String(byId('triageAction').value || '').trim() || 'triage_update'; setStatus('triageActionStatus', 'Applying triage update...', ''); try { const payload = { action, sourceType: item.sourceType, period: item.period, providerId: item.providerId || null, mismatchType: item.mismatchType, mismatchKey: item.mismatchKey, mismatchCode: item.mismatchCode || null, status, severity: severity || null, ownerPrincipalId: ownerPrincipalId || null, notes: notes || null }; const out = await requestJson('/ops/finance/reconciliation/triage', { method: 'POST', body: payload, write: true, idem: idem('triage') }); setStatus('triageActionStatus', `Triage saved: ${out.triage?.status || status} (revision=${out.triage?.revision || 'n/a'}).`, 'good'); await loadAll(); } catch (err) { setStatus('triageActionStatus', `Triage update failed: ${err.message}`, 'bad'); } }",
            "async function persistReconcile(){ const p = period(); if(!p){ setStatus('closeOpsStatus', 'period is required', 'bad'); return; } setStatus('closeOpsStatus', 'Persisting reconcile artifact...', ''); try { const out = await requestJson(`/ops/finance/reconcile?period=${encodeURIComponent(p)}&persist=true`); setStatus('closeOpsStatus', `Persisted reconcile report hash=${out.reportHash}.`, 'good'); setText('closeOpsDetail', JSON.stringify(out, null, 2)); } catch (err) { setStatus('closeOpsStatus', `Persist reconcile failed: ${err.message}`, 'bad'); } }",
            "async function dryRunNetClose(){ const p = period(); if(!p){ setStatus('closeOpsStatus', 'period is required', 'bad'); return; } setStatus('closeOpsStatus', 'Running net-close dry-run...', ''); try { const out = await requestJson(`/ops/finance/net-close?period=${encodeURIComponent(p)}`); setStatus('closeOpsStatus', `Net-close status=${out.status}.`, out.status === 'pass' ? 'good' : 'warn'); setText('closeOpsDetail', JSON.stringify(out, null, 2)); } catch (err) { setStatus('closeOpsStatus', `Net-close dry-run failed: ${err.message}`, 'bad'); } }",
            "async function executeNetClose(){ const p = period(); if(!p){ setStatus('closeOpsStatus', 'period is required', 'bad'); return; } setStatus('closeOpsStatus', 'Executing net-close...', ''); try { const out = await requestJson('/ops/finance/net-close/execute', { method:'POST', body: { period: p, dryRun: false }, write: true, idem: idem('net_close') }); setStatus('closeOpsStatus', `Net-close executed=${out.executed === true}. status=${out.status}.`, out.status === 'pass' ? 'good' : 'warn'); setText('closeOpsDetail', JSON.stringify(out, null, 2)); } catch (err) { setStatus('closeOpsStatus', `Net-close execute failed: ${err.message}`, 'bad'); } }",
            "async function runMaintenance(){ const p = period(); const maxTenants = parsePositiveIntInput('maintenanceMaxTenantsInput', 25); const maxPeriodsPerTenant = parsePositiveIntInput('maintenanceMaxPeriodsInput', 2); const payload = { force: true, maxTenants, maxPeriodsPerTenant }; if(p) payload.period = p; setStatus('maintenanceStatus', 'Running finance reconciliation maintenance...', ''); try { const out = await requestJson('/ops/maintenance/finance-reconcile/run', { method:'POST', body: payload, write:true, idem: idem('maintenance') }); setStatus('maintenanceStatus', `Maintenance run complete: reconciled=${Number(out?.summary?.reconciledPeriods || 0)}, attempted=${Number(out?.summary?.attemptedPeriods || 0)}.`, 'good'); setText('maintenanceDetail', JSON.stringify(out, null, 2)); await loadAll(); } catch (err) { setStatus('maintenanceStatus', `Maintenance run failed: ${err.message}`, 'bad'); } }",
            "byId('tenantIdInput').value = String(INITIAL.tenantId || 'tenant_default');",
            "byId('opsTokenInput').value = String(INITIAL.opsToken || '');",
            "byId('protocolInput').value = String(INITIAL.protocol || '');",
            "byId('periodInput').value = String(INITIAL.period || '');",
            "byId('providerIdInput').value = String(INITIAL.providerId || 'stub_default');",
            "byId('maintenanceMaxTenantsInput').value = '25';",
            "byId('maintenanceMaxPeriodsInput').value = '2';",
            "byId('loadAllBtn').addEventListener('click', ()=>loadAll());",
            "byId('loadCoreBtn').addEventListener('click', async()=>{ try { await loadCore(); await loadTriages(); mergeQueue(); renderQueue(); setStatus('workspaceStatus','Core reconciliation loaded.','good'); } catch(err){ setStatus('workspaceStatus', `Core load failed: ${err.message}`, 'bad'); } });",
            "byId('loadMoneyRailBtn').addEventListener('click', async()=>{ try { await loadMoney(); await loadTriages(); mergeQueue(); renderQueue(); setStatus('workspaceStatus','Money rail reconciliation loaded.','good'); } catch(err){ setStatus('workspaceStatus', `Money rail load failed: ${err.message}`, 'bad'); } });",
            "byId('refreshTriageBtn').addEventListener('click', async()=>{ try { await loadTriages(); mergeQueue(); renderQueue(); setStatus('workspaceStatus','Triage state refreshed.','good'); } catch(err){ setStatus('workspaceStatus', `Triage refresh failed: ${err.message}`, 'bad'); } });",
            "byId('refreshMaintenanceBtn').addEventListener('click', ()=>loadMaintenance());",
            "byId('runMaintenanceBtn').addEventListener('click', ()=>runMaintenance());",
            "byId('applyTriageBtn').addEventListener('click', ()=>applyTriage());",
            "byId('persistReconcileBtn').addEventListener('click', ()=>persistReconcile());",
            "byId('dryRunNetCloseBtn').addEventListener('click', ()=>dryRunNetClose());",
            "byId('executeNetCloseBtn').addEventListener('click', ()=>executeNetClose());",
            "loadAll();",
            "</script>",
            "</div></body></html>"
          ].join("\n");
          return sendText(res, 200, html, { contentType: "text/html; charset=utf-8" });
        }

        if (parts[1] === "settlement-policies" && parts[2] === "state" && parts.length === 3 && req.method === "GET") {
          const hasScope = requireScope(auth.scopes, OPS_SCOPES.OPS_READ) || requireScope(auth.scopes, OPS_SCOPES.OPS_WRITE);
          if (!hasScope) return sendError(res, 403, "forbidden");
          let policyId = null;
          try {
            policyId = parseSettlementPolicyRegistryId(url.searchParams.get("policyId"), {
              fieldPath: "policyId",
              allowNull: true
            });
          } catch (err) {
            return sendError(res, 400, "invalid policy state query", { message: err?.message });
          }
          const state = selectTenantSettlementPolicyControlPlaneState({ tenantId, policyId });
          return sendJson(res, 200, {
            ok: true,
            tenantId,
            schemaVersion: TENANT_SETTLEMENT_POLICY_ROLLOUT_SCHEMA_VERSION,
            generatedAt: nowIso(),
            ...state
          });
        }

        if (parts[1] === "settlement-policies" && parts[2] === "rollout" && parts.length === 3 && req.method === "POST") {
          if (!requireScope(auth.scopes, OPS_SCOPES.OPS_WRITE)) return sendError(res, 403, "forbidden");
          if (!requireProtocolHeaderForWrite(req, res)) return;
          const body = (await readJsonBody(req)) ?? {};
          let idemStoreKey = null;
          let idemRequestHash = null;
          try {
            ({ idemStoreKey, idemRequestHash } = readIdempotency({ method: "POST", requestPath: path, expectedPrevChainHash: null, body }));
          } catch (err) {
            return sendError(res, 400, "invalid idempotency key", { message: err?.message });
          }
          if (idemStoreKey) {
            const existingIdem = store.idempotency.get(idemStoreKey);
            if (existingIdem) {
              if (existingIdem.requestHash !== idemRequestHash) {
                return sendError(res, 409, "idempotency key conflict", "request differs from initial use of this key");
              }
              return sendJson(res, existingIdem.statusCode, existingIdem.body);
            }
          }

          let stage = null;
          try {
            stage = parseSettlementPolicyRolloutStage(body.stage, { fieldPath: "stage" });
          } catch (err) {
            return sendError(res, 400, "invalid rollout stage", { message: err?.message });
          }
          const clear = body?.clear === true;
          const note = normalizeSettlementPolicyRolloutNote(body?.note);
          const nowAt = nowIso();
          const fallbackRef = deriveTenantSettlementPolicyActiveFallbackRef({ tenantId });
          const rollout = normalizeTenantSettlementPolicyRollout({
            tenantId,
            rollout: getTenantSettlementPolicyRolloutRecord({ tenantId }),
            activeFallbackRef: fallbackRef
          });
          let fromPolicyRef = null;
          let toPolicyRef = null;
          let action = "rollout_updated";
          let rolloutPercent = null;

          if (stage === SETTLEMENT_POLICY_ROLLOUT_STAGE.DRAFT) {
            fromPolicyRef = cloneTenantSettlementPolicyRef(rollout.stages.draft);
            if (clear) {
              rollout.stages.draft = null;
              action = "draft_cleared";
            } else {
              let policyRef = null;
              try {
                policyRef = parseTenantSettlementPolicyRefInput(
                  body?.policyRef && typeof body.policyRef === "object" && !Array.isArray(body.policyRef)
                    ? body.policyRef
                    : { policyId: body?.policyId, policyVersion: body?.policyVersion },
                  { fieldPath: "policyRef" }
                );
              } catch (err) {
                return sendError(res, 400, "invalid policy reference", { message: err?.message });
              }
              const record = getTenantSettlementPolicyRecord({
                tenantId,
                policyId: policyRef.policyId,
                policyVersion: policyRef.policyVersion
              });
              if (!record) return sendError(res, 404, "policy version not found");
              toPolicyRef = normalizeTenantSettlementPolicyRef(record);
              rollout.stages.draft = toPolicyRef;
              action = "draft_selected";
            }
          } else if (stage === SETTLEMENT_POLICY_ROLLOUT_STAGE.CANARY) {
            fromPolicyRef = cloneTenantSettlementPolicyRef(rollout.stages.canary?.policyRef ?? null);
            if (clear) {
              rollout.stages.canary = { policyRef: null, rolloutPercent: 0 };
              action = "canary_cleared";
              rolloutPercent = 0;
            } else {
              let policyRef = null;
              try {
                policyRef = parseTenantSettlementPolicyRefInput(
                  body?.policyRef && typeof body.policyRef === "object" && !Array.isArray(body.policyRef)
                    ? body.policyRef
                    : { policyId: body?.policyId, policyVersion: body?.policyVersion },
                  { fieldPath: "policyRef" }
                );
              } catch (err) {
                return sendError(res, 400, "invalid policy reference", { message: err?.message });
              }
              const record = getTenantSettlementPolicyRecord({
                tenantId,
                policyId: policyRef.policyId,
                policyVersion: policyRef.policyVersion
              });
              if (!record) return sendError(res, 404, "policy version not found");
              toPolicyRef = normalizeTenantSettlementPolicyRef(record);
              try {
                rolloutPercent = parseSettlementPolicyRolloutPercent(body?.rolloutPercent, { allowNull: true });
              } catch (err) {
                return sendError(res, 400, "invalid rolloutPercent", { message: err?.message });
              }
              if (rolloutPercent === null) {
                const existingPercent = Number(rollout.stages.canary?.rolloutPercent ?? 0);
                rolloutPercent = settlementPolicyRefEquals(fromPolicyRef, toPolicyRef) && existingPercent > 0 ? existingPercent : 10;
              }
              rolloutPercent = Math.max(1, Math.min(100, rolloutPercent));
              rollout.stages.canary = { policyRef: toPolicyRef, rolloutPercent };
              action = "canary_updated";
            }
          } else {
            let policyRef = null;
            try {
              policyRef = parseTenantSettlementPolicyRefInput(
                body?.policyRef && typeof body.policyRef === "object" && !Array.isArray(body.policyRef)
                  ? body.policyRef
                  : { policyId: body?.policyId, policyVersion: body?.policyVersion },
                { fieldPath: "policyRef" }
              );
            } catch (err) {
              return sendError(res, 400, "invalid policy reference", { message: err?.message });
            }
            const record = getTenantSettlementPolicyRecord({
              tenantId,
              policyId: policyRef.policyId,
              policyVersion: policyRef.policyVersion
            });
            if (!record) return sendError(res, 404, "policy version not found");
            fromPolicyRef = cloneTenantSettlementPolicyRef(rollout.stages.active);
            toPolicyRef = normalizeTenantSettlementPolicyRef(record);
            rollout.stages.active = toPolicyRef;
            action = settlementPolicyRefEquals(fromPolicyRef, toPolicyRef) ? "active_confirmed" : "active_promoted";
          }

          appendTenantSettlementPolicyRolloutHistory({
            rollout,
            entry: {
              at: nowAt,
              action,
              stage,
              fromPolicyRef,
              toPolicyRef,
              rolloutPercent,
              note,
              actorPrincipalId: principalId
            }
          });

          const responseBody = {
            ok: true,
            tenantId,
            stage,
            action,
            rollout,
            defaultPolicyRef: rollout.stages.active ?? null,
            rolloutHistory: Array.isArray(rollout.history) ? rollout.history.slice(-50).reverse() : []
          };
          const ops = [{ kind: "TENANT_SETTLEMENT_POLICY_ROLLOUT_UPSERT", tenantId, rollout }];
          if (idemStoreKey) {
            ops.push({ kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode: 200, body: responseBody } });
          }
          await commitTx(ops, {
            audit: makeOpsAudit({
              action: "TENANT_SETTLEMENT_POLICY_ROLLOUT_UPDATED",
              targetType: "tenant_settlement_policy_rollout",
              targetId: stage,
              details: { stage, action, fromPolicyRef, toPolicyRef, rolloutPercent, note }
            })
          });
          return sendJson(res, 200, responseBody);
        }

        if (parts[1] === "settlement-policies" && parts[2] === "rollback" && parts.length === 3 && req.method === "POST") {
          if (!requireScope(auth.scopes, OPS_SCOPES.OPS_WRITE)) return sendError(res, 403, "forbidden");
          if (!requireProtocolHeaderForWrite(req, res)) return;
          const body = (await readJsonBody(req)) ?? {};
          let idemStoreKey = null;
          let idemRequestHash = null;
          try {
            ({ idemStoreKey, idemRequestHash } = readIdempotency({ method: "POST", requestPath: path, expectedPrevChainHash: null, body }));
          } catch (err) {
            return sendError(res, 400, "invalid idempotency key", { message: err?.message });
          }
          if (idemStoreKey) {
            const existingIdem = store.idempotency.get(idemStoreKey);
            if (existingIdem) {
              if (existingIdem.requestHash !== idemRequestHash) {
                return sendError(res, 409, "idempotency key conflict", "request differs from initial use of this key");
              }
              return sendJson(res, existingIdem.statusCode, existingIdem.body);
            }
          }
          const fallbackRef = deriveTenantSettlementPolicyActiveFallbackRef({ tenantId });
          const rollout = normalizeTenantSettlementPolicyRollout({
            tenantId,
            rollout: getTenantSettlementPolicyRolloutRecord({ tenantId }),
            activeFallbackRef: fallbackRef
          });
          const currentActiveRef = cloneTenantSettlementPolicyRef(rollout.stages.active);
          if (!currentActiveRef) return sendError(res, 409, "active policy is not set");
          const note = normalizeSettlementPolicyRolloutNote(body?.note);

          let explicitTargetRef = null;
          try {
            explicitTargetRef =
              body?.policyRef || body?.policyId !== undefined || body?.policyVersion !== undefined
                ? parseTenantSettlementPolicyRefInput(
                    body?.policyRef && typeof body.policyRef === "object" && !Array.isArray(body.policyRef)
                      ? body.policyRef
                      : { policyId: body?.policyId, policyVersion: body?.policyVersion },
                    { fieldPath: "policyRef" }
                  )
                : null;
          } catch (err) {
            return sendError(res, 400, "invalid policy reference", { message: err?.message });
          }

          let targetRef = null;
          if (explicitTargetRef) {
            const row = getTenantSettlementPolicyRecord({
              tenantId,
              policyId: explicitTargetRef.policyId,
              policyVersion: explicitTargetRef.policyVersion
            });
            if (!row) return sendError(res, 404, "rollback target not found");
            targetRef = normalizeTenantSettlementPolicyRef(row);
          } else {
            const inferred = findTenantSettlementPolicyRollbackTargetRef({ rollout, currentActiveRef });
            if (inferred) {
              const row = getTenantSettlementPolicyRecord({
                tenantId,
                policyId: inferred.policyId,
                policyVersion: inferred.policyVersion
              });
              if (row) targetRef = normalizeTenantSettlementPolicyRef(row);
            }
          }

          if (!targetRef) {
            return sendError(res, 409, "no previous active policy is available for rollback");
          }

          if (settlementPolicyRefEquals(currentActiveRef, targetRef)) {
            const responseBody = {
              ok: true,
              tenantId,
              action: "rollback_noop",
              rollbackTargetRef: targetRef,
              rollout,
              defaultPolicyRef: rollout.stages.active ?? null,
              rolloutHistory: Array.isArray(rollout.history) ? rollout.history.slice(-50).reverse() : []
            };
            if (idemStoreKey) {
              await commitTx([
                { kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode: 200, body: responseBody } }
              ]);
            }
            return sendJson(res, 200, responseBody);
          }

          rollout.stages.active = targetRef;
          appendTenantSettlementPolicyRolloutHistory({
            rollout,
            entry: {
              at: nowIso(),
              action: "active_rollback",
              stage: SETTLEMENT_POLICY_ROLLOUT_STAGE.ACTIVE,
              fromPolicyRef: currentActiveRef,
              toPolicyRef: targetRef,
              note,
              actorPrincipalId: principalId
            }
          });
          const responseBody = {
            ok: true,
            tenantId,
            action: "active_rollback",
            rollbackTargetRef: targetRef,
            rollout,
            defaultPolicyRef: rollout.stages.active ?? null,
            rolloutHistory: Array.isArray(rollout.history) ? rollout.history.slice(-50).reverse() : []
          };
          const ops = [{ kind: "TENANT_SETTLEMENT_POLICY_ROLLOUT_UPSERT", tenantId, rollout }];
          if (idemStoreKey) {
            ops.push({ kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode: 200, body: responseBody } });
          }
          await commitTx(ops, {
            audit: makeOpsAudit({
              action: "TENANT_SETTLEMENT_POLICY_ROLLBACK",
              targetType: "tenant_settlement_policy_rollout",
              targetId: "active",
              details: { fromPolicyRef: currentActiveRef, toPolicyRef: targetRef, note }
            })
          });
          return sendJson(res, 200, responseBody);
        }

        if (parts[1] === "settlement-policies" && parts[2] === "diff" && parts.length === 3 && req.method === "GET") {
          const hasScope = requireScope(auth.scopes, OPS_SCOPES.OPS_READ) || requireScope(auth.scopes, OPS_SCOPES.OPS_WRITE);
          if (!hasScope) return sendError(res, 403, "forbidden");
          const limitRaw = url.searchParams.get("limit");
          const limit = limitRaw === null || limitRaw === "" ? 200 : Number(limitRaw);
          if (!Number.isSafeInteger(limit) || limit < 1 || limit > 2000) {
            return sendError(res, 400, "invalid diff query", { message: "limit must be an integer in range 1..2000" });
          }
          const includeUnchanged = url.searchParams.get("includeUnchanged") === "1" || url.searchParams.get("includeUnchanged") === "true";
          const fallbackRef = deriveTenantSettlementPolicyActiveFallbackRef({ tenantId });
          const rollout = normalizeTenantSettlementPolicyRollout({
            tenantId,
            rollout: getTenantSettlementPolicyRolloutRecord({ tenantId }),
            activeFallbackRef: fallbackRef
          });

          let fromRef = null;
          let toRef = null;
          try {
            const fromPolicyId = url.searchParams.get("fromPolicyId");
            const fromPolicyVersion = url.searchParams.get("fromPolicyVersion");
            const toPolicyId = url.searchParams.get("toPolicyId");
            const toPolicyVersion = url.searchParams.get("toPolicyVersion");
            const hasFromInput = (fromPolicyId !== null && fromPolicyId !== "") || (fromPolicyVersion !== null && fromPolicyVersion !== "");
            const hasToInput = (toPolicyId !== null && toPolicyId !== "") || (toPolicyVersion !== null && toPolicyVersion !== "");
            fromRef = hasFromInput
              ? parseTenantSettlementPolicyRefInput({ policyId: fromPolicyId, policyVersion: fromPolicyVersion }, { fieldPath: "fromPolicyRef" })
              : cloneTenantSettlementPolicyRef(rollout.stages.active ?? fallbackRef ?? null);
            toRef = hasToInput
              ? parseTenantSettlementPolicyRefInput({ policyId: toPolicyId, policyVersion: toPolicyVersion }, { fieldPath: "toPolicyRef" })
              : cloneTenantSettlementPolicyRef(rollout.stages.draft ?? rollout.stages.active ?? fallbackRef ?? null);
          } catch (err) {
            return sendError(res, 400, "invalid diff query", { message: err?.message });
          }
          if (!fromRef || !toRef) {
            return sendError(res, 409, "from/to policy references are required");
          }
          const fromRecord = getTenantSettlementPolicyRecord({
            tenantId,
            policyId: fromRef.policyId,
            policyVersion: fromRef.policyVersion
          });
          if (!fromRecord) return sendError(res, 404, "from policy version not found");
          const toRecord = getTenantSettlementPolicyRecord({
            tenantId,
            policyId: toRef.policyId,
            policyVersion: toRef.policyVersion
          });
          if (!toRecord) return sendError(res, 404, "to policy version not found");

          const fromPayload = {
            policyId: fromRecord.policyId,
            policyVersion: fromRecord.policyVersion,
            description: fromRecord.description ?? null,
            verificationMethod: fromRecord.verificationMethod ?? null,
            policy: fromRecord.policy ?? null
          };
          const toPayload = {
            policyId: toRecord.policyId,
            policyVersion: toRecord.policyVersion,
            description: toRecord.description ?? null,
            verificationMethod: toRecord.verificationMethod ?? null,
            policy: toRecord.policy ?? null
          };
          const diff = buildTenantSettlementPolicyDiff({ fromPolicy: fromPayload, toPolicy: toPayload, includeUnchanged, limit });
          return sendJson(res, 200, {
            ok: true,
            tenantId,
            schemaVersion: TENANT_SETTLEMENT_POLICY_DIFF_SCHEMA_VERSION,
            generatedAt: nowIso(),
            fromPolicyRef: normalizeTenantSettlementPolicyRef(fromRecord),
            toPolicyRef: normalizeTenantSettlementPolicyRef(toRecord),
            summary: diff.summary,
            limited: diff.limited,
            changes: diff.changes
          });
        }

        if (parts[1] === "policy" && parts[2] === "workspace" && parts.length === 3 && req.method === "GET") {
          const hasScope = requireScope(auth.scopes, OPS_SCOPES.OPS_READ) || requireScope(auth.scopes, OPS_SCOPES.OPS_WRITE);
          if (!hasScope) return sendError(res, 403, "forbidden");
          const initialOpsToken = typeof url.searchParams.get("opsToken") === "string" ? url.searchParams.get("opsToken") : "";
          const initialPolicyId = typeof url.searchParams.get("policyId") === "string" ? url.searchParams.get("policyId") : "";
          const initialRunId = typeof url.searchParams.get("runId") === "string" ? url.searchParams.get("runId") : "";
          const html = [
            "<!doctype html>",
            "<html><head><meta charset=\"utf-8\"/>",
            "<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\"/>",
            "<title>Settlement Policy Control Plane</title>",
            "<style>",
            ":root{--bg:#f6f5f2;--card:#ffffff;--ink:#1f2220;--muted:#56615a;--line:#d2d8d3;--good:#0f6b45;--warn:#915100;--bad:#a42c2c}",
            "*{box-sizing:border-box} body{margin:0;font:14px/1.5 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;background:radial-gradient(1000px 420px at 0% 0%,#e6f0ea,transparent),linear-gradient(155deg,#f9faf7,#f2f5f2);color:var(--ink)}",
            ".wrap{max-width:1480px;margin:0 auto;padding:18px} .row{display:flex;gap:10px;flex-wrap:wrap;align-items:flex-end}",
            ".card{background:var(--card);border:1px solid var(--line);border-radius:14px;padding:14px;box-shadow:0 8px 24px rgba(16,34,20,.06)}",
            "h1{margin:0 0 6px;font-size:27px} h2{margin:0 0 8px;font-size:18px}",
            ".muted{color:var(--muted)} .status{padding:8px 10px;border-radius:10px;background:#eef4ef;border:1px solid var(--line)}",
            ".status.good{background:#daf1e5;border-color:#9dccb2;color:#0f5c3a} .status.warn{background:#fff1dc;border-color:#eec892;color:#764300} .status.bad{background:#ffe2e2;border-color:#efb0b0;color:#8a1f1f}",
            ".field{display:flex;flex-direction:column;gap:4px;min-width:160px;flex:1} .field.small{max-width:190px;flex:0 0 190px}",
            "input,select,textarea,button{font:inherit} input,select,textarea{width:100%;padding:8px 10px;border-radius:10px;border:1px solid #bccbc0;background:#fff;color:var(--ink)} textarea{min-height:130px;resize:vertical}",
            "button{padding:8px 12px;border-radius:10px;border:1px solid #9eb3a4;background:#e8f3eb;color:#19402c;cursor:pointer} button.secondary{background:#eff2f5;border-color:#bec9d2;color:#243644} button.warn{background:#ffe8cb;border-color:#eebb75;color:#6c3f00} button.danger{background:#ffdce0;border-color:#eba6af;color:#7c202a}",
            ".split{display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-top:12px} table{width:100%;border-collapse:collapse} th,td{text-align:left;padding:8px;border-bottom:1px solid #e2ebe4;vertical-align:top} tbody tr:hover{background:#f1f6f2}",
            ".tag{display:inline-block;padding:2px 8px;border-radius:999px;font-size:12px;border:1px solid #b9ccbe;background:#edf4ef;color:#214531} .tag.active{background:#daf1e5;border-color:#9dccb2;color:#0f5c3a} .tag.draft{background:#e6efff;border-color:#bfd0f1;color:#214a84} .tag.canary{background:#fff1dc;border-color:#eec892;color:#764300}",
            ".mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace} pre{margin:0;background:#fbfefc;border:1px solid #d7e5da;border-radius:10px;padding:10px;overflow:auto}",
            "@media (max-width: 1080px){.split{grid-template-columns:1fr}}",
            "</style></head><body><div class=\"wrap\" id=\"policyControlWorkspaceRoot\">",
            "<h1>Settlement Policy Control Plane</h1>",
            "<div class=\"muted\">Versioned policy registry, staged rollout controls, rollback safety, diff review, and run replay hooks.</div>",
            "<div class=\"card\" style=\"margin-top:12px\">",
            "<div class=\"row\">",
            "<div class=\"field\"><div class=\"muted\">Tenant ID</div><input id=\"tenantIdInput\"/></div>",
            "<div class=\"field\"><div class=\"muted\">Ops token</div><input id=\"opsTokenInput\" type=\"password\" placeholder=\"tok_opsr or tok_opsw\"/></div>",
            "<div class=\"field small\"><div class=\"muted\">Protocol</div><input id=\"protocolInput\"/></div>",
            "<div class=\"field\"><div class=\"muted\">Policy ID filter</div><input id=\"policyIdFilterInput\" placeholder=\"market.default.auto-v1\"/></div>",
            "</div>",
            "<div class=\"row\" style=\"margin-top:10px\">",
            "<button id=\"refreshPolicyStateBtn\">Refresh control plane state</button>",
            "<button class=\"secondary\" id=\"refreshPolicyDiffBtn\">Refresh diff</button>",
            "<button class=\"secondary\" id=\"refreshPolicyReplayBtn\">Replay selected run policy</button>",
            "</div>",
            "<div id=\"workspaceStatus\" class=\"status\" style=\"margin-top:10px\">Loading policy control plane...</div>",
            "</div>",
            "<div class=\"split\">",
            "<section class=\"card\">",
            "<h2>Policy Versions</h2>",
            "<div style=\"overflow:auto\"><table id=\"policyVersionsTable\"><thead><tr><th>Policy</th><th>Description</th><th>Hashes</th><th>Stages</th><th>Actions</th></tr></thead><tbody id=\"policyVersionsBody\"></tbody></table></div>",
            "</section>",
            "<section class=\"card\">",
            "<h2>Rollout History</h2>",
            "<div style=\"overflow:auto\"><table id=\"policyRolloutHistoryTable\"><thead><tr><th>When</th><th>Action</th><th>From</th><th>To</th><th>Stage</th><th>Note</th></tr></thead><tbody id=\"policyRolloutHistoryBody\"></tbody></table></div>",
            "</section>",
            "</div>",
            "<div class=\"split\" style=\"margin-top:12px\">",
            "<section class=\"card\">",
            "<h2>Version Upsert</h2>",
            "<div class=\"row\">",
            "<div class=\"field\"><div class=\"muted\">Policy ID</div><input id=\"upsertPolicyIdInput\" placeholder=\"market.default.auto-v1\"/></div>",
            "<div class=\"field small\"><div class=\"muted\">Policy Version (optional)</div><input id=\"upsertPolicyVersionInput\" type=\"number\" min=\"1\"/></div>",
            "<div class=\"field\"><div class=\"muted\">Description</div><input id=\"upsertPolicyDescriptionInput\" placeholder=\"deterministic default for marketplace\"/></div>",
            "</div>",
            "<div style=\"margin-top:8px\"><div class=\"muted\">Policy JSON</div><textarea id=\"upsertPolicyJson\" class=\"mono\"></textarea></div>",
            "<div style=\"margin-top:8px\"><div class=\"muted\">Verification Method JSON (optional)</div><textarea id=\"upsertVerificationJson\" class=\"mono\"></textarea></div>",
            "<div class=\"row\" style=\"margin-top:10px\"><button id=\"policyUpsertBtn\">Save policy version</button></div>",
            "<div id=\"upsertStatus\" class=\"status\" style=\"margin-top:10px\">No upsert yet.</div>",
            "</section>",
            "<section class=\"card\">",
            "<h2>Rollout and Rollback</h2>",
            "<div class=\"row\">",
            "<div class=\"field small\"><div class=\"muted\">Stage</div><select id=\"rolloutStageInput\"><option value=\"draft\">draft</option><option value=\"canary\">canary</option><option value=\"active\">active</option></select></div>",
            "<div class=\"field\"><div class=\"muted\">Policy ID</div><input id=\"rolloutPolicyIdInput\" placeholder=\"market.default.auto-v1\"/></div>",
            "<div class=\"field small\"><div class=\"muted\">Policy Version</div><input id=\"rolloutPolicyVersionInput\" type=\"number\" min=\"1\"/></div>",
            "<div class=\"field small\"><div class=\"muted\">Canary %</div><input id=\"rolloutPercentInput\" type=\"number\" min=\"1\" max=\"100\" placeholder=\"10\"/></div>",
            "</div>",
            "<div class=\"row\" style=\"margin-top:8px\">",
            "<div class=\"field\"><div class=\"muted\">Note</div><input id=\"rolloutNoteInput\" placeholder=\"rollout rationale\"/></div>",
            "<div class=\"field small\"><label><input id=\"rolloutClearInput\" type=\"checkbox\"/> clear stage</label></div>",
            "</div>",
            "<div class=\"row\" style=\"margin-top:10px\"><button id=\"policyRolloutBtn\">Apply rollout stage</button></div>",
            "<hr style=\"border:0;border-top:1px solid #e1e8e2;margin:12px 0\"/>",
            "<div class=\"row\">",
            "<div class=\"field\"><div class=\"muted\">Rollback target policy ID (optional)</div><input id=\"rollbackPolicyIdInput\" placeholder=\"leave empty for inferred previous\"/></div>",
            "<div class=\"field small\"><div class=\"muted\">Rollback target version (optional)</div><input id=\"rollbackPolicyVersionInput\" type=\"number\" min=\"1\"/></div>",
            "<div class=\"field\"><div class=\"muted\">Rollback note</div><input id=\"rollbackNoteInput\" placeholder=\"rollback reason\"/></div>",
            "</div>",
            "<div class=\"row\" style=\"margin-top:10px\"><button class=\"danger\" id=\"policyRollbackBtn\">Rollback active stage</button></div>",
            "<div id=\"rolloutStatus\" class=\"status\" style=\"margin-top:10px\">No rollout action yet.</div>",
            "</section>",
            "</div>",
            "<div class=\"split\" style=\"margin-top:12px\">",
            "<section class=\"card\">",
            "<h2>Policy Diff</h2>",
            "<div class=\"row\">",
            "<div class=\"field\"><div class=\"muted\">From policy ID</div><input id=\"diffFromPolicyIdInput\" placeholder=\"active by default\"/></div>",
            "<div class=\"field small\"><div class=\"muted\">From version</div><input id=\"diffFromPolicyVersionInput\" type=\"number\" min=\"1\"/></div>",
            "<div class=\"field\"><div class=\"muted\">To policy ID</div><input id=\"diffToPolicyIdInput\" placeholder=\"draft by default\"/></div>",
            "<div class=\"field small\"><div class=\"muted\">To version</div><input id=\"diffToPolicyVersionInput\" type=\"number\" min=\"1\"/></div>",
            "</div>",
            "<div class=\"row\" style=\"margin-top:8px\">",
            "<div class=\"field small\"><div class=\"muted\">Diff limit</div><input id=\"diffLimitInput\" type=\"number\" min=\"1\" max=\"2000\" value=\"200\"/></div>",
            "<div class=\"field small\"><label><input id=\"diffIncludeUnchangedInput\" type=\"checkbox\"/> include unchanged</label></div>",
            "<div class=\"field small\"><button id=\"policyDiffBtn\">Compute diff</button></div>",
            "</div>",
            "<div id=\"diffStatus\" class=\"status\" style=\"margin-top:10px\">No diff yet.</div>",
            "<div style=\"margin-top:10px\"><div class=\"muted\">Diff detail</div><pre id=\"policyDiffDetail\" class=\"mono\">{}</pre></div>",
            "</section>",
            "<section class=\"card\">",
            "<h2>Run Policy Replay</h2>",
            "<div class=\"row\">",
            "<div class=\"field\"><div class=\"muted\">Run ID</div><input id=\"replayRunIdInput\" placeholder=\"run_...\"/></div>",
            "<div class=\"field small\"><button id=\"policyReplayBtn\">Replay run settlement policy</button></div>",
            "</div>",
            "<div id=\"replayStatus\" class=\"status\" style=\"margin-top:10px\">No replay yet.</div>",
            "<div style=\"margin-top:10px\"><div class=\"muted\">Replay detail</div><pre id=\"policyReplayDetail\" class=\"mono\">{}</pre></div>",
            "</section>",
            "</div>",
            "<div class=\"card\" style=\"margin-top:12px\">",
            "<h2>Current State Snapshot</h2>",
            "<pre id=\"policyStateDetail\" class=\"mono\">{}</pre>",
            "</div>",
            "<script>",
            `const INITIAL = ${JSON.stringify({
              tenantId,
              opsToken: initialOpsToken,
              protocol: protocolPolicy.current,
              policyId: initialPolicyId,
              runId: initialRunId
            })};`,
            "const state = { snapshot: null };",
            "function byId(id){ return document.getElementById(id); }",
            "function setText(id, text){ const el = byId(id); if(el) el.textContent = String(text ?? ''); }",
            "function setStatus(id, text, kind){ const el = byId(id); if(!el) return; el.className = 'status' + (kind ? (' ' + kind) : ''); el.textContent = String(text ?? ''); }",
            "function headers({ write=false, json=false } = {}){ const h = { 'x-proxy-tenant-id': String(byId('tenantIdInput').value || '').trim() }; const tok = String(byId('opsTokenInput').value || '').trim(); if(tok) h['x-proxy-ops-token'] = tok; if(write) h['x-settld-protocol'] = String(byId('protocolInput').value || '').trim() || INITIAL.protocol; if(json) h['content-type'] = 'application/json'; return h; }",
            "async function requestJson(path, { method='GET', body=null, write=false, idem=null } = {}){ const h = headers({ write, json: body !== null }); if(idem) h['x-idempotency-key'] = idem; const res = await fetch(path, { method, headers: h, body: body === null ? undefined : JSON.stringify(body) }); const txt = await res.text(); let j = null; try { j = txt ? JSON.parse(txt) : null; } catch {} if(!res.ok){ throw new Error((j && (j.message || j.error)) ? (j.message || j.error) : (txt || ('HTTP ' + res.status))); } return j; }",
            "function idem(prefix){ return `policy_ws_${prefix}_${Date.now()}_${Math.random().toString(16).slice(2,10)}`; }",
            "function parseJsonInput(id, allowEmpty = false){ const raw = String(byId(id).value || '').trim(); if(!raw){ if(allowEmpty) return null; throw new Error(`${id} is required`); } try { return JSON.parse(raw); } catch (err){ throw new Error(`${id} must be valid JSON`); } }",
            "function refMatches(ref, policy){ if(!ref || !policy) return false; return String(ref.policyId||'')===String(policy.policyId||'') && Number(ref.policyVersion||0)===Number(policy.policyVersion||0); }",
            "function setPolicyRefInputs(policy){ if(!policy) return; byId('rolloutPolicyIdInput').value = String(policy.policyId || ''); byId('rolloutPolicyVersionInput').value = String(policy.policyVersion || ''); byId('rollbackPolicyIdInput').value = String(policy.policyId || ''); byId('rollbackPolicyVersionInput').value = String(policy.policyVersion || ''); byId('diffToPolicyIdInput').value = String(policy.policyId || ''); byId('diffToPolicyVersionInput').value = String(policy.policyVersion || ''); }",
            "function renderPolicies(){ const body = byId('policyVersionsBody'); body.innerHTML = ''; const rows = Array.isArray(state.snapshot?.policies) ? state.snapshot.policies : []; const rollout = state.snapshot?.rollout || null; const activeRef = rollout?.stages?.active || null; const draftRef = rollout?.stages?.draft || null; const canaryRef = rollout?.stages?.canary?.policyRef || null; if(!rows.length){ body.innerHTML = '<tr><td colspan=\"5\" class=\"muted\">No tenant policy versions yet.</td></tr>'; return; } for(const row of rows){ const stageTags = []; if(refMatches(activeRef,row)) stageTags.push('<span class=\"tag active\">active</span>'); if(refMatches(draftRef,row)) stageTags.push('<span class=\"tag draft\">draft</span>'); if(refMatches(canaryRef,row)) stageTags.push('<span class=\"tag canary\">canary</span>'); const tr = document.createElement('tr'); tr.innerHTML = `<td><div class=\\\"mono\\\">${row.policyId}@${row.policyVersion}</div><div class=\\\"muted mono\\\">updated ${row.updatedAt || 'n/a'}</div></td><td>${row.description || '<span class=\\\"muted\\\">(none)</span>'}</td><td><div class=\\\"mono\\\">policy ${row.policyHash || 'n/a'}</div><div class=\\\"mono\\\">verify ${row.verificationMethodHash || 'n/a'}</div></td><td>${stageTags.join(' ') || '<span class=\\\"muted\\\">-</span>'}</td><td><button class=\\\"secondary\\\" type=\\\"button\\\">Select</button></td>`; tr.querySelector('button').addEventListener('click', ()=>{ setPolicyRefInputs(row); byId('upsertPolicyIdInput').value = String(row.policyId || ''); byId('upsertPolicyVersionInput').value = String(row.policyVersion || ''); byId('upsertPolicyDescriptionInput').value = String(row.description || ''); byId('upsertPolicyJson').value = JSON.stringify(row.policy || {}, null, 2); byId('upsertVerificationJson').value = row.verificationMethod ? JSON.stringify(row.verificationMethod, null, 2) : ''; }); body.appendChild(tr); } }",
            "function renderHistory(){ const body = byId('policyRolloutHistoryBody'); body.innerHTML = ''; const rows = Array.isArray(state.snapshot?.rolloutHistory) ? state.snapshot.rolloutHistory : []; if(!rows.length){ body.innerHTML = '<tr><td colspan=\"6\" class=\"muted\">No rollout history yet.</td></tr>'; return; } for(const row of rows){ const tr = document.createElement('tr'); const fromRef = row?.fromPolicyRef ? `${row.fromPolicyRef.policyId}@${row.fromPolicyRef.policyVersion}` : ''; const toRef = row?.toPolicyRef ? `${row.toPolicyRef.policyId}@${row.toPolicyRef.policyVersion}` : ''; tr.innerHTML = `<td class=\\\"mono\\\">${row.at || 'n/a'}</td><td>${row.action || 'update'}</td><td class=\\\"mono\\\">${fromRef}</td><td class=\\\"mono\\\">${toRef}</td><td>${row.stage || '-'}</td><td>${row.note || '<span class=\\\"muted\\\">-</span>'}</td>`; body.appendChild(tr); } }",
            "function renderState(){ setText('policyStateDetail', JSON.stringify(state.snapshot || {}, null, 2)); renderPolicies(); renderHistory(); }",
            "function policyStateQuery(){ const q = new URLSearchParams(); const policyId = String(byId('policyIdFilterInput').value || '').trim(); if(policyId) q.set('policyId', policyId); return q.toString(); }",
            "async function loadState(){ setStatus('workspaceStatus', 'Loading policy control plane...', ''); try { const q = policyStateQuery(); const out = await requestJson(`/ops/settlement-policies/state${q ? ('?' + q) : ''}`); state.snapshot = out; renderState(); setStatus('workspaceStatus', `Loaded ${Array.isArray(out.policies) ? out.policies.length : 0} policy version(s).`, 'good'); } catch (err){ setStatus('workspaceStatus', `Load failed: ${err.message}`, 'bad'); } }",
            "async function upsertPolicy(){ let policy = null; let verificationMethod = null; try { policy = parseJsonInput('upsertPolicyJson', false); verificationMethod = parseJsonInput('upsertVerificationJson', true); } catch (err) { setStatus('upsertStatus', err.message, 'bad'); return; } const policyId = String(byId('upsertPolicyIdInput').value || '').trim(); if(!policyId){ setStatus('upsertStatus', 'policyId is required.', 'bad'); return; } const policyVersionRaw = String(byId('upsertPolicyVersionInput').value || '').trim(); const description = String(byId('upsertPolicyDescriptionInput').value || '').trim(); const body = { policyId, policy, description: description || null }; if(policyVersionRaw) body.policyVersion = Number(policyVersionRaw); if(verificationMethod) body.verificationMethod = verificationMethod; setStatus('upsertStatus', 'Saving policy version...', ''); try { const out = await requestJson('/marketplace/settlement-policies', { method:'POST', body, write:true, idem: idem('upsert') }); const saved = out && out.policy ? out.policy : null; setStatus('upsertStatus', `Saved ${saved?.policyId || policyId}@${saved?.policyVersion || policyVersionRaw || 'auto'}.`, 'good'); await loadState(); } catch (err){ setStatus('upsertStatus', `Save failed: ${err.message}`, 'bad'); } }",
            "async function applyRollout(){ const stage = String(byId('rolloutStageInput').value || '').trim(); const clear = byId('rolloutClearInput').checked; const note = String(byId('rolloutNoteInput').value || '').trim(); const body = { stage, clear }; if(note) body.note = note; if(!clear){ const policyId = String(byId('rolloutPolicyIdInput').value || '').trim(); const policyVersionRaw = String(byId('rolloutPolicyVersionInput').value || '').trim(); if(!policyId || !policyVersionRaw){ setStatus('rolloutStatus', 'policyId and policyVersion are required unless clear is checked.', 'bad'); return; } body.policyRef = { policyId, policyVersion: Number(policyVersionRaw) }; if(stage === 'canary'){ const rolloutPercentRaw = String(byId('rolloutPercentInput').value || '').trim(); if(rolloutPercentRaw) body.rolloutPercent = Number(rolloutPercentRaw); } } setStatus('rolloutStatus', `Applying ${stage} rollout...`, ''); try { const out = await requestJson('/ops/settlement-policies/rollout', { method:'POST', body, write:true, idem: idem('rollout') }); setStatus('rolloutStatus', `${out.action || 'rollout_updated'} succeeded.`, 'good'); await loadState(); } catch (err){ setStatus('rolloutStatus', `Rollout failed: ${err.message}`, 'bad'); } }",
            "async function rollbackPolicy(){ const policyId = String(byId('rollbackPolicyIdInput').value || '').trim(); const policyVersionRaw = String(byId('rollbackPolicyVersionInput').value || '').trim(); const note = String(byId('rollbackNoteInput').value || '').trim(); const body = {}; if(note) body.note = note; if(policyId || policyVersionRaw){ if(!policyId || !policyVersionRaw){ setStatus('rolloutStatus', 'rollback target requires both policyId and policyVersion.', 'bad'); return; } body.policyRef = { policyId, policyVersion: Number(policyVersionRaw) }; } setStatus('rolloutStatus', 'Applying rollback...', ''); try { const out = await requestJson('/ops/settlement-policies/rollback', { method:'POST', body, write:true, idem: idem('rollback') }); setStatus('rolloutStatus', `${out.action || 'rollback'} completed.`, out.action === 'rollback_noop' ? 'warn' : 'good'); await loadState(); } catch (err){ setStatus('rolloutStatus', `Rollback failed: ${err.message}`, 'bad'); } }",
            "async function runDiff(){ const q = new URLSearchParams(); const fromPolicyId = String(byId('diffFromPolicyIdInput').value || '').trim(); const fromPolicyVersion = String(byId('diffFromPolicyVersionInput').value || '').trim(); const toPolicyId = String(byId('diffToPolicyIdInput').value || '').trim(); const toPolicyVersion = String(byId('diffToPolicyVersionInput').value || '').trim(); const limit = String(byId('diffLimitInput').value || '200').trim(); const includeUnchanged = byId('diffIncludeUnchangedInput').checked; if(fromPolicyId) q.set('fromPolicyId', fromPolicyId); if(fromPolicyVersion) q.set('fromPolicyVersion', fromPolicyVersion); if(toPolicyId) q.set('toPolicyId', toPolicyId); if(toPolicyVersion) q.set('toPolicyVersion', toPolicyVersion); if(limit) q.set('limit', limit); if(includeUnchanged) q.set('includeUnchanged', 'true'); setStatus('diffStatus', 'Computing diff...', ''); try { const out = await requestJson(`/ops/settlement-policies/diff?${q.toString()}`); setText('policyDiffDetail', JSON.stringify(out, null, 2)); setStatus('diffStatus', `Diff ready: changed=${out.summary?.changed || 0}, added=${out.summary?.added || 0}, removed=${out.summary?.removed || 0}.`, 'good'); } catch (err){ setStatus('diffStatus', `Diff failed: ${err.message}`, 'bad'); setText('policyDiffDetail', '{}'); } }",
            "async function runReplay(){ const runId = String(byId('replayRunIdInput').value || '').trim(); if(!runId){ setStatus('replayStatus', 'runId is required.', 'bad'); return; } setStatus('replayStatus', `Replaying settlement policy for ${runId}...`, ''); try { const out = await requestJson(`/runs/${encodeURIComponent(runId)}/settlement/policy-replay`); setText('policyReplayDetail', JSON.stringify(out, null, 2)); setStatus('replayStatus', `Replay computed. matchesStoredDecision=${out.matchesStoredDecision === true}.`, out.matchesStoredDecision === true ? 'good' : 'warn'); } catch (err){ setStatus('replayStatus', `Replay failed: ${err.message}`, 'bad'); setText('policyReplayDetail', '{}'); } }",
            "byId('tenantIdInput').value = String(INITIAL.tenantId || 'tenant_default');",
            "byId('opsTokenInput').value = String(INITIAL.opsToken || '');",
            "byId('protocolInput').value = String(INITIAL.protocol || '');",
            "byId('policyIdFilterInput').value = String(INITIAL.policyId || '');",
            "byId('replayRunIdInput').value = String(INITIAL.runId || '');",
            "byId('upsertPolicyIdInput').value = String(INITIAL.policyId || 'market.default.auto-v1');",
            "byId('upsertPolicyJson').value = JSON.stringify({ mode: 'automatic', rules: { requireDeterministicVerification: true, autoReleaseOnGreen: true, autoReleaseOnAmber: false, autoReleaseOnRed: false, greenReleaseRatePct: 100, amberReleaseRatePct: 25, redReleaseRatePct: 0 } }, null, 2);",
            "byId('upsertVerificationJson').value = JSON.stringify({ mode: 'deterministic', source: 'verifier://settld-verify' }, null, 2);",
            "byId('refreshPolicyStateBtn').addEventListener('click', ()=>loadState());",
            "byId('refreshPolicyDiffBtn').addEventListener('click', ()=>runDiff());",
            "byId('refreshPolicyReplayBtn').addEventListener('click', ()=>runReplay());",
            "byId('policyUpsertBtn').addEventListener('click', ()=>upsertPolicy());",
            "byId('policyRolloutBtn').addEventListener('click', ()=>applyRollout());",
            "byId('policyRollbackBtn').addEventListener('click', ()=>rollbackPolicy());",
            "byId('policyDiffBtn').addEventListener('click', ()=>runDiff());",
            "byId('policyReplayBtn').addEventListener('click', ()=>runReplay());",
            "loadState();",
            "</script>",
            "</div></body></html>"
          ].join("\n");
          return sendText(res, 200, html, { contentType: "text/html; charset=utf-8" });
        }

        if (parts[1] === "config" && parts.length === 2 && req.method === "GET") {
          if (!requireScope(auth.scopes, OPS_SCOPES.OPS_READ)) return sendError(res, 403, "forbidden");
          const cfg = getTenantConfig(tenantId) ?? {};
          const billingCfg = cfg?.billing && typeof cfg.billing === "object" && !Array.isArray(cfg.billing) ? cfg.billing : {};
          return sendJson(res, 200, {
            tenantId,
            config: {
              evidenceRetentionMaxDays: Number.isSafeInteger(cfg.evidenceRetentionMaxDays) ? cfg.evidenceRetentionMaxDays : 365,
              billing: {
                plan: normalizeBillingPlanId(billingCfg.plan ?? BILLING_PLAN_ID.FREE, {
                  allowNull: false,
                  defaultPlan: BILLING_PLAN_ID.FREE
                }),
                planOverrides: normalizeBillingPlanOverrides(billingCfg.planOverrides ?? null, { allowNull: true }),
                hardLimitEnforced: billingCfg.hardLimitEnforced !== false
              }
            }
          });
        }

        if (parts[1] === "tenants" && parts[2] === "bootstrap" && parts.length === 3 && req.method === "POST") {
          if (!requireScope(auth.scopes, OPS_SCOPES.OPS_WRITE)) return sendError(res, 403, "forbidden");

          const body = (await readJsonBody(req)) ?? {};

          const apiKeyCreateRequested = body?.apiKey?.create !== false && body?.createApiKey !== false;
          if (apiKeyCreateRequested && typeof store.putAuthKey !== "function") return sendError(res, 501, "auth keys not supported for this store");
          let apiKeyInput = null;
          let billingPlan = null;
          let hardLimitEnforced = null;
          try {
            if (apiKeyCreateRequested) {
              const scopesInput = body?.apiKey?.scopes ?? body?.scopes ?? DEFAULT_TENANT_BOOTSTRAP_API_KEY_SCOPES;
              const scopes = normalizeScopes(scopesInput);
              if (scopes.length === 0) throw new TypeError("apiKey.scopes[] is required");
              for (const s of scopes) {
                if (!ALL_OPS_SCOPES.has(s)) throw new TypeError(`unknown scope: ${s}`);
              }
              const keyIdInput = body?.apiKey?.keyId ?? body?.keyId ?? null;
              const keyId = keyIdInput === null || keyIdInput === undefined ? authKeyId() : String(keyIdInput);
              if (keyId.includes(".") || keyId.includes(" ") || keyId.includes("\n") || keyId.includes("\r")) {
                throw new TypeError("apiKey.keyId is invalid");
              }
              apiKeyInput = {
                keyId,
                scopes,
                expiresAt: body?.apiKey?.expiresAt ?? body?.expiresAt ?? null,
                description: body?.apiKey?.description ?? body?.description ?? "tenant bootstrap"
              };
            }

            const billingInput =
              body?.billing && typeof body.billing === "object" && !Array.isArray(body.billing) ? body.billing : body;
            if (Object.prototype.hasOwnProperty.call(billingInput, "plan")) {
              billingPlan = normalizeBillingPlanId(billingInput.plan, { allowNull: false, defaultPlan: BILLING_PLAN_ID.FREE });
            }
            if (Object.prototype.hasOwnProperty.call(billingInput, "hardLimitEnforced")) {
              hardLimitEnforced = billingInput.hardLimitEnforced === true;
            }
          } catch (err) {
            return sendError(res, 400, "invalid tenant bootstrap payload", { message: err?.message }, { code: "SCHEMA_INVALID" });
          }

          if (typeof store.ensureTenant === "function") store.ensureTenant(tenantId);

          const existingBilling = await getTenantBillingConfig(tenantId);
          const nextBilling = {
            ...(existingBilling && typeof existingBilling === "object" && !Array.isArray(existingBilling) ? existingBilling : {})
          };
          let billingChanged = false;
          if (billingPlan !== null) {
            nextBilling.plan = billingPlan;
            billingChanged = true;
          }
          if (hardLimitEnforced !== null) {
            nextBilling.hardLimitEnforced = hardLimitEnforced;
            billingChanged = true;
          }
          if (billingChanged) {
            await putTenantBillingConfig(tenantId, nextBilling);
          }
          const finalBillingCfg = await getTenantBillingConfig(tenantId);
          const resolvedPlan = resolveTenantBillingPlan({ tenantId });

          let createdApiKey = null;
          if (apiKeyInput) {
            const secret = authKeySecret();
            const secretHash = hashAuthKeySecret(secret);
            const at = nowIso();
            await store.putAuthKey({
              tenantId,
              authKey: {
                keyId: apiKeyInput.keyId,
                secretHash,
                scopes: apiKeyInput.scopes,
                status: "active",
                expiresAt: apiKeyInput.expiresAt,
                description: apiKeyInput.description,
                createdAt: at
              },
              audit: makeOpsAudit({
                action: "API_KEY_CREATE",
                targetType: "auth_key",
                targetId: apiKeyInput.keyId,
                details: {
                  scopes: apiKeyInput.scopes,
                  expiresAt: apiKeyInput.expiresAt,
                  description: apiKeyInput.description,
                  source: "tenant_bootstrap"
                }
              })
            });
            createdApiKey = {
              keyId: apiKeyInput.keyId,
              secret,
              token: `${apiKeyInput.keyId}.${secret}`,
              scopes: apiKeyInput.scopes,
              expiresAt: apiKeyInput.expiresAt,
              description: apiKeyInput.description
            };
          }

          if (typeof store.appendOpsAudit === "function") {
            await store.appendOpsAudit({
              tenantId,
              audit: makeOpsAudit({
                action: "TENANT_BOOTSTRAP",
                targetType: "tenant",
                targetId: tenantId,
                details: {
                  billingChanged,
                  plan: resolvedPlan.planId,
                  hardLimitEnforced: billingChanged ? nextBilling.hardLimitEnforced !== false : null,
                  apiKeyCreated: Boolean(createdApiKey),
                  apiKeyId: createdApiKey?.keyId ?? null
                }
              })
            });
          }

          const requestBaseUrl = deriveRequestBaseUrl(req);
          const env = {
            SETTLD_TENANT_ID: tenantId
          };
          if (requestBaseUrl) env.SETTLD_BASE_URL = requestBaseUrl;
          if (createdApiKey?.token) env.SETTLD_API_KEY = createdApiKey.token;
          const exportCommands = Object.entries(env)
            .map(([name, value]) => `export ${name}=${JSON.stringify(String(value))}`)
            .join("\n");

          return sendJson(res, 201, {
            tenantId,
            bootstrap: {
              tenantId,
              apiBaseUrl: requestBaseUrl,
              apiKey: createdApiKey,
              billing: {
                plan: resolvedPlan.planId,
                hardLimitEnforced:
                  finalBillingCfg && typeof finalBillingCfg === "object" && !Array.isArray(finalBillingCfg)
                    ? finalBillingCfg.hardLimitEnforced !== false
                    : true,
                resolvedPlan
              },
              env,
              exportCommands,
              next: {
                healthcheckCurl: requestBaseUrl ? `curl -sS ${requestBaseUrl}/healthz | jq` : null,
                sdkFirstRunCommand: "npm run dev:sdk:first-run"
              }
            }
          });
        }

        if (parts[1] === "sla-templates" && parts.length === 2 && req.method === "GET") {
          if (!requireScope(auth.scopes, OPS_SCOPES.OPS_READ)) return sendError(res, 403, "forbidden");
          const vertical = url.searchParams.get("vertical");
          try {
            const templates = listSlaPolicyTemplates({ vertical });
            return sendJson(res, 200, {
              schemaVersion: SLA_POLICY_TEMPLATE_CATALOG_VERSION,
              tenantId,
              templates
            });
          } catch (err) {
            return sendError(res, 400, "invalid vertical", { message: err?.message ?? "invalid vertical" }, { code: "SCHEMA_INVALID" });
          }
        }

        // NOTE: /ops/contracts is a legacy contract upsert surface used by existing tests/integrations.
        // Contracts-as-code v1 lives under /ops/contracts-v2 to avoid breaking legacy payloads.
        if (parts[1] === "contracts-v2" && parts[2] === "simulate" && parts.length === 3 && req.method === "POST") {
          metricInc("ops_contracts_v2_requests_total");
          if (!requireScope(auth.scopes, OPS_SCOPES.OPS_READ)) return sendError(res, 403, "forbidden");
          const body = await readJsonBody(req);
          const doc = body?.doc && typeof body.doc === "object" ? body.doc : body;
          try {
            validateContractDocumentV1(doc);
          } catch (err) {
            return sendError(res, 400, "invalid contract document", { message: err?.message }, { code: "SCHEMA_INVALID" });
          }
          const contractHash = hashContractDocumentV1(doc);
          const compiled = compileContractPolicyTemplate({ contractDoc: doc });
          return sendJson(res, 200, {
            contractHash,
            policyHash: compiled.policyHash,
            compilerId: compiled.compilerId,
            policyTemplate: compiled.policyTemplate
          });
        }

        if (parts[1] === "contracts-v2" && parts.length === 2 && req.method === "GET") {
          metricInc("ops_contracts_v2_requests_total");
          if (!requireScope(auth.scopes, OPS_SCOPES.OPS_READ)) return sendError(res, 403, "forbidden");
          if (typeof store.listContractsV2 !== "function") return sendError(res, 501, "contracts v2 not supported for this store");
          const status = url.searchParams.get("status");
          const contracts = await store.listContractsV2({ tenantId, status: status ?? null, limit: 200, offset: 0 });
          return sendJson(res, 200, { contracts });
        }

        if (parts[1] === "contracts-v2" && parts.length === 2 && req.method === "POST") {
          metricInc("ops_contracts_v2_requests_total");
          if (!requireScope(auth.scopes, OPS_SCOPES.OPS_WRITE)) return sendError(res, 403, "forbidden");
          if (typeof store.createContractDraftV2 !== "function") return sendError(res, 501, "contracts v2 not supported for this store");
          const body = await readJsonBody(req);
          const raw = body?.doc && typeof body.doc === "object" ? body.doc : body;

          const contractId = raw?.contractId ? String(raw.contractId) : createId("ctr");
          const contractVersion = raw?.contractVersion !== undefined ? Number(raw.contractVersion) : 1;
          const name = raw?.name ? String(raw.name) : contractId;

          const doc = {
            ...raw,
            type: CONTRACT_DOCUMENT_TYPE_V1,
            v: 1,
            contractId,
            contractVersion,
            name
          };

          try {
            validateContractDocumentV1(doc);
          } catch (err) {
            return sendError(res, 400, "invalid contract document", { message: err?.message }, { code: "SCHEMA_INVALID" });
          }

          let record;
          try {
            record = await store.createContractDraftV2({
              tenantId,
              contractId,
              contractVersion,
              doc,
              audit: makeOpsAudit({ action: "CONTRACT_DRAFT_UPSERT", targetType: "contract", targetId: `${contractId}@${contractVersion}`, details: null })
            });
          } catch (err) {
            if (err?.code === "CONTRACT_NOT_EDITABLE") return sendError(res, 409, "contract is not editable");
            return sendError(res, 400, "failed to upsert contract draft", { message: err?.message });
          }
          return sendJson(res, 201, { contract: record });
        }

        if (parts[1] === "contracts-v2" && parts[2] && parts.length === 3 && req.method === "GET") {
          metricInc("ops_contracts_v2_requests_total");
          if (!requireScope(auth.scopes, OPS_SCOPES.OPS_READ)) return sendError(res, 403, "forbidden");
          const contractId = String(parts[2]);
          if (typeof store.getContractV2 !== "function" || typeof store.getLatestContractV2 !== "function") {
            return sendError(res, 501, "contracts v2 not supported for this store");
          }
          const vRaw = url.searchParams.get("v") ?? url.searchParams.get("contractVersion");
          const v = vRaw === null ? null : Number(vRaw);
          const record =
            v === null || v === undefined
              ? await store.getLatestContractV2({ tenantId, contractId })
              : await store.getContractV2({ tenantId, contractId, contractVersion: v });
          if (!record) return sendError(res, 404, "contract not found");
          return sendJson(res, 200, { contract: record });
        }

        if (parts[1] === "contracts-v2" && parts[2] && parts[3] === "publish" && parts.length === 4 && req.method === "POST") {
          metricInc("ops_contracts_v2_requests_total");
          if (!requireScope(auth.scopes, OPS_SCOPES.OPS_WRITE)) return sendError(res, 403, "forbidden");
          if (typeof store.publishContractV2 !== "function" || typeof store.getContractV2 !== "function") {
            return sendError(res, 501, "contracts v2 not supported for this store");
          }
          const contractId = String(parts[2]);
          const body = (await readJsonBody(req)) ?? {};
          const contractVersion = body?.contractVersion !== undefined ? Number(body.contractVersion) : 1;
          const existing = await store.getContractV2({ tenantId, contractId, contractVersion });
          if (!existing) return sendError(res, 404, "contract not found");
          const doc = existing.doc ?? null;
          if (!doc || typeof doc !== "object") return sendError(res, 500, "contract doc missing");
          const contractHash = hashContractDocumentV1(doc);
          let record;
          try {
            record = await store.publishContractV2({
              tenantId,
              contractId,
              contractVersion,
              contractHash,
              audit: makeOpsAudit({ action: "CONTRACT_PUBLISH", targetType: "contract", targetId: `${contractId}@${contractVersion}`, details: { contractHash } })
            });
          } catch (err) {
            if (err?.code === "CONTRACT_HASH_MISMATCH") return sendError(res, 409, "contract hash mismatch", null, { code: "CONTRACT_HASH_MISMATCH" });
            if (err?.code === "CONTRACT_NOT_PUBLISHABLE") return sendError(res, 409, "contract not publishable");
            return sendError(res, 400, "failed to publish contract", { message: err?.message });
          }
          return sendJson(res, 200, { contract: record });
        }

        if (parts[1] === "contracts-v2" && parts[2] && parts[3] === "sign" && parts.length === 4 && req.method === "POST") {
          metricInc("ops_contracts_v2_requests_total");
          if (!requireScope(auth.scopes, OPS_SCOPES.OPS_WRITE)) return sendError(res, 403, "forbidden");
          if (typeof store.getSignerKey !== "function" || typeof store.putContractSignatureV2 !== "function" || typeof store.getContractV2 !== "function") {
            return sendError(res, 501, "contracts v2 not supported for this store");
          }
          const contractId = String(parts[2]);
          const body = (await readJsonBody(req)) ?? {};
          const contractVersion = body?.contractVersion !== undefined ? Number(body.contractVersion) : 1;
          const partyRole = body?.partyRole ? String(body.partyRole) : null;
          const signerKeyId = body?.signerKeyId ? String(body.signerKeyId) : null;
          const signature = body?.signature ? String(body.signature) : null;
          if (!partyRole) return sendError(res, 400, "partyRole is required");
          if (!signerKeyId) return sendError(res, 400, "signerKeyId is required");
          if (!signature) return sendError(res, 400, "signature is required");
          const contract = await store.getContractV2({ tenantId, contractId, contractVersion });
          if (!contract) return sendError(res, 404, "contract not found");
          const contractHash = contract.contractHash ?? hashContractDocumentV1(contract.doc);
          const signerKey = await store.getSignerKey({ tenantId, keyId: signerKeyId });
          if (!signerKey) return sendError(res, 404, "signer key not found");
          if (String(signerKey.status ?? "") !== "active") return sendError(res, 409, "signer key is not active", null, { code: "SIGNER_REVOKED" });
          const ok = verifyHashHexEd25519({ hashHex: contractHash, signatureBase64: signature, publicKeyPem: signerKey.publicKeyPem });
          if (!ok) return sendError(res, 400, "invalid signature", null, { code: "SIG_INVALID" });
          await store.putContractSignatureV2({
            tenantId,
            contractHash,
            partyRole,
            signerKeyId,
            signature,
            audit: makeOpsAudit({
              action: "CONTRACT_SIGN",
              targetType: "contract",
              targetId: `${contractId}@${contractVersion}`,
              details: { contractHash, partyRole, signerKeyId }
            })
          });
          return sendJson(res, 200, { ok: true });
        }

        if (parts[1] === "contracts-v2" && parts[2] && parts[3] === "activate" && parts.length === 4 && req.method === "POST") {
          metricInc("ops_contracts_v2_requests_total");
          if (!requireScope(auth.scopes, OPS_SCOPES.OPS_WRITE)) return sendError(res, 403, "forbidden");
          if (
            typeof store.getContractV2 !== "function" ||
            typeof store.activateContractV2 !== "function" ||
            typeof store.listContractSignaturesV2 !== "function"
          ) {
            return sendError(res, 501, "contracts v2 not supported for this store");
          }
          const contractId = String(parts[2]);
          const body = (await readJsonBody(req)) ?? {};
          const contractVersion = body?.contractVersion !== undefined ? Number(body.contractVersion) : 1;
          const contract = await store.getContractV2({ tenantId, contractId, contractVersion });
          if (!contract) return sendError(res, 404, "contract not found");
          const doc = contract.doc ?? null;
          if (!doc || typeof doc !== "object") return sendError(res, 500, "contract doc missing");
          const contractHash = contract.contractHash ?? hashContractDocumentV1(doc);

          const sigs = await store.listContractSignaturesV2({ tenantId, contractHash });
          const signedRoles = new Set((sigs ?? []).map((s) => String(s.partyRole ?? "")));

          const requiredRoles = [];
          if (doc.parties && typeof doc.parties === "object") {
            for (const [role, party] of Object.entries(doc.parties)) {
              if (party?.requiresSignature === true) requiredRoles.push(String(role));
            }
          } else {
            requiredRoles.push("platform");
          }
          for (const role of requiredRoles) {
            if (!signedRoles.has(role)) return sendError(res, 409, "missing required signature", { partyRole: role }, { code: "SIGNATURE_REQUIRED" });
          }

          const compiled = compileContractPolicyTemplate({ contractDoc: doc });
          let updated;
          try {
            updated = await store.activateContractV2({
              tenantId,
              contractId,
              contractVersion,
              policyHash: compiled.policyHash,
              compilerId: compiled.compilerId,
              audit: makeOpsAudit({
                action: "CONTRACT_ACTIVATE",
                targetType: "contract",
                targetId: `${contractId}@${contractVersion}`,
                details: { contractHash, policyHash: compiled.policyHash, compilerId: compiled.compilerId }
              })
            });
          } catch (err) {
            if (err?.code === "CONTRACT_NOT_ACTIVATABLE") return sendError(res, 409, "contract not activatable");
            return sendError(res, 400, "failed to activate contract", { message: err?.message });
          }
          return sendJson(res, 200, { contract: updated, contractHash, policyHash: compiled.policyHash, compilerId: compiled.compilerId });
        }

        if (parts[1] === "parties" && parts.length === 2 && req.method === "GET") {
          if (!requireScope(auth.scopes, OPS_SCOPES.OPS_READ)) return sendError(res, 403, "forbidden");
          if (typeof store.listParties !== "function") return sendError(res, 501, "parties not supported for this store");
          const role = url.searchParams.get("role");
          const status = url.searchParams.get("status");
          const parties = await store.listParties({ tenantId, role: role ?? null, status: status ?? null, limit: 200, offset: 0 });
          return sendJson(res, 200, { parties });
        }

        if (parts[1] === "parties" && parts.length === 2 && req.method === "POST") {
          if (!requireScope(auth.scopes, OPS_SCOPES.OPS_WRITE)) return sendError(res, 403, "forbidden");
          if (typeof store.upsertParty !== "function") return sendError(res, 501, "parties not supported for this store");
          const body = (await readJsonBody(req)) ?? {};
          const partyId = body?.partyId ? String(body.partyId) : createId("pty");
          const partyRole = body?.partyRole ? String(body.partyRole) : null;
          const displayName = body?.displayName ? String(body.displayName) : partyId;
          const status = body?.status ? String(body.status) : "active";
          if (!partyRole) return sendError(res, 400, "partyRole is required");
          const record = await store.upsertParty({
            tenantId,
            party: { partyId, partyRole, displayName, status },
            audit: makeOpsAudit({
              action: "PARTY_UPSERT",
              targetType: "party",
              targetId: partyId,
              details: { partyId, partyRole, status }
            })
          });
          return sendJson(res, 201, { party: record });
        }

        if (parts[1] === "parties" && parts[2] && parts.length === 3 && req.method === "GET") {
          if (!requireScope(auth.scopes, OPS_SCOPES.OPS_READ)) return sendError(res, 403, "forbidden");
          if (typeof store.getParty !== "function") return sendError(res, 501, "parties not supported for this store");
          const partyId = String(parts[2]);
          const party = await store.getParty({ tenantId, partyId });
          if (!party) return sendError(res, 404, "party not found");
          return sendJson(res, 200, { party });
        }

	        if (parts[1] === "parties" && parts[2] && parts.length === 3 && req.method === "PATCH") {
	          if (!requireScope(auth.scopes, OPS_SCOPES.OPS_WRITE)) return sendError(res, 403, "forbidden");
	          if (typeof store.upsertParty !== "function" || typeof store.getParty !== "function") return sendError(res, 501, "parties not supported for this store");
	          const partyId = String(parts[2]);
	          const existing = await store.getParty({ tenantId, partyId });
	          if (!existing) return sendError(res, 404, "party not found");
          const body = (await readJsonBody(req)) ?? {};
          const next = {
            partyId,
            partyRole: body?.partyRole ? String(body.partyRole) : existing.partyRole,
            displayName: body?.displayName ? String(body.displayName) : existing.displayName,
            status: body?.status ? String(body.status) : existing.status
          };
          const record = await store.upsertParty({
            tenantId,
            party: next,
            audit: makeOpsAudit({
              action: "PARTY_UPDATE",
              targetType: "party",
              targetId: partyId,
              details: { partyId, status: next.status }
            })
          });
	          return sendJson(res, 200, { party: record });
	        }

	        if (parts[1] === "party-statements" && parts.length === 2 && req.method === "GET") {
	          if (!(requireScope(auth.scopes, OPS_SCOPES.FINANCE_READ) || requireScope(auth.scopes, OPS_SCOPES.FINANCE_WRITE))) {
	            return sendError(res, 403, "forbidden");
	          }
	          if (typeof store.listPartyStatements !== "function") return sendError(res, 501, "party statements not supported for this store");
	          const period = url.searchParams.get("period");
	          if (!period) return sendError(res, 400, "period is required");
	          const status = url.searchParams.get("status");
	          const partyId = url.searchParams.get("partyId");
	          const statements = await store.listPartyStatements({
	            tenantId,
	            period,
	            partyId: partyId ?? null,
	            status: status ?? null,
	            limit: 500,
	            offset: 0
	          });
	          return sendJson(res, 200, { statements });
	        }

	        if (parts[1] === "party-statements" && parts.length === 4 && req.method === "GET") {
	          if (!(requireScope(auth.scopes, OPS_SCOPES.FINANCE_READ) || requireScope(auth.scopes, OPS_SCOPES.FINANCE_WRITE))) {
	            return sendError(res, 403, "forbidden");
	          }
	          if (typeof store.getPartyStatement !== "function") return sendError(res, 501, "party statements not supported for this store");
	          const partyId = String(parts[2]);
	          const period = String(parts[3]);
	          const record = await store.getPartyStatement({ tenantId, partyId, period });
	          if (!record) return sendError(res, 404, "party statement not found");
	          let artifact = null;
	          if (typeof store.getArtifact === "function") {
	            try {
	              artifact = await store.getArtifact({ tenantId, artifactId: record.artifactId });
	            } catch {
	              artifact = null;
	            }
	          }
	          return sendJson(res, 200, { statement: record, artifact });
	        }

	        if (parts[1] === "payouts" && parts.length === 5 && parts[4] === "enqueue" && req.method === "POST") {
	          if (!requireScope(auth.scopes, OPS_SCOPES.FINANCE_WRITE)) return sendError(res, 403, "forbidden");
	          if (typeof store.getPartyStatement !== "function" || typeof store.getArtifact !== "function") {
	            return sendError(res, 501, "payouts not supported for this store");
	          }
          const body = (await readJsonBody(req)) ?? {};
	          const partyId = String(parts[2]);
	          const period = String(parts[3]);
	          const record = await store.getPartyStatement({ tenantId, partyId, period });
	          if (!record) return sendError(res, 404, "party statement not found");

	          const monthId = makeMonthCloseStreamId({ month: period, basis: MONTH_CLOSE_BASIS.SETTLED_AT });
	          let monthEvents = getMonthEvents(tenantId, monthId);
	          if (!monthEvents.length && typeof store.listAggregateEvents === "function") {
	            try {
	              monthEvents = await store.listAggregateEvents({ tenantId, aggregateType: "month", aggregateId: monthId });
	            } catch {
	              monthEvents = [];
	            }
	          }
	          if (!monthEvents.length) return sendError(res, 409, "month close not found");
	          const monthClose = reduceMonthClose(monthEvents);
	          if (!monthClose || monthClose.status !== "CLOSED") return sendError(res, 409, "month is not closed");

	          const partyArtifact = await store.getArtifact({ tenantId, artifactId: record.artifactId });
	          const partyStatementBody = partyArtifact?.statement ?? null;
	          const partyRole = partyArtifact?.partyRole ?? null;
	          if (!partyStatementBody || typeof partyStatementBody !== "object") return sendError(res, 409, "party statement artifact missing statement body");
	          if (typeof partyRole !== "string" || !partyRole.trim()) return sendError(res, 409, "party statement artifact missing partyRole");

	          const payoutAmountCentsGross = computePayoutAmountCentsForStatement({ partyRole, statement: partyStatementBody });
	          if (!Number.isSafeInteger(payoutAmountCentsGross) || payoutAmountCentsGross <= 0) {
	            return sendJson(res, 200, { ok: true, enqueued: false, reason: "no_payout_due" });
	          }

          const providerIdInput =
            typeof body?.moneyRailProviderId === "string" && body.moneyRailProviderId.trim() !== ""
              ? body.moneyRailProviderId.trim()
              : defaultMoneyRailProviderId;
          const adapter = getMoneyRailAdapter(providerIdInput);
          if (!adapter) return sendError(res, 400, "unknown money rail provider");
          const providerConfig = getMoneyRailProviderConfig(providerIdInput);
          if (!providerConfig) return sendError(res, 400, "unknown money rail provider");
          if (providerConfig.allowPayout !== true) {
            return sendError(res, 409, "money rail provider does not support payout direction");
          }

          const billingCfg = await getTenantBillingConfig(tenantId);
          const moneyRailControls = resolveTenantMoneyRailControls({ billingCfg });
          if (providerConfig.mode === "production" && moneyRailControls.realMoneyEnabled !== true) {
            return sendError(
              res,
              409,
              "real-money payouts are disabled for this tenant",
              { providerId: providerIdInput },
              { code: "REAL_MONEY_DISABLED" }
            );
          }
          if (moneyRailControls.payoutKillSwitch === true) {
            return sendError(
              res,
              409,
              "payout kill switch is active",
              { providerId: providerIdInput },
              { code: "PAYOUT_KILL_SWITCH_ACTIVE" }
            );
          }
          if (
            Array.isArray(moneyRailControls.allowedProviderIds) &&
            moneyRailControls.allowedProviderIds.length > 0 &&
            !moneyRailControls.allowedProviderIds.includes(providerIdInput)
          ) {
            return sendError(
              res,
              409,
              "money rail provider is not allowed for this tenant",
              { providerId: providerIdInput, allowedProviderIds: moneyRailControls.allowedProviderIds },
              { code: "MONEY_RAIL_PROVIDER_NOT_ALLOWED" }
            );
          }
          let providerOperationsForChecks = null;
          let payoutAmountCents = payoutAmountCentsGross;
          let chargebackContext = {
            policyEnabled: false,
            negativeBalanceMode: null,
            outstandingBeforeCents: 0,
            recoveryAppliedCents: 0,
            outstandingAfterCents: 0,
            payoutAmountGrossCents: payoutAmountCentsGross,
            payoutAmountNetCents: payoutAmountCentsGross
          };

          const chargebackPolicy = normalizeMoneyRailChargebackPolicy(moneyRailControls.chargebacks ?? null, {
            allowNull: false,
            nowAt: null
          });
          if (chargebackPolicy.enabled === true) {
            if (typeof adapter.listOperations !== "function") {
              return sendError(
                res,
                409,
                "money rail provider does not support chargeback exposure checks",
                { providerId: providerIdInput },
                { code: "CHARGEBACK_POLICY_UNSUPPORTED" }
              );
            }
            providerOperationsForChecks = await adapter.listOperations({ tenantId });
            const exposureByParty = deriveMoneyRailChargebackExposureByParty({ operations: providerOperationsForChecks });
            const partyExposure = exposureByParty.get(partyId) ?? null;
            const outstandingBeforeCents = Number(partyExposure?.outstandingCents ?? 0);
            const maxOutstandingCents =
              Number.isSafeInteger(chargebackPolicy.maxOutstandingCents) && chargebackPolicy.maxOutstandingCents > 0
                ? chargebackPolicy.maxOutstandingCents
                : null;
            chargebackContext = {
              policyEnabled: true,
              negativeBalanceMode: chargebackPolicy.negativeBalanceMode,
              outstandingBeforeCents,
              recoveryAppliedCents: 0,
              outstandingAfterCents: outstandingBeforeCents,
              payoutAmountGrossCents: payoutAmountCentsGross,
              payoutAmountNetCents: payoutAmountCentsGross
            };
            if (maxOutstandingCents !== null && outstandingBeforeCents > maxOutstandingCents) {
              return sendError(
                res,
                409,
                "chargeback outstanding balance exceeds tenant threshold",
                {
                  providerId: providerIdInput,
                  partyId,
                  outstandingBeforeCents,
                  maxOutstandingCents
                },
                { code: "CHARGEBACK_OUTSTANDING_LIMIT_EXCEEDED" }
              );
            }
            if (outstandingBeforeCents > 0) {
              if (chargebackPolicy.negativeBalanceMode === MONEY_RAIL_CHARGEBACK_NEGATIVE_BALANCE_MODE.HOLD) {
                return sendError(
                  res,
                  409,
                  "payout blocked until chargeback balance is resolved",
                  {
                    providerId: providerIdInput,
                    partyId,
                    outstandingBeforeCents,
                    payoutAmountCentsGross
                  },
                  { code: "NEGATIVE_BALANCE_PAYOUT_HOLD" }
                );
              }
              if (chargebackPolicy.negativeBalanceMode === MONEY_RAIL_CHARGEBACK_NEGATIVE_BALANCE_MODE.NET) {
                const recoveryAppliedCents = Math.min(outstandingBeforeCents, payoutAmountCentsGross);
                payoutAmountCents = payoutAmountCentsGross - recoveryAppliedCents;
                chargebackContext = {
                  ...chargebackContext,
                  recoveryAppliedCents,
                  outstandingAfterCents: Math.max(0, outstandingBeforeCents - recoveryAppliedCents),
                  payoutAmountNetCents: payoutAmountCents
                };
                if (payoutAmountCents <= 0) {
                  return sendJson(res, 200, {
                    ok: true,
                    enqueued: false,
                    reason: "chargeback_offset_consumed",
                    chargeback: chargebackContext
                  });
                }
              }
            }
          }
          if (
            Number.isSafeInteger(moneyRailControls.maxPayoutAmountCents) &&
            moneyRailControls.maxPayoutAmountCents > 0 &&
            payoutAmountCents > moneyRailControls.maxPayoutAmountCents
          ) {
            return sendError(
              res,
              409,
              "single payout exceeds tenant limit",
              {
                providerId: providerIdInput,
                payoutAmountCents,
                maxPayoutAmountCents: moneyRailControls.maxPayoutAmountCents
              },
              { code: "PAYOUT_AMOUNT_LIMIT_EXCEEDED" }
            );
          }
          if (Number.isSafeInteger(moneyRailControls.dailyPayoutLimitCents) && moneyRailControls.dailyPayoutLimitCents > 0) {
            if (typeof adapter.listOperations !== "function") {
              return sendError(
                res,
                409,
                "money rail provider does not support payout limit checks",
                { providerId: providerIdInput },
                { code: "MONEY_RAIL_LIMIT_CHECK_UNAVAILABLE" }
              );
            }
            const allOperations = Array.isArray(providerOperationsForChecks) ? providerOperationsForChecks : await adapter.listOperations({ tenantId });
            const dayKey = nowIso().slice(0, 10);
            const currentExposureCents = computeMoneyRailDailyPayoutExposureCents({ operations: allOperations, dayKey });
            const projectedExposureCents = currentExposureCents + payoutAmountCents;
            if (projectedExposureCents > moneyRailControls.dailyPayoutLimitCents) {
              return sendError(
                res,
                409,
                "daily payout limit exceeded",
                {
                  providerId: providerIdInput,
                  dayKey,
                  currentExposureCents,
                  payoutAmountCents,
                  projectedExposureCents,
                  dailyPayoutLimitCents: moneyRailControls.dailyPayoutLimitCents
                },
                { code: "PAYOUT_DAILY_LIMIT_EXCEEDED" }
              );
            }
          }

          let stripeConnectAccountId = null;
          const isStripeProductionProvider =
            providerConfig.mode === "production" && String(providerIdInput).trim().toLowerCase().startsWith("stripe");
          const stripeConnectConfig = normalizeMoneyRailConnectConfig(moneyRailControls.connect ?? null, {
            allowNull: false,
            nowAt: null
          });
          if (isStripeProductionProvider && stripeConnectConfig.enabled === true) {
            const resolvedConnect = resolveStripeConnectAccountForPayout({
              connectConfig: stripeConnectConfig,
              partyId
            });
            if (!resolvedConnect.ok) {
              return sendError(
                res,
                409,
                resolvedConnect.message,
                { providerId: providerIdInput, partyId },
                { code: resolvedConnect.code }
              );
            }
            stripeConnectAccountId = resolvedConnect.account.accountId;
          }

		          const statementHash = record.artifactHash;
		          const payoutKey = payoutKeyFor({ tenantId, partyId, period, statementHash });
		          const payoutArtifactId = `payout_${tenantId}_${partyId}_${period}_${statementHash}`;
		          // Determinism: month-close workers slice eventProof through the MONTH_CLOSE_REQUESTED anchor,
		          // not the later MONTH_CLOSED event. Keep payout instruction hashing aligned so enqueue is idempotent.
		          let requestedEvent = null;
		          for (let i = monthEvents.length - 1; i >= 0; i -= 1) {
		            const e = monthEvents[i];
		            if (e?.type === "MONTH_CLOSE_REQUESTED") {
		              requestedEvent = e;
		              break;
		            }
		          }
		          const requestedChainHash =
		            typeof requestedEvent?.chainHash === "string" && requestedEvent.chainHash.trim() ? requestedEvent.chainHash : null;
		          const proofEvents = requestedChainHash ? sliceEventsThroughChainHash(monthEvents, requestedChainHash) : monthEvents;
		          const generatedAt =
		            (typeof requestedEvent?.payload?.requestedAt === "string" && requestedEvent.payload.requestedAt.trim()
		              ? String(requestedEvent.payload.requestedAt)
		              : null) ??
		            monthClose.requestedAt ??
		            record.closedAt ??
		            nowIso();
		          const payoutBody = buildPayoutInstructionV1({
		            tenantId,
		            partyId,
		            partyRole,
		            period,
		            statementHash,
		            payoutKey,
		            currency: "USD",
		            amountCents: payoutAmountCents,
		            destinationRef: null,
		            events: proofEvents,
		            artifactId: payoutArtifactId,
		            generatedAt
		          });
		          const payoutCore = {
		            ...payoutBody,
		            sourceEventId: requestedEvent?.id ?? monthClose.lastEventId ?? null,
		            atChainHash: requestedChainHash ?? monthClose.lastChainHash ?? null
		          };
		          const payoutHash = computeArtifactHash(payoutCore);
		          const payoutArtifact = { ...payoutCore, artifactHash: payoutHash };
		          await store.putArtifact({ tenantId, artifact: payoutArtifact });

	          const destinations = listDestinationsForTenant(tenantId).filter((d) => {
	            const allowed = Array.isArray(d.artifactTypes) && d.artifactTypes.length ? d.artifactTypes : null;
	            return !allowed || allowed.includes(ARTIFACT_TYPE.PAYOUT_INSTRUCTION_V1);
	          });
	          for (const dest of destinations) {
	            const dedupeKey = `${tenantId}:${dest.destinationId}:${ARTIFACT_TYPE.PAYOUT_INSTRUCTION_V1}:${payoutKey}:${payoutArtifact.artifactHash}`;
	            const scopeKey = `payout:${partyId}:period:${period}`;
	            const orderSeq = 0;
	            const priority = 95;
	            const orderKey = `${scopeKey}\n${String(orderSeq)}\n${String(priority)}\n${payoutArtifact.artifactId}`;
	            try {
	              await store.createDelivery({
	                tenantId,
	                delivery: {
	                  destinationId: dest.destinationId,
	                  artifactType: ARTIFACT_TYPE.PAYOUT_INSTRUCTION_V1,
	                  artifactId: payoutArtifact.artifactId,
	                  artifactHash: payoutArtifact.artifactHash,
	                  dedupeKey,
	                  scopeKey,
	                  orderSeq,
	                  priority,
	                  orderKey
	                }
	              });
	            } catch {
	              // best-effort
	            }
	          }
          let moneyRailOperation = null;
          try {
            const operationId = `mop_${payoutKey}`;
            const counterpartyRefInput =
              typeof body?.counterpartyRef === "string" && body.counterpartyRef.trim() !== ""
                ? body.counterpartyRef.trim()
                : null;
            const expectedStripeConnectCounterpartyRef =
              stripeConnectAccountId !== null ? `stripe_connect:${stripeConnectAccountId}` : null;
            if (
              expectedStripeConnectCounterpartyRef !== null &&
              counterpartyRefInput !== null &&
              counterpartyRefInput !== expectedStripeConnectCounterpartyRef
            ) {
              return sendError(
                res,
                409,
                "counterpartyRef must match configured Stripe Connect account",
                {
                  providerId: providerIdInput,
                  partyId,
                  expectedCounterpartyRef: expectedStripeConnectCounterpartyRef,
                  receivedCounterpartyRef: counterpartyRefInput
                },
                { code: "STRIPE_CONNECT_COUNTERPARTY_MISMATCH" }
              );
            }
            const counterpartyRef =
              expectedStripeConnectCounterpartyRef ??
              counterpartyRefInput ??
              `party:${partyId}`;
            const createdOperation = await adapter.create({
              tenantId,
              operationId,
              direction: "payout",
              idempotencyKey: payoutKey,
              amountCents: payoutAmountCents,
              currency: "USD",
              counterpartyRef,
              metadata: {
                payoutKey,
                payoutArtifactId: payoutArtifact.artifactId,
                payoutArtifactHash: payoutArtifact.artifactHash,
                period,
                partyId,
                stripeConnectAccountId,
                providerMode: providerConfig.mode,
                payoutAmountGrossCents: chargebackContext.payoutAmountGrossCents,
                payoutAmountNetCents: chargebackContext.payoutAmountNetCents,
                chargebackRecoveryAppliedCents: chargebackContext.recoveryAppliedCents,
                chargebackOutstandingBeforeCents: chargebackContext.outstandingBeforeCents,
                chargebackOutstandingAfterCents: chargebackContext.outstandingAfterCents,
                chargebackNegativeBalanceMode: chargebackContext.negativeBalanceMode
              },
              at: nowIso()
            });
            moneyRailOperation = createdOperation?.operation ?? null;
          } catch (err) {
            return sendError(res, 409, "money rail operation rejected", { message: err?.message, code: err?.code ?? null });
          }

	          return sendJson(res, 201, {
              ok: true,
              payout: { payoutKey, artifactId: payoutArtifact.artifactId, artifactHash: payoutArtifact.artifactHash },
              chargeback: chargebackContext,
              moneyRailOperation
            });
	        }

          if (parts[1] === "money-rails" && parts[2] && parts[3] === "operations" && parts[4] && parts.length === 5 && req.method === "GET") {
            if (!(requireScope(auth.scopes, OPS_SCOPES.FINANCE_READ) || requireScope(auth.scopes, OPS_SCOPES.FINANCE_WRITE))) {
              return sendError(res, 403, "forbidden");
            }
            const providerId = decodePathPart(parts[2]);
            const operationId = decodePathPart(parts[4]);
            const adapter = getMoneyRailAdapter(providerId);
            if (!adapter) return sendError(res, 404, "money rail provider not found");
            const operation = await adapter.status({ tenantId, operationId });
            if (!operation) return sendError(res, 404, "money rail operation not found");
            return sendJson(res, 200, { operation });
          }

          if (
            parts[1] === "money-rails" &&
            parts[2] &&
            parts[3] === "operations" &&
            parts[4] &&
            parts[5] === "submit" &&
            parts.length === 6 &&
            req.method === "POST"
          ) {
            if (!requireScope(auth.scopes, OPS_SCOPES.FINANCE_WRITE)) return sendError(res, 403, "forbidden");
            const providerId = decodePathPart(parts[2]);
            const operationId = decodePathPart(parts[4]);
            const adapter = getMoneyRailAdapter(providerId);
            if (!adapter) return sendError(res, 404, "money rail provider not found");
            const providerConfig = getMoneyRailProviderConfig(providerId);
            if (!providerConfig) return sendError(res, 404, "money rail provider not found");

            const body = (await readJsonBody(req)) ?? {};
            if (!body || typeof body !== "object" || Array.isArray(body)) {
              return sendError(res, 400, "invalid submit payload", { message: "body must be an object" }, { code: "SCHEMA_INVALID" });
            }

            let idemStoreKey = null;
            let idemRequestHash = null;
            try {
              ({ idemStoreKey, idemRequestHash } = readIdempotency({ method: "POST", requestPath: path, expectedPrevChainHash: null, body }));
            } catch (err) {
              return sendError(res, 400, "invalid idempotency key", { message: err?.message });
            }
            if (idemStoreKey) {
              const existing = store.idempotency.get(idemStoreKey);
              if (existing) {
                if (existing.requestHash !== idemRequestHash) {
                  return sendError(res, 409, "idempotency key conflict", "request differs from initial use of this key");
                }
                return sendJson(res, existing.statusCode, existing.body);
              }
            }

            const operation = await adapter.status({ tenantId, operationId });
            if (!operation) return sendError(res, 404, "money rail operation not found");
            if (String(operation.direction ?? "").toLowerCase() !== MONEY_RAIL_DIRECTION.PAYOUT) {
              return sendError(
                res,
                409,
                "money rail submit only supports payout operations",
                { operationId, direction: operation.direction ?? null },
                { code: "MONEY_RAIL_SUBMIT_DIRECTION_UNSUPPORTED" }
              );
            }

            const operationState = String(operation.state ?? "").toLowerCase();
            if (operationState !== MONEY_RAIL_OPERATION_STATE.INITIATED) {
              const alreadySubmitted =
                operationState === MONEY_RAIL_OPERATION_STATE.SUBMITTED ||
                operationState === MONEY_RAIL_OPERATION_STATE.CONFIRMED ||
                operationState === MONEY_RAIL_OPERATION_STATE.REVERSED;
              if (alreadySubmitted) {
                const responseBody = {
                  operation,
                  applied: false,
                  reason: "already_submitted",
                  providerSubmission: null
                };
                if (idemStoreKey) {
                  await commitTx([{ kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode: 200, body: responseBody } }]);
                }
                return sendJson(res, 200, responseBody);
              }
              return sendError(
                res,
                409,
                "money rail operation is not in initiated state",
                { operationId, state: operationState },
                { code: "MONEY_RAIL_SUBMIT_INVALID_STATE" }
              );
            }

            let providerRef =
              typeof body?.providerRef === "string" && body.providerRef.trim() !== ""
                ? body.providerRef.trim()
                : null;
            let providerSubmission = null;
            if (providerConfig.mode === "production" && isStripeMoneyRailProviderId(providerId)) {
              const stripeConnectAccountId = parseStripeConnectAccountFromCounterpartyRef(operation.counterpartyRef);
              if (!stripeConnectAccountId) {
                return sendError(
                  res,
                  409,
                  "counterpartyRef must be a Stripe Connect destination for production Stripe payouts",
                  { operationId, counterpartyRef: operation.counterpartyRef ?? null },
                  { code: "STRIPE_CONNECT_COUNTERPARTY_REQUIRED" }
                );
              }

              const payoutKey = normalizeNonEmptyStringOrNull(operation?.metadata?.payoutKey) ?? `${tenantId}:${operationId}`;
              const currency = String(operation.currency ?? "USD").trim().toLowerCase() || "usd";
              let stripeTransfer = null;
              try {
                stripeTransfer = await stripeApiPostJson({
                  endpoint: "/v1/transfers",
                  formData: {
                    amount: String(operation.amountCents),
                    currency,
                    destination: stripeConnectAccountId,
                    transfer_group: payoutKey,
                    description: `Settld payout ${operationId}`,
                    "metadata[settld_tenant_id]": String(tenantId),
                    "metadata[settld_operation_id]": String(operationId),
                    "metadata[settld_provider_id]": String(providerId),
                    "metadata[settld_payout_key]": String(payoutKey)
                  }
                });
              } catch (err) {
                if (typeof store.appendOpsAudit === "function") {
                  try {
                    await store.appendOpsAudit({
                      tenantId,
                      audit: makeOpsAudit({
                        action: "MONEY_RAIL_OPERATION_SUBMIT_REJECTED",
                        targetType: "money_rail_operation",
                        targetId: operationId,
                        details: {
                          providerId,
                          operationId,
                          mode: providerConfig.mode,
                          error: serializeStripeProviderError(err),
                          code: "MONEY_RAIL_PROVIDER_UPSTREAM_ERROR"
                        }
                      })
                    });
                  } catch {
                    // best-effort
                  }
                }
                return sendError(
                  res,
                  stripeProviderErrorStatusCode(err, 502),
                  "money rail payout submit failed",
                  serializeStripeProviderError(err),
                  { code: "MONEY_RAIL_PROVIDER_UPSTREAM_ERROR" }
                );
              }

              providerRef = normalizeNonEmptyStringOrNull(stripeTransfer?.id);
              if (!providerRef) {
                if (typeof store.appendOpsAudit === "function") {
                  try {
                    await store.appendOpsAudit({
                      tenantId,
                      audit: makeOpsAudit({
                        action: "MONEY_RAIL_OPERATION_SUBMIT_REJECTED",
                        targetType: "money_rail_operation",
                        targetId: operationId,
                        details: {
                          providerId,
                          operationId,
                          mode: providerConfig.mode,
                          code: "MONEY_RAIL_PROVIDER_INVALID_RESPONSE",
                          response: stripeTransfer ?? null
                        }
                      })
                    });
                  } catch {
                    // best-effort
                  }
                }
                return sendError(
                  res,
                  502,
                  "stripe payout submission missing transfer id",
                  { operationId, providerId },
                  { code: "MONEY_RAIL_PROVIDER_INVALID_RESPONSE" }
                );
              }
              const createdEpochSeconds = Number(stripeTransfer?.created);
              providerSubmission = {
                providerId,
                mode: providerConfig.mode,
                transferId: providerRef,
                destinationAccountId: stripeConnectAccountId,
                amountCents: Number.isSafeInteger(Number(stripeTransfer?.amount)) ? Number(stripeTransfer.amount) : Number(operation.amountCents),
                currency: typeof stripeTransfer?.currency === "string" ? stripeTransfer.currency : currency,
                createdAt:
                  Number.isFinite(createdEpochSeconds) && createdEpochSeconds > 0
                    ? new Date(createdEpochSeconds * 1000).toISOString()
                    : nowIso()
              };
            } else {
              if (!providerRef) providerRef = `sim_submit_${operationId}`;
              providerSubmission = {
                providerId,
                mode: providerConfig.mode,
                transferId: providerRef,
                simulated: true
              };
            }

            let nextOperation = null;
            let applied = true;
            try {
              if (typeof adapter.transition === "function") {
                nextOperation = await adapter.transition({
                  tenantId,
                  operationId,
                  state: MONEY_RAIL_OPERATION_STATE.SUBMITTED,
                  providerRef,
                  at: nowIso()
                });
              } else if (typeof adapter.ingestProviderEvent === "function") {
                const ingested = await adapter.ingestProviderEvent({
                  tenantId,
                  operationId,
                  eventType: MONEY_RAIL_PROVIDER_EVENT_TYPE.SUBMITTED,
                  providerRef,
                  at: nowIso(),
                  payload: providerSubmission
                });
                nextOperation = ingested?.operation ?? null;
                applied = ingested?.applied !== false;
              } else {
                return sendError(
                  res,
                  409,
                  "money rail provider does not support submit transition",
                  { providerId },
                  { code: "MONEY_RAIL_SUBMIT_UNSUPPORTED" }
                );
              }
            } catch (err) {
              if (err?.code === "MONEY_RAIL_OPERATION_NOT_FOUND") return sendError(res, 404, "money rail operation not found");
              if (err?.code === "MONEY_RAIL_INVALID_TRANSITION") {
                return sendError(
                  res,
                  409,
                  "money rail submit rejected",
                  { message: err?.message, code: err?.code ?? null },
                  { code: "MONEY_RAIL_SUBMIT_INVALID_STATE" }
                );
              }
              return sendError(
                res,
                409,
                "money rail submit rejected",
                { message: err?.message, code: err?.code ?? null },
                { code: "MONEY_RAIL_SUBMIT_REJECTED" }
              );
            }

            if (!nextOperation || typeof nextOperation !== "object") {
              nextOperation = await adapter.status({ tenantId, operationId });
            }
            if (typeof store.appendOpsAudit === "function") {
              try {
                await store.appendOpsAudit({
                  tenantId,
                  audit: makeOpsAudit({
                    action: "MONEY_RAIL_OPERATION_SUBMITTED",
                    targetType: "money_rail_operation",
                    targetId: operationId,
                    details: {
                      providerId,
                      operationId,
                      providerRef: providerRef ?? null,
                      mode: providerConfig.mode,
                      applied
                    }
                  })
                });
              } catch {
                // best-effort
              }
            }

            const responseBody = {
              operation: nextOperation,
              applied,
              providerSubmission
            };
            if (idemStoreKey) {
              await commitTx([{ kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode: 200, body: responseBody } }]);
            }
            return sendJson(res, 200, responseBody);
          }

          if (parts[1] === "finance" && parts[2] === "money-rails" && parts[3] === "chargebacks" && parts.length === 4 && req.method === "GET") {
            if (!(requireScope(auth.scopes, OPS_SCOPES.FINANCE_READ) || requireScope(auth.scopes, OPS_SCOPES.FINANCE_WRITE))) {
              return sendError(res, 403, "forbidden");
            }
            const providerId =
              typeof url.searchParams.get("providerId") === "string" && url.searchParams.get("providerId").trim() !== ""
                ? url.searchParams.get("providerId").trim()
                : defaultMoneyRailProviderId;
            const partyId = normalizeNonEmptyStringOrNull(url.searchParams.get("partyId"));
            let period = null;
            try {
              period = normalizeFinanceReconciliationPeriod(url.searchParams.get("period"), {
                fieldName: "period",
                allowNull: true
              });
            } catch (err) {
              return sendError(res, 400, "invalid chargeback query", { message: err?.message });
            }
            const adapter = getMoneyRailAdapter(providerId);
            if (!adapter) return sendError(res, 404, "money rail provider not found");
            if (typeof adapter.listOperations !== "function") {
              return sendError(res, 409, "money rail provider does not support chargeback exposure listing");
            }
            const operations = await adapter.listOperations({ tenantId });
            const exposureByParty = deriveMoneyRailChargebackExposureByParty({
              operations,
              period
            });
            let rows = Array.from(exposureByParty.values())
              .filter((row) => Number(row?.totalReversedAmountCents ?? 0) > 0 || Number(row?.outstandingCents ?? 0) > 0)
              .map((row) => ({
                partyId: row.partyId,
                outstandingCents: Number(row.outstandingCents ?? 0),
                totalReversedAmountCents: Number(row.totalReversedAmountCents ?? 0),
                totalRecoveredCents: Number(row.totalRecoveredCents ?? 0),
                reversedCount: Number(row.reversedCount ?? 0),
                recoveryCount: Number(row.recoveryCount ?? 0),
                latestReversedAt: row.latestReversedAt ?? null,
                status: Number(row.outstandingCents ?? 0) > 0 ? "negative_balance" : "clear"
              }))
              .sort((a, b) => String(a.partyId).localeCompare(String(b.partyId)));
            if (partyId !== null) {
              rows = rows.filter((row) => row.partyId === partyId);
            }
            const totalOutstandingCents = rows.reduce((sum, row) => sum + Number(row.outstandingCents ?? 0), 0);
            const totalReversedAmountCents = rows.reduce((sum, row) => sum + Number(row.totalReversedAmountCents ?? 0), 0);
            const totalRecoveredCents = rows.reduce((sum, row) => sum + Number(row.totalRecoveredCents ?? 0), 0);
            return sendJson(res, 200, {
              tenantId,
              providerId,
              period,
              partyId,
              summary: {
                partyCount: rows.length,
                totalOutstandingCents,
                totalReversedAmountCents,
                totalRecoveredCents
              },
              parties: rows
            });
          }

          if (parts[1] === "money-rails" && parts[2] && parts[3] === "events" && parts[4] === "ingest" && parts.length === 5 && req.method === "POST") {
            if (!requireScope(auth.scopes, OPS_SCOPES.FINANCE_WRITE)) return sendError(res, 403, "forbidden");
            const providerId = String(parts[2]);
            const adapter = getMoneyRailAdapter(providerId);
            if (!adapter) return sendError(res, 404, "money rail provider not found");
            const providerConfig = getMoneyRailProviderConfig(providerId);
            if (!providerConfig) return sendError(res, 404, "money rail provider not found");
            if (typeof adapter.ingestProviderEvent !== "function") {
              return sendError(res, 409, "money rail provider does not support provider event ingestion");
            }

            const rawBody = await readRawBody(req);
            let body = {};
            if (String(rawBody ?? "").trim() !== "") {
              try {
                body = JSON.parse(String(rawBody));
              } catch (err) {
                return sendError(res, 400, "invalid provider event", { message: "invalid JSON body" }, { code: "SCHEMA_INVALID" });
              }
            }
            if (!body || typeof body !== "object" || Array.isArray(body)) {
              return sendError(res, 400, "invalid provider event", { message: "provider event payload must be an object" }, { code: "SCHEMA_INVALID" });
            }
            if (providerConfig.requireSignedIngest === true) {
              try {
                verifyMoneyRailProviderSignature({
                  signatureHeader: req.headers["x-proxy-provider-signature"] ?? null,
                  rawBody: String(rawBody ?? ""),
                  secret: providerConfig.webhookSecret ?? "",
                  toleranceSeconds: providerConfig.webhookSignatureToleranceSeconds ?? 300,
                  nowAt: nowIso()
                });
              } catch (err) {
                return sendError(res, 400, "invalid provider signature", { message: err?.message ?? null }, { code: "SCHEMA_INVALID" });
              }
            }
            let idemStoreKey = null;
            let idemRequestHash = null;
            try {
              ({ idemStoreKey, idemRequestHash } = readIdempotency({ method: "POST", requestPath: path, expectedPrevChainHash: null, body }));
            } catch (err) {
              return sendError(res, 400, "invalid idempotency key", { message: err?.message });
            }
            if (idemStoreKey) {
              const existing = store.idempotency.get(idemStoreKey);
              if (existing) {
                if (existing.requestHash !== idemRequestHash) {
                  return sendError(res, 409, "idempotency key conflict", "request differs from initial use of this key");
                }
                return sendJson(res, existing.statusCode, existing.body);
              }
            }

            const stripeWebhookHints = isStripeMoneyRailProviderId(providerId) ? extractStripeMoneyRailWebhookHints(body?.payload ?? body) : null;
            let operationId = normalizeNonEmptyStringOrNull(body?.operationId);
            if (!operationId && stripeWebhookHints) {
              operationId = await resolveMoneyRailOperationIdFromStripeHints({
                tenantId,
                adapter,
                hints: stripeWebhookHints
              });
            }
            if (!operationId) {
              if (typeof store.appendOpsAudit === "function") {
                try {
                  await store.appendOpsAudit({
                    tenantId,
                    audit: makeOpsAudit({
                      action: "MONEY_RAIL_PROVIDER_EVENT_REJECTED",
                      targetType: "money_rail_operation",
                      targetId: "unknown",
                      details: {
                        providerId,
                        code: "MONEY_RAIL_OPERATION_ID_REQUIRED",
                        source: stripeWebhookHints ? "stripe_webhook" : "ops_ingest"
                      }
                    })
                  });
                } catch {
                  // best-effort
                }
              }
              return sendError(res, 400, "operationId is required");
            }

            let eventType = null;
            const providerStatusInput = body?.providerStatus ?? stripeWebhookHints?.providerStatus ?? null;
            const eventTypeInput = body?.eventType ?? stripeWebhookHints?.mappedEventType ?? null;
            try {
              eventType = resolveMoneyRailProviderEventType({
                providerId,
                eventType: eventTypeInput,
                providerStatus: providerStatusInput
              });
            } catch (err) {
              if (typeof store.appendOpsAudit === "function") {
                try {
                  await store.appendOpsAudit({
                    tenantId,
                    audit: makeOpsAudit({
                      action: "MONEY_RAIL_PROVIDER_EVENT_REJECTED",
                      targetType: "money_rail_operation",
                      targetId: operationId,
                      details: {
                        providerId,
                        operationId,
                        eventType: eventTypeInput,
                        providerStatus: normalizeMoneyRailProviderStatusValue(providerStatusInput),
                        message: err?.message ?? null,
                        code: "MONEY_RAIL_PROVIDER_EVENT_TYPE_INVALID",
                        source: stripeWebhookHints ? "stripe_webhook" : "ops_ingest"
                      }
                    })
                  });
                } catch {
                  // best-effort
                }
              }
              return sendError(res, 400, "invalid provider event", { message: err?.message });
            }

            const eventId = normalizeNonEmptyStringOrNull(body?.eventId) ?? stripeWebhookHints?.eventId ?? null;
            const providerRef = normalizeNonEmptyStringOrNull(body?.providerRef) ?? stripeWebhookHints?.providerRef ?? null;
            const reasonCode = typeof body?.reasonCode === "string" && body.reasonCode.trim() !== "" ? body.reasonCode.trim() : null;
            const payload = Object.prototype.hasOwnProperty.call(body, "payload") ? body?.payload : stripeWebhookHints?.rawEvent ?? null;
            if (payload !== undefined && payload !== null && (typeof payload !== "object" || Array.isArray(payload))) {
              return sendError(res, 400, "payload must be an object or null");
            }
            const at =
              typeof body?.at === "string" && body.at.trim() !== ""
                ? body.at.trim()
                : stripeWebhookHints?.at
                  ? stripeWebhookHints.at
                : nowIso();
            if (!Number.isFinite(Date.parse(at))) return sendError(res, 400, "at must be an ISO date-time");

            let ingested = null;
            try {
              ingested = await adapter.ingestProviderEvent({
                tenantId,
                operationId,
                eventType,
                providerRef,
                reasonCode,
                at,
                eventId,
                payload: payload ?? null
              });
            } catch (err) {
              if (typeof store.appendOpsAudit === "function") {
                try {
                  await store.appendOpsAudit({
                    tenantId,
                    audit: makeOpsAudit({
                      action: "MONEY_RAIL_PROVIDER_EVENT_REJECTED",
                      targetType: "money_rail_operation",
                      targetId: operationId,
                      details: {
                        providerId,
                        operationId,
                        eventType,
                        providerStatus: normalizeMoneyRailProviderStatusValue(providerStatusInput),
                        eventId: eventId ?? null,
                        providerRef: providerRef ?? null,
                        reasonCode: reasonCode ?? null,
                        message: err?.message ?? null,
                        code: err?.code ?? "MONEY_RAIL_PROVIDER_EVENT_REJECTED",
                        source: stripeWebhookHints ? "stripe_webhook" : "ops_ingest"
                      }
                    })
                  });
                } catch {
                  // best-effort
                }
              }
              if (err?.code === "MONEY_RAIL_OPERATION_NOT_FOUND") return sendError(res, 404, "money rail operation not found");
              if (err?.code === "MONEY_RAIL_INVALID_TRANSITION") {
                return sendError(res, 409, "money rail provider event rejected", { message: err?.message, code: err?.code ?? null });
              }
              return sendError(res, 409, "money rail provider event rejected", { message: err?.message, code: err?.code ?? null });
            }

            const responseBody = {
              operation: ingested?.operation ?? null,
              event: ingested?.event ?? null,
              applied: Boolean(ingested?.applied),
              eventType,
              providerStatus: normalizeMoneyRailProviderStatusValue(providerStatusInput)
            };
            if (typeof store.appendOpsAudit === "function") {
              try {
                await store.appendOpsAudit({
                  tenantId,
                  audit: makeOpsAudit({
                    action: "MONEY_RAIL_PROVIDER_EVENT_INGEST",
                    targetType: "money_rail_operation",
                    targetId: operationId,
                    details: {
                      providerId,
                      operationId,
                      eventType,
                      providerStatus: responseBody.providerStatus,
                      eventId: eventId ?? null,
                      providerRef: providerRef ?? null,
                      reasonCode: reasonCode ?? null,
                      applied: responseBody.applied === true,
                      duplicate: responseBody.applied !== true,
                      source: stripeWebhookHints ? "stripe_webhook" : "ops_ingest"
                    }
                  })
                });
              } catch {
                // best-effort
              }
            }
            if (
              responseBody.applied === true &&
              eventType === MONEY_RAIL_PROVIDER_EVENT_TYPE.REVERSED &&
              typeof store.appendOpsAudit === "function"
            ) {
              try {
                const operation = responseBody.operation ?? null;
                const partyId = normalizeMoneyRailOperationPartyId(operation);
                const amountCents = Number.isSafeInteger(Number(operation?.amountCents)) ? Number(operation.amountCents) : null;
                let outstandingAfterCents = null;
                if (partyId && typeof adapter.listOperations === "function") {
                  const allOperations = await adapter.listOperations({ tenantId });
                  const exposureByParty = deriveMoneyRailChargebackExposureByParty({ operations: allOperations });
                  outstandingAfterCents = Number(exposureByParty.get(partyId)?.outstandingCents ?? 0);
                }
                await store.appendOpsAudit({
                  tenantId,
                  audit: makeOpsAudit({
                    action: "MONEY_RAIL_CHARGEBACK_RECORDED",
                    targetType: "money_rail_operation",
                    targetId: operationId,
                    details: {
                      providerId,
                      operationId,
                      eventType,
                      eventId: eventId ?? null,
                      partyId,
                      amountCents,
                      reasonCode: reasonCode ?? null,
                      outstandingAfterCents
                    }
                  })
                });
              } catch {
                // best-effort audit signal
              }
            }
            if (idemStoreKey) {
              await commitTx([
                {
                  kind: "IDEMPOTENCY_PUT",
                  key: idemStoreKey,
                  value: { requestHash: idemRequestHash, statusCode: 200, body: responseBody }
                }
              ]);
            }
            return sendJson(res, 200, responseBody);
          }

          if (
            parts[1] === "money-rails" &&
            parts[2] &&
            parts[3] === "operations" &&
            parts[4] &&
            parts[5] === "cancel" &&
            parts.length === 6 &&
            req.method === "POST"
          ) {
            if (!requireScope(auth.scopes, OPS_SCOPES.FINANCE_WRITE)) return sendError(res, 403, "forbidden");
            const providerId = decodePathPart(parts[2]);
            const operationId = decodePathPart(parts[4]);
            const adapter = getMoneyRailAdapter(providerId);
            if (!adapter) return sendError(res, 404, "money rail provider not found");

            const body = (await readJsonBody(req)) ?? {};
            let idemStoreKey = null;
            let idemRequestHash = null;
            try {
              ({ idemStoreKey, idemRequestHash } = readIdempotency({ method: "POST", requestPath: path, expectedPrevChainHash: null, body }));
            } catch (err) {
              return sendError(res, 400, "invalid idempotency key", { message: err?.message });
            }
            if (idemStoreKey) {
              const existing = store.idempotency.get(idemStoreKey);
              if (existing) {
                if (existing.requestHash !== idemRequestHash) {
                  return sendError(res, 409, "idempotency key conflict", "request differs from initial use of this key");
                }
                return sendJson(res, existing.statusCode, existing.body);
              }
            }

            const reasonCode =
              typeof body?.reasonCode === "string" && body.reasonCode.trim() !== "" ? body.reasonCode.trim() : "cancelled_by_ops";
            let cancelled = null;
            try {
              cancelled = await adapter.cancel({ tenantId, operationId, reasonCode, at: nowIso() });
            } catch (err) {
              if (err?.code === "MONEY_RAIL_OPERATION_NOT_FOUND") return sendError(res, 404, "money rail operation not found");
              return sendError(res, 409, "money rail cancellation rejected", { message: err?.message, code: err?.code ?? null });
            }

            const responseBody = { operation: cancelled?.operation ?? null, applied: Boolean(cancelled?.applied) };
            if (idemStoreKey) {
              await commitTx([
                {
                  kind: "IDEMPOTENCY_PUT",
                  key: idemStoreKey,
                  value: { requestHash: idemRequestHash, statusCode: 200, body: responseBody }
                }
              ]);
            }
            return sendJson(res, 200, responseBody);
          }

          if (
            parts[1] === "finance" &&
            parts[2] === "money-rails" &&
            parts[3] === "stripe-connect" &&
            parts[4] === "accounts" &&
            parts.length === 5 &&
            req.method === "GET"
          ) {
            if (!(requireScope(auth.scopes, OPS_SCOPES.FINANCE_READ) || requireScope(auth.scopes, OPS_SCOPES.FINANCE_WRITE))) {
              return sendError(res, 403, "forbidden");
            }
            const billingCfg = await getTenantBillingConfig(tenantId);
            const moneyRailControls = resolveTenantMoneyRailControls({ billingCfg });
            const connect = normalizeMoneyRailConnectConfig(moneyRailControls.connect ?? null, {
              allowNull: false,
              nowAt: null
            });
            const activeCount = connect.accounts.filter((row) => row.status === "active").length;
            const payoutsEnabledCount = connect.accounts.filter((row) => row.status === "active" && row.payoutsEnabled === true).length;
            const verifiedCount = connect.accounts.filter((row) => row.kybStatus === MONEY_RAIL_CONNECT_KYB_STATUS.VERIFIED).length;
            const pendingCount = connect.accounts.filter((row) => row.kybStatus === MONEY_RAIL_CONNECT_KYB_STATUS.PENDING).length;
            const rejectedCount = connect.accounts.filter((row) => row.kybStatus === MONEY_RAIL_CONNECT_KYB_STATUS.REJECTED).length;
            return sendJson(res, 200, {
              tenantId,
              connect,
              summary: {
                totalAccounts: connect.accounts.length,
                activeCount,
                payoutsEnabledCount,
                verifiedCount,
                pendingCount,
                rejectedCount,
                defaultAccountId: connect.defaultAccountId
              }
            });
          }

          if (
            parts[1] === "finance" &&
            parts[2] === "money-rails" &&
            parts[3] === "stripe-connect" &&
            parts[4] === "accounts" &&
            parts[5] === "sync" &&
            parts.length === 6 &&
            req.method === "POST"
          ) {
            if (!requireScope(auth.scopes, OPS_SCOPES.FINANCE_WRITE)) return sendError(res, 403, "forbidden");
            const body = (await readJsonBody(req)) ?? {};
            if (!body || typeof body !== "object" || Array.isArray(body)) {
              return sendError(res, 400, "invalid stripe connect sync payload", { message: "body must be an object" }, { code: "SCHEMA_INVALID" });
            }
            const providerIdQuery = normalizeNonEmptyStringOrNull(url.searchParams.get("providerId"));
            const providerIdBody = normalizeNonEmptyStringOrNull(body.providerId);
            const providerId = providerIdBody ?? providerIdQuery ?? defaultMoneyRailProviderId;
            if (!isStripeMoneyRailProviderId(providerId)) {
              return sendError(res, 400, "stripe connect sync requires a stripe provider", { providerId }, { code: "SCHEMA_INVALID" });
            }
            const providerConfig = getMoneyRailProviderConfig(providerId);
            if (!providerConfig) return sendError(res, 404, "money rail provider not found");
            if (!effectiveBillingStripeSecretKey) {
              return sendError(
                res,
                409,
                "stripe secret key is not configured",
                { providerId },
                { code: "STRIPE_SECRET_KEY_REQUIRED" }
              );
            }

            const dryRun = body?.dryRun === true;
            const accountIdsInput = Array.isArray(body.accountIds) ? body.accountIds : [];
            let idemStoreKey = null;
            let idemRequestHash = null;
            const idempotencyBody = {
              ...body,
              providerId
            };
            try {
              ({ idemStoreKey, idemRequestHash } = readIdempotency({
                method: "POST",
                requestPath: path,
                expectedPrevChainHash: null,
                body: idempotencyBody
              }));
            } catch (err) {
              return sendError(res, 400, "invalid idempotency key", { message: err?.message });
            }
            if (idemStoreKey) {
              const existing = store.idempotency.get(idemStoreKey);
              if (existing) {
                if (existing.requestHash !== idemRequestHash) {
                  return sendError(res, 409, "idempotency key conflict", "request differs from initial use of this key");
                }
                return sendJson(res, existing.statusCode, existing.body);
              }
            }

            const billingCfg = await getTenantBillingConfig(tenantId);
            const moneyRailControls = resolveTenantMoneyRailControls({ billingCfg });
            const connect = normalizeMoneyRailConnectConfig(moneyRailControls.connect ?? null, { allowNull: false, nowAt: null });
            const byAccountId = new Map(connect.accounts.map((row) => [row.accountId, row]));

            const requestedIds = [];
            const seenRequested = new Set();
            for (const rawId of accountIdsInput) {
              let accountId = null;
              try {
                accountId = normalizeStripeConnectAccountId(rawId, {
                  fieldName: "accountIds[]",
                  allowNull: false
                });
              } catch (err) {
                return sendError(res, 400, "invalid stripe connect sync payload", { message: err?.message }, { code: "SCHEMA_INVALID" });
              }
              if (seenRequested.has(accountId)) continue;
              seenRequested.add(accountId);
              requestedIds.push(accountId);
            }
            const targetAccountIds = requestedIds.length > 0 ? requestedIds : connect.accounts.map((row) => row.accountId);
            if (targetAccountIds.length === 0) {
              const responseBody = {
                tenantId,
                providerId,
                dryRun,
                summary: {
                  requestedCount: 0,
                  syncedCount: 0,
                  failedCount: 0
                },
                results: [],
                connect
              };
              if (idemStoreKey) {
                await commitTx([{ kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode: 200, body: responseBody } }]);
              }
              return sendJson(res, 200, responseBody);
            }

            const nowAt = nowIso();
            const accountUpdates = new Map();
            const results = [];
            let syncedCount = 0;
            let failedCount = 0;
            for (const accountId of targetAccountIds) {
              const existingAccount = byAccountId.get(accountId) ?? null;
              if (!existingAccount) {
                failedCount += 1;
                results.push({
                  accountId,
                  ok: false,
                  error: "account is not configured in tenant connect settings",
                  code: "STRIPE_CONNECT_ACCOUNT_NOT_CONFIGURED"
                });
                continue;
              }
              try {
                const stripeAccount = await stripeApiGetJson({
                  endpoint: `/v1/accounts/${encodeURIComponent(accountId)}`
                });
                const kybSnapshot = deriveStripeConnectKybSnapshot(stripeAccount);
                const nextAccount = normalizeMoneyRailConnectAccounts(
                  [
                    {
                      ...existingAccount,
                      accountId,
                      payoutsEnabled: kybSnapshot.payoutsEnabled,
                      transfersEnabled: kybSnapshot.transfersEnabled,
                      status: kybSnapshot.kybStatus === MONEY_RAIL_CONNECT_KYB_STATUS.REJECTED ? "disabled" : "active",
                      kybStatus: kybSnapshot.kybStatus,
                      kybCurrentlyDue: kybSnapshot.kybCurrentlyDue,
                      kybPendingVerification: kybSnapshot.kybPendingVerification,
                      kybDisabledReason: kybSnapshot.kybDisabledReason,
                      kybLastSyncAt: nowAt,
                      kybLastSyncError: null,
                      updatedAt: nowAt
                    }
                  ],
                  { nowAt }
                )[0];
                accountUpdates.set(accountId, nextAccount);
                syncedCount += 1;
                results.push({
                  accountId,
                  ok: true,
                  payoutsEnabled: nextAccount.payoutsEnabled,
                  transfersEnabled: nextAccount.transfersEnabled,
                  kybStatus: nextAccount.kybStatus,
                  kybCurrentlyDueCount: nextAccount.kybCurrentlyDue.length,
                  kybPendingVerificationCount: nextAccount.kybPendingVerification.length,
                  kybDisabledReason: nextAccount.kybDisabledReason ?? null
                });
              } catch (err) {
                failedCount += 1;
                const serializedError = serializeStripeProviderError(err);
                if (dryRun !== true) {
                  const nextAccount = normalizeMoneyRailConnectAccounts(
                    [
                      {
                        ...existingAccount,
                        kybLastSyncAt: nowAt,
                        kybLastSyncError:
                          serializedError.message ??
                          "stripe account sync failed",
                        updatedAt: nowAt
                      }
                    ],
                    { nowAt }
                  )[0];
                  accountUpdates.set(accountId, nextAccount);
                }
                results.push({
                  accountId,
                  ok: false,
                  code: "STRIPE_CONNECT_SYNC_FAILED",
                  error: serializedError
                });
              }
            }

            let nextConnect = connect;
            if (dryRun !== true) {
              const nextAccounts = connect.accounts.map((row) => accountUpdates.get(row.accountId) ?? row);
              nextConnect = normalizeMoneyRailConnectConfig(
                {
                  ...connect,
                  accounts: nextAccounts,
                  updatedAt: nowAt
                },
                { allowNull: false, nowAt }
              );
              const nextMoneyRails = normalizeMoneyRailControls(
                {
                  ...moneyRailControls,
                  connect: nextConnect,
                  updatedAt: nowAt
                },
                { allowNull: false, defaultRealMoneyEnabled: moneyRailControls.realMoneyEnabled === true, nowAt }
              );
              await putTenantBillingConfig(tenantId, {
                ...billingCfg,
                moneyRails: nextMoneyRails
              });
            }

            if (typeof store.appendOpsAudit === "function") {
              await store.appendOpsAudit({
                tenantId,
                audit: makeOpsAudit({
                  action: "STRIPE_CONNECT_ACCOUNTS_SYNC",
                  targetType: "stripe_connect_account",
                  targetId: providerId,
                  details: {
                    providerId,
                    dryRun,
                    requestedCount: targetAccountIds.length,
                    syncedCount,
                    failedCount
                  }
                })
              });
            }

            const responseBody = {
              tenantId,
              providerId,
              dryRun,
              summary: {
                requestedCount: targetAccountIds.length,
                syncedCount,
                failedCount
              },
              results,
              connect: nextConnect
            };
            if (idemStoreKey) {
              await commitTx([{ kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode: 200, body: responseBody } }]);
            }
            return sendJson(res, 200, responseBody);
          }

          if (
            parts[1] === "finance" &&
            parts[2] === "money-rails" &&
            parts[3] === "stripe-connect" &&
            parts[4] === "accounts" &&
            parts[5] &&
            parts.length === 6 &&
            req.method === "PUT"
          ) {
            if (!requireScope(auth.scopes, OPS_SCOPES.FINANCE_WRITE)) return sendError(res, 403, "forbidden");
            let accountId = null;
            try {
              accountId = normalizeStripeConnectAccountId(parts[5], {
                fieldName: "accountId",
                allowNull: false
              });
            } catch (err) {
              return sendError(res, 400, "invalid stripe connect account payload", { message: err?.message }, { code: "SCHEMA_INVALID" });
            }
            const body = (await readJsonBody(req)) ?? {};
            if (!body || typeof body !== "object" || Array.isArray(body)) {
              return sendError(res, 400, "invalid stripe connect account payload", { message: "body must be an object" }, { code: "SCHEMA_INVALID" });
            }
            const billingCfg = await getTenantBillingConfig(tenantId);
            const moneyRailControls = resolveTenantMoneyRailControls({ billingCfg });
            const connect = normalizeMoneyRailConnectConfig(moneyRailControls.connect ?? null, { allowNull: false, nowAt: null });
            const byAccountId = new Map(connect.accounts.map((row) => [row.accountId, row]));
            const existing = byAccountId.get(accountId) ?? null;
            const nowAt = nowIso();
            const partyId =
              Object.prototype.hasOwnProperty.call(body, "partyId")
                ? normalizeNonEmptyStringOrNull(body.partyId)
                : existing?.partyId ?? null;
            const partyRole =
              Object.prototype.hasOwnProperty.call(body, "partyRole")
                ? normalizeNonEmptyStringOrNull(body.partyRole)
                : existing?.partyRole ?? null;
            const statusRaw =
              Object.prototype.hasOwnProperty.call(body, "status")
                ? normalizeNonEmptyStringOrNull(body.status)
                : existing?.status ?? "active";
            const status = String(statusRaw ?? "active").toLowerCase();
            if (status !== "active" && status !== "disabled") {
              return sendError(res, 400, "invalid stripe connect account payload", { message: "status must be active|disabled" }, { code: "SCHEMA_INVALID" });
            }
            const payoutsEnabled =
              Object.prototype.hasOwnProperty.call(body, "payoutsEnabled")
                ? body.payoutsEnabled === true
                : existing?.payoutsEnabled !== false;
            const transfersEnabled =
              Object.prototype.hasOwnProperty.call(body, "transfersEnabled")
                ? body.transfersEnabled === true
                : existing?.transfersEnabled !== false;

            const nextAccount = normalizeMoneyRailConnectAccounts(
              [
                {
                  accountId,
                  partyId,
                  partyRole,
                  status,
                  payoutsEnabled,
                  transfersEnabled,
                  kybStatus: existing?.kybStatus ?? null,
                  kybCurrentlyDue: existing?.kybCurrentlyDue ?? [],
                  kybPendingVerification: existing?.kybPendingVerification ?? [],
                  kybDisabledReason: existing?.kybDisabledReason ?? null,
                  kybLastSyncAt: existing?.kybLastSyncAt ?? null,
                  kybLastSyncError: existing?.kybLastSyncError ?? null,
                  updatedAt: nowAt
                }
              ],
              { nowAt }
            )[0];

            const nextAccounts = connect.accounts.filter((row) => row.accountId !== accountId);
            if (nextAccount.partyId !== null) {
              const conflict = nextAccounts.find((row) => row.partyId === nextAccount.partyId);
              if (conflict) {
                return sendError(
                  res,
                  409,
                  "party is already mapped to another Stripe Connect account",
                  { partyId: nextAccount.partyId, conflictingAccountId: conflict.accountId },
                  { code: "STRIPE_CONNECT_PARTY_CONFLICT" }
                );
              }
            }
            nextAccounts.push(nextAccount);
            nextAccounts.sort((a, b) => String(a.accountId).localeCompare(String(b.accountId)));

            const nextDefaultAccountId =
              body?.setDefault === true
                ? accountId
                : body?.setDefault === false && connect.defaultAccountId === accountId
                  ? null
                  : connect.defaultAccountId;
            const nextConnect = normalizeMoneyRailConnectConfig(
              {
                ...connect,
                enabled: body?.enableConnect === true ? true : connect.enabled,
                defaultAccountId: nextDefaultAccountId,
                accounts: nextAccounts,
                updatedAt: nowAt
              },
              { allowNull: false, nowAt }
            );
            const nextMoneyRails = normalizeMoneyRailControls(
              {
                ...moneyRailControls,
                connect: nextConnect,
                updatedAt: nowAt
              },
              { allowNull: false, defaultRealMoneyEnabled: moneyRailControls.realMoneyEnabled === true, nowAt }
            );
            const nextBilling = {
              ...billingCfg,
              moneyRails: nextMoneyRails
            };
            await putTenantBillingConfig(tenantId, nextBilling);
            if (typeof store.appendOpsAudit === "function") {
              await store.appendOpsAudit({
                tenantId,
                audit: makeOpsAudit({
                  action: "STRIPE_CONNECT_ACCOUNT_UPSERT",
                  targetType: "stripe_connect_account",
                  targetId: accountId,
                  details: {
                    accountId,
                    partyId: nextAccount.partyId,
                    status: nextAccount.status,
                    payoutsEnabled: nextAccount.payoutsEnabled,
                    isDefault: nextConnect.defaultAccountId === accountId
                  }
                })
              });
            }
            return sendJson(res, 200, {
              tenantId,
              account: nextAccount,
              connect: nextConnect
            });
          }

          if (
            parts[1] === "finance" &&
            parts[2] === "money-rails" &&
            parts[3] === "stripe-connect" &&
            parts[4] === "accounts" &&
            parts[5] &&
            parts.length === 6 &&
            req.method === "DELETE"
          ) {
            if (!requireScope(auth.scopes, OPS_SCOPES.FINANCE_WRITE)) return sendError(res, 403, "forbidden");
            let accountId = null;
            try {
              accountId = normalizeStripeConnectAccountId(parts[5], {
                fieldName: "accountId",
                allowNull: false
              });
            } catch (err) {
              return sendError(res, 400, "invalid stripe connect account payload", { message: err?.message }, { code: "SCHEMA_INVALID" });
            }
            const billingCfg = await getTenantBillingConfig(tenantId);
            const moneyRailControls = resolveTenantMoneyRailControls({ billingCfg });
            const connect = normalizeMoneyRailConnectConfig(moneyRailControls.connect ?? null, { allowNull: false, nowAt: null });
            const existing = connect.accounts.find((row) => row.accountId === accountId) ?? null;
            if (!existing) return sendError(res, 404, "stripe connect account not found");
            const nowAt = nowIso();
            const nextAccounts = connect.accounts.filter((row) => row.accountId !== accountId);
            const nextConnect = normalizeMoneyRailConnectConfig(
              {
                ...connect,
                defaultAccountId: connect.defaultAccountId === accountId ? null : connect.defaultAccountId,
                accounts: nextAccounts,
                updatedAt: nowAt
              },
              { allowNull: false, nowAt }
            );
            const nextMoneyRails = normalizeMoneyRailControls(
              {
                ...moneyRailControls,
                connect: nextConnect,
                updatedAt: nowAt
              },
              { allowNull: false, defaultRealMoneyEnabled: moneyRailControls.realMoneyEnabled === true, nowAt }
            );
            const nextBilling = {
              ...billingCfg,
              moneyRails: nextMoneyRails
            };
            await putTenantBillingConfig(tenantId, nextBilling);
            if (typeof store.appendOpsAudit === "function") {
              await store.appendOpsAudit({
                tenantId,
                audit: makeOpsAudit({
                  action: "STRIPE_CONNECT_ACCOUNT_DELETE",
                  targetType: "stripe_connect_account",
                  targetId: accountId,
                  details: {
                    accountId,
                    partyId: existing.partyId ?? null
                  }
                })
              });
            }
            return sendJson(res, 200, {
              tenantId,
              deleted: true,
              accountId,
              connect: nextConnect
            });
          }

          if (parts[1] === "finance" && parts[2] === "money-rails" && parts[3] === "reconcile" && parts.length === 4 && req.method === "GET") {
            if (!(requireScope(auth.scopes, OPS_SCOPES.FINANCE_READ) || requireScope(auth.scopes, OPS_SCOPES.FINANCE_WRITE))) {
              return sendError(res, 403, "forbidden");
            }

            const period = url.searchParams.get("period") ?? url.searchParams.get("month");
            if (!period) return sendError(res, 400, "period is required");

            const providerIdQuery =
              typeof url.searchParams.get("providerId") === "string" && url.searchParams.get("providerId").trim() !== ""
                ? url.searchParams.get("providerId").trim()
                : defaultMoneyRailProviderId;
            let persist = false;
            try {
              persist = parseBooleanQueryValue(url.searchParams.get("persist"), {
                defaultValue: false,
                name: "persist"
              });
            } catch (err) {
              return sendError(res, 400, "invalid money rail reconciliation query", { message: err?.message });
            }
            try {
              const report = await computeMoneyRailReconcileReport({
                tenantId,
                period,
                providerId: providerIdQuery,
                persist,
                includeTriages: true
              });
              return sendJson(res, 200, report);
            } catch (err) {
              if (Number.isSafeInteger(err?.statusCode)) {
                return sendError(res, err.statusCode, err?.message ?? "money rail reconcile failed", { code: err?.code ?? null });
              }
              throw err;
            }
          }

          if (parts[1] === "finance" && parts[2] === "billing" && parts[3] === "catalog" && parts.length === 4 && req.method === "GET") {
            if (!(requireScope(auth.scopes, OPS_SCOPES.FINANCE_READ) || requireScope(auth.scopes, OPS_SCOPES.FINANCE_WRITE))) {
              return sendError(res, 403, "forbidden");
            }
            return sendJson(res, 200, {
              schemaVersion: "BillingPlanCatalog.v1",
              plans: getBillingPlanCatalog()
            });
          }

          if (parts[1] === "finance" && parts[2] === "billing" && parts[3] === "plan" && parts.length === 4 && req.method === "GET") {
            if (!(requireScope(auth.scopes, OPS_SCOPES.FINANCE_READ) || requireScope(auth.scopes, OPS_SCOPES.FINANCE_WRITE))) {
              return sendError(res, 403, "forbidden");
            }
            const billingCfg = await getTenantBillingConfig(tenantId);
            const resolvedPlan = resolveTenantBillingPlan({ tenantId });
            return sendJson(res, 200, {
              tenantId,
              billing: {
                plan: normalizeBillingPlanId(billingCfg.plan ?? BILLING_PLAN_ID.FREE, { allowNull: false, defaultPlan: BILLING_PLAN_ID.FREE }),
                planOverrides: normalizeBillingPlanOverrides(billingCfg.planOverrides ?? null, { allowNull: true }),
                hardLimitEnforced: billingCfg.hardLimitEnforced !== false,
                moneyRails: resolveTenantMoneyRailControls({ billingCfg })
              },
              resolvedPlan
            });
          }

          if (parts[1] === "finance" && parts[2] === "billing" && parts[3] === "plan" && parts.length === 4 && req.method === "PUT") {
            if (!requireScope(auth.scopes, OPS_SCOPES.FINANCE_WRITE)) return sendError(res, 403, "forbidden");
            const body = (await readJsonBody(req)) ?? {};
            let plan = null;
            let planOverrides = undefined;
            let moneyRails = undefined;
            try {
              plan = normalizeBillingPlanId(body?.plan ?? BILLING_PLAN_ID.FREE, { allowNull: false, defaultPlan: BILLING_PLAN_ID.FREE });
              planOverrides = normalizeBillingPlanOverrides(body?.planOverrides, { allowNull: true });
              if (Object.prototype.hasOwnProperty.call(body, "moneyRails")) {
                moneyRails = normalizeMoneyRailControls(body?.moneyRails ?? null, { allowNull: true, defaultRealMoneyEnabled: false, nowAt: nowIso() });
              }
            } catch (err) {
              return sendError(res, 400, "invalid billing plan payload", { message: err?.message }, { code: "SCHEMA_INVALID" });
            }
            const hardLimitEnforced =
              body?.hardLimitEnforced === undefined || body?.hardLimitEnforced === null
                ? true
                : body.hardLimitEnforced === true;
            const existingBilling = await getTenantBillingConfig(tenantId);
            const nextBilling = {
              ...existingBilling,
              plan,
              planOverrides: planOverrides === undefined ? null : planOverrides,
              hardLimitEnforced,
              moneyRails: moneyRails === undefined ? existingBilling?.moneyRails ?? null : moneyRails
            };
            await putTenantBillingConfig(tenantId, nextBilling);
            if (typeof store.appendOpsAudit === "function") {
              await store.appendOpsAudit({
                tenantId,
                audit: makeOpsAudit({
                  action: "BILLING_PLAN_UPSERT",
                  targetType: "billing_plan",
                  targetId: plan,
                  details: {
                    plan,
                    hardLimitEnforced,
                    hasPlanOverrides: planOverrides !== undefined && planOverrides !== null,
                    hasMoneyRailsControls: moneyRails !== undefined
                  }
                })
              });
            }
            return sendJson(res, 200, {
              tenantId,
              billing: nextBilling,
              resolvedPlan: resolveTenantBillingPlan({ tenantId })
            });
          }

          if (parts[1] === "finance" && parts[2] === "billing" && parts[3] === "subscription" && parts.length === 4 && req.method === "GET") {
            if (!(requireScope(auth.scopes, OPS_SCOPES.FINANCE_READ) || requireScope(auth.scopes, OPS_SCOPES.FINANCE_WRITE))) {
              return sendError(res, 403, "forbidden");
            }
            const billingCfg = await getTenantBillingConfig(tenantId);
            const subscription = normalizeBillingSubscriptionRecord(billingCfg.subscription ?? null, { allowNull: true, strictPlan: false });
            return sendJson(res, 200, {
              tenantId,
              subscription,
              resolvedPlan: resolveTenantBillingPlan({ tenantId })
            });
          }

          if (parts[1] === "finance" && parts[2] === "billing" && parts[3] === "subscription" && parts.length === 4 && req.method === "PUT") {
            if (!requireScope(auth.scopes, OPS_SCOPES.FINANCE_WRITE)) return sendError(res, 403, "forbidden");
            const body = (await readJsonBody(req)) ?? {};
            const hasExplicitSubscriptionField = Object.prototype.hasOwnProperty.call(body, "subscription");
            const rawSubscription = hasExplicitSubscriptionField ? body.subscription : body;
            const updatePlanFromBody = Object.prototype.hasOwnProperty.call(body, "plan");
            const shouldUpdateSubscription =
              hasExplicitSubscriptionField || Object.keys(body).some((key) => key !== "plan");

            let nextSubscription = null;
            let explicitPlan = null;
            const existingBilling = await getTenantBillingConfig(tenantId);

            try {
              nextSubscription = shouldUpdateSubscription
                ? normalizeBillingSubscriptionRecord(rawSubscription, { allowNull: true, strictPlan: true })
                : normalizeBillingSubscriptionRecord(existingBilling.subscription ?? null, { allowNull: true, strictPlan: false });
              explicitPlan = updatePlanFromBody
                ? normalizeBillingPlanId(body?.plan, { allowNull: false, defaultPlan: BILLING_PLAN_ID.FREE })
                : null;
            } catch (err) {
              return sendError(res, 400, "invalid billing subscription payload", { message: err?.message }, { code: "SCHEMA_INVALID" });
            }
            const plan = explicitPlan ?? nextSubscription?.plan ?? normalizeBillingPlanId(existingBilling.plan ?? BILLING_PLAN_ID.FREE);
            const nextBilling = {
              ...existingBilling,
              plan,
              subscription: nextSubscription
            };
            await putTenantBillingConfig(tenantId, nextBilling);

            if (typeof store.appendOpsAudit === "function") {
              await store.appendOpsAudit({
                tenantId,
                audit: makeOpsAudit({
                  action: "BILLING_SUBSCRIPTION_UPSERT",
                  targetType: "billing_subscription",
                  targetId: nextSubscription?.subscriptionId ?? "none",
                  details: {
                    provider: nextSubscription?.provider ?? null,
                    status: nextSubscription?.status ?? null,
                    customerId: nextSubscription?.customerId ?? null,
                    plan
                  }
                })
              });
            }

            return sendJson(res, 200, {
              tenantId,
              subscription: nextSubscription,
              resolvedPlan: resolveTenantBillingPlan({ tenantId })
            });
          }

          if (
            parts[1] === "finance" &&
            parts[2] === "billing" &&
            parts[3] === "providers" &&
            parts[4] === "stripe" &&
            parts[5] === "checkout" &&
            parts.length === 6 &&
            req.method === "POST"
          ) {
            if (!requireScope(auth.scopes, OPS_SCOPES.FINANCE_WRITE)) return sendError(res, 403, "forbidden");
            const body = (await readJsonBody(req)) ?? {};

            let idemStoreKey = null;
            let idemRequestHash = null;
            try {
              ({ idemStoreKey, idemRequestHash } = readIdempotency({ method: "POST", requestPath: path, expectedPrevChainHash: null, body }));
            } catch (err) {
              return sendError(res, 400, "invalid idempotency key", { message: err?.message });
            }
            if (idemStoreKey) {
              const existing = store.idempotency.get(idemStoreKey);
              if (existing) {
                if (existing.requestHash !== idemRequestHash) {
                  return sendError(res, 409, "idempotency key conflict", "request differs from initial use of this key");
                }
                return sendJson(res, existing.statusCode, existing.body);
              }
            }

            const existingBilling = await getTenantBillingConfig(tenantId);
            const existingSubscription = normalizeBillingSubscriptionRecord(existingBilling.subscription ?? null, {
              allowNull: true,
              strictPlan: false
            });
            let selectedPlan = null;
            let successUrl = null;
            let cancelUrl = null;
            try {
              selectedPlan = normalizeBillingPlanId(
                body?.plan ?? existingSubscription?.plan ?? existingBilling?.plan ?? BILLING_PLAN_ID.FREE,
                { allowNull: false, defaultPlan: BILLING_PLAN_ID.FREE }
              );
              successUrl = normalizeOptionalAbsoluteUrl(body?.successUrl ?? effectiveBillingStripeCheckoutSuccessUrl ?? null, {
                fieldName: "successUrl"
              });
              cancelUrl = normalizeOptionalAbsoluteUrl(body?.cancelUrl ?? effectiveBillingStripeCheckoutCancelUrl ?? null, {
                fieldName: "cancelUrl"
              });
            } catch (err) {
              return sendError(res, 400, "invalid stripe checkout payload", { message: err?.message }, { code: "SCHEMA_INVALID" });
            }

            let customerId =
              typeof body?.customerId === "string" && body.customerId.trim() !== ""
                ? body.customerId.trim()
                : existingSubscription?.customerId ?? null;
            const sessionCreatedAt = nowIso();
            const sessionExpiresAt = new Date(Date.parse(sessionCreatedAt) + 30 * 60 * 1000).toISOString();
            const liveStripeEnabled = Boolean(effectiveBillingStripeSecretKey);
            const livePriceId = resolveStripePriceIdForPlanId(selectedPlan);

            let sessionId = `cs_test_${createId("stripe_checkout").replace(/^stripe_checkout_/, "")}`;
            let sessionUrl = buildStripeBillingHostedSessionUrl({
              baseUrl: effectiveBillingStripeCheckoutBaseUrl,
              tenantId,
              sessionId,
              context: {
                mode: "stub",
                plan: selectedPlan,
                customer_id: customerId ?? null,
                success_url: successUrl ?? null,
                cancel_url: cancelUrl ?? null
              }
            });
            let sessionMode = "stub";
            let subscriptionId = existingSubscription?.subscriptionId ?? null;

            if (liveStripeEnabled) {
              if (selectedPlan === BILLING_PLAN_ID.FREE) {
                return sendError(res, 400, "stripe checkout only supports paid plans");
              }
              if (!livePriceId) {
                return sendError(
                  res,
                  409,
                  "stripe price id is not configured for selected plan",
                  { plan: selectedPlan },
                  { code: "BILLING_PROVIDER_NOT_CONFIGURED" }
                );
              }
              if (!successUrl || !cancelUrl) {
                return sendError(
                  res,
                  400,
                  "successUrl and cancelUrl are required when stripe live checkout is enabled",
                  null,
                  { code: "SCHEMA_INVALID" }
                );
              }
              const buildCheckoutFormData = (resolvedCustomerId) => ({
                mode: "subscription",
                success_url: successUrl,
                cancel_url: cancelUrl,
                client_reference_id: tenantId,
                "line_items[0][price]": livePriceId,
                "line_items[0][quantity]": "1",
                "metadata[tenantId]": tenantId,
                "metadata[settldPlan]": selectedPlan,
                ...(resolvedCustomerId ? { customer: resolvedCustomerId } : {})
              });

              let checkoutResponse;
              try {
                checkoutResponse = await stripeApiPostJson({
                  endpoint: "/v1/checkout/sessions",
                  formData: buildCheckoutFormData(customerId)
                });
              } catch (err) {
                if (customerId && isStripeNoSuchCustomerError(err)) {
                  try {
                    checkoutResponse = await stripeApiPostJson({
                      endpoint: "/v1/checkout/sessions",
                      formData: buildCheckoutFormData(null)
                    });
                    customerId = null;
                  } catch (retryErr) {
                    return sendError(
                      res,
                      stripeProviderErrorStatusCode(retryErr, 502),
                      "stripe checkout session creation failed",
                      serializeStripeProviderError(retryErr),
                      { code: retryErr?.code ?? "BILLING_PROVIDER_UPSTREAM_ERROR" }
                    );
                  }
                } else {
                  return sendError(
                    res,
                    stripeProviderErrorStatusCode(err, 502),
                    "stripe checkout session creation failed",
                    serializeStripeProviderError(err),
                    { code: err?.code ?? "BILLING_PROVIDER_UPSTREAM_ERROR" }
                  );
                }
              }
              const returnedSessionId =
                typeof checkoutResponse?.id === "string" && checkoutResponse.id.trim() !== ""
                  ? checkoutResponse.id.trim()
                  : null;
              const returnedSessionUrl =
                typeof checkoutResponse?.url === "string" && checkoutResponse.url.trim() !== ""
                  ? checkoutResponse.url.trim()
                  : null;
              if (!returnedSessionId || !returnedSessionUrl) {
                return sendError(
                  res,
                  502,
                  "stripe checkout response missing id or url",
                  { provider: "stripe", category: "invalid_response", retryable: false, endpoint: "/v1/checkout/sessions" },
                  { code: "BILLING_PROVIDER_INVALID_RESPONSE" }
                );
              }
              sessionId = returnedSessionId;
              sessionUrl = returnedSessionUrl;
              sessionMode = "live";
              subscriptionId =
                typeof checkoutResponse?.subscription === "string" && checkoutResponse.subscription.trim() !== ""
                  ? checkoutResponse.subscription.trim()
                  : subscriptionId;
            }

            const checkoutSession = {
              schemaVersion: BILLING_STRIPE_CHECKOUT_SESSION_SCHEMA,
              provider: "stripe",
              mode: sessionMode,
              sessionId,
              sessionUrl,
              plan: selectedPlan,
              priceId: livePriceId ?? null,
              customerId,
              subscriptionId,
              createdAt: sessionCreatedAt,
              expiresAt: sessionExpiresAt
            };
            const responseBody = {
              tenantId,
              checkoutSession,
              resolvedPlan: resolveTenantBillingPlan({ tenantId })
            };
            if (typeof store.appendOpsAudit === "function") {
              await store.appendOpsAudit({
                tenantId,
                audit: makeOpsAudit({
                  action: "BILLING_PROVIDER_CHECKOUT_SESSION_CREATED",
                  targetType: "billing_provider_session",
                  targetId: sessionId,
                  details: {
                    provider: "stripe",
                    plan: selectedPlan,
                    customerId
                  }
                })
              });
            }
            if (idemStoreKey) {
              await commitTx([{ kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode: 201, body: responseBody } }]);
            }
            return sendJson(res, 201, responseBody);
          }

          if (
            parts[1] === "finance" &&
            parts[2] === "billing" &&
            parts[3] === "providers" &&
            parts[4] === "stripe" &&
            parts[5] === "portal" &&
            parts.length === 6 &&
            req.method === "POST"
          ) {
            if (!requireScope(auth.scopes, OPS_SCOPES.FINANCE_WRITE)) return sendError(res, 403, "forbidden");
            const body = (await readJsonBody(req)) ?? {};

            let idemStoreKey = null;
            let idemRequestHash = null;
            try {
              ({ idemStoreKey, idemRequestHash } = readIdempotency({ method: "POST", requestPath: path, expectedPrevChainHash: null, body }));
            } catch (err) {
              return sendError(res, 400, "invalid idempotency key", { message: err?.message });
            }
            if (idemStoreKey) {
              const existing = store.idempotency.get(idemStoreKey);
              if (existing) {
                if (existing.requestHash !== idemRequestHash) {
                  return sendError(res, 409, "idempotency key conflict", "request differs from initial use of this key");
                }
                return sendJson(res, existing.statusCode, existing.body);
              }
            }

            const existingBilling = await getTenantBillingConfig(tenantId);
            const existingSubscription = normalizeBillingSubscriptionRecord(existingBilling.subscription ?? null, { allowNull: true, strictPlan: false });
            const customerId =
              typeof body?.customerId === "string" && body.customerId.trim() !== ""
                ? body.customerId.trim()
                : existingSubscription?.customerId ?? null;
            if (!customerId) return sendError(res, 400, "customerId is required");
            let returnUrl = null;
            try {
              returnUrl = normalizeOptionalAbsoluteUrl(body?.returnUrl ?? effectiveBillingStripePortalReturnUrl ?? null, {
                fieldName: "returnUrl"
              });
            } catch (err) {
              return sendError(res, 400, "invalid stripe portal payload", { message: err?.message }, { code: "SCHEMA_INVALID" });
            }

            const sessionCreatedAt = nowIso();
            const sessionExpiresAt = new Date(Date.parse(sessionCreatedAt) + 30 * 60 * 1000).toISOString();
            const liveStripeEnabled = Boolean(effectiveBillingStripeSecretKey);

            let sessionId = `bps_test_${createId("stripe_portal").replace(/^stripe_portal_/, "")}`;
            let sessionUrl = buildStripeBillingHostedSessionUrl({
              baseUrl: effectiveBillingStripePortalBaseUrl,
              tenantId,
              sessionId,
              context: {
                mode: "stub",
                customer_id: customerId,
                return_url: returnUrl ?? null
              }
            });
            let sessionMode = "stub";

            if (liveStripeEnabled) {
              if (!returnUrl) {
                return sendError(
                  res,
                  400,
                  "returnUrl is required when stripe live portal is enabled",
                  null,
                  { code: "SCHEMA_INVALID" }
                );
              }
              let portalResponse;
              try {
                portalResponse = await stripeApiPostJson({
                  endpoint: "/v1/billing_portal/sessions",
                  formData: {
                    customer: customerId,
                    return_url: returnUrl
                  }
                });
              } catch (err) {
                return sendError(
                  res,
                  stripeProviderErrorStatusCode(err, 502),
                  "stripe portal session creation failed",
                  serializeStripeProviderError(err),
                  { code: err?.code ?? "BILLING_PROVIDER_UPSTREAM_ERROR" }
                );
              }
              const returnedSessionId =
                typeof portalResponse?.id === "string" && portalResponse.id.trim() !== ""
                  ? portalResponse.id.trim()
                  : null;
              const returnedSessionUrl =
                typeof portalResponse?.url === "string" && portalResponse.url.trim() !== ""
                  ? portalResponse.url.trim()
                  : null;
              if (!returnedSessionId || !returnedSessionUrl) {
                return sendError(
                  res,
                  502,
                  "stripe portal response missing id or url",
                  { provider: "stripe", category: "invalid_response", retryable: false, endpoint: "/v1/billing_portal/sessions" },
                  { code: "BILLING_PROVIDER_INVALID_RESPONSE" }
                );
              }
              sessionId = returnedSessionId;
              sessionUrl = returnedSessionUrl;
              sessionMode = "live";
            }

            const portalSession = {
              schemaVersion: BILLING_STRIPE_PORTAL_SESSION_SCHEMA,
              provider: "stripe",
              mode: sessionMode,
              sessionId,
              sessionUrl,
              customerId,
              createdAt: sessionCreatedAt,
              expiresAt: sessionExpiresAt
            };
            const responseBody = {
              tenantId,
              portalSession,
              subscription: existingSubscription
            };
            if (typeof store.appendOpsAudit === "function") {
              await store.appendOpsAudit({
                tenantId,
                audit: makeOpsAudit({
                  action: "BILLING_PROVIDER_PORTAL_SESSION_CREATED",
                  targetType: "billing_provider_session",
                  targetId: sessionId,
                  details: {
                    provider: "stripe",
                    customerId
                  }
                })
              });
            }
            if (idemStoreKey) {
              await commitTx([{ kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode: 201, body: responseBody } }]);
            }
            return sendJson(res, 201, responseBody);
          }

          if (parts[1] === "finance" && parts[2] === "billing" && parts[3] === "period-close" && parts.length === 4 && req.method === "GET") {
            if (!(requireScope(auth.scopes, OPS_SCOPES.FINANCE_READ) || requireScope(auth.scopes, OPS_SCOPES.FINANCE_WRITE))) {
              return sendError(res, 403, "forbidden");
            }
            if (typeof store.listArtifacts !== "function") return sendError(res, 501, "artifacts not supported for this store");
            let period = null;
            try {
              period = normalizeBillingPeriodInput(url.searchParams.get("period"), { defaultToNow: true });
            } catch (err) {
              return sendError(res, 400, "invalid period", { message: err?.message });
            }
            const { limit, offset } = parsePagination({
              limitRaw: url.searchParams.get("limit"),
              offsetRaw: url.searchParams.get("offset"),
              defaultLimit: 50,
              maxLimit: 500
            });
            const artifacts = await listBillingPeriodCloseArtifacts({ tenantId, period, limit, offset });
            return sendJson(res, 200, {
              tenantId,
              period,
              count: artifacts.length,
              limit,
              offset,
              latest: artifacts[0] ?? null,
              artifacts
            });
          }

          if (parts[1] === "finance" && parts[2] === "billing" && parts[3] === "period-close" && parts.length === 4 && req.method === "POST") {
            if (!requireScope(auth.scopes, OPS_SCOPES.FINANCE_WRITE)) return sendError(res, 403, "forbidden");
            if (typeof store.listBillableUsageEvents !== "function") {
              return sendError(res, 501, "billable usage events not supported for this store");
            }
            if (typeof store.putArtifact !== "function") return sendError(res, 501, "artifact persistence not supported for this store");
            const body = (await readJsonBody(req)) ?? {};
            let idemStoreKey = null;
            let idemRequestHash = null;
            try {
              ({ idemStoreKey, idemRequestHash } = readIdempotency({ method: "POST", requestPath: path, expectedPrevChainHash: null, body }));
            } catch (err) {
              return sendError(res, 400, "invalid idempotency key", { message: err?.message });
            }
            if (idemStoreKey) {
              const existing = store.idempotency.get(idemStoreKey);
              if (existing) {
                if (existing.requestHash !== idemRequestHash) {
                  return sendError(res, 409, "idempotency key conflict", "request differs from initial use of this key");
                }
                return sendJson(res, existing.statusCode, existing.body);
              }
            }

            let period = null;
            let dryRun = false;
            let cutoffAt = null;
            try {
              const periodInput = body?.period ?? body?.month ?? null;
              period = normalizeBillingPeriodInput(periodInput, { defaultToNow: true });
              dryRun = body?.dryRun === true;
              const hasCutoffAt = Object.prototype.hasOwnProperty.call(body, "cutoffAt");
              if (hasCutoffAt) {
                cutoffAt = normalizeBillingTimestampInput(body?.cutoffAt);
                if (!cutoffAt) throw new TypeError("cutoffAt must be an ISO date-time");
              }
            } catch (err) {
              return sendError(res, 400, "invalid billing period-close payload", { message: err?.message }, { code: "SCHEMA_INVALID" });
            }

            const summary = await computeTenantBillingPeriodSummary({ tenantId, period });
            const events = await listBillableUsageEventsAll({ tenantId, period, eventType: null });
            const digestRows = computeBillableUsageEventDigestRows(events);
            const eventsDigest = sha256Hex(canonicalJsonStringify(normalizeForCanonicalJson(digestRows, { path: "$" })));
            const occurredAtRows = digestRows
              .map((row) => row?.occurredAt)
              .filter((value) => typeof value === "string" && Number.isFinite(Date.parse(value)))
              .sort();
            const firstOccurredAt = occurredAtRows[0] ?? null;
            const lastOccurredAt = occurredAtRows.length ? occurredAtRows[occurredAtRows.length - 1] : null;
            const resolvedCutoffAt = cutoffAt ?? lastOccurredAt ?? defaultBillingPeriodCutoffAt(period);
            const generatedAt = resolvedCutoffAt;
            const invoice = buildBillingPeriodCloseInvoiceDraft({
              summary,
              digestRows,
              period,
              generatedAt,
              eventsDigest
            });
            const artifactId = `billing_close_${String(period).replaceAll(/[^0-9a-zA-Z_-]/g, "_")}_${eventsDigest.slice(0, 24)}`;
            const artifactBody = normalizeForCanonicalJson(
              {
                schemaVersion: BILLING_PERIOD_CLOSE_ARTIFACT_TYPE,
                artifactType: BILLING_PERIOD_CLOSE_ARTIFACT_TYPE,
                artifactId,
                tenantId,
                period,
                cutoffAt: resolvedCutoffAt,
                generatedAt,
                inputs: {
                  eventCount: digestRows.length,
                  firstOccurredAt,
                  lastOccurredAt,
                  eventsDigest
                },
                plan: summary.plan,
                usage: summary.usage,
                estimate: summary.estimate,
                enforcement: summary.enforcement,
                invoice
              },
              { path: "$" }
            );
            const artifactHash = computeArtifactHash(artifactBody);
            const artifact = { ...artifactBody, artifactHash };

            let artifactSummary = null;
            if (!dryRun) {
              let storedArtifact = artifact;
              try {
                await store.putArtifact({ tenantId, artifact });
              } catch (err) {
                if (err?.code !== "ARTIFACT_HASH_MISMATCH") throw err;
                if (typeof store.getArtifact !== "function") throw err;
                const existing = await store.getArtifact({ tenantId, artifactId });
                if (!existing || typeof existing?.artifactHash !== "string" || existing.artifactHash.trim() === "") throw err;
                storedArtifact = existing;
              }

              let deliveriesCreated = 0;
              if (typeof store.createDelivery === "function") {
                const destinations = listDestinationsForTenant(tenantId).filter((destination) => {
                  const allowed = Array.isArray(destination?.artifactTypes) && destination.artifactTypes.length ? destination.artifactTypes : null;
                  return !allowed || allowed.includes(BILLING_PERIOD_CLOSE_ARTIFACT_TYPE);
                });
                const orderSeq = Number.isFinite(Date.parse(generatedAt)) ? Date.parse(generatedAt) : Date.now();
                const priority = 96;
                const scopeKey = `billing_period_close:period:${period}`;
                for (const destination of destinations) {
                  const dedupeKey = `${tenantId}:${destination.destinationId}:${BILLING_PERIOD_CLOSE_ARTIFACT_TYPE}:${artifactId}:${String(storedArtifact.artifactHash)}`;
                  const orderKey = `${scopeKey}\n${String(orderSeq)}\n${String(priority)}\n${artifactId}`;
                  try {
                    await store.createDelivery({
                      tenantId,
                      delivery: {
                        destinationId: destination.destinationId,
                        artifactType: BILLING_PERIOD_CLOSE_ARTIFACT_TYPE,
                        artifactId,
                        artifactHash: String(storedArtifact.artifactHash),
                        dedupeKey,
                        scopeKey,
                        orderSeq,
                        priority,
                        orderKey
                      }
                    });
                    deliveriesCreated += 1;
                  } catch (err) {
                    if (err?.code === "DELIVERY_DEDUPE_CONFLICT") continue;
                    throw err;
                  }
                }
              }
              artifactSummary = {
                artifactId,
                artifactHash: String(storedArtifact.artifactHash),
                deliveriesCreated
              };
            }

            const responseBody = {
              ok: true,
              tenantId,
              period,
              dryRun,
              cutoffAt: resolvedCutoffAt,
              eventsDigest,
              usage: summary.usage,
              estimate: summary.estimate,
              enforcement: summary.enforcement,
              invoice,
              artifact: artifactSummary
            };
            if (typeof store.appendOpsAudit === "function") {
              await store.appendOpsAudit({
                tenantId,
                audit: makeOpsAudit({
                  action: "BILLING_PERIOD_CLOSE",
                  targetType: "billing_period_close",
                  targetId: artifactId,
                  details: {
                    period,
                    dryRun,
                    eventCount: digestRows.length,
                    eventsDigest,
                    invoiceTotalEstimatedCents: invoice?.totalEstimatedCents ?? null,
                    artifactHash: artifactHash
                  }
                })
              });
            }
            if (idemStoreKey) {
              await commitTx([{ kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode: 200, body: responseBody } }]);
            }
            return sendJson(res, 200, responseBody);
          }

          if (
            parts[1] === "finance" &&
            parts[2] === "billing" &&
            parts[3] === "providers" &&
            parts[4] === "stripe" &&
            parts[5] === "webhook" &&
            parts.length === 6 &&
            req.method === "POST"
          ) {
            if (!requireScope(auth.scopes, OPS_SCOPES.FINANCE_WRITE)) return sendError(res, 403, "forbidden");
            const rawBody = await readRawBody(req);
            const rawText = String(rawBody ?? "");
            let body = {};
            if (rawText.trim() !== "") {
              try {
                body = JSON.parse(rawText);
              } catch (err) {
                await appendBillingProviderRejectedAudit({
                  provider: "stripe",
                  reason: "invalid_json",
                  message: "invalid JSON body",
                  source: "webhook",
                  details: {
                    rawBodyPreview: rawText.slice(0, 1024)
                  }
                });
                return sendError(res, 400, "invalid stripe event", { message: "invalid JSON body" }, { code: "SCHEMA_INVALID" });
              }
            }
            if (!body || typeof body !== "object" || Array.isArray(body)) {
              await appendBillingProviderRejectedAudit({
                provider: "stripe",
                eventId: body?.id ?? null,
                eventType: body?.type ?? null,
                reason: "schema_invalid",
                message: "stripe event payload must be an object",
                source: "webhook",
                event: body
              });
              return sendError(res, 400, "invalid stripe event", { message: "stripe event payload must be an object" }, { code: "SCHEMA_INVALID" });
            }

            if (effectiveBillingStripeWebhookSecret) {
              try {
                verifyStripeWebhookSignature({
                  signatureHeader: req.headers["stripe-signature"] ?? null,
                  rawBody: rawText,
                  secret: effectiveBillingStripeWebhookSecret,
                  toleranceSeconds: effectiveBillingStripeWebhookToleranceSeconds,
                  nowAt: nowIso()
                });
              } catch (err) {
                await appendBillingProviderRejectedAudit({
                  provider: "stripe",
                  eventId: body?.id ?? null,
                  eventType: body?.type ?? null,
                  reason: "signature_verification_failed",
                  message: err?.message ?? null,
                  source: "webhook",
                  event: body
                });
                return sendError(res, 400, "invalid stripe signature", { message: err?.message ?? null }, { code: "SCHEMA_INVALID" });
              }
            }

            try {
              const applied = await applyStripeBillingProviderEvent({ tenantId, body });
              await appendBillingProviderIngestAudit(applied, { source: "webhook", captureDuplicate: false });
              return sendJson(res, 200, applied);
            } catch (err) {
              await appendBillingProviderRejectedAudit({
                provider: "stripe",
                eventId: body?.id ?? null,
                eventType: body?.type ?? null,
                reason: "apply_failed",
                message: err?.message ?? null,
                source: "webhook",
                event: body
              });
              return sendError(res, 400, "invalid stripe event", { message: err?.message }, { code: "SCHEMA_INVALID" });
            }
          }

          if (
            parts[1] === "finance" &&
            parts[2] === "billing" &&
            parts[3] === "providers" &&
            parts[4] === "stripe" &&
            parts[5] === "reconcile" &&
            parts.length === 6 &&
            req.method === "POST"
          ) {
            if (!requireScope(auth.scopes, OPS_SCOPES.FINANCE_WRITE)) return sendError(res, 403, "forbidden");
            const body = (await readJsonBody(req)) ?? {};
            const events = Array.isArray(body?.events) ? body.events : null;
            if (!events || events.length === 0) {
              return sendError(res, 400, "events[] is required", null, { code: "SCHEMA_INVALID" });
            }
            const results = [];
            for (const event of events) {
              try {
                // eslint-disable-next-line no-await-in-loop
                const applied = await applyStripeBillingProviderEvent({ tenantId, body: event });
                // eslint-disable-next-line no-await-in-loop
                await appendBillingProviderIngestAudit(applied, { source: "reconcile", captureDuplicate: true });
                results.push({
                  ok: true,
                  eventId: applied?.eventId ?? null,
                  eventType: applied?.eventType ?? null,
                  duplicate: applied?.duplicate === true,
                  ignored: applied?.ignored === true
                });
              } catch (err) {
                // eslint-disable-next-line no-await-in-loop
                await appendBillingProviderRejectedAudit({
                  provider: "stripe",
                  eventId: event?.id ?? null,
                  eventType: event?.type ?? null,
                  reason: "reconcile_apply_failed",
                  message: err?.message ?? "unknown error",
                  source: "reconcile",
                  event
                });
                results.push({
                  ok: false,
                  eventId: event?.id ?? null,
                  eventType: event?.type ?? null,
                  error: err?.message ?? "unknown error"
                });
              }
            }
            const appliedCount = results.filter((row) => row.ok === true && row.duplicate !== true && row.ignored !== true).length;
            const duplicateCount = results.filter((row) => row.ok === true && row.duplicate === true).length;
            const ignoredCount = results.filter((row) => row.ok === true && row.ignored === true).length;
            const failedCount = results.filter((row) => row.ok !== true).length;
            return sendJson(res, 200, {
              tenantId,
              provider: "stripe",
              summary: {
                total: results.length,
                applied: appliedCount,
                duplicate: duplicateCount,
                ignored: ignoredCount,
                failed: failedCount
              },
              results
            });
          }

          if (
            parts[1] === "finance" &&
            parts[2] === "billing" &&
            parts[3] === "providers" &&
            parts[4] === "stripe" &&
            parts[5] === "reconcile" &&
            parts[6] === "report" &&
            parts.length === 7 &&
            req.method === "GET"
          ) {
            if (!(requireScope(auth.scopes, OPS_SCOPES.FINANCE_READ) || requireScope(auth.scopes, OPS_SCOPES.FINANCE_WRITE))) {
              return sendError(res, 403, "forbidden");
            }
            if (typeof store.listOpsAudit !== "function") {
              return sendError(res, 501, "ops audit not supported for this store");
            }
            const { limit, offset } = parsePagination({
              limitRaw: url.searchParams.get("limit"),
              offsetRaw: url.searchParams.get("offset"),
              defaultLimit: 200,
              maxLimit: 1000
            });
            const audits = await store.listOpsAudit({ tenantId, limit, offset });
            const rows = (Array.isArray(audits) ? audits : []).filter((row) => {
              const action = String(row?.action ?? "");
              return action === "BILLING_PROVIDER_EVENT_INGEST" || action === "BILLING_PROVIDER_EVENT_REJECTED";
            }).filter((row) => (normalizeAuditDetailsObject(row?.details).provider ?? "stripe") === "stripe");
            const counts = {
              ingested: rows.filter((row) => String(row?.action ?? "") === "BILLING_PROVIDER_EVENT_INGEST").length,
              rejected: rows.filter((row) => String(row?.action ?? "") === "BILLING_PROVIDER_EVENT_REJECTED").length
            };
            const ingestedRows = rows.filter((row) => String(row?.action ?? "") === "BILLING_PROVIDER_EVENT_INGEST");
            const rejectedRows = rows.filter((row) => String(row?.action ?? "") === "BILLING_PROVIDER_EVENT_REJECTED");
            const ingestBreakdown = {
              duplicate: ingestedRows.filter((row) => normalizeAuditDetailsObject(row?.details).duplicate === true).length,
              ignored: ingestedRows.filter((row) => normalizeAuditDetailsObject(row?.details).ignored === true).length,
              replayed: ingestedRows.filter((row) => normalizeAuditDetailsObject(row?.details).replayed === true).length
            };
            const rejectedReasonCounts = rows
              .filter((row) => String(row?.action ?? "") === "BILLING_PROVIDER_EVENT_REJECTED")
              .reduce((acc, row) => {
                const reason =
                  row?.details && typeof row.details === "object" && !Array.isArray(row.details) && typeof row.details.reason === "string"
                    ? row.details.reason.trim()
                    : "";
                const key = reason || "unknown";
                acc[key] = (acc[key] ?? 0) + 1;
                return acc;
              }, {});
            const sourceCounts = rows.reduce((acc, row) => {
              const details = normalizeAuditDetailsObject(row?.details);
              const source = typeof details.source === "string" && details.source.trim() !== "" ? details.source.trim() : "unknown";
              acc[source] = (acc[source] ?? 0) + 1;
              return acc;
            }, {});
            const replayableRejectedCount = rejectedRows.filter((row) => normalizeAuditDetailsObject(row?.details).replayable === true).length;
            const billingCfg = await getTenantBillingConfig(tenantId);
            const subscription = normalizeBillingSubscriptionRecord(billingCfg?.subscription ?? null, { allowNull: true, strictPlan: false });
            const dedupCount = normalizeBillingProviderEventDedupList(billingCfg?.providerEventDedupKeys ?? []).length;
            return sendJson(res, 200, {
              tenantId,
              provider: "stripe",
              counts,
              ingestBreakdown,
              rejectedReasonCounts,
              sourceCounts,
              replayableRejectedCount,
              dedupeKeyCount: dedupCount,
              subscription,
              recent: rows
            });
          }

          if (
            parts[1] === "finance" &&
            parts[2] === "billing" &&
            parts[3] === "providers" &&
            parts[4] === "stripe" &&
            parts[5] === "dead-letter" &&
            parts.length === 6 &&
            req.method === "GET"
          ) {
            if (!(requireScope(auth.scopes, OPS_SCOPES.FINANCE_READ) || requireScope(auth.scopes, OPS_SCOPES.FINANCE_WRITE))) {
              return sendError(res, 403, "forbidden");
            }
            if (typeof store.listOpsAudit !== "function") {
              return sendError(res, 501, "ops audit not supported for this store");
            }
            const { limit, offset } = parsePagination({
              limitRaw: url.searchParams.get("limit"),
              offsetRaw: url.searchParams.get("offset"),
              defaultLimit: 200,
              maxLimit: 1000
            });
            const reasonFilter = typeof url.searchParams.get("reason") === "string" ? String(url.searchParams.get("reason")).trim() : "";
            const eventTypeFilter = typeof url.searchParams.get("eventType") === "string" ? String(url.searchParams.get("eventType")).trim() : "";
            const audits = await store.listOpsAudit({ tenantId, limit, offset });
            const deadLetters = (Array.isArray(audits) ? audits : [])
              .filter((row) => String(row?.action ?? "") === "BILLING_PROVIDER_EVENT_REJECTED")
              .map((row) => ({
                row,
                details: normalizeAuditDetailsObject(row?.details)
              }))
              .filter(({ details }) => (details.provider ?? "stripe") === "stripe")
              .filter(({ details }) => details.replayable === true && details.event && typeof details.event === "object" && !Array.isArray(details.event))
              .filter(({ details }) => (reasonFilter ? String(details.reason ?? "") === reasonFilter : true))
              .filter(({ details }) => (eventTypeFilter ? String(details.eventType ?? "") === eventTypeFilter : true))
              .map(({ row, details }) => ({
                auditId: row?.id ?? null,
                at: row?.at ?? null,
                requestId: row?.requestId ?? null,
                eventId: details.eventId ?? row?.targetId ?? null,
                eventType: details.eventType ?? null,
                reason: details.reason ?? null,
                message: details.message ?? null,
                source: details.source ?? null,
                replayable: details.replayable === true,
                event: details.event
              }));
            return sendJson(res, 200, {
              tenantId,
              provider: "stripe",
              count: deadLetters.length,
              limit,
              offset,
              events: deadLetters
            });
          }

          if (
            parts[1] === "finance" &&
            parts[2] === "billing" &&
            parts[3] === "providers" &&
            parts[4] === "stripe" &&
            parts[5] === "dead-letter" &&
            parts[6] === "replay" &&
            parts.length === 7 &&
            req.method === "POST"
          ) {
            if (!requireScope(auth.scopes, OPS_SCOPES.FINANCE_WRITE)) return sendError(res, 403, "forbidden");
            if (typeof store.listOpsAudit !== "function") {
              return sendError(res, 501, "ops audit not supported for this store");
            }
            const body = (await readJsonBody(req)) ?? {};
            const reasonFilter = typeof body.reason === "string" ? body.reason.trim() : "";
            const eventTypeFilter = typeof body.eventType === "string" ? body.eventType.trim() : "";
            const idFilter = Array.isArray(body.auditIds)
              ? new Set(body.auditIds.map((value) => Number(value)).filter((value) => Number.isSafeInteger(value) && value > 0))
              : null;
            const limitRaw = body.limit ?? 200;
            const offsetRaw = body.offset ?? 0;
            const { limit, offset } = parsePagination({
              limitRaw,
              offsetRaw,
              defaultLimit: 200,
              maxLimit: 1000
            });
            const dryRun = body.dryRun === true;
            const audits = await store.listOpsAudit({ tenantId, limit, offset });
            const candidates = (Array.isArray(audits) ? audits : [])
              .filter((row) => String(row?.action ?? "") === "BILLING_PROVIDER_EVENT_REJECTED")
              .map((row) => ({ row, details: normalizeAuditDetailsObject(row?.details) }))
              .filter(({ details }) => (details.provider ?? "stripe") === "stripe")
              .filter(({ details }) => details.replayable === true && details.event && typeof details.event === "object" && !Array.isArray(details.event))
              .filter(({ details }) => (reasonFilter ? String(details.reason ?? "") === reasonFilter : true))
              .filter(({ details }) => (eventTypeFilter ? String(details.eventType ?? "") === eventTypeFilter : true))
              .filter(({ row }) => (idFilter && idFilter.size ? idFilter.has(Number(row?.id)) : true));

            const results = [];
            for (const candidate of candidates) {
              const replayEvent = candidate.details.event;
              if (dryRun) {
                results.push({
                  ok: true,
                  dryRun: true,
                  auditId: candidate.row?.id ?? null,
                  eventId: replayEvent?.id ?? candidate.row?.targetId ?? null,
                  eventType: replayEvent?.type ?? candidate.details.eventType ?? null
                });
                continue;
              }
              try {
                // eslint-disable-next-line no-await-in-loop
                const applied = await applyStripeBillingProviderEvent({ tenantId, body: replayEvent });
                // eslint-disable-next-line no-await-in-loop
                await appendBillingProviderIngestAudit(applied, {
                  source: "dead_letter_replay",
                  replayed: true,
                  replayAuditId: candidate.row?.id ?? null,
                  captureDuplicate: true
                });
                results.push({
                  ok: true,
                  auditId: candidate.row?.id ?? null,
                  eventId: applied?.eventId ?? replayEvent?.id ?? null,
                  eventType: applied?.eventType ?? replayEvent?.type ?? null,
                  duplicate: applied?.duplicate === true,
                  ignored: applied?.ignored === true
                });
              } catch (err) {
                // eslint-disable-next-line no-await-in-loop
                await appendBillingProviderRejectedAudit({
                  provider: "stripe",
                  eventId: replayEvent?.id ?? candidate.row?.targetId ?? null,
                  eventType: replayEvent?.type ?? candidate.details.eventType ?? null,
                  reason: "dead_letter_replay_apply_failed",
                  message: err?.message ?? "unknown error",
                  source: "dead_letter_replay",
                  event: replayEvent,
                  details: {
                    replayAuditId: candidate.row?.id ?? null,
                    originalReason: candidate.details.reason ?? null
                  }
                });
                results.push({
                  ok: false,
                  auditId: candidate.row?.id ?? null,
                  eventId: replayEvent?.id ?? candidate.row?.targetId ?? null,
                  eventType: replayEvent?.type ?? candidate.details.eventType ?? null,
                  error: err?.message ?? "unknown error"
                });
              }
            }
            const summary = {
              total: results.length,
              applied: results.filter((row) => row.ok === true && row.dryRun !== true && row.duplicate !== true && row.ignored !== true).length,
              duplicate: results.filter((row) => row.ok === true && row.duplicate === true).length,
              ignored: results.filter((row) => row.ok === true && row.ignored === true).length,
              failed: results.filter((row) => row.ok !== true).length,
              dryRun: results.filter((row) => row.ok === true && row.dryRun === true).length
            };
            return sendJson(res, 200, {
              tenantId,
              provider: "stripe",
              dryRun,
              summary,
              results
            });
          }

          if (parts[1] === "finance" && parts[2] === "billing" && parts[3] === "summary" && parts.length === 4 && req.method === "GET") {
            if (!(requireScope(auth.scopes, OPS_SCOPES.FINANCE_READ) || requireScope(auth.scopes, OPS_SCOPES.FINANCE_WRITE))) {
              return sendError(res, 403, "forbidden");
            }
            if (typeof store.listBillableUsageEvents !== "function") {
              return sendError(res, 501, "billable usage events not supported for this store");
            }
            let period = null;
            try {
              period = normalizeBillingPeriodInput(url.searchParams.get("period"), { defaultToNow: true });
            } catch (err) {
              return sendError(res, 400, "invalid period", { message: err?.message });
            }
            const summary = await computeTenantBillingPeriodSummary({
              tenantId,
              period
            });
            return sendJson(res, 200, summary);
          }

          if (parts[1] === "finance" && parts[2] === "billable-events" && parts.length === 3 && req.method === "GET") {
            if (!(requireScope(auth.scopes, OPS_SCOPES.FINANCE_READ) || requireScope(auth.scopes, OPS_SCOPES.FINANCE_WRITE))) {
              return sendError(res, 403, "forbidden");
            }
            if (typeof store.listBillableUsageEvents !== "function") {
              return sendError(res, 501, "billable usage events not supported for this store");
            }
            const periodRaw = url.searchParams.get("period") ?? null;
            const period = periodRaw ? String(periodRaw).trim() : null;
            if (period !== null && !/^\d{4}-\d{2}$/.test(period)) {
              return sendError(res, 400, "period must match YYYY-MM");
            }
            const eventTypeRaw = url.searchParams.get("eventType") ?? null;
            const eventType = eventTypeRaw && String(eventTypeRaw).trim() !== "" ? String(eventTypeRaw).trim().toLowerCase() : null;
            const { limit, offset } = parsePagination({
              limitRaw: url.searchParams.get("limit"),
              offsetRaw: url.searchParams.get("offset"),
              defaultLimit: 200,
              maxLimit: 1000
            });
            const events = await store.listBillableUsageEvents({
              tenantId,
              period,
              eventType,
              limit,
              offset
            });
            return sendJson(res, 200, {
              tenantId,
              period,
              eventType,
              events,
              count: Array.isArray(events) ? events.length : 0,
              limit,
              offset
            });
          }

          // Finance Pack v1: tenant-scoped account map + GLBatch CSV export.
          if (parts[1] === "finance" && parts[2] === "account-map" && parts.length === 3 && req.method === "GET") {
            if (!requireScope(auth.scopes, OPS_SCOPES.OPS_READ)) return sendError(res, 403, "forbidden");
            if (typeof store.getFinanceAccountMap !== "function") return sendError(res, 501, "finance account map not supported for this store");
            const mapping = await store.getFinanceAccountMap({ tenantId });
            return sendJson(res, 200, { mapping });
          }

          if (parts[1] === "finance" && parts[2] === "account-map" && parts.length === 3 && req.method === "PUT") {
            if (!requireScope(auth.scopes, OPS_SCOPES.FINANCE_WRITE)) return sendError(res, 403, "forbidden");
            if (typeof store.putFinanceAccountMap !== "function") return sendError(res, 501, "finance account map not supported for this store");
            const body = (await readJsonBody(req)) ?? {};
            const mapping = body?.mapping ?? body;
            try {
              validateFinanceAccountMapV1(mapping);
            } catch (err) {
              return sendError(res, 400, "invalid finance account map", { message: err?.message }, { code: "INVALID_FINANCE_ACCOUNT_MAP" });
            }
            const result = await store.putFinanceAccountMap({
              tenantId,
              mapping,
              audit: makeOpsAudit({
                action: "FINANCE_ACCOUNT_MAP_UPSERT",
                targetType: "finance_account_map",
                targetId: "default",
                details: { schemaVersion: mapping?.schemaVersion ?? null }
              })
            });
            return sendJson(res, 200, { ok: true, mappingHash: result?.mappingHash ?? null });
          }

          if (parts[1] === "finance" && parts[2] === "reconciliation" && parts[3] === "triage" && parts.length === 4 && req.method === "GET") {
            if (!(requireScope(auth.scopes, OPS_SCOPES.FINANCE_READ) || requireScope(auth.scopes, OPS_SCOPES.FINANCE_WRITE))) {
              return sendError(res, 403, "forbidden");
            }
            let period = null;
            let status = null;
            let sourceType = null;
            let providerId = null;
            let limit = 100;
            let offset = 0;
            try {
              period = normalizeFinanceReconciliationPeriod(url.searchParams.get("period") ?? url.searchParams.get("month"), {
                fieldName: "period",
                allowNull: true
              });
              status = normalizeFinanceReconciliationTriageStatus(url.searchParams.get("status"), { fieldName: "status", allowNull: true });
              sourceType = normalizeFinanceReconciliationTriageSourceType(url.searchParams.get("sourceType"), {
                fieldName: "sourceType",
                allowNull: true
              });
              providerId = normalizeNonEmptyStringOrNull(url.searchParams.get("providerId"));
              ({ limit, offset } = parsePagination({
                limitRaw: url.searchParams.get("limit"),
                offsetRaw: url.searchParams.get("offset"),
                defaultLimit: 100,
                maxLimit: 1000
              }));
            } catch (err) {
              return sendError(res, 400, "invalid reconciliation triage query", { message: err?.message });
            }
            let triages = [];
            try {
              triages = await listFinanceReconciliationTriageRecords({
                tenantId,
                period,
                status,
                sourceType,
                providerId,
                limit,
                offset
              });
            } catch (err) {
              return sendError(res, 501, "finance reconciliation triage not supported for this store", { message: err?.message });
            }
            const statusCounts = {};
            for (const row of triages) {
              const key = normalizeFinanceReconciliationTriageStatus(row?.status, { allowNull: true }) ?? FINANCE_RECONCILIATION_TRIAGE_STATUS.OPEN;
              statusCounts[key] = (statusCounts[key] ?? 0) + 1;
            }
            return sendJson(res, 200, {
              tenantId,
              filters: { period, status, sourceType, providerId },
              limit,
              offset,
              count: triages.length,
              statusCounts,
              triages
            });
          }

          if (parts[1] === "finance" && parts[2] === "reconciliation" && parts[3] === "triage" && parts.length === 4 && req.method === "POST") {
            if (!requireScope(auth.scopes, OPS_SCOPES.FINANCE_WRITE)) return sendError(res, 403, "forbidden");
            const body = (await readJsonBody(req)) ?? {};
            let idemStoreKey = null;
            let idemRequestHash = null;
            try {
              ({ idemStoreKey, idemRequestHash } = readIdempotency({ method: "POST", requestPath: path, expectedPrevChainHash: null, body }));
            } catch (err) {
              return sendError(res, 400, "invalid idempotency key", { message: err?.message });
            }
            if (idemStoreKey) {
              const existing = store.idempotency.get(idemStoreKey);
              if (existing) {
                if (existing.requestHash !== idemRequestHash) {
                  return sendError(res, 409, "idempotency key conflict", "request differs from initial use of this key");
                }
                return sendJson(res, existing.statusCode, existing.body);
              }
            }

            let existingRecord = null;
            const triageKeyFromBody = normalizeNonEmptyStringOrNull(body?.triageKey);
            if (triageKeyFromBody) {
              try {
                existingRecord = await getFinanceReconciliationTriageRecord({ tenantId, triageKey: triageKeyFromBody });
              } catch (err) {
                return sendError(res, 501, "finance reconciliation triage not supported for this store", { message: err?.message });
              }
            }

            let sourceType = null;
            let period = null;
            let providerId = null;
            let mismatchType = null;
            let mismatchKey = null;
            let mismatchCode = null;
            let status = null;
            let severity = null;
            let action = null;
            try {
              sourceType = normalizeFinanceReconciliationTriageSourceType(body?.sourceType ?? existingRecord?.sourceType, { fieldName: "sourceType" });
              period = normalizeFinanceReconciliationPeriod(body?.period ?? body?.month ?? existingRecord?.period, { fieldName: "period" });
              providerId = normalizeNonEmptyStringOrNull(body?.providerId ?? existingRecord?.providerId);
              mismatchType = normalizeNonEmptyStringOrNull(body?.mismatchType ?? existingRecord?.mismatchType);
              mismatchKey = normalizeNonEmptyStringOrNull(body?.mismatchKey ?? existingRecord?.mismatchKey);
              mismatchCode = normalizeNonEmptyStringOrNull(body?.mismatchCode ?? existingRecord?.mismatchCode);
              if (!mismatchType || !mismatchKey) {
                return sendError(res, 400, "mismatchType and mismatchKey are required");
              }
              status = normalizeFinanceReconciliationTriageStatus(body?.status ?? existingRecord?.status ?? FINANCE_RECONCILIATION_TRIAGE_STATUS.OPEN, {
                fieldName: "status"
              });
              severity = normalizeFinanceReconciliationTriageSeverity(body?.severity ?? existingRecord?.severity, { fieldName: "severity", allowNull: true });
              action = normalizeNonEmptyStringOrNull(body?.action) ?? "triage_update";
            } catch (err) {
              return sendError(res, 400, "invalid reconciliation triage payload", { message: err?.message });
            }
            const triageKey =
              triageKeyFromBody ??
              buildFinanceReconciliationTriageKey({
                sourceType,
                period,
                providerId,
                mismatchType,
                mismatchKey
              });
            if (!existingRecord) {
              try {
                existingRecord = await getFinanceReconciliationTriageRecord({ tenantId, triageKey });
              } catch (err) {
                return sendError(res, 501, "finance reconciliation triage not supported for this store", { message: err?.message });
              }
            }

            const ownerPrincipalId = Object.prototype.hasOwnProperty.call(body, "ownerPrincipalId")
              ? normalizeNonEmptyStringOrNull(body?.ownerPrincipalId)
              : normalizeNonEmptyStringOrNull(existingRecord?.ownerPrincipalId);
            const notes = Object.prototype.hasOwnProperty.call(body, "notes")
              ? normalizeNonEmptyStringOrNull(body?.notes)
              : normalizeNonEmptyStringOrNull(existingRecord?.notes);
            const sourceReportHash = Object.prototype.hasOwnProperty.call(body, "sourceReportHash")
              ? normalizeNonEmptyStringOrNull(body?.sourceReportHash)
              : normalizeNonEmptyStringOrNull(existingRecord?.sourceReportHash);
            const metadata =
              body?.metadata && typeof body.metadata === "object" && !Array.isArray(body.metadata)
                ? normalizeForCanonicalJson(body.metadata, { path: "$.metadata" })
                : existingRecord?.metadata && typeof existingRecord.metadata === "object" && !Array.isArray(existingRecord.metadata)
                  ? existingRecord.metadata
                  : null;
            const nowAt = nowIso();
            const resolvedStatus =
              status === FINANCE_RECONCILIATION_TRIAGE_STATUS.RESOLVED || status === FINANCE_RECONCILIATION_TRIAGE_STATUS.DISMISSED;
            const resolvedAt = resolvedStatus
              ? normalizeNonEmptyStringOrNull(existingRecord?.resolvedAt) ?? nowAt
              : null;
            const resolvedByPrincipalId = resolvedStatus
              ? normalizeNonEmptyStringOrNull(existingRecord?.resolvedByPrincipalId) ?? principalId
              : null;

            const hasChanges =
              !existingRecord ||
              String(existingRecord.status ?? "") !== String(status) ||
              String(existingRecord.ownerPrincipalId ?? "") !== String(ownerPrincipalId ?? "") ||
              String(existingRecord.notes ?? "") !== String(notes ?? "") ||
              String(existingRecord.severity ?? "") !== String(severity ?? "") ||
              String(existingRecord.sourceReportHash ?? "") !== String(sourceReportHash ?? "");
            if (!hasChanges) {
              const responseBody = { ok: true, tenantId, changed: false, triage: existingRecord };
              if (idemStoreKey) {
                await commitTx([{ kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode: 200, body: responseBody } }]);
              }
              return sendJson(res, 200, responseBody);
            }

            const actionLogEntry = normalizeForCanonicalJson(
              {
                actionId: idemStoreKey ? String(idemStoreKey) : createId("frta"),
                action,
                at: nowAt,
                actorPrincipalId: principalId,
                prevStatus: existingRecord?.status ?? null,
                nextStatus: status,
                ownerPrincipalId,
                notes
              },
              { path: "$" }
            );
            const previousActionLog = Array.isArray(existingRecord?.actionLog) ? existingRecord.actionLog : [];
            const actionLog = [actionLogEntry, ...previousActionLog].slice(0, 50);
            const nextTriage = normalizeForCanonicalJson(
              {
                schemaVersion: "FinanceReconciliationTriage.v1",
                tenantId,
                triageKey,
                sourceType,
                period,
                providerId,
                mismatchType,
                mismatchKey,
                mismatchCode,
                severity,
                status,
                ownerPrincipalId,
                notes,
                sourceReportHash,
                metadata,
                actionLog,
                revision: Number(existingRecord?.revision ?? 0) + 1,
                createdAt: existingRecord?.createdAt ?? nowAt,
                updatedAt: nowAt,
                resolvedAt,
                resolvedByPrincipalId
              },
              { path: "$" }
            );
            let saved = null;
            try {
              saved = await putFinanceReconciliationTriageRecord({
                tenantId,
                triage: nextTriage,
                audit: makeOpsAudit({
                  action: "FINANCE_RECONCILIATION_TRIAGE_UPSERT",
                  targetType: "finance_reconciliation_triage",
                  targetId: triageKey,
                  details: {
                    sourceType,
                    period,
                    providerId,
                    mismatchType,
                    mismatchKey,
                    status,
                    ownerPrincipalId
                  }
                })
              });
            } catch (err) {
              return sendError(res, 501, "finance reconciliation triage not supported for this store", { message: err?.message });
            }
            const responseBody = { ok: true, tenantId, changed: true, triage: saved };
            if (idemStoreKey) {
              await commitTx([{ kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode: 200, body: responseBody } }]);
            }
            return sendJson(res, 200, responseBody);
          }

          if (parts[1] === "finance" && parts[2] === "gl-batch" && parts.length === 3 && req.method === "GET") {
            if (!requireScope(auth.scopes, OPS_SCOPES.FINANCE_WRITE)) return sendError(res, 403, "forbidden");
            if (typeof store.listArtifacts !== "function") return sendError(res, 501, "artifacts not supported for this store");
            const period = url.searchParams.get("period") ?? url.searchParams.get("month");
            if (!period) return sendError(res, 400, "period is required");
            const artifacts = await store.listArtifacts({ tenantId });
            const candidates = artifacts.filter((a) => a?.artifactType === ARTIFACT_TYPE.GL_BATCH_V1 && String(a?.period ?? "") === String(period));
            if (!candidates.length) return sendError(res, 404, "GL batch not found");
            candidates.sort((a, b) => String(a?.generatedAt ?? "").localeCompare(String(b?.generatedAt ?? "")));
            const artifact = candidates[candidates.length - 1];
            return sendJson(res, 200, { artifact });
          }

          if (parts[1] === "finance" && parts[2] === "gl-batch.csv" && parts.length === 3 && req.method === "GET") {
            if (!requireScope(auth.scopes, OPS_SCOPES.FINANCE_WRITE)) return sendError(res, 403, "forbidden");
            if (typeof store.listArtifacts !== "function" || typeof store.getFinanceAccountMap !== "function") {
              return sendError(res, 501, "finance export not supported for this store");
            }
            const period = url.searchParams.get("period") ?? url.searchParams.get("month");
            if (!period) return sendError(res, 400, "period is required");

            const artifacts = await store.listArtifacts({ tenantId });
            const candidates = artifacts.filter((a) => a?.artifactType === ARTIFACT_TYPE.GL_BATCH_V1 && String(a?.period ?? "") === String(period));
            if (!candidates.length) return sendError(res, 404, "GL batch not found");
            candidates.sort((a, b) => String(a?.generatedAt ?? "").localeCompare(String(b?.generatedAt ?? "")));
            const glBatch = candidates[candidates.length - 1];

            const accountMap = await store.getFinanceAccountMap({ tenantId });
            if (!accountMap) return sendError(res, 409, "finance account map not configured", null, { code: "FINANCE_ACCOUNT_MAP_REQUIRED" });

            let csv;
            try {
              ({ csv } = renderJournalCsvV1({ glBatchArtifact: glBatch, accountMap }));
            } catch (err) {
              const code = typeof err?.code === "string" && err.code.trim() ? err.code : "FINANCE_EXPORT_FAILED";
              return sendError(res, 409, "failed to render journal CSV", { message: err?.message }, { code });
            }

            res.setHeader("content-type", "text/csv; charset=utf-8");
            return res.end(csv);
          }

          if (parts[1] === "finance" && parts[2] === "reconcile" && parts.length === 3 && req.method === "GET") {
            if (!(requireScope(auth.scopes, OPS_SCOPES.FINANCE_READ) || requireScope(auth.scopes, OPS_SCOPES.FINANCE_WRITE))) {
              return sendError(res, 403, "forbidden");
            }
            const periodRaw = url.searchParams.get("period") ?? url.searchParams.get("month");
            if (!periodRaw) return sendError(res, 400, "period is required");
            let period = null;
            try {
              period = normalizeFinanceReconciliationPeriod(periodRaw, { fieldName: "period", allowNull: false });
            } catch (err) {
              return sendError(res, 400, err?.message ?? "period must match YYYY-MM");
            }

            let persist = false;
            try {
              persist = parseBooleanQueryValue(url.searchParams.get("persist"), { defaultValue: false, name: "persist" });
            } catch (err) {
              return sendError(res, 400, err?.message ?? "persist must be boolean");
            }
            if (persist && !requireScope(auth.scopes, OPS_SCOPES.FINANCE_WRITE)) return sendError(res, 403, "forbidden");

            let report;
            try {
              report = await computeFinanceReconcileReport({
                tenantId,
                period,
                persist,
                includeTriages: true
              });
            } catch (err) {
              const statusCode = Number.isSafeInteger(err?.statusCode) ? err.statusCode : 500;
              return sendError(res, statusCode, err?.message ?? "finance reconcile failed");
            }

            return sendJson(res, 200, {
              ok: true,
              tenantId: report.tenantId,
              period: report.period,
              reportHash: report.reportHash,
              reconcile: report.reconcile,
              inputs: report.inputs,
              artifact: report.artifact,
              triageQueue: report.triageQueue,
              triageSummary: report.triageSummary
            });
          }

          if (parts[1] === "finance" && parts[2] === "net-close" && parts.length === 3 && req.method === "GET") {
            if (!(requireScope(auth.scopes, OPS_SCOPES.FINANCE_READ) || requireScope(auth.scopes, OPS_SCOPES.FINANCE_WRITE))) {
              return sendError(res, 403, "forbidden");
            }
            const period = url.searchParams.get("period") ?? url.searchParams.get("month");
            if (!period) return sendError(res, 400, "period is required");

            let persist = false;
            try {
              persist = parseBooleanQueryValue(url.searchParams.get("persist"), { defaultValue: false, name: "persist" });
            } catch (err) {
              return sendError(res, 400, err?.message ?? "persist must be boolean");
            }
            if (persist && !requireScope(auth.scopes, OPS_SCOPES.FINANCE_WRITE)) return sendError(res, 403, "forbidden");

            let report;
            try {
              report = await computeEscrowNetCloseReport({ tenantId, period });
            } catch (err) {
              const statusCode = Number.isSafeInteger(err?.statusCode) ? err.statusCode : 400;
              return sendError(res, statusCode, err?.message ?? "invalid net close request");
            }
            let artifactSummary = null;
            if (persist) {
              try {
                artifactSummary = await persistEscrowNetCloseArtifact({ tenantId, report });
              } catch (err) {
                const statusCode = Number.isSafeInteger(err?.statusCode) ? err.statusCode : 500;
                return sendError(res, statusCode, err?.message ?? "failed to persist escrow net-close artifact");
              }
            }

            return sendJson(res, 200, {
              ok: true,
              tenantId,
              period: report.period,
              basis: report.basis,
              status: report.status,
              mismatchCodes: report.mismatchCodes,
              snapshot: report.snapshot,
              evidence: report.evidence,
              artifact: artifactSummary
            });
          }

          if (parts[1] === "finance" && parts[2] === "net-close" && parts[3] === "execute" && parts.length === 4 && req.method === "POST") {
            if (!requireScope(auth.scopes, OPS_SCOPES.FINANCE_WRITE)) return sendError(res, 403, "forbidden");
            const body = (await readJsonBody(req)) ?? {};
            const period =
              typeof body?.period === "string" && body.period.trim() !== ""
                ? body.period.trim()
                : typeof body?.month === "string" && body.month.trim() !== ""
                  ? body.month.trim()
                  : null;
            if (!period) return sendError(res, 400, "period is required");
            const dryRun = typeof body?.dryRun === "boolean" ? body.dryRun : false;

            let report;
            try {
              report = await computeEscrowNetCloseReport({ tenantId, period });
            } catch (err) {
              const statusCode = Number.isSafeInteger(err?.statusCode) ? err.statusCode : 400;
              return sendError(res, statusCode, err?.message ?? "invalid net close execute request");
            }

            if (report.status !== "pass") {
              return sendError(res, 409, "escrow net-close preconditions failed", {
                mismatchCodes: report.mismatchCodes,
                snapshot: report.snapshot,
                evidence: report.evidence
              });
            }

            if (dryRun) {
              return sendJson(res, 200, {
                ok: true,
                tenantId,
                period: report.period,
                basis: report.basis,
                executed: false,
                dryRun: true,
                status: report.status,
                mismatchCodes: report.mismatchCodes,
                snapshot: report.snapshot,
                evidence: report.evidence
              });
            }

            let artifactSummary;
            try {
              artifactSummary = await persistEscrowNetCloseArtifact({ tenantId, report });
            } catch (err) {
              const statusCode = Number.isSafeInteger(err?.statusCode) ? err.statusCode : 500;
              return sendError(res, statusCode, err?.message ?? "failed to persist escrow net-close artifact");
            }

            return sendJson(res, 200, {
              ok: true,
              tenantId,
              period: report.period,
              basis: report.basis,
              executed: true,
              dryRun: false,
              status: report.status,
              mismatchCodes: report.mismatchCodes,
              snapshot: report.snapshot,
              evidence: report.evidence,
              artifact: artifactSummary
            });
          }

	        if (parts[1] === "status" && parts.length === 2 && req.method === "GET") {
	          const hasStatusScope = requireScope(auth.scopes, OPS_SCOPES.OPS_READ) || requireScope(auth.scopes, OPS_SCOPES.FINANCE_READ);
	          if (!hasStatusScope) return sendError(res, 403, "forbidden");

	          const backlog = await computeOpsBacklogSummary({ tenantId, includeOutbox: true });
	          const retentionInfo = await fetchMaintenanceRetentionRunInfo({ tenantId });
          const financeReconcileInfo = await fetchMaintenanceFinanceReconcileRunInfo({ tenantId });
          const moneyRailReconcileInfo = await fetchMaintenanceMoneyRailReconcileRunInfo({ tenantId });
          const lastRetention = retentionInfo?.last ?? null;
          const lastFinanceReconcile = financeReconcileInfo?.last ?? null;
          const lastFinanceReconcileOk = financeReconcileInfo?.lastOk ?? null;
          const lastMoneyRailReconcile = moneyRailReconcileInfo?.last ?? null;
          const lastMoneyRailReconcileOk = moneyRailReconcileInfo?.lastOk ?? null;
          const snapshot = (() => {
            try {
              return metrics.snapshot();
            } catch {
              return null;
            }
          })();
          const topAppendRejectReasons = parseTopReasonCodesFromMetrics({ metricPrefix: "append_rejected_total", snapshot, topN: 10 });
          const topIngestRejectReasons = parseTopReasonCodesFromMetrics({ metricPrefix: "ingest_rejected_total", snapshot, topN: 10 });

          return sendJson(res, 200, {
            ok: true,
            tenantId,
            process: {
              startedAt: apiStartedAtIso,
              uptimeSeconds: Math.floor((Date.now() - apiStartedAtMs) / 1000)
            },
            backlog,
            maintenance: {
              retentionCleanup: lastRetention
                ? {
                    at: lastRetention.at ?? null,
                    outcome: lastRetention?.details?.outcome ?? null,
                    dryRun: lastRetention?.details?.dryRun ?? null,
                    runtimeMs: lastRetention?.details?.runtimeMs ?? null,
                    purged: lastRetention?.details?.purged ?? null,
                    code: lastRetention?.details?.code ?? null,
                    requestId: lastRetention.requestId ?? null,
                    auditId: lastRetention.id ?? null
                  }
                : null,
              billingStripeSync: (() => {
                const lastRunAt = store?.__billingStripeSyncLastRunAt ?? null;
                const lastSuccessAt = store?.__billingStripeSyncLastSuccessAt ?? null;
                const lastResult = store?.__billingStripeSyncLastResult ?? null;
                return {
                  enabled: effectiveBillingStripeSyncEnabled,
                  intervalSeconds: effectiveBillingStripeSyncIntervalSeconds,
                  batchSize: effectiveBillingStripeSyncBatchSize,
                  lastRunAt,
                  lastSuccessAt,
                  lastResult
                };
              })(),
              financeReconciliation: (() => {
                const stateLastRunAt = store?.__financeReconcileLastRunAt ?? null;
                const stateLastSuccessAt = store?.__financeReconcileLastSuccessAt ?? null;
                const stateLastResult = store?.__financeReconcileLastResult ?? null;
                const auditOutcome = lastFinanceReconcile?.details?.outcome ?? null;
                const auditAt = lastFinanceReconcile?.at ?? null;
                const auditSuccessAt = lastFinanceReconcileOk?.at ?? null;
                const runtimeMs = lastFinanceReconcile?.details?.runtimeMs ?? stateLastResult?.runtimeMs ?? null;
                const effectiveLastRunAt = stateLastRunAt ?? auditAt;
                const effectiveLastSuccessAt = stateLastSuccessAt ?? auditSuccessAt;
                return {
                  enabled: effectiveFinanceReconcileEnabled,
                  intervalSeconds: effectiveFinanceReconcileIntervalSeconds,
                  maxTenants: effectiveFinanceReconcileMaxTenants,
                  maxPeriodsPerTenant: effectiveFinanceReconcileMaxPeriodsPerTenant,
                  lastRunAt: effectiveLastRunAt,
                  lastSuccessAt: effectiveLastSuccessAt,
                  lastResult: stateLastResult,
                  outcome: auditOutcome ?? (stateLastResult?.ok === true ? "ok" : stateLastResult ? "error" : null),
                  runtimeMs,
                  requestId: lastFinanceReconcile?.requestId ?? null,
                  auditId: lastFinanceReconcile?.id ?? null
                };
              })(),
              moneyRailReconciliation: (() => {
                const stateLastRunAt = store?.__moneyRailReconcileLastRunAt ?? null;
                const stateLastSuccessAt = store?.__moneyRailReconcileLastSuccessAt ?? null;
                const stateLastResult = store?.__moneyRailReconcileLastResult ?? null;
                const auditOutcome = lastMoneyRailReconcile?.details?.outcome ?? null;
                const auditAt = lastMoneyRailReconcile?.at ?? null;
                const auditSuccessAt = lastMoneyRailReconcileOk?.at ?? null;
                const runtimeMs = lastMoneyRailReconcile?.details?.runtimeMs ?? stateLastResult?.runtimeMs ?? null;
                const effectiveLastRunAt = stateLastRunAt ?? auditAt;
                const effectiveLastSuccessAt = stateLastSuccessAt ?? auditSuccessAt;
                return {
                  enabled: effectiveMoneyRailReconcileEnabled,
                  intervalSeconds: effectiveMoneyRailReconcileIntervalSeconds,
                  maxTenants: effectiveMoneyRailReconcileMaxTenants,
                  maxPeriodsPerTenant: effectiveMoneyRailReconcileMaxPeriodsPerTenant,
                  maxProvidersPerTenant: effectiveMoneyRailReconcileMaxProvidersPerTenant,
                  lastRunAt: effectiveLastRunAt,
                  lastSuccessAt: effectiveLastSuccessAt,
                  lastResult: stateLastResult,
                  outcome: auditOutcome ?? (stateLastResult?.ok === true ? "ok" : stateLastResult ? "error" : null),
                  runtimeMs,
                  requestId: lastMoneyRailReconcile?.requestId ?? null,
                  auditId: lastMoneyRailReconcile?.id ?? null
                };
              })()
            },
            reasons: {
              topAppendRejected: topAppendRejectReasons,
              topIngestRejected: topIngestRejectReasons
            }
          });
        }

        if (parts[1] === "network" && parts[2] === "command-center" && parts.length === 3 && req.method === "GET") {
          if (!requireScope(auth.scopes, OPS_SCOPES.OPS_READ)) return sendError(res, 403, "forbidden");
          const transactionFeeBpsRaw = url.searchParams.get("transactionFeeBps");
          const windowHoursRaw = url.searchParams.get("windowHours");
          const disputeSlaHoursRaw = url.searchParams.get("disputeSlaHours");

          const transactionFeeBps =
            transactionFeeBpsRaw === null || transactionFeeBpsRaw.trim() === ""
              ? 100
              : Number(transactionFeeBpsRaw);
          if (!Number.isSafeInteger(transactionFeeBps) || transactionFeeBps < 0 || transactionFeeBps > 5000) {
            return sendError(res, 400, "transactionFeeBps must be an integer within 0..5000");
          }

          const windowHours =
            windowHoursRaw === null || windowHoursRaw.trim() === ""
              ? 24
              : Number(windowHoursRaw);
          if (!Number.isSafeInteger(windowHours) || windowHours <= 0 || windowHours > 24 * 365) {
            return sendError(res, 400, "windowHours must be an integer within 1..8760");
          }

          const disputeSlaHours =
            disputeSlaHoursRaw === null || disputeSlaHoursRaw.trim() === ""
              ? 24
              : Number(disputeSlaHoursRaw);
          if (!Number.isSafeInteger(disputeSlaHours) || disputeSlaHours <= 0 || disputeSlaHours > 24 * 365) {
            return sendError(res, 400, "disputeSlaHours must be an integer within 1..8760");
          }

          const commandCenter = await computeNetworkCommandCenterSummary({
            tenantId,
            transactionFeeBps,
            windowHours,
            disputeSlaHours
          });
          const emitAlertsRaw = url.searchParams.get("emitAlerts");
          const persistAlertsRaw = url.searchParams.get("persistAlerts");

          let emitAlerts;
          let persistAlerts;
          try {
            emitAlerts = parseBooleanQueryValue(emitAlertsRaw, { defaultValue: false, name: "emitAlerts" });
            persistAlerts = parseBooleanQueryValue(persistAlertsRaw, { defaultValue: false, name: "persistAlerts" });
          } catch (err) {
            return sendError(res, 400, err?.message ?? "invalid alert query parameters");
          }
          if (persistAlerts && !requireScope(auth.scopes, OPS_SCOPES.OPS_WRITE)) return sendError(res, 403, "forbidden");

          let alertsSummary = null;
          if (emitAlerts || persistAlerts) {
            let thresholds;
            try {
              thresholds = {
                httpClientErrorRateThresholdPct: parseThresholdNumberQueryValue(url.searchParams.get("httpClientErrorRateThresholdPct"), {
                  defaultValue: COMMAND_CENTER_ALERT_DEFAULT_THRESHOLDS.httpClientErrorRateThresholdPct,
                  min: 0,
                  name: "httpClientErrorRateThresholdPct"
                }),
                httpServerErrorRateThresholdPct: parseThresholdNumberQueryValue(url.searchParams.get("httpServerErrorRateThresholdPct"), {
                  defaultValue: COMMAND_CENTER_ALERT_DEFAULT_THRESHOLDS.httpServerErrorRateThresholdPct,
                  min: 0,
                  name: "httpServerErrorRateThresholdPct"
                }),
                deliveryDlqThreshold: parseThresholdIntegerQueryValue(url.searchParams.get("deliveryDlqThreshold"), {
                  defaultValue: COMMAND_CENTER_ALERT_DEFAULT_THRESHOLDS.deliveryDlqThreshold,
                  min: 0,
                  name: "deliveryDlqThreshold"
                }),
                disputeOverSlaThreshold: parseThresholdIntegerQueryValue(url.searchParams.get("disputeOverSlaThreshold"), {
                  defaultValue: COMMAND_CENTER_ALERT_DEFAULT_THRESHOLDS.disputeOverSlaThreshold,
                  min: 0,
                  name: "disputeOverSlaThreshold"
                }),
                determinismRejectThreshold: parseThresholdIntegerQueryValue(url.searchParams.get("determinismRejectThreshold"), {
                  defaultValue: COMMAND_CENTER_ALERT_DEFAULT_THRESHOLDS.determinismRejectThreshold,
                  min: 0,
                  name: "determinismRejectThreshold"
                }),
                kernelVerificationErrorThreshold: parseThresholdIntegerQueryValue(
                  url.searchParams.get("kernelVerificationErrorThreshold"),
                  {
                    defaultValue: COMMAND_CENTER_ALERT_DEFAULT_THRESHOLDS.kernelVerificationErrorThreshold,
                    min: 0,
                    name: "kernelVerificationErrorThreshold"
                  }
                )
              };
            } catch (err) {
              return sendError(res, 400, err?.message ?? "invalid alert thresholds");
            }

            const alerts = evaluateNetworkCommandCenterAlerts({ commandCenter, thresholds });
            const emitted = persistAlerts
              ? await emitCommandCenterAlertArtifacts({
                  tenantId,
                  commandCenter,
                  thresholds,
                  alerts
                })
              : [];
            alertsSummary = {
              evaluatedCount: Object.keys(COMMAND_CENTER_ALERT_DEFAULT_THRESHOLDS).length,
              breachCount: alerts.length,
              emittedCount: emitted.length,
              emitted
            };
          }

          return sendJson(res, 200, {
            ok: true,
            tenantId,
            commandCenter,
            alerts: alertsSummary
          });
        }

        if (parts[1] === "maintenance" && parts[2] === "finance-reconcile" && parts[3] === "run" && parts.length === 4 && req.method === "POST") {
          const hasMaintenanceWriteScope =
            requireScope(auth.scopes, OPS_SCOPES.OPS_WRITE) || requireScope(auth.scopes, OPS_SCOPES.FINANCE_WRITE);
          if (!hasMaintenanceWriteScope) return sendError(res, 403, "forbidden");
          if (typeof store.appendOpsAudit !== "function") return sendError(res, 501, "ops audit not supported for this store");

          const body = (await readJsonBody(req)) ?? {};
          let period = null;
          if (Object.prototype.hasOwnProperty.call(body, "period") || Object.prototype.hasOwnProperty.call(body, "month")) {
            try {
              period = normalizeFinanceReconciliationPeriod(body?.period ?? body?.month ?? null, { fieldName: "period", allowNull: true });
            } catch (err) {
              return sendError(res, 400, err?.message ?? "period must match YYYY-MM", null, { code: "SCHEMA_INVALID" });
            }
          }
          const force = body?.force === undefined ? true : body.force === true;
          const maxTenantsRaw = body?.maxTenants ?? null;
          const maxTenants = maxTenantsRaw === null ? effectiveFinanceReconcileMaxTenants : Number(maxTenantsRaw);
          if (!Number.isSafeInteger(maxTenants) || maxTenants <= 0) {
            return sendError(res, 400, "invalid maxTenants", null, { code: "SCHEMA_INVALID" });
          }
          const maxPeriodsRaw = body?.maxPeriodsPerTenant ?? body?.maxPeriods ?? null;
          const maxPeriodsPerTenant = maxPeriodsRaw === null ? effectiveFinanceReconcileMaxPeriodsPerTenant : Number(maxPeriodsRaw);
          if (!Number.isSafeInteger(maxPeriodsPerTenant) || maxPeriodsPerTenant <= 0) {
            return sendError(res, 400, "invalid maxPeriodsPerTenant", null, { code: "SCHEMA_INVALID" });
          }

          let result;
          let outcome = "ok";
          try {
            result = await tickFinanceReconciliation({
              tenantId,
              period,
              maxTenants,
              maxPeriodsPerTenant,
              force,
              requireLock: true
            });
            if (!result?.ok && result?.code === "MAINTENANCE_ALREADY_RUNNING") outcome = "already_running";
            else if (!result?.ok) outcome = "error";
          } catch (err) {
            outcome = "error";
            result = {
              ok: false,
              scope: "tenant",
              tenantId,
              period,
              runtimeMs: null
            };
            try {
              await store.appendOpsAudit({
                tenantId,
                audit: makeOpsAudit({
                  action: "MAINTENANCE_FINANCE_RECONCILE_RUN",
                  targetType: "maintenance",
                  targetId: "finance_reconcile",
                  details: {
                    path: "/ops/maintenance/finance-reconcile/run",
                    outcome,
                    period,
                    force,
                    maxTenants,
                    maxPeriodsPerTenant,
                    error: err?.message ?? String(err)
                  }
                })
              });
            } catch {}
            return sendError(res, 500, "maintenance run failed", { message: err?.message });
          }

          try {
            await store.appendOpsAudit({
              tenantId,
              audit: makeOpsAudit({
                action: "MAINTENANCE_FINANCE_RECONCILE_RUN",
                targetType: "maintenance",
                targetId: "finance_reconcile",
                details: {
                  path: "/ops/maintenance/finance-reconcile/run",
                  outcome,
                  scope: result?.scope ?? "tenant",
                  period: result?.period ?? period ?? null,
                  force,
                  maxTenants: Number(result?.maxTenants ?? maxTenants),
                  maxPeriodsPerTenant: Number(result?.maxPeriodsPerTenant ?? maxPeriodsPerTenant),
                  runtimeMs: result?.runtimeMs ?? null,
                  summary: result?.summary ?? null,
                  code: result?.code ?? null
                }
              })
            });
          } catch (err) {
            return sendError(res, 500, "failed to write audit record", { message: err?.message }, { code: "AUDIT_LOG_FAILED" });
          }

          if (!result?.ok && result?.code === "MAINTENANCE_ALREADY_RUNNING") {
            return sendError(res, 409, "maintenance already running", null, { code: "MAINTENANCE_ALREADY_RUNNING" });
          }

          return sendJson(res, 200, {
            ok: result?.ok === true,
            period: result?.period ?? period ?? null,
            runtimeMs: result?.runtimeMs ?? null,
            summary: result?.summary ?? null,
            results: result?.results ?? []
          });
        }

	        if (parts[1] === "maintenance" && parts[2] === "outbox" && parts[3] === "run" && parts.length === 4 && req.method === "POST") {
	          const hasMaintenanceWriteScope =
	            requireScope(auth.scopes, OPS_SCOPES.OPS_WRITE) || requireScope(auth.scopes, OPS_SCOPES.FINANCE_WRITE);
	          if (!hasMaintenanceWriteScope) return sendError(res, 403, "forbidden");
	          if (typeof store.processOutbox !== "function") return sendError(res, 501, "outbox processing not supported for this store");

          const body = (await readJsonBody(req)) ?? {};
          const maxMessagesRaw = body?.maxMessages ?? null;
          const maxMessages = maxMessagesRaw === null || maxMessagesRaw === undefined || maxMessagesRaw === "" ? 1000 : Number(maxMessagesRaw);
          if (!Number.isSafeInteger(maxMessages) || maxMessages <= 0) {
            return sendError(res, 400, "invalid maxMessages", null, { code: "SCHEMA_INVALID" });
          }
          const passesRaw = body?.passes ?? null;
          const passes = passesRaw === null || passesRaw === undefined || passesRaw === "" ? 3 : Number(passesRaw);
          if (!Number.isSafeInteger(passes) || passes <= 0 || passes > 25) {
            return sendError(res, 400, "invalid passes", null, { code: "SCHEMA_INVALID" });
          }

	          const startedMs = Date.now();
	          const result = { passes, runs: [] };
	          try {
	            for (let i = 0; i < passes; i += 1) {
	              const run = {
	                index: i,
	                storeOutbox: null,
	                dispatch: null,
	                proof: null,
	                artifacts: null,
	                deliveries: null
	              };
	              run.storeOutbox = await store.processOutbox({ maxMessages });
	              // Some outbox topics are handled by "tick*" workers in this API monolith, not by store.processOutbox().
	              // Include them here so ops tooling can drain outbox even when PROXY_AUTOTICK is disabled.
	              if (typeof tickDispatch === "function") run.dispatch = await tickDispatch({ maxMessages });
	              if (typeof tickProof === "function") run.proof = await tickProof({ maxMessages });
	              if (typeof tickArtifacts === "function") run.artifacts = await tickArtifacts({ maxMessages });
	              if (typeof tickDeliveries === "function") run.deliveries = await tickDeliveries({ maxMessages });
	              result.runs.push(run);

              const storeProcessedCount = (() => {
                try {
                  const out = run.storeOutbox ?? {};
                  let n = 0;
                  for (const v of Object.values(out)) {
                    if (!v || typeof v !== "object") continue;
                    if (Array.isArray(v.processed)) n += v.processed.length;
                    else if (Array.isArray(v.processed ?? null)) n += v.processed.length;
                    else if (Array.isArray(v?.processed ?? null)) n += v.processed.length;
                  }
                  return n;
                } catch {
                  return 0;
                }
	              })();
	              const dispatchCount = Array.isArray(run.dispatch?.processed) ? run.dispatch.processed.length : 0;
	              const proofCount = Array.isArray(run.proof?.processed) ? run.proof.processed.length : 0;
	              const artifactCount = Array.isArray(run.artifacts?.processed) ? run.artifacts.processed.length : 0;
	              const deliveryCount = Array.isArray(run.deliveries?.processed) ? run.deliveries.processed.length : 0;
	              if (storeProcessedCount + dispatchCount + proofCount + artifactCount + deliveryCount === 0) break;
	            }
	          } catch (err) {
	            return sendError(res, 500, "outbox processing failed", { message: err?.message ?? String(err) });
	          }

          const runtimeMs = Date.now() - startedMs;
          try {
            if (typeof store.appendOpsAudit === "function") {
              await store.appendOpsAudit({
                tenantId,
                audit: makeOpsAudit({
                  action: "MAINTENANCE_OUTBOX_RUN",
                  targetType: "maintenance",
                  targetId: "outbox",
                  details: {
                    path: "/ops/maintenance/outbox/run",
                    maxMessages,
                    passes,
                    runtimeMs,
                    result
                  }
                })
              });
            }
          } catch {
            // best-effort
          }

	          return sendJson(res, 200, {
	            ok: true,
	            runtimeMs,
	            maxMessages,
	            result
	          });
	        }

	        if (parts[1] === "debug" && parts[2] === "outbox" && parts.length === 3 && req.method === "GET") {
	          if (!requireScope(auth.scopes, OPS_SCOPES.OPS_READ)) return sendError(res, 403, "forbidden");
	          if (typeof store.listOutboxDebug !== "function") return sendError(res, 501, "outbox debug not supported for this store");
	          const topic = url.searchParams.get("topic");
	          const tenantFilter = url.searchParams.get("tenantId");
	          const includeProcessed = url.searchParams.get("includeProcessed") === "true";
	          const limitRaw = url.searchParams.get("limit");
	          const limit = limitRaw === null ? 50 : Number(limitRaw);
	          if (limitRaw !== null && (!Number.isSafeInteger(limit) || limit <= 0 || limit > 500)) {
	            return sendError(res, 400, "invalid limit", null, { code: "SCHEMA_INVALID" });
	          }
	          let rows;
	          try {
	            rows = await store.listOutboxDebug({
	              topic,
	              tenantId: tenantFilter,
	              includeProcessed,
	              limit
	            });
	          } catch (err) {
	            return sendError(res, 400, "invalid outbox debug query", { message: err?.message });
	          }
	          return sendJson(res, 200, { rows });
	        }

        if (parts[1] === "maintenance" && parts[2] === "money-rails-reconcile" && parts[3] === "run" && parts.length === 4 && req.method === "POST") {
          const hasMaintenanceWriteScope =
            requireScope(auth.scopes, OPS_SCOPES.OPS_WRITE) || requireScope(auth.scopes, OPS_SCOPES.FINANCE_WRITE);
          if (!hasMaintenanceWriteScope) return sendError(res, 403, "forbidden");
          if (typeof store.appendOpsAudit !== "function") return sendError(res, 501, "ops audit not supported for this store");

          const body = (await readJsonBody(req)) ?? {};
          let period = null;
          if (Object.prototype.hasOwnProperty.call(body, "period") || Object.prototype.hasOwnProperty.call(body, "month")) {
            try {
              period = normalizeFinanceReconciliationPeriod(body?.period ?? body?.month ?? null, { fieldName: "period", allowNull: true });
            } catch (err) {
              return sendError(res, 400, err?.message ?? "period must match YYYY-MM", null, { code: "SCHEMA_INVALID" });
            }
          }
          let providerId = null;
          try {
            providerId = normalizeNonEmptyStringOrNull(body?.providerId ?? null);
          } catch (err) {
            return sendError(res, 400, "invalid providerId", { message: err?.message }, { code: "SCHEMA_INVALID" });
          }
          const force = body?.force === undefined ? true : body.force === true;
          const maxTenantsRaw = body?.maxTenants ?? null;
          const maxTenants = maxTenantsRaw === null ? effectiveMoneyRailReconcileMaxTenants : Number(maxTenantsRaw);
          if (!Number.isSafeInteger(maxTenants) || maxTenants <= 0) {
            return sendError(res, 400, "invalid maxTenants", null, { code: "SCHEMA_INVALID" });
          }
          const maxPeriodsRaw = body?.maxPeriodsPerTenant ?? body?.maxPeriods ?? null;
          const maxPeriodsPerTenant = maxPeriodsRaw === null ? effectiveMoneyRailReconcileMaxPeriodsPerTenant : Number(maxPeriodsRaw);
          if (!Number.isSafeInteger(maxPeriodsPerTenant) || maxPeriodsPerTenant <= 0) {
            return sendError(res, 400, "invalid maxPeriodsPerTenant", null, { code: "SCHEMA_INVALID" });
          }
          const maxProvidersRaw = body?.maxProvidersPerTenant ?? body?.maxProviders ?? null;
          const maxProvidersPerTenant = maxProvidersRaw === null ? effectiveMoneyRailReconcileMaxProvidersPerTenant : Number(maxProvidersRaw);
          if (!Number.isSafeInteger(maxProvidersPerTenant) || maxProvidersPerTenant <= 0) {
            return sendError(res, 400, "invalid maxProvidersPerTenant", null, { code: "SCHEMA_INVALID" });
          }

          let result;
          let outcome = "ok";
          try {
            result = await tickMoneyRailReconciliation({
              tenantId,
              period,
              providerId,
              maxTenants,
              maxPeriodsPerTenant,
              maxProvidersPerTenant,
              force,
              requireLock: true
            });
            if (!result?.ok && result?.code === "MAINTENANCE_ALREADY_RUNNING") outcome = "already_running";
            else if (!result?.ok) outcome = "error";
          } catch (err) {
            outcome = "error";
            result = {
              ok: false,
              scope: "tenant",
              tenantId,
              period,
              providerId,
              runtimeMs: null
            };
            try {
              await store.appendOpsAudit({
                tenantId,
                audit: makeOpsAudit({
                  action: "MAINTENANCE_MONEY_RAIL_RECONCILE_RUN",
                  targetType: "maintenance",
                  targetId: "money_rails_reconcile",
                  details: {
                    path: "/ops/maintenance/money-rails-reconcile/run",
                    outcome,
                    period,
                    providerId,
                    force,
                    maxTenants,
                    maxPeriodsPerTenant,
                    maxProvidersPerTenant,
                    error: err?.message ?? String(err)
                  }
                })
              });
            } catch {}
            return sendError(res, 500, "maintenance run failed", { message: err?.message });
          }

          try {
            await store.appendOpsAudit({
              tenantId,
              audit: makeOpsAudit({
                action: "MAINTENANCE_MONEY_RAIL_RECONCILE_RUN",
                targetType: "maintenance",
                targetId: "money_rails_reconcile",
                details: {
                  path: "/ops/maintenance/money-rails-reconcile/run",
                  outcome,
                  scope: result?.scope ?? "tenant",
                  period: result?.period ?? period ?? null,
                  providerId: result?.providerId ?? providerId ?? null,
                  force,
                  maxTenants: Number(result?.maxTenants ?? maxTenants),
                  maxPeriodsPerTenant: Number(result?.maxPeriodsPerTenant ?? maxPeriodsPerTenant),
                  maxProvidersPerTenant: Number(result?.maxProvidersPerTenant ?? maxProvidersPerTenant),
                  runtimeMs: result?.runtimeMs ?? null,
                  summary: result?.summary ?? null,
                  code: result?.code ?? null
                }
              })
            });
          } catch (err) {
            return sendError(res, 500, "failed to write audit record", { message: err?.message }, { code: "AUDIT_LOG_FAILED" });
          }

          if (!result?.ok && result?.code === "MAINTENANCE_ALREADY_RUNNING") {
            return sendError(res, 409, "maintenance already running", null, { code: "MAINTENANCE_ALREADY_RUNNING" });
          }

          return sendJson(res, 200, {
            ok: result?.ok === true,
            period: result?.period ?? period ?? null,
            providerId: result?.providerId ?? providerId ?? null,
            runtimeMs: result?.runtimeMs ?? null,
            summary: result?.summary ?? null,
            results: result?.results ?? []
          });
        }

        if (parts[1] === "maintenance" && parts[2] === "retention" && parts[3] === "run" && parts.length === 4 && req.method === "POST") {
          if (!requireScope(auth.scopes, OPS_SCOPES.OPS_WRITE)) return sendError(res, 403, "forbidden");
          if (typeof store.appendOpsAudit !== "function") return sendError(res, 501, "ops audit not supported for this store");

          const body = (await readJsonBody(req)) ?? {};
          const bodyDryRun = typeof body?.dryRun === "boolean" ? body.dryRun : null;
          const dryRun = bodyDryRun === null ? retentionCleanupDefaultDryRun : bodyDryRun;

          const batchRaw = body?.batchSize ?? body?.maxRows ?? null;
          const maxRows = batchRaw === null ? retentionCleanupDefaultBatchSize : Number(batchRaw);
          if (!Number.isSafeInteger(maxRows) || maxRows <= 0) return sendError(res, 400, "invalid batchSize", null, { code: "SCHEMA_INVALID" });

          const maxMillisRaw = body?.maxMillis ?? null;
          const maxMillis = maxMillisRaw === null ? retentionCleanupDefaultMaxMillis : Number(maxMillisRaw);
          if (!Number.isSafeInteger(maxMillis) || maxMillis <= 0) return sendError(res, 400, "invalid maxMillis", null, { code: "SCHEMA_INVALID" });

          let result;
          let outcome = "ok";
          try {
            result = await tickRetentionCleanup({ tenantId, maxRows, maxMillis, dryRun, requireLock: true });
            if (!result?.ok && result?.code === "MAINTENANCE_ALREADY_RUNNING") outcome = "already_running";
          } catch (err) {
            outcome = "error";
            result = { ok: false, scope: "tenant", tenantId, dryRun: Boolean(dryRun), maxRows, maxMillis, runtimeMs: null };
            try {
              await store.appendOpsAudit({
                tenantId,
                audit: makeOpsAudit({
                  action: "MAINTENANCE_RETENTION_RUN",
                  targetType: "maintenance",
                  targetId: "retention",
                  details: {
                    path: "/ops/maintenance/retention/run",
                    outcome,
                    dryRun: Boolean(dryRun),
                    maxRows,
                    maxMillis,
                    error: err?.message ?? String(err)
                  }
                })
              });
            } catch {}
            return sendError(res, 500, "maintenance run failed", { message: err?.message });
          }

          try {
            await store.appendOpsAudit({
              tenantId,
              audit: makeOpsAudit({
                action: "MAINTENANCE_RETENTION_RUN",
                targetType: "maintenance",
                targetId: "retention",
                details: {
                  path: "/ops/maintenance/retention/run",
                  outcome,
                  scope: result?.scope ?? "tenant",
                  dryRun: Boolean(result?.dryRun),
                  maxRows: Number(result?.maxRows ?? maxRows),
                  maxMillis: Number(result?.maxMillis ?? maxMillis),
                  runtimeMs: result?.runtimeMs ?? null,
                  timedOut: result?.timedOut === true,
                  purged: result?.purged ?? null,
                  code: result?.code ?? null
                }
              })
            });
          } catch (err) {
            return sendError(res, 500, "failed to write audit record", { message: err?.message }, { code: "AUDIT_LOG_FAILED" });
          }

          if (!result?.ok && result?.code === "MAINTENANCE_ALREADY_RUNNING") {
            return sendError(res, 409, "maintenance already running", null, { code: "MAINTENANCE_ALREADY_RUNNING" });
          }

          return sendJson(res, 200, {
            ok: true,
            dryRun: Boolean(result?.dryRun),
            runtimeMs: result?.runtimeMs ?? null,
            timedOut: result?.timedOut === true,
            purged: result?.purged ?? { ingest_records: 0, deliveries: 0, delivery_receipts: 0 }
          });
        }

        if (parts[1] === "delegation" && parts[2] === "chains" && parts.length === 3 && req.method === "GET") {
          if (!requireScope(auth.scopes, OPS_SCOPES.OPS_READ)) return sendError(res, 403, "forbidden");
          const { limit, offset } = parsePagination({
            limitRaw: url.searchParams.get("limit"),
            offsetRaw: url.searchParams.get("offset"),
            defaultLimit: 200,
            maxLimit: 1000
          });
          const runId = url.searchParams.get("runId");
          const chainHash = url.searchParams.get("chainHash");
          const delegationId = url.searchParams.get("delegationId");
          const signerKeyId = url.searchParams.get("signerKeyId");
          const signerAgentId = url.searchParams.get("signerAgentId");
          const listed = listDelegationTraces({
            tenantId,
            runId,
            chainHash,
            delegationId,
            signerKeyId,
            signerAgentId,
            limit,
            offset
          });
          return sendJson(res, 200, listed);
        }

        if (parts[1] === "delegation" && parts[2] === "chains" && parts[3] && parts.length === 4 && req.method === "GET") {
          if (!requireScope(auth.scopes, OPS_SCOPES.OPS_READ)) return sendError(res, 403, "forbidden");
          const chainHash = String(parts[3]).trim().toLowerCase();
          if (!chainHash) return sendError(res, 400, "chainHash is required");
          const listed = listDelegationTraces({
            tenantId,
            chainHash,
            limit: 1000,
            offset: 0
          });
          if (listed.total === 0) return sendError(res, 404, "delegation chain not found");
          return sendJson(res, 200, {
            chainHash,
            traces: listed.traces,
            total: listed.total
          });
        }

        if (parts[1] === "delegation" && parts[2] === "emergency-revoke" && parts.length === 3 && req.method === "POST") {
          if (!requireScope(auth.scopes, OPS_SCOPES.OPS_WRITE)) return sendError(res, 403, "forbidden");
          const body = (await readJsonBody(req)) ?? {};
          const runId = typeof body?.runId === "string" && body.runId.trim() !== "" ? body.runId.trim() : null;
          const chainHash = typeof body?.chainHash === "string" && body.chainHash.trim() !== "" ? body.chainHash.trim().toLowerCase() : null;
          const delegationId = typeof body?.delegationId === "string" && body.delegationId.trim() !== "" ? body.delegationId.trim() : null;
          const signerKeyIdInput = typeof body?.signerKeyId === "string" && body.signerKeyId.trim() !== "" ? body.signerKeyId.trim() : null;
          const signerAgentIdInput =
            typeof body?.signerAgentId === "string" && body.signerAgentId.trim() !== "" ? body.signerAgentId.trim() : null;
          const authKeyIdInput = typeof body?.authKeyId === "string" && body.authKeyId.trim() !== "" ? body.authKeyId.trim() : null;
          const agentIdInput = typeof body?.agentId === "string" && body.agentId.trim() !== "" ? body.agentId.trim() : null;
          const reason = typeof body?.reason === "string" && body.reason.trim() !== "" ? body.reason.trim() : null;
          const includeDelegateAgent = body?.includeDelegateAgent === undefined ? true : body.includeDelegateAgent === true;
          const includePrincipalAgent = body?.includePrincipalAgent === true;
          const includeSignerKey = body?.includeSignerKey === undefined ? true : body.includeSignerKey === true;

          if (!runId && !chainHash && !delegationId && !signerKeyIdInput && !signerAgentIdInput && !authKeyIdInput && !agentIdInput) {
            return sendError(res, 400, "at least one revoke selector is required");
          }

          const listed = listDelegationTraces({
            tenantId,
            runId,
            chainHash,
            delegationId,
            signerKeyId: signerKeyIdInput,
            signerAgentId: signerAgentIdInput,
            limit: 1000,
            offset: 0
          });

          const signerKeyIds = new Set();
          const agentIds = new Set();
          const authKeyIds = new Set();

          if (signerKeyIdInput) signerKeyIds.add(signerKeyIdInput);
          if (authKeyIdInput) authKeyIds.add(authKeyIdInput);
          if (agentIdInput) agentIds.add(agentIdInput);

          for (const trace of listed.traces) {
            if (includeSignerKey && typeof trace?.signerKeyId === "string" && trace.signerKeyId.trim() !== "") {
              signerKeyIds.add(trace.signerKeyId.trim());
            }
            if (includeDelegateAgent && typeof trace?.delegateAgentId === "string" && trace.delegateAgentId.trim() !== "") {
              agentIds.add(trace.delegateAgentId.trim());
            }
            if (includePrincipalAgent && typeof trace?.principalAgentId === "string" && trace.principalAgentId.trim() !== "") {
              agentIds.add(trace.principalAgentId.trim());
            }
          }

          if (signerKeyIds.size === 0 && authKeyIds.size === 0 && agentIds.size === 0) {
            return sendError(res, 404, "no revocation targets found for selectors");
          }

          const nowAt = nowIso();
          const revoked = {
            agents: [],
            signerKeys: [],
            authKeys: []
          };
          const missing = {
            agents: [],
            signerKeys: [],
            authKeys: []
          };

          if (agentIds.size > 0) {
            if (typeof store.getAgentIdentity !== "function") {
              return sendError(res, 501, "agent identity revocation not supported for this store");
            }
            for (const targetAgentId of [...agentIds]) {
              const existingIdentity = await store.getAgentIdentity({ tenantId, agentId: targetAgentId });
              if (!existingIdentity) {
                missing.agents.push(targetAgentId);
                continue;
              }
              const nextIdentity = {
                ...existingIdentity,
                status: "revoked",
                updatedAt: nowAt
              };
              await commitTx([{ kind: "AGENT_IDENTITY_UPSERT", tenantId, agentIdentity: nextIdentity }]);
              revoked.agents.push({
                agentId: targetAgentId,
                status: nextIdentity.status,
                updatedAt: nextIdentity.updatedAt ?? nowAt
              });
            }
          }

          if (signerKeyIds.size > 0) {
            if (typeof store.setSignerKeyStatus !== "function") return sendError(res, 501, "signer key revocation not supported for this store");
            for (const targetSignerKeyId of [...signerKeyIds]) {
              const updated = await store.setSignerKeyStatus({
                tenantId,
                keyId: targetSignerKeyId,
                status: SIGNER_KEY_STATUS.REVOKED,
                at: nowAt
              });
              if (!updated) {
                missing.signerKeys.push(targetSignerKeyId);
                continue;
              }
              revoked.signerKeys.push({
                keyId: targetSignerKeyId,
                status: updated?.status ?? SIGNER_KEY_STATUS.REVOKED,
                revokedAt: updated?.revokedAt ?? nowAt
              });
            }
          }

          if (authKeyIds.size > 0) {
            if (typeof store.setAuthKeyStatus !== "function") return sendError(res, 501, "auth key revocation not supported for this store");
            for (const targetAuthKeyId of [...authKeyIds]) {
              const updated = await store.setAuthKeyStatus({
                tenantId,
                keyId: targetAuthKeyId,
                status: normalizeAuthKeyStatus("revoked"),
                at: nowAt
              });
              if (!updated) {
                missing.authKeys.push(targetAuthKeyId);
                continue;
              }
              revoked.authKeys.push({
                keyId: targetAuthKeyId,
                status: updated?.status ?? "revoked",
                revokedAt: updated?.revokedAt ?? nowAt
              });
            }
          }

          if (typeof store.appendOpsAudit === "function") {
            await store.appendOpsAudit({
              tenantId,
              audit: makeOpsAudit({
                action: "DELEGATION_EMERGENCY_REVOKE",
                targetType: "delegation_authority",
                targetId: chainHash ?? delegationId ?? runId ?? signerKeyIdInput ?? authKeyIdInput ?? agentIdInput ?? "bulk",
                details: {
                  selectors: {
                    runId,
                    chainHash,
                    delegationId,
                    signerKeyId: signerKeyIdInput,
                    signerAgentId: signerAgentIdInput,
                    authKeyId: authKeyIdInput,
                    agentId: agentIdInput
                  },
                  includeDelegateAgent,
                  includePrincipalAgent,
                  includeSignerKey,
                  reason,
                  affectedTraceCount: listed.total,
                  revoked,
                  missing
                }
              })
            });
          }

          return sendJson(res, 200, {
            ok: true,
            selectors: {
              runId,
              chainHash,
              delegationId,
              signerKeyId: signerKeyIdInput,
              signerAgentId: signerAgentIdInput,
              authKeyId: authKeyIdInput,
              agentId: agentIdInput
            },
            affectedTraceCount: listed.total,
            revoked,
            missing
          });
        }

        const opsSubresource = parts[1] ?? null;
        const isAuthKeyResource = opsSubresource === "auth-keys" || opsSubresource === "api-keys";

        if (opsSubresource === "audit" && parts.length === 2 && req.method === "GET") {
          if (!requireScope(auth.scopes, OPS_SCOPES.OPS_READ)) return sendError(res, 403, "forbidden");
          if (typeof store.listOpsAudit !== "function") return sendError(res, 501, "ops audit not supported for this store");
          const limitRaw = url.searchParams.get("limit");
          const offsetRaw = url.searchParams.get("offset");
          const limit = limitRaw ? Number(limitRaw) : 200;
          const offset = offsetRaw ? Number(offsetRaw) : 0;
          let records;
          try {
            records = await store.listOpsAudit({ tenantId, limit, offset });
          } catch (err) {
            return sendError(res, 400, "invalid audit query", { message: err?.message });
          }
          return sendJson(res, 200, { audit: records });
        }

        if (isAuthKeyResource && parts.length === 2 && req.method === "GET") {
          if (!requireScope(auth.scopes, OPS_SCOPES.OPS_READ)) return sendError(res, 403, "forbidden");
          if (typeof store.listAuthKeys !== "function") return sendError(res, 501, "auth keys not supported for this store");
          const keys = await store.listAuthKeys({ tenantId });
          const redacted = keys.map((k) => ({
            tenantId: normalizeTenantId(k?.tenantId ?? tenantId),
            keyId: k?.keyId ?? null,
            status: k?.status ?? null,
            scopes: Array.isArray(k?.scopes) ? k.scopes : [],
            description: k?.description ?? null,
            expiresAt: k?.expiresAt ?? null,
            createdAt: k?.createdAt ?? null,
            updatedAt: k?.updatedAt ?? null,
            lastUsedAt: k?.lastUsedAt ?? null,
            rotatedAt: k?.rotatedAt ?? null,
            revokedAt: k?.revokedAt ?? null
          }));
          return sendJson(res, 200, opsSubresource === "api-keys" ? { apiKeys: redacted } : { authKeys: redacted });
        }

        if (isAuthKeyResource && parts.length === 2 && req.method === "POST") {
          if (!requireScope(auth.scopes, OPS_SCOPES.OPS_WRITE)) return sendError(res, 403, "forbidden");
          if (typeof store.putAuthKey !== "function") return sendError(res, 501, "auth keys not supported for this store");
          const body = await readJsonBody(req);

          const requestedScopes = normalizeScopes(body?.scopes ?? []);
          if (requestedScopes.length === 0) return sendError(res, 400, "scopes[] is required");
          for (const s of requestedScopes) {
            if (!ALL_OPS_SCOPES.has(s)) return sendError(res, 400, "unknown scope", { scope: s });
          }

          const keyId = body?.keyId ? String(body.keyId) : authKeyId();
          if (keyId.includes(".") || keyId.includes(" ") || keyId.includes("\n") || keyId.includes("\r")) return sendError(res, 400, "invalid keyId");
          const secret = authKeySecret();
          const secretHash = hashAuthKeySecret(secret);
          const expiresAt = body?.expiresAt ?? null;
          const description = body?.description ?? null;
          const at = nowIso();

          await store.putAuthKey({
            tenantId,
            authKey: {
              keyId,
              secretHash,
              scopes: requestedScopes,
              status: "active",
              expiresAt,
              description,
              createdAt: at
            },
            audit: makeOpsAudit({
              action: "API_KEY_CREATE",
              targetType: "auth_key",
              targetId: keyId,
              details: { scopes: requestedScopes, expiresAt, description }
            })
          });

          return sendJson(res, 201, { tenantId, keyId, secret, scopes: requestedScopes, expiresAt, description });
        }

        if (isAuthKeyResource && parts[2] && parts[3] === "revoke" && parts.length === 4 && req.method === "POST") {
          if (!requireScope(auth.scopes, OPS_SCOPES.OPS_WRITE)) return sendError(res, 403, "forbidden");
          if (typeof store.setAuthKeyStatus !== "function") return sendError(res, 501, "auth keys not supported for this store");
          const keyId = String(parts[2]);
          const updated = await store.setAuthKeyStatus({
            tenantId,
            keyId,
            status: normalizeAuthKeyStatus("revoked"),
            at: nowIso(),
            audit: makeOpsAudit({ action: "API_KEY_REVOKE", targetType: "auth_key", targetId: keyId, details: null })
          });
          if (!updated) return sendError(res, 404, "auth key not found");
          return sendJson(res, 200, { authKey: { ...updated, secretHash: undefined } });
        }

        if (isAuthKeyResource && parts[2] && parts[3] === "rotate" && parts.length === 4 && req.method === "POST") {
          if (!requireScope(auth.scopes, OPS_SCOPES.OPS_WRITE)) return sendError(res, 403, "forbidden");
          if (typeof store.rotateAuthKey !== "function") {
            return sendError(res, 501, "auth keys not supported for this store");
          }
          const oldKeyId = String(parts[2]);
          const rotatedAt = nowIso();
          const newKeyId = authKeyId();
          if (newKeyId.includes(".") || newKeyId.includes(" ") || newKeyId.includes("\n") || newKeyId.includes("\r")) return sendError(res, 500, "invalid authKeyId()");
          const secret = authKeySecret();
          const secretHash = hashAuthKeySecret(secret);
          try {
            const rotated = await store.rotateAuthKey({
              tenantId,
              oldKeyId,
              newAuthKey: { keyId: newKeyId, secretHash },
              rotatedAt,
              audit: makeOpsAudit({
                action: "API_KEY_ROTATE",
                targetType: "auth_key",
                targetId: oldKeyId,
                details: { oldKeyId, newKeyId }
              })
            });
            if (!rotated) return sendError(res, 404, "auth key not found");
            if (!rotated.newKey) return sendError(res, 500, "failed to create rotated key");
            return sendJson(res, 201, {
              tenantId,
              rotatedAt: rotated.rotatedAt ?? rotatedAt,
              oldKeyId,
              newKeyId,
              secret,
              scopes: Array.isArray(rotated.newKey.scopes) ? rotated.newKey.scopes : []
            });
          } catch (err) {
            if (err?.code === "AUTH_KEY_REVOKED") return sendError(res, 409, "auth key is revoked");
            return sendError(res, 400, "auth key rotation failed", { message: err?.message });
          }
        }

        if (parts[1] === "signer-keys" && parts.length === 2 && req.method === "GET") {
          if (!requireScope(auth.scopes, OPS_SCOPES.OPS_READ)) return sendError(res, 403, "forbidden");
          if (typeof store.listSignerKeys !== "function") return sendError(res, 501, "signer keys not supported for this store");
          const keys = await store.listSignerKeys({ tenantId });
          return sendJson(res, 200, { signerKeys: keys });
        }

        if (parts[1] === "signer-keys" && parts.length === 2 && req.method === "POST") {
          if (!requireScope(auth.scopes, OPS_SCOPES.OPS_WRITE)) return sendError(res, 403, "forbidden");
          if (typeof store.putSignerKey !== "function") return sendError(res, 501, "signer keys not supported for this store");
          const body = await readJsonBody(req);
          const publicKeyPem = body?.publicKeyPem ? String(body.publicKeyPem) : null;
          if (!publicKeyPem) return sendError(res, 400, "publicKeyPem is required");
          const derivedKeyId = keyIdFromPublicKeyPem(publicKeyPem);
          if (body?.keyId && String(body.keyId) !== derivedKeyId) return sendError(res, 400, "keyId does not match publicKeyPem");

          const purpose = body?.purpose ? normalizeSignerKeyPurpose(body.purpose) : SIGNER_KEY_PURPOSE.ROBOT;
          const status = body?.status ? normalizeSignerKeyStatus(body.status) : SIGNER_KEY_STATUS.ACTIVE;
          const nowAt = nowIso();

          const record = await store.putSignerKey({
            tenantId,
            signerKey: {
              keyId: derivedKeyId,
              publicKeyPem,
              purpose,
              status,
              description: body?.description ?? null,
              validFrom: body?.validFrom ?? null,
              validTo: body?.validTo ?? null,
              createdAt: nowAt
            },
            audit: makeOpsAudit({
              action: "SIGNER_KEY_REGISTER",
              targetType: "signer_key",
              targetId: derivedKeyId,
              details: { purpose, status, description: body?.description ?? null, validFrom: body?.validFrom ?? null, validTo: body?.validTo ?? null }
            })
          });
          return sendJson(res, 201, { signerKey: record });
        }

        if (parts[1] === "signer-keys" && parts[2] && parts[3] === "revoke" && parts.length === 4 && req.method === "POST") {
          if (!requireScope(auth.scopes, OPS_SCOPES.OPS_WRITE)) return sendError(res, 403, "forbidden");
          if (typeof store.setSignerKeyStatus !== "function") return sendError(res, 501, "signer keys not supported for this store");
          const keyId = String(parts[2]);
          const updated = await store.setSignerKeyStatus({
            tenantId,
            keyId,
            status: SIGNER_KEY_STATUS.REVOKED,
            at: nowIso(),
            audit: makeOpsAudit({ action: "SIGNER_KEY_REVOKE", targetType: "signer_key", targetId: keyId, details: null })
          });
          if (!updated) return sendError(res, 404, "signer key not found");
          return sendJson(res, 200, { signerKey: updated });
        }

        if (parts[1] === "signer-keys" && parts[2] && parts[3] === "rotate" && parts.length === 4 && req.method === "POST") {
          if (!requireScope(auth.scopes, OPS_SCOPES.OPS_WRITE)) return sendError(res, 403, "forbidden");
          if (typeof store.setSignerKeyStatus !== "function") return sendError(res, 501, "signer keys not supported for this store");
          const keyId = String(parts[2]);
          const updated = await store.setSignerKeyStatus({
            tenantId,
            keyId,
            status: SIGNER_KEY_STATUS.ROTATED,
            at: nowIso(),
            audit: makeOpsAudit({ action: "SIGNER_KEY_ROTATE", targetType: "signer_key", targetId: keyId, details: null })
          });
          if (!updated) return sendError(res, 404, "signer key not found");
          return sendJson(res, 200, { signerKey: updated });
        }

        if (parts[1] === "jobs" && parts.length === 2 && req.method === "GET") {
          if (!(requireScope(auth.scopes, OPS_SCOPES.OPS_READ) || requireScope(auth.scopes, OPS_SCOPES.AUDIT_READ))) {
            return sendError(res, 403, "forbidden");
          }
          const status = url.searchParams.get("status");
          const zoneRaw = url.searchParams.get("zoneId");
          const zoneId = zoneRaw ? normalizeZoneId(zoneRaw) : null;
          const environmentTier = url.searchParams.get("environmentTier");
          const templateId = url.searchParams.get("templateId");

          let jobs = listJobs({ tenantId });
          if (status) jobs = jobs.filter((j) => j?.status === status);
          if (zoneId) {
            jobs = jobs.filter((j) => normalizeZoneId(j?.booking?.zoneId ?? j?.constraints?.zoneId) === zoneId);
          }
          if (environmentTier) jobs = jobs.filter((j) => j?.booking?.environmentTier === environmentTier);
          if (templateId) jobs = jobs.filter((j) => j?.templateId === templateId);

          jobs.sort((a, b) => {
            const at = Date.parse(a?.updatedAt ?? a?.createdAt ?? 0);
            const bt = Date.parse(b?.updatedAt ?? b?.createdAt ?? 0);
            if (Number.isFinite(bt) && Number.isFinite(at) && bt !== at) return bt - at;
            return String(a?.id ?? "").localeCompare(String(b?.id ?? ""));
          });

          const limitRaw = url.searchParams.get("limit");
          const offsetRaw = url.searchParams.get("offset");
          const limit = limitRaw ? Number(limitRaw) : 200;
          const offset = offsetRaw ? Number(offsetRaw) : 0;
          const safeLimit = Number.isSafeInteger(limit) && limit > 0 ? Math.min(1000, limit) : 200;
          const safeOffset = Number.isSafeInteger(offset) && offset >= 0 ? offset : 0;

          const page = jobs.slice(safeOffset, safeOffset + safeLimit);
          const pageJobIds = page
            .map((item) => (typeof item?.id === "string" && item.id.trim() !== "" ? String(item.id) : null))
            .filter(Boolean);

          const artifactsByJobId = new Map();
          if (pageJobIds.length && typeof store.listArtifacts === "function") {
            try {
              let artifacts = [];
              if (store.kind === "pg") {
                const batchLimit = 1000;
                let batchOffset = 0;
                while (true) {
                  const rows = await store.listArtifacts({ tenantId, jobIds: pageJobIds, limit: batchLimit, offset: batchOffset });
                  if (!Array.isArray(rows) || rows.length === 0) break;
                  artifacts.push(...rows);
                  if (rows.length < batchLimit) break;
                  batchOffset += rows.length;
                }
              } else {
                artifacts = await store.listArtifacts({ tenantId, jobIds: pageJobIds });
              }

              for (const artifact of artifacts) {
                if (!artifact || typeof artifact !== "object") continue;
                const artifactJobId = typeof artifact.jobId === "string" && artifact.jobId.trim() !== "" ? String(artifact.jobId) : null;
                if (!artifactJobId) continue;
                const list = artifactsByJobId.get(artifactJobId) ?? [];
                list.push(artifact);
                artifactsByJobId.set(artifactJobId, list);
              }
            } catch {
              // Best-effort enrichment; fall back to job-derived proof status below.
            }
          }

          const artifactHasProofSignals = (artifact) =>
            Boolean(
              artifact &&
                typeof artifact === "object" &&
                ((artifact.proof && typeof artifact.proof === "object" && !Array.isArray(artifact.proof)) ||
                  (artifact.proofReceipt && typeof artifact.proofReceipt === "object" && !Array.isArray(artifact.proofReceipt)) ||
                  (artifact.settlement &&
                    typeof artifact.settlement === "object" &&
                    artifact.settlement.settlementProofRef &&
                    typeof artifact.settlement.settlementProofRef === "object" &&
                    !Array.isArray(artifact.settlement.settlementProofRef)))
            );

          const artifactSortDesc = (left, right) => {
            const leftAt = Date.parse(left?.generatedAt ?? left?.createdAt ?? left?.updatedAt ?? 0);
            const rightAt = Date.parse(right?.generatedAt ?? right?.createdAt ?? right?.updatedAt ?? 0);
            if (Number.isFinite(leftAt) && Number.isFinite(rightAt) && rightAt !== leftAt) return rightAt - leftAt;
            return String(right?.artifactId ?? "").localeCompare(String(left?.artifactId ?? ""));
          };

          const pickStatusArtifact = ({ artifacts, job }) => {
            if (!Array.isArray(artifacts) || artifacts.length === 0) return null;
            const sorted = [...artifacts].sort(artifactSortDesc);
            const settledEventId = typeof job?.settlement?.settledEventId === "string" && job.settlement.settledEventId.trim() ? job.settlement.settledEventId : null;
            if (settledEventId) {
              const preferredSettled =
                sorted.find(
                  (artifact) =>
                    artifact?.sourceEventId === settledEventId &&
                    (artifact?.artifactType === ARTIFACT_TYPE.SETTLEMENT_STATEMENT_V1 || artifact?.artifactType === ARTIFACT_TYPE.WORK_CERTIFICATE_V1)
                ) ?? null;
              if (preferredSettled) return preferredSettled;
              const anySettled = sorted.find((artifact) => artifact?.sourceEventId === settledEventId) ?? null;
              if (anySettled) return anySettled;
            }
            const latestWithProof = sorted.find((artifact) => artifactHasProofSignals(artifact)) ?? null;
            return latestWithProof ?? sorted[0] ?? null;
          };

          const jobsWithVerification = page.map((jobItem) => {
            const artifactList = artifactsByJobId.get(String(jobItem.id)) ?? [];
            const statusArtifact = pickStatusArtifact({ artifacts: artifactList, job: jobItem });
            const fallbackArtifact = { artifactId: `status_${String(jobItem.id)}`, artifactType: "JobStatusInline.v1" };

            let verification;
            try {
              verification = computeArtifactVerificationStatus({ artifact: statusArtifact ?? fallbackArtifact, job: jobItem });
            } catch {
              verification = {
                verificationStatus: "amber",
                proofStatus: null,
                reasonCodes: [],
                missingEvidence: [],
                evidenceCount: Array.isArray(jobItem?.evidence) ? jobItem.evidence.length : 0,
                activeEvidenceCount: Array.isArray(jobItem?.evidence)
                  ? jobItem.evidence.filter((item) => !item?.expiredAt || String(item.expiredAt).trim() === "").length
                  : 0,
                slaCompliancePct: null,
                metrics: {
                  requiredZones: null,
                  reportedZones: null,
                  excusedZones: null,
                  belowThresholdZones: null,
                  missingZoneCount: 0
                }
              };
            }

            return {
              ...jobItem,
              verificationStatus: verification.verificationStatus,
              evidenceCount: verification.evidenceCount,
              activeEvidenceCount: verification.activeEvidenceCount,
              slaCompliancePct: verification.slaCompliancePct,
              verification
            };
          });

          return sendJson(res, 200, { jobs: jobsWithVerification, total: jobs.length, offset: safeOffset, limit: safeLimit });
        }

        if (parts[1] === "robots" && parts.length === 2 && req.method === "GET") {
          if (!requireScope(auth.scopes, OPS_SCOPES.OPS_READ)) return sendError(res, 403, "forbidden");
          const zoneRaw = url.searchParams.get("zoneId");
          const zoneId = zoneRaw ? normalizeZoneId(zoneRaw) : null;
          const status = url.searchParams.get("status");
          const quarantinedOnly = url.searchParams.get("quarantined") === "1";

          let robots = listRobots({ tenantId });
          if (zoneId) robots = robots.filter((r) => normalizeZoneId(r?.currentZoneId ?? r?.homeZoneId) === zoneId);
          if (status) robots = robots.filter((r) => r?.status === status);
          if (quarantinedOnly) robots = robots.filter((r) => r?.status === "quarantined");

          robots.sort((a, b) => String(a?.id ?? "").localeCompare(String(b?.id ?? "")));
          return sendJson(res, 200, { robots });
        }

        if (parts[1] === "operators" && parts.length === 2 && req.method === "GET") {
          if (!requireScope(auth.scopes, OPS_SCOPES.OPS_READ)) return sendError(res, 403, "forbidden");
          const zoneRaw = url.searchParams.get("zoneId");
          const zoneId = zoneRaw ? normalizeZoneId(zoneRaw) : null;
          const shiftStatus = url.searchParams.get("shiftStatus");

          let operators = listOperators({ tenantId });
          if (zoneId) operators = operators.filter((o) => normalizeZoneId(o?.shift?.zoneId) === zoneId);
          if (shiftStatus) operators = operators.filter((o) => o?.shift?.status === shiftStatus);

          operators.sort((a, b) => String(a?.id ?? "").localeCompare(String(b?.id ?? "")));
          return sendJson(res, 200, { operators });
        }

        if (parts[1] === "operator-queue" && parts.length === 2 && req.method === "GET") {
          if (!requireScope(auth.scopes, OPS_SCOPES.OPS_READ)) return sendError(res, 403, "forbidden");
          const items = [];
          for (const job of listJobs({ tenantId })) {
            const status = job.assist?.status ?? "none";
            if (status !== "requested" && status !== "queued" && status !== "assigned" && status !== "accepted" && status !== "timeout") continue;
            items.push({
              jobId: job.id,
              jobStatus: job.status,
              zoneId: normalizeZoneId(job.booking?.zoneId ?? job.constraints?.zoneId),
              assist: job.assist
            });
          }
          items.sort((a, b) => String(a.jobId).localeCompare(String(b.jobId)));
          return sendJson(res, 200, { queue: items });
        }

        if (parts[1] === "arbitration" && parts[2] === "queue" && parts.length === 3 && req.method === "GET") {
          const hasScope =
            requireScope(auth.scopes, OPS_SCOPES.FINANCE_READ) ||
            requireScope(auth.scopes, OPS_SCOPES.FINANCE_WRITE) ||
            requireScope(auth.scopes, OPS_SCOPES.OPS_READ);
          if (!hasScope) return sendError(res, 403, "forbidden");

          let statusFilter = null;
          let openedSince = null;
          let runIdFilter = null;
          let caseIdFilter = null;
          let priorityFilter = null;
          let assignedArbiterFilter = null;
          let slaHours = 24;
          try {
            const statusRaw = url.searchParams.get("status");
            statusFilter = statusRaw && statusRaw.trim() !== "" ? statusRaw.trim().toLowerCase() : null;
            const openedSinceRaw = url.searchParams.get("openedSince");
            if (openedSinceRaw !== null && openedSinceRaw !== undefined && String(openedSinceRaw).trim() !== "") {
              const parsedOpenedSince = normalizeBillingTimestampInput(openedSinceRaw);
              if (!parsedOpenedSince) throw new TypeError("openedSince must be an ISO date-time");
              openedSince = parsedOpenedSince;
            }
            const runIdRaw = url.searchParams.get("runId");
            runIdFilter = runIdRaw && runIdRaw.trim() !== "" ? runIdRaw.trim() : null;
            const caseIdRaw = url.searchParams.get("caseId");
            caseIdFilter = caseIdRaw && caseIdRaw.trim() !== "" ? caseIdRaw.trim() : null;
            const priorityRaw = url.searchParams.get("priority");
            priorityFilter = normalizeArbitrationCasePriority(priorityRaw, {
              fieldName: "priority",
              allowNull: true
            });
            if (url.searchParams.has("assignedArbiter")) {
              assignedArbiterFilter = parseBooleanQueryValue(url.searchParams.get("assignedArbiter"), {
                name: "assignedArbiter"
              });
            }
            const slaHoursRaw = url.searchParams.get("slaHours");
            if (slaHoursRaw !== null && slaHoursRaw !== undefined && String(slaHoursRaw).trim() !== "") {
              const parsedSlaHours = Number(slaHoursRaw);
              if (!Number.isFinite(parsedSlaHours) || parsedSlaHours <= 0 || parsedSlaHours > 24 * 365) {
                throw new TypeError("slaHours must be a positive number <= 8760");
              }
              slaHours = parsedSlaHours;
            }
          } catch (err) {
            return sendError(res, 400, "invalid arbitration queue query", { message: err?.message });
          }

          let allCases = [];
          try {
            allCases = await listArbitrationCaseRecordsAll({
              tenantId,
              runId: runIdFilter,
              status: statusFilter,
              pageSize: 500
            });
          } catch (err) {
            return sendError(res, 501, "arbitration cases not supported for this store", { message: err?.message });
          }

          const openedSinceMs = openedSince ? Date.parse(openedSince) : Number.NaN;
          const nowMs = Date.parse(nowIso());
          const filtered = [];
          const statusCounts = new Map();
          const settlementPriorityByRunId = new Map();
          let overSlaCount = 0;

          for (const arbitrationCase of allCases) {
            if (!arbitrationCase || typeof arbitrationCase !== "object") continue;
            if (caseIdFilter && String(arbitrationCase.caseId ?? "") !== caseIdFilter) continue;
            if (runIdFilter && String(arbitrationCase.runId ?? "") !== runIdFilter) continue;
            if (statusFilter && String(arbitrationCase.status ?? "").toLowerCase() !== statusFilter) continue;
            const runId =
              typeof arbitrationCase.runId === "string" && arbitrationCase.runId.trim() !== ""
                ? arbitrationCase.runId.trim()
                : null;
            let disputePriority = normalizeArbitrationCasePriority(arbitrationCase?.priority, {
              fieldName: "arbitrationCase.priority",
              allowNull: true
            });
            if (!disputePriority && runId) {
              if (!settlementPriorityByRunId.has(runId)) {
                let priorityFromSettlement = null;
                try {
                  const settlement = await getAgentRunSettlementRecord({ tenantId, runId });
                  priorityFromSettlement = normalizeArbitrationCasePriority(settlement?.disputeContext?.priority, {
                    fieldName: "settlement.disputeContext.priority",
                    allowNull: true
                  });
                } catch {
                  priorityFromSettlement = null;
                }
                settlementPriorityByRunId.set(runId, priorityFromSettlement);
              }
              disputePriority = settlementPriorityByRunId.get(runId) ?? null;
            }
            if (priorityFilter && disputePriority !== priorityFilter) continue;
            const disputeId = typeof arbitrationCase.disputeId === "string" && arbitrationCase.disputeId.trim() !== "" ? arbitrationCase.disputeId.trim() : null;
            const arbiterAgentId =
              typeof arbitrationCase.arbiterAgentId === "string" && arbitrationCase.arbiterAgentId.trim() !== ""
                ? arbitrationCase.arbiterAgentId.trim()
                : null;
            if (assignedArbiterFilter === true && !arbiterAgentId) continue;
            if (assignedArbiterFilter === false && arbiterAgentId) continue;

            const openedAt = typeof arbitrationCase.openedAt === "string" && arbitrationCase.openedAt.trim() !== "" ? arbitrationCase.openedAt : null;
            const openedAtMs = openedAt && Number.isFinite(Date.parse(openedAt)) ? Date.parse(openedAt) : Number.NaN;
            if (Number.isFinite(openedSinceMs) && (!Number.isFinite(openedAtMs) || openedAtMs < openedSinceMs)) continue;
            const ageSeconds = Number.isFinite(openedAtMs) ? Math.max(0, Math.floor((nowMs - openedAtMs) / 1000)) : null;
            const ageHours = ageSeconds === null ? null : Number((ageSeconds / 3600).toFixed(2));
            const dueAtMs = Number.isFinite(openedAtMs) ? openedAtMs + Math.round(slaHours * 3600 * 1000) : Number.NaN;
            const dueAt = Number.isFinite(dueAtMs) ? new Date(dueAtMs).toISOString() : null;
            const statusValue = String(arbitrationCase.status ?? "").toLowerCase();
            const overSla = statusValue !== ARBITRATION_CASE_STATUS.CLOSED && Number.isFinite(dueAtMs) && nowMs > dueAtMs;
            if (overSla) overSlaCount += 1;
            statusCounts.set(statusValue || "unknown", (statusCounts.get(statusValue || "unknown") ?? 0) + 1);

            filtered.push({
              caseId: arbitrationCase.caseId ?? null,
              runId,
              disputeId,
              settlementId: arbitrationCase.settlementId ?? null,
              priority: disputePriority,
              status: arbitrationCase.status ?? null,
              arbiterAgentId,
              openedAt,
              closedAt: arbitrationCase.closedAt ?? null,
              ageSeconds,
              ageHours,
              slaHours,
              dueAt,
              overSla,
              summary: arbitrationCase.summary ?? null,
              evidenceCount: Array.isArray(arbitrationCase.evidenceRefs) ? arbitrationCase.evidenceRefs.length : 0,
              appealRef: arbitrationCase.appealRef ?? null,
              revision: arbitrationCase.revision ?? null,
              updatedAt: arbitrationCase.updatedAt ?? null
            });
          }

          filtered.sort((left, right) => {
            if (left.overSla !== right.overSla) return left.overSla ? -1 : 1;
            const leftOpenedMs = left.openedAt && Number.isFinite(Date.parse(left.openedAt)) ? Date.parse(left.openedAt) : Number.POSITIVE_INFINITY;
            const rightOpenedMs = right.openedAt && Number.isFinite(Date.parse(right.openedAt)) ? Date.parse(right.openedAt) : Number.POSITIVE_INFINITY;
            if (leftOpenedMs !== rightOpenedMs) return leftOpenedMs - rightOpenedMs;
            return String(left.caseId ?? "").localeCompare(String(right.caseId ?? ""));
          });

          const { limit, offset } = parsePagination({
            limitRaw: url.searchParams.get("limit"),
            offsetRaw: url.searchParams.get("offset"),
            defaultLimit: 50,
            maxLimit: 500
          });
          const page = filtered.slice(offset, offset + limit);

          return sendJson(res, 200, {
            tenantId,
            filters: {
              status: statusFilter,
              openedSince,
              runId: runIdFilter,
              caseId: caseIdFilter,
              priority: priorityFilter,
              assignedArbiter: assignedArbiterFilter,
              slaHours
            },
            count: filtered.length,
            limit,
            offset,
            overSlaCount,
            statusCounts: Object.fromEntries([...statusCounts.entries()].sort((a, b) => String(a[0]).localeCompare(String(b[0])))),
            queue: page
          });
        }

        if (parts[1] === "arbitration" && parts[2] === "cases" && parts[3] && parts[4] === "workspace" && parts.length === 5 && req.method === "GET") {
          const hasReadScope =
            requireScope(auth.scopes, OPS_SCOPES.FINANCE_READ) ||
            requireScope(auth.scopes, OPS_SCOPES.FINANCE_WRITE) ||
            requireScope(auth.scopes, OPS_SCOPES.OPS_READ);
          if (!hasReadScope) return sendError(res, 403, "forbidden");

          const caseId = String(parts[3] ?? "").trim();
          if (!caseId) return sendError(res, 400, "caseId is required");

          let slaHours = 24;
          try {
            const slaHoursRaw = url.searchParams.get("slaHours");
            if (slaHoursRaw !== null && slaHoursRaw !== undefined && String(slaHoursRaw).trim() !== "") {
              const parsedSlaHours = Number(slaHoursRaw);
              if (!Number.isFinite(parsedSlaHours) || parsedSlaHours <= 0 || parsedSlaHours > 24 * 365) {
                throw new TypeError("slaHours must be a positive number <= 8760");
              }
              slaHours = parsedSlaHours;
            }
          } catch (err) {
            return sendError(res, 400, "invalid arbitration workspace query", { message: err?.message });
          }

          let arbitrationCase = null;
          try {
            arbitrationCase = await getArbitrationCaseRecord({ tenantId, caseId });
          } catch (err) {
            return sendError(res, 501, "arbitration cases not supported for this store", { message: err?.message });
          }
          if (!arbitrationCase) return sendError(res, 404, "arbitration case not found");

          const runId = typeof arbitrationCase.runId === "string" && arbitrationCase.runId.trim() !== "" ? arbitrationCase.runId.trim() : null;
          if (!runId) return sendError(res, 409, "arbitration case missing runId");

          let settlement = null;
          try {
            settlement = await getAgentRunSettlementRecord({ tenantId, runId });
          } catch (err) {
            return sendError(res, 501, "agent run settlements not supported for this store", { message: err?.message });
          }
          if (!settlement) return sendError(res, 404, "run settlement not found");

          const hasWriteScope = requireScope(auth.scopes, OPS_SCOPES.FINANCE_WRITE) || requireScope(auth.scopes, OPS_SCOPES.OPS_WRITE);
          const nowMs = Date.parse(nowIso());
          const openedAt = typeof arbitrationCase.openedAt === "string" && arbitrationCase.openedAt.trim() !== "" ? arbitrationCase.openedAt : null;
          const openedAtMs = openedAt && Number.isFinite(Date.parse(openedAt)) ? Date.parse(openedAt) : Number.NaN;
          const ageSeconds = Number.isFinite(openedAtMs) && Number.isFinite(nowMs) ? Math.max(0, Math.floor((nowMs - openedAtMs) / 1000)) : null;
          const ageHours = ageSeconds === null ? null : Number((ageSeconds / 3600).toFixed(2));
          const dueAtMs = Number.isFinite(openedAtMs) ? openedAtMs + Math.round(slaHours * 3600 * 1000) : Number.NaN;
          const dueAt = Number.isFinite(dueAtMs) ? new Date(dueAtMs).toISOString() : null;
          const normalizedCaseStatus = normalizeArbitrationCaseStatus(arbitrationCase.status, { fieldName: "arbitrationCase.status" });
          const overSla = normalizedCaseStatus !== ARBITRATION_CASE_STATUS.CLOSED && Number.isFinite(dueAtMs) && nowMs > dueAtMs;
          const casePriority =
            normalizeArbitrationCasePriority(arbitrationCase?.priority, {
              fieldName: "arbitrationCase.priority",
              allowNull: true
            }) ??
            normalizeArbitrationCasePriority(settlement?.disputeContext?.priority, {
              fieldName: "settlement.disputeContext.priority",
              allowNull: true
            }) ??
            null;

          let run = null;
          let runVerification = null;
          let recentRunEvents = [];
          try {
            if (typeof store.getAgentRun === "function") {
              run = await store.getAgentRun({ tenantId, runId });
            } else if (store.agentRuns instanceof Map) {
              run = store.agentRuns.get(runStoreKey(tenantId, runId)) ?? null;
            }
            let runEvents = [];
            if (typeof store.getAgentRunEvents === "function") {
              runEvents = await store.getAgentRunEvents({ tenantId, runId });
            } else if (store.agentRunEvents instanceof Map) {
              runEvents = store.agentRunEvents.get(runStoreKey(tenantId, runId)) ?? [];
            }
            runEvents = normalizeAgentRunEventRecords(runEvents);
            if (run) {
              runVerification = computeAgentRunVerification({ run, events: runEvents });
            }
            recentRunEvents = runEvents.slice(-25).map((event) =>
              normalizeForCanonicalJson(
                {
                  id: event?.id ?? null,
                  type: event?.type ?? null,
                  at: event?.at ?? null,
                  actor: event?.actor ?? null
                },
                { path: "$" }
              )
            );
          } catch {
            run = null;
            runVerification = null;
            recentRunEvents = [];
          }

          const caseEvidenceRefs = Array.isArray(arbitrationCase?.evidenceRefs) ? arbitrationCase.evidenceRefs : [];
          const disputeContextEvidenceRefs = Array.isArray(settlement?.disputeContext?.evidenceRefs) ? settlement.disputeContext.evidenceRefs : [];
          const disputeResolutionEvidenceRefs = Array.isArray(settlement?.disputeResolution?.evidenceRefs)
            ? settlement.disputeResolution.evidenceRefs
            : [];
          const evidenceRefs = {
            case: caseEvidenceRefs,
            disputeContext: disputeContextEvidenceRefs,
            disputeResolution: disputeResolutionEvidenceRefs,
            all: mergeUniqueStringArrays(caseEvidenceRefs, disputeContextEvidenceRefs, disputeResolutionEvidenceRefs)
          };

          const relatedCases = [];
          try {
            const listed = await listArbitrationCaseRecords({
              tenantId,
              runId,
              disputeId: arbitrationCase.disputeId ?? null,
              status: null,
              limit: 500,
              offset: 0
            });
            for (const row of listed) {
              if (!row || typeof row !== "object") continue;
              const rowOpenedAt = typeof row.openedAt === "string" && row.openedAt.trim() !== "" ? row.openedAt : null;
              const rowOpenedAtMs = rowOpenedAt && Number.isFinite(Date.parse(rowOpenedAt)) ? Date.parse(rowOpenedAt) : Number.NaN;
              const rowDueAtMs = Number.isFinite(rowOpenedAtMs) ? rowOpenedAtMs + Math.round(slaHours * 3600 * 1000) : Number.NaN;
              relatedCases.push(
                normalizeForCanonicalJson(
                  {
                    caseId: row.caseId ?? null,
                    runId: row.runId ?? null,
                    disputeId: row.disputeId ?? null,
                    priority:
                      normalizeArbitrationCasePriority(row?.priority, { fieldName: "arbitrationCase.priority", allowNull: true }) ?? null,
                    status: row.status ?? null,
                    arbiterAgentId: row.arbiterAgentId ?? null,
                    openedAt: rowOpenedAt,
	                    closedAt: row.closedAt ?? null,
	                    appealRef: row.appealRef ?? null,
	                    dueAt: Number.isFinite(rowDueAtMs) ? new Date(rowDueAtMs).toISOString() : null,
	                    overSla:
	                      normalizeArbitrationCaseStatus(row.status ?? ARBITRATION_CASE_STATUS.OPEN, {
                        fieldName: "arbitrationCase.status"
                      }) !== ARBITRATION_CASE_STATUS.CLOSED &&
                      Number.isFinite(rowDueAtMs) &&
                      Number.isFinite(nowMs) &&
                      nowMs > rowDueAtMs,
                    revision: Number.isSafeInteger(Number(row.revision)) ? Number(row.revision) : null,
                    updatedAt: row.updatedAt ?? null
                  },
                  { path: "$" }
                )
              );
            }
            relatedCases.sort((left, right) => {
              const leftOpenedAtMs =
                typeof left?.openedAt === "string" && Number.isFinite(Date.parse(left.openedAt))
                  ? Date.parse(left.openedAt)
                  : Number.POSITIVE_INFINITY;
              const rightOpenedAtMs =
                typeof right?.openedAt === "string" && Number.isFinite(Date.parse(right.openedAt))
                  ? Date.parse(right.openedAt)
                  : Number.POSITIVE_INFINITY;
              if (leftOpenedAtMs !== rightOpenedAtMs) return leftOpenedAtMs - rightOpenedAtMs;
              return String(left?.caseId ?? "").localeCompare(String(right?.caseId ?? ""));
            });
          } catch {
            // Related case listing is best-effort.
          }

          const timeline = [];
          const pushTimeline = (eventType, at, details = null, source = null) => {
            if (typeof at !== "string" || !Number.isFinite(Date.parse(at))) return;
            timeline.push(
              normalizeForCanonicalJson(
                {
                  eventType: String(eventType),
                  at: String(at),
                  source: source ?? null,
                  details: details ?? null
                },
                { path: "$" }
              )
            );
          };
          pushTimeline(
            "dispute.opened",
            settlement?.disputeOpenedAt ?? null,
            {
              disputeId: settlement?.disputeId ?? null,
              openedByAgentId: settlement?.disputeContext?.openedByAgentId ?? null,
              priority: settlement?.disputeContext?.priority ?? null,
              channel: settlement?.disputeContext?.channel ?? null,
              escalationLevel: settlement?.disputeContext?.escalationLevel ?? null
            },
            "settlement"
          );
          pushTimeline(
            "arbitration.opened",
            arbitrationCase?.openedAt ?? null,
            {
              caseId: arbitrationCase?.caseId ?? null,
              arbiterAgentId: arbitrationCase?.arbiterAgentId ?? null
            },
            "arbitration_case"
          );
          pushTimeline(
            "arbitration.verdict_issued",
            arbitrationCase?.metadata?.verdictIssuedAt ?? null,
            {
              verdictId: arbitrationCase?.verdictId ?? null,
              verdictHash: arbitrationCase?.verdictHash ?? null,
              outcome: arbitrationCase?.metadata?.verdictOutcome ?? null,
              releaseRatePct: arbitrationCase?.metadata?.verdictReleaseRatePct ?? null
            },
            "arbitration_case"
          );
          pushTimeline(
            "dispute.closed",
            settlement?.disputeClosedAt ?? null,
            {
              outcome: settlement?.disputeResolution?.outcome ?? null,
              escalationLevel: settlement?.disputeResolution?.escalationLevel ?? null,
              closedByAgentId: settlement?.disputeResolution?.closedByAgentId ?? null
            },
            "settlement"
          );
          pushTimeline(
            "arbitration.closed",
            arbitrationCase?.closedAt ?? null,
            {
              caseId: arbitrationCase?.caseId ?? null
            },
            "arbitration_case"
          );
          pushTimeline(
            "settlement.resolved",
            settlement?.resolvedAt ?? null,
            {
              settlementStatus: settlement?.status ?? null,
              releaseRatePct: settlement?.releaseRatePct ?? null,
              releasedAmountCents: settlement?.releasedAmountCents ?? null,
              refundedAmountCents: settlement?.refundedAmountCents ?? null
            },
            "settlement"
          );
          const disputeWindowEndsAtMs = settlementDisputeWindowEndsAtMs(settlement);
          if (Number.isFinite(disputeWindowEndsAtMs)) {
            pushTimeline(
              "dispute.window_ends",
              new Date(disputeWindowEndsAtMs).toISOString(),
              {
                disputeWindowDays: settlement?.disputeWindowDays ?? null
              },
              "settlement"
            );
          }
          timeline.sort((left, right) => {
            const leftAtMs = Number.isFinite(Date.parse(String(left?.at ?? ""))) ? Date.parse(String(left?.at ?? "")) : Number.POSITIVE_INFINITY;
            const rightAtMs = Number.isFinite(Date.parse(String(right?.at ?? ""))) ? Date.parse(String(right?.at ?? "")) : Number.POSITIVE_INFINITY;
            if (leftAtMs !== rightAtMs) return leftAtMs - rightAtMs;
            return String(left?.eventType ?? "").localeCompare(String(right?.eventType ?? ""));
          });

          const queueItem = normalizeForCanonicalJson(
            {
              caseId: arbitrationCase.caseId ?? null,
              runId,
              disputeId: arbitrationCase.disputeId ?? null,
              settlementId: arbitrationCase.settlementId ?? null,
              priority: casePriority,
              status: arbitrationCase.status ?? null,
              arbiterAgentId: arbitrationCase.arbiterAgentId ?? null,
              openedAt,
              closedAt: arbitrationCase.closedAt ?? null,
              ageSeconds,
              ageHours,
              slaHours,
              dueAt,
              overSla,
              summary: arbitrationCase.summary ?? null,
              evidenceCount: caseEvidenceRefs.length,
              appealRef: arbitrationCase.appealRef ?? null,
              revision: arbitrationCase.revision ?? null,
              updatedAt: arbitrationCase.updatedAt ?? null
            },
            { path: "$" }
          );

          const disputeStatus = String(settlement?.disputeStatus ?? "").toLowerCase();
          const disputeIsOpen = disputeStatus === AGENT_RUN_SETTLEMENT_DISPUTE_STATUS.OPEN;
          const disputeWindowOpen = Number.isFinite(disputeWindowEndsAtMs) && Number.isFinite(nowMs) ? nowMs <= disputeWindowEndsAtMs : false;
          const canAssignArbiter = normalizedCaseStatus === ARBITRATION_CASE_STATUS.OPEN || normalizedCaseStatus === ARBITRATION_CASE_STATUS.UNDER_REVIEW;
          const canAddEvidence = normalizedCaseStatus === ARBITRATION_CASE_STATUS.OPEN || normalizedCaseStatus === ARBITRATION_CASE_STATUS.UNDER_REVIEW;
          const canSubmitVerdict =
            (normalizedCaseStatus === ARBITRATION_CASE_STATUS.OPEN || normalizedCaseStatus === ARBITRATION_CASE_STATUS.UNDER_REVIEW) &&
            disputeIsOpen &&
            disputeWindowOpen;
          const canCloseCase = normalizedCaseStatus === ARBITRATION_CASE_STATUS.VERDICT_ISSUED;
	          const canOpenAppeal =
	            (normalizedCaseStatus === ARBITRATION_CASE_STATUS.VERDICT_ISSUED || normalizedCaseStatus === ARBITRATION_CASE_STATUS.CLOSED) &&
	            disputeWindowOpen;
	          const normalizedRevision = Number(arbitrationCase?.revision);
	          const arbitrationCaseArtifactId =
	            Number.isSafeInteger(normalizedRevision) && normalizedRevision > 1
	              ? `arbitration_case_${String(caseId)}_r${normalizedRevision}`
	              : `arbitration_case_${String(caseId)}`;
	          const verdictId =
	            typeof arbitrationCase?.verdictId === "string" && arbitrationCase.verdictId.trim() !== ""
	              ? arbitrationCase.verdictId.trim()
	              : null;
	          const arbitrationVerdictArtifactId = verdictId ? `arbitration_verdict_${verdictId}` : null;
	          const currentMonth = (() => {
	            const atIso = Number.isFinite(nowMs) ? new Date(nowMs).toISOString() : nowIso();
	            return typeof atIso === "string" && atIso.length >= 7 ? atIso.slice(0, 7) : null;
	          })();
	          const appealParentCaseId =
	            typeof arbitrationCase?.appealRef?.parentCaseId === "string" && arbitrationCase.appealRef.parentCaseId.trim() !== ""
	              ? arbitrationCase.appealRef.parentCaseId.trim()
	              : null;
	          const appealChildCaseIds = relatedCases
	            .filter(
	              (row) =>
	                row &&
	                typeof row === "object" &&
	                typeof row?.appealRef?.parentCaseId === "string" &&
	                row.appealRef.parentCaseId === caseId &&
	                typeof row?.caseId === "string" &&
	                row.caseId !== caseId
	            )
	            .map((row) => row.caseId);
		          const links = normalizeForCanonicalJson(
		            {
		              runSettlement: `/runs/${encodeURIComponent(runId)}/settlement`,
		              runSettlementPolicyReplay: `/runs/${encodeURIComponent(runId)}/settlement/policy-replay`,
		              runSettlementReplayEvaluate: `/runs/${encodeURIComponent(runId)}/settlement/replay-evaluate`,
		              runArbitrationCases: `/runs/${encodeURIComponent(runId)}/arbitration/cases`,
		              selectedArbitrationCase: `/runs/${encodeURIComponent(runId)}/arbitration/cases/${encodeURIComponent(caseId)}`,
		              opsAudit: "/ops/audit?limit=200",
		              settlementsExportTemplate: currentMonth ? `/ops/settlements/export?month=${encodeURIComponent(currentMonth)}` : null,
		              arbitrationCaseArtifactStatus: `/artifacts/${encodeURIComponent(arbitrationCaseArtifactId)}/status`,
	              arbitrationVerdictArtifactStatus: arbitrationVerdictArtifactId
	                ? `/artifacts/${encodeURIComponent(arbitrationVerdictArtifactId)}/status`
	                : null
	            },
	            { path: "$" }
	          );
	          const appealChain = normalizeForCanonicalJson(
	            {
	              parentCaseId: appealParentCaseId,
	              childCaseIds: [...new Set(appealChildCaseIds)]
	            },
	            { path: "$" }
	          );

	          return sendJson(res, 200, {
	            tenantId,
            runId,
            caseId,
            slaHours,
            queueItem,
            arbitrationCase,
	            relatedCases,
	            appealChain,
	            settlement: buildSettlementResponseBody(settlement),
	            links,
	            run: run
	              ? {
	                  run,
                  verification: runVerification ?? null,
                  recentEvents: recentRunEvents
                }
              : null,
            actionability: {
              canWrite: hasWriteScope,
              canAssignArbiter: hasWriteScope && canAssignArbiter,
              canAddEvidence: hasWriteScope && canAddEvidence,
              canSubmitVerdict: hasWriteScope && canSubmitVerdict,
              canCloseCase: hasWriteScope && canCloseCase,
              canOpenAppeal: hasWriteScope && canOpenAppeal
            },
            timeline,
            evidenceRefs
          });
        }

        if (parts[1] === "notifications" && parts.length === 2 && req.method === "GET") {
          if (!requireScope(auth.scopes, OPS_SCOPES.OPS_READ)) return sendError(res, 403, "forbidden");
          if (typeof store.listNotifications !== "function") return sendError(res, 501, "notifications not supported for this store");

          const topic = url.searchParams.get("topic");
          const limitRaw = url.searchParams.get("limit");
          const offsetRaw = url.searchParams.get("offset");
          const limit = limitRaw ? Number(limitRaw) : 200;
          const offset = offsetRaw ? Number(offsetRaw) : 0;

          let notifications;
          try {
            notifications = await store.listNotifications({ tenantId, topic, limit, offset });
          } catch (err) {
            return sendError(res, 400, "invalid notifications query", { message: err?.message });
          }

          return sendJson(res, 200, { notifications });
        }

        if (parts[1] === "deliveries" && parts.length === 2 && req.method === "GET") {
          if (!requireScope(auth.scopes, OPS_SCOPES.OPS_READ)) return sendError(res, 403, "forbidden");
          if (typeof store.listDeliveries !== "function") return sendError(res, 501, "deliveries not supported for this store");

          const state = url.searchParams.get("state");
          const limitRaw = url.searchParams.get("limit");
          const offsetRaw = url.searchParams.get("offset");
          const limit = limitRaw ? Number(limitRaw) : 200;
          const offset = offsetRaw ? Number(offsetRaw) : 0;

          let deliveries;
          try {
            deliveries = await store.listDeliveries({ tenantId, state: state ?? null, limit, offset });
          } catch (err) {
            return sendError(res, 400, "invalid deliveries query", { message: err?.message });
          }

          return sendJson(res, 200, { deliveries });
        }

        if (parts[1] === "deliveries" && parts[2] && parts[3] === "requeue" && parts.length === 4 && req.method === "POST") {
          if (!requireScope(auth.scopes, OPS_SCOPES.OPS_WRITE)) return sendError(res, 403, "forbidden");
          const idRaw = parts[2];
          if (!idRaw) return sendError(res, 400, "delivery id is required");

          if (store.kind === "pg") {
            const id = Number(idRaw);
            if (!Number.isSafeInteger(id) || id <= 0) return sendError(res, 400, "invalid delivery id");
            if (typeof store.requeueDelivery !== "function") return sendError(res, 501, "requeue not supported");
            await store.requeueDelivery({
              tenantId,
              id,
              audit: makeOpsAudit({ action: "DELIVERY_REQUEUE", targetType: "delivery", targetId: String(id), details: null })
            });
            return sendJson(res, 200, { ok: true });
          }

          if (typeof store.requeueDelivery !== "function") return sendError(res, 501, "requeue not supported");
          const updated = await store.requeueDelivery({ tenantId, deliveryId: idRaw });
          if (!updated) return sendError(res, 404, "delivery not found");
          try {
            if (typeof store.appendOpsAudit === "function") {
              await store.appendOpsAudit({
                tenantId,
                audit: makeOpsAudit({ action: "DELIVERY_REQUEUE", targetType: "delivery", targetId: idRaw, details: null })
              });
            }
          } catch {}
          return sendJson(res, 200, { delivery: updated });
        }

        if (parts[1] === "dlq" && parts.length === 2 && req.method === "GET") {
          if (!requireScope(auth.scopes, OPS_SCOPES.OPS_READ)) return sendError(res, 403, "forbidden");
          const type = url.searchParams.get("type") ?? null;
          const limitRaw = url.searchParams.get("limit");
          const offsetRaw = url.searchParams.get("offset");
          const limit = limitRaw ? Number(limitRaw) : 200;
          const offset = offsetRaw ? Number(offsetRaw) : 0;

          const out = {};
          if (!type || type === "delivery") {
            if (typeof store.listDeliveries !== "function") return sendError(res, 501, "deliveries not supported for this store");
            const deliveries = await store.listDeliveries({ tenantId, state: "failed", limit, offset });
            out.deliveries = deliveries;
          }
          if (!type || type === "ingest") {
            if (typeof store.listIngestRecords !== "function") return sendError(res, 501, "ingest records not supported for this store");
            const ingest = await store.listIngestRecords({ tenantId, status: "rejected", limit, offset });
            out.ingest = ingest;
          }

          return sendJson(res, 200, out);
        }

        if (parts[1] === "dlq" && parts[2] === "deliveries" && parts[3] && parts[4] === "requeue" && parts.length === 5 && req.method === "POST") {
          if (!requireScope(auth.scopes, OPS_SCOPES.OPS_WRITE)) return sendError(res, 403, "forbidden");
          const idRaw = parts[3];
          if (!idRaw) return sendError(res, 400, "delivery id is required");
          // Alias to /ops/deliveries/:id/requeue.
          if (store.kind === "pg") {
            const id = Number(idRaw);
            if (!Number.isSafeInteger(id) || id <= 0) return sendError(res, 400, "invalid delivery id");
            if (typeof store.requeueDelivery !== "function") return sendError(res, 501, "requeue not supported");
            await store.requeueDelivery({
              tenantId,
              id,
              audit: makeOpsAudit({ action: "DELIVERY_REQUEUE", targetType: "delivery", targetId: String(id), details: { alias: true } })
            });
            return sendJson(res, 200, { ok: true });
          }
          if (typeof store.requeueDelivery !== "function") return sendError(res, 501, "requeue not supported");
          const updated = await store.requeueDelivery({ tenantId, deliveryId: idRaw });
          if (!updated) return sendError(res, 404, "delivery not found");
          try {
            if (typeof store.appendOpsAudit === "function") {
              await store.appendOpsAudit({
                tenantId,
                audit: makeOpsAudit({ action: "DELIVERY_REQUEUE", targetType: "delivery", targetId: idRaw, details: { alias: true } })
              });
            }
          } catch {}
          return sendJson(res, 200, { delivery: updated });
        }

        if (parts[1] === "correlations" && parts.length === 2 && req.method === "GET") {
          if (!requireScope(auth.scopes, OPS_SCOPES.OPS_READ)) return sendError(res, 403, "forbidden");
          if (typeof store.listCorrelations !== "function") return sendError(res, 501, "correlations listing not supported for this store");
          const siteId = url.searchParams.get("siteId");
          const jobId = url.searchParams.get("jobId");
          const limitRaw = url.searchParams.get("limit");
          const offsetRaw = url.searchParams.get("offset");
          const limit = limitRaw ? Number(limitRaw) : 200;
          const offset = offsetRaw ? Number(offsetRaw) : 0;
          let correlations;
          try {
            correlations = await store.listCorrelations({ tenantId, siteId: siteId ?? null, jobId: jobId ?? null, limit, offset });
          } catch (err) {
            return sendError(res, 400, "invalid correlations query", { message: err?.message });
          }
          return sendJson(res, 200, { correlations });
        }

        if (parts[1] === "correlations" && parts[2] === "link" && parts.length === 3 && req.method === "POST") {
          if (!requireScope(auth.scopes, OPS_SCOPES.OPS_WRITE)) return sendError(res, 403, "forbidden");
          const body = await readJsonBody(req);
          const jobId = body?.jobId ? String(body.jobId) : null;
          const siteId = body?.siteId ? String(body.siteId) : null;
          const correlationKey = body?.correlationKey ? String(body.correlationKey) : null;
          const expiresAt = body?.expiresAt ?? null;
          const forceRelink = body?.forceRelink === true;
          if (!jobId || !siteId || !correlationKey) return sendError(res, 400, "jobId, siteId, and correlationKey are required");

          const existing = getJobEvents(tenantId, jobId);
          if (!existing.length) return sendError(res, 404, "job not found");
          const jobBefore = reduceJob(existing);
          if (!jobBefore) return sendError(res, 404, "job not found");

          let previousJobId = null;
          if (typeof store.lookupCorrelation === "function") {
            const current = await store.lookupCorrelation({ tenantId, siteId, correlationKey });
            if (current?.jobId && String(current.jobId) !== String(jobId)) {
              if (!forceRelink) return sendError(res, 409, "correlation key already linked", { existingJobId: current.jobId });
              previousJobId = String(current.jobId);
            }
          }

          const linkedAt = nowIso();
          const payload = { jobId, siteId, correlationKey, linkedAt, expiresAt, previousJobId: previousJobId ?? null, forceRelink };
          const draft = createChainedEvent({
            streamId: jobId,
            type: previousJobId ? "CORRELATION_RELINKED" : "CORRELATION_LINKED",
            at: linkedAt,
            actor: { type: "ops", id: principalId },
            payload
          });
          const nextEvents = appendChainedEvent({ events: existing, event: draft, signer: serverSigner });
          const event = nextEvents[nextEvents.length - 1];

          try {
            enforceSignaturePolicy({ tenantId, signerKind: requiredSignerKindForEventType(event.type), event });
          } catch (err) {
            return sendError(res, 400, "signature policy rejected", { message: err?.message });
          }

          try {
            reduceJob(nextEvents);
          } catch (err) {
            return sendError(res, 400, "job update rejected", { message: err?.message });
          }

          await commitTx([{ kind: "JOB_EVENTS_APPENDED", tenantId, jobId, events: [event] }]);

          // Update correlation index synchronously so ingest can use it immediately.
          try {
            if (typeof store.upsertCorrelation === "function") {
              await store.upsertCorrelation({ tenantId, siteId, correlationKey, jobId, expiresAt, force: forceRelink });
            }
          } catch (err) {
            return sendError(res, 409, "correlation apply failed", { message: err?.message, existingJobId: err?.existingJobId });
          }

          return sendJson(res, 201, { event });
        }

        if (parts[1] === "month-close" && parts.length === 2 && req.method === "GET") {
          if (!(requireScope(auth.scopes, OPS_SCOPES.FINANCE_READ) || requireScope(auth.scopes, OPS_SCOPES.FINANCE_WRITE))) {
            return sendError(res, 403, "forbidden");
          }
          const month = url.searchParams.get("month");
          if (!month) return sendError(res, 400, "month is required");
          const basis = url.searchParams.get("basis") ?? MONTH_CLOSE_BASIS.SETTLED_AT;
          let monthId;
          try {
            monthId = makeMonthCloseStreamId({ month, basis });
          } catch (err) {
            return sendError(res, 400, "invalid month close query", { message: err?.message });
          }

          const events = getMonthEvents(tenantId, monthId);
          if (!events.length) return sendError(res, 404, "month close not found");
          const monthClose = reduceMonthClose(events);
          if (!monthClose) return sendError(res, 404, "month close not found");

          let statementArtifact = null;
          if (monthClose.status === "CLOSED" && monthClose.statementArtifactId && typeof store.getArtifact === "function") {
            try {
              statementArtifact = await store.getArtifact({ tenantId, artifactId: monthClose.statementArtifactId });
            } catch {
              statementArtifact = null;
            }
          }

          return sendJson(res, 200, { monthClose, statementArtifact });
        }

        if (parts[1] === "month-close" && parts.length === 2 && req.method === "POST") {
          if (!requireScope(auth.scopes, OPS_SCOPES.FINANCE_WRITE)) return sendError(res, 403, "forbidden");
          const body = await readJsonBody(req);

          let idemStoreKey = null;
          let idemRequestHash = null;
          try {
            ({ idemStoreKey, idemRequestHash } = readIdempotency({ method: "POST", requestPath: path, expectedPrevChainHash: null, body }));
          } catch (err) {
            return sendError(res, 400, "invalid idempotency key", { message: err?.message });
          }
          if (idemStoreKey) {
            const existingIdem = store.idempotency.get(idemStoreKey);
            if (existingIdem) {
              if (existingIdem.requestHash !== idemRequestHash) {
                return sendError(res, 409, "idempotency key conflict", "request differs from initial use of this key");
              }
              return sendJson(res, existingIdem.statusCode, existingIdem.body);
            }
          }

          const month = body?.month ? String(body.month) : null;
          const basis = body?.basis ? String(body.basis) : MONTH_CLOSE_BASIS.SETTLED_AT;
          if (!month) return sendError(res, 400, "month is required");
          let monthId;
          try {
            monthId = makeMonthCloseStreamId({ month, basis });
          } catch (err) {
            return sendError(res, 400, "invalid month close request", { message: err?.message });
          }

          const existing = getMonthEvents(tenantId, monthId);
          const monthBefore = existing.length ? reduceMonthClose(existing) : null;
          if (monthBefore?.status === "CLOSED") {
            const responseBody = { monthClose: monthBefore };
            if (idemStoreKey) {
              await commitTx([{ kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode: 200, body: responseBody } }]);
            }
            return sendJson(res, 200, responseBody);
          }

          const pending = existing.length ? getPendingMonthCloseRequestEvent(existing) : null;
          if (pending) {
            // Ensure a worker sees the request even if the previous outbox message was lost.
            await commitTx([
              {
                kind: "OUTBOX_ENQUEUE",
                messages: [{ type: "MONTH_CLOSE_REQUESTED", tenantId, month, basis, monthId, sourceEventId: pending.id, at: pending.at ?? null }]
              }
            ]);
            const responseBody = { event: pending };
            if (idemStoreKey) {
              await commitTx([{ kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode: 202, body: responseBody } }]);
            }
            return sendJson(res, 202, responseBody);
          }

          const requestedAt = nowIso();
          const requestedPayload = { tenantId, month, basis, requestedAt };
          try {
            validateMonthCloseRequestedPayload(requestedPayload);
          } catch (err) {
            return sendError(res, 400, "invalid month close request", { message: err?.message });
          }

          const draft = createChainedEvent({
            streamId: monthId,
            type: "MONTH_CLOSE_REQUESTED",
            at: requestedAt,
            actor: { type: "ops", id: principalId },
            payload: requestedPayload
          });
          const nextEvents = appendChainedEvent({ events: existing, event: draft, signer: serverSigner });
          const event = nextEvents[nextEvents.length - 1];

          try {
            enforceSignaturePolicy({ tenantId, signerKind: requiredSignerKindForEventType(event.type), event });
          } catch (err) {
            return sendError(res, 400, "signature policy rejected", { message: err?.message });
          }

          const outboxMessages = [
            { type: "MONTH_CLOSE_REQUESTED", tenantId, month, basis, monthId, sourceEventId: event.id, at: requestedAt }
          ];

          const ops = [
            { kind: "MONTH_EVENTS_APPENDED", tenantId, monthId, events: [event] },
            { kind: "OUTBOX_ENQUEUE", messages: outboxMessages }
          ];
          if (idemStoreKey) {
            ops.push({ kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode: 202, body: { event } } });
          }

          await commitTx(ops);
          return sendJson(res, 202, { event });
        }

        if (parts[1] === "month-close" && parts[2] === "reopen" && parts.length === 3 && req.method === "POST") {
          if (!requireScope(auth.scopes, OPS_SCOPES.FINANCE_WRITE)) return sendError(res, 403, "forbidden");
          const body = await readJsonBody(req);
          const month = body?.month ? String(body.month) : null;
          const basis = body?.basis ? String(body.basis) : MONTH_CLOSE_BASIS.SETTLED_AT;
          const reason = body?.reason ?? null;
          if (!month) return sendError(res, 400, "month is required");
          let monthId;
          try {
            monthId = makeMonthCloseStreamId({ month, basis });
          } catch (err) {
            return sendError(res, 400, "invalid month close reopen request", { message: err?.message });
          }

          const existing = getMonthEvents(tenantId, monthId);
          if (!existing.length) return sendError(res, 404, "month close not found");
          const monthBefore = reduceMonthClose(existing);
          if (!monthBefore) return sendError(res, 404, "month close not found");
          if (monthBefore.status !== "CLOSED") return sendError(res, 409, "month is not closed");

          const reopenedAt = nowIso();
          const payload = { tenantId, month, basis, reopenedAt, reason };
          try {
            validateMonthCloseReopenedPayload(payload);
          } catch (err) {
            return sendError(res, 400, "invalid month close reopen request", { message: err?.message });
          }

          const draft = createChainedEvent({
            streamId: monthId,
            type: "MONTH_CLOSE_REOPENED",
            at: reopenedAt,
            actor: { type: "ops", id: principalId },
            payload
          });
          const nextEvents = appendChainedEvent({ events: existing, event: draft, signer: serverSigner });
          const event = nextEvents[nextEvents.length - 1];

          try {
            enforceSignaturePolicy({ tenantId, signerKind: requiredSignerKindForEventType(event.type), event });
          } catch (err) {
            return sendError(res, 400, "signature policy rejected", { message: err?.message });
          }

          await commitTx([{ kind: "MONTH_EVENTS_APPENDED", tenantId, monthId, events: [event] }]);
          return sendJson(res, 201, { event });
        }

        if (parts[1] === "governance" && parts[2] === "events" && parts.length === 3 && req.method === "GET") {
          const scope = url.searchParams.get("scope") ?? "tenant";
          if (scope === "global") {
            const ok =
              requireScope(auth.scopes, OPS_SCOPES.GOVERNANCE_GLOBAL_READ) ||
              requireScope(auth.scopes, OPS_SCOPES.GOVERNANCE_GLOBAL_WRITE) ||
              requireScope(auth.scopes, OPS_SCOPES.AUDIT_READ) ||
              requireScope(auth.scopes, OPS_SCOPES.OPS_WRITE);
            if (!ok) return sendError(res, 403, "forbidden");
          } else {
            const ok =
              requireScope(auth.scopes, OPS_SCOPES.GOVERNANCE_TENANT_READ) ||
              requireScope(auth.scopes, OPS_SCOPES.GOVERNANCE_TENANT_WRITE) ||
              requireScope(auth.scopes, OPS_SCOPES.FINANCE_READ) ||
              requireScope(auth.scopes, OPS_SCOPES.FINANCE_WRITE);
            if (!ok) return sendError(res, 403, "forbidden");
          }
          const targetTenantId = scope === "global" ? DEFAULT_TENANT_ID : tenantId;
          const events = getMonthEvents(targetTenantId, GOVERNANCE_STREAM_ID);
          return sendJson(res, 200, { tenantId: targetTenantId, streamId: GOVERNANCE_STREAM_ID, events });
        }

        if (parts[1] === "governance" && parts[2] === "events" && parts.length === 3 && req.method === "POST") {
          const body = await readJsonBody(req);
          const type = body?.type ? String(body.type) : null;
          if (!type) return sendError(res, 400, "type is required");
          const scope = body?.scope ? String(body.scope) : "tenant";
          if (scope === "global") {
            const ok = requireScope(auth.scopes, OPS_SCOPES.GOVERNANCE_GLOBAL_WRITE) || requireScope(auth.scopes, OPS_SCOPES.OPS_WRITE);
            if (!ok) return sendError(res, 403, "forbidden");
          } else {
            const ok = requireScope(auth.scopes, OPS_SCOPES.GOVERNANCE_TENANT_WRITE) || requireScope(auth.scopes, OPS_SCOPES.FINANCE_WRITE);
            if (!ok) return sendError(res, 403, "forbidden");
          }
          const targetTenantId = scope === "global" ? DEFAULT_TENANT_ID : tenantId;
          const nowAt = nowIso();

          // Scope guards:
          // - Server signer key lifecycle is global governance only.
          // - Tenant policy updates are tenant governance only.
          if (type.startsWith("SERVER_SIGNER_KEY_") && scope !== "global") {
            return sendError(res, 400, "invalid governance scope", null, { code: "GOVERNANCE_SCOPE_REQUIRED_GLOBAL" });
          }
          if (type === "TENANT_POLICY_UPDATED" && scope !== "tenant") {
            return sendError(res, 400, "invalid governance scope", null, { code: "GOVERNANCE_SCOPE_REQUIRED_TENANT" });
          }

          // Governance events must be written with an optimistic concurrency precondition to avoid forked streams.
          const existingForPrecondition = getMonthEvents(targetTenantId, GOVERNANCE_STREAM_ID);
          const currentPrevChainHash = getCurrentPrevChainHash(existingForPrecondition);
          const expectedHeader = parseExpectedPrevChainHashHeader(req);
          if (!expectedHeader.ok) return sendError(res, 428, "missing precondition", "x-proxy-expected-prev-chain-hash is required");
          if (expectedHeader.expectedPrevChainHash !== currentPrevChainHash) {
            return sendError(res, 409, "event append conflict", {
              expectedPrevChainHash: currentPrevChainHash,
              gotExpectedPrevChainHash: expectedHeader.expectedPrevChainHash
            });
          }

          // Governance writes must be idempotent.
          let idemStoreKey = null;
          let idemRequestHash = null;
          try {
            ({ idemStoreKey, idemRequestHash } = readIdempotency({
              method: "POST",
              requestPath: path,
              expectedPrevChainHash: expectedHeader.expectedPrevChainHash,
              body
            }));
          } catch (err) {
            return sendError(res, 400, "invalid idempotency key", { message: err?.message });
          }
          if (!idemStoreKey) return sendError(res, 400, "x-idempotency-key is required");
          {
            const existingIdem = store.idempotency.get(idemStoreKey);
            if (existingIdem) {
              if (existingIdem.requestHash !== idemRequestHash) {
                return sendError(res, 409, "idempotency key conflict", "request differs from initial use of this key");
              }
              return sendJson(res, existingIdem.statusCode, existingIdem.body);
            }
          }

          let payload;
          try {
            if (type === "TENANT_POLICY_UPDATED") {
              payload = validateTenantPolicyUpdatedPayload({
                tenantId: targetTenantId,
                policyId: createId("pol"),
                effectiveFrom: body?.payload?.effectiveFrom ? String(body.payload.effectiveFrom) : nowAt,
                updatedAt: nowAt,
                policy: body?.payload?.policy ?? {},
                reason: body?.payload?.reason ?? null
              });
            } else if (type === "SERVER_SIGNER_KEY_REGISTERED") {
              payload = validateServerSignerKeyRegisteredPayload({
                tenantId: targetTenantId,
                keyId: body?.payload?.keyId ? String(body.payload.keyId) : "",
                publicKeyPem: body?.payload?.publicKeyPem ? String(body.payload.publicKeyPem) : "",
                registeredAt: body?.payload?.registeredAt ? String(body.payload.registeredAt) : nowAt,
                reason: body?.payload?.reason ?? null
              });
            } else if (type === "SERVER_SIGNER_KEY_ROTATED") {
              payload = validateServerSignerKeyRotatedPayload({
                tenantId: targetTenantId,
                oldKeyId: body?.payload?.oldKeyId ? String(body.payload.oldKeyId) : "",
                newKeyId: body?.payload?.newKeyId ? String(body.payload.newKeyId) : "",
                newPublicKeyPem: body?.payload?.newPublicKeyPem ? String(body.payload.newPublicKeyPem) : "",
                rotatedAt: body?.payload?.rotatedAt ? String(body.payload.rotatedAt) : nowAt,
                reason: body?.payload?.reason ?? null
              });
            } else if (type === "SERVER_SIGNER_KEY_REVOKED") {
              payload = validateServerSignerKeyRevokedPayload({
                tenantId: targetTenantId,
                keyId: body?.payload?.keyId ? String(body.payload.keyId) : "",
                revokedAt: body?.payload?.revokedAt ? String(body.payload.revokedAt) : nowAt,
                reason: body?.payload?.reason ?? null
              });
            } else {
              return sendError(res, 400, "unsupported governance event type", null, { code: "UNSUPPORTED_EVENT_TYPE" });
            }
          } catch (err) {
            return sendError(res, 400, "invalid governance payload", { message: err?.message });
          }

          const existing = existingForPrecondition;

          // Governance semantic uniqueness:
          // For policy updates, enforce 1 update per effectiveFrom per scope.
          if (type === "TENANT_POLICY_UPDATED") {
            const effectiveFrom = typeof payload?.effectiveFrom === "string" && payload.effectiveFrom.trim() ? String(payload.effectiveFrom) : null;
            if (effectiveFrom) {
              const prior = existing.find((e) => e?.type === "TENANT_POLICY_UPDATED" && String(e?.payload?.effectiveFrom ?? "") === effectiveFrom) ?? null;
              if (prior) {
                const priorPolicy = prior?.payload?.policy ?? null;
                const nextPolicy = payload?.policy ?? null;
                const samePolicy = canonicalJsonStringify(priorPolicy ?? {}) === canonicalJsonStringify(nextPolicy ?? {});
                if (!samePolicy) {
                  return sendError(res, 409, "governance effectiveFrom conflict", { existingEventId: prior.id ?? null }, { code: "GOVERNANCE_EFFECTIVE_FROM_CONFLICT" });
                }
                const responseBody = { event: prior, alreadyExists: true };
                await commitTx([{ kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode: 200, body: responseBody } }]);
                return sendJson(res, 200, responseBody);
              }
            }
          }

          if (type === "SERVER_SIGNER_KEY_REGISTERED") {
            const keyId = typeof payload?.keyId === "string" ? String(payload.keyId) : null;
            if (keyId) {
              const prior =
                existing.find((e) => e?.type === "SERVER_SIGNER_KEY_REGISTERED" && String(e?.payload?.keyId ?? "") === keyId) ??
                existing.find((e) => e?.type === "SERVER_SIGNER_KEY_ROTATED" && String(e?.payload?.newKeyId ?? "") === keyId) ??
                null;
              if (prior) {
                const priorPem = prior?.payload?.publicKeyPem ?? prior?.payload?.newPublicKeyPem ?? null;
                const nextPem = payload?.publicKeyPem ?? null;
                const same = typeof priorPem === "string" && typeof nextPem === "string" && priorPem === nextPem;
                if (!same) {
                  return sendError(res, 409, "server signer key already exists", { existingEventId: prior.id ?? null, keyId }, { code: "GOVERNANCE_KEY_CONFLICT" });
                }
                const responseBody = { event: prior, alreadyExists: true };
                await commitTx([{ kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode: 200, body: responseBody } }]);
                return sendJson(res, 200, responseBody);
              }
            }
          }

          if (type === "SERVER_SIGNER_KEY_ROTATED") {
            const oldKeyId = typeof payload?.oldKeyId === "string" ? String(payload.oldKeyId) : null;
            const newKeyId = typeof payload?.newKeyId === "string" ? String(payload.newKeyId) : null;
            if (oldKeyId) {
              const prior = existing.find((e) => e?.type === "SERVER_SIGNER_KEY_ROTATED" && String(e?.payload?.oldKeyId ?? "") === oldKeyId) ?? null;
              if (prior) {
                const same =
                  String(prior?.payload?.newKeyId ?? "") === String(newKeyId ?? "") &&
                  String(prior?.payload?.rotatedAt ?? "") === String(payload?.rotatedAt ?? "") &&
                  String(prior?.payload?.newPublicKeyPem ?? "") === String(payload?.newPublicKeyPem ?? "");
                if (!same) {
                  return sendError(res, 409, "server signer key rotation conflict", { existingEventId: prior.id ?? null, oldKeyId }, { code: "GOVERNANCE_KEY_CONFLICT" });
                }
                const responseBody = { event: prior, alreadyExists: true };
                await commitTx([{ kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode: 200, body: responseBody } }]);
                return sendJson(res, 200, responseBody);
              }
            }
          }

          if (type === "SERVER_SIGNER_KEY_REVOKED") {
            const keyId = typeof payload?.keyId === "string" ? String(payload.keyId) : null;
            if (keyId) {
              const prior = existing.find((e) => e?.type === "SERVER_SIGNER_KEY_REVOKED" && String(e?.payload?.keyId ?? "") === keyId) ?? null;
              if (prior) {
                const same = String(prior?.payload?.revokedAt ?? "") === String(payload?.revokedAt ?? "");
                if (!same) {
                  return sendError(res, 409, "server signer key revocation conflict", { existingEventId: prior.id ?? null, keyId }, { code: "GOVERNANCE_KEY_CONFLICT" });
                }
                const responseBody = { event: prior, alreadyExists: true };
                await commitTx([{ kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode: 200, body: responseBody } }]);
                return sendJson(res, 200, responseBody);
              }
            }
          }

          const draft = createChainedEvent({
            streamId: GOVERNANCE_STREAM_ID,
            type,
            at: payload?.updatedAt ?? payload?.rotatedAt ?? payload?.revokedAt ?? payload?.registeredAt ?? nowAt,
            actor: { type: "finance", id: principalId },
            payload
          });
          const nextEvents = appendChainedEvent({ events: existing, event: draft, signer: serverSigner });
          const event = nextEvents[nextEvents.length - 1];

          try {
            enforceSignaturePolicy({ tenantId: targetTenantId, signerKind: requiredSignerKindForEventType(event.type), event });
          } catch (err) {
            return sendError(res, 400, "signature policy rejected", { message: err?.message });
          }

          const responseBody = { event };
          try {
            await commitTx([
              { kind: "MONTH_EVENTS_APPENDED", tenantId: targetTenantId, monthId: GOVERNANCE_STREAM_ID, events: [event] },
              { kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode: 201, body: responseBody } }
            ]);
            return sendJson(res, 201, responseBody);
          } catch (err) {
            // If we lost a race (prevChainHash mismatch) or hit a DB uniqueness constraint, re-load the latest
            // governance stream and apply semantic uniqueness rules (idempotent success vs typed conflict).
            const code = err?.code ?? null;
            if (code === "PREV_CHAIN_HASH_MISMATCH" || code === "23505") {
              let latest = null;
              try {
                if (typeof store.listAggregateEvents === "function") {
                  latest = await store.listAggregateEvents({ tenantId: targetTenantId, aggregateType: "month", aggregateId: GOVERNANCE_STREAM_ID });
                } else {
                  latest = getMonthEvents(targetTenantId, GOVERNANCE_STREAM_ID);
                }
              } catch {
                latest = null;
              }
              const stream = Array.isArray(latest) ? latest : existing;

              const respondAlreadyExists = async (priorEvent) => {
                const body = { event: priorEvent, alreadyExists: true };
                await commitTx([{ kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode: 200, body } }]);
                return sendJson(res, 200, body);
              };

              if (type === "TENANT_POLICY_UPDATED") {
                const effectiveFrom = typeof payload?.effectiveFrom === "string" && payload.effectiveFrom.trim() ? String(payload.effectiveFrom) : null;
                const prior = effectiveFrom
                  ? stream.find((e) => e?.type === "TENANT_POLICY_UPDATED" && String(e?.payload?.effectiveFrom ?? "") === effectiveFrom) ?? null
                  : null;
                if (prior) {
                  const priorPolicy = prior?.payload?.policy ?? null;
                  const nextPolicy = payload?.policy ?? null;
                  const samePolicy = canonicalJsonStringify(priorPolicy ?? {}) === canonicalJsonStringify(nextPolicy ?? {});
                  if (!samePolicy) {
                    return sendError(res, 409, "governance effectiveFrom conflict", { existingEventId: prior.id ?? null }, { code: "GOVERNANCE_EFFECTIVE_FROM_CONFLICT" });
                  }
                  return await respondAlreadyExists(prior);
                }
              }

              if (type === "SERVER_SIGNER_KEY_REGISTERED") {
                const keyId = typeof payload?.keyId === "string" ? String(payload.keyId) : null;
                const prior = keyId
                  ? stream.find((e) => e?.type === "SERVER_SIGNER_KEY_REGISTERED" && String(e?.payload?.keyId ?? "") === keyId) ??
                    stream.find((e) => e?.type === "SERVER_SIGNER_KEY_ROTATED" && String(e?.payload?.newKeyId ?? "") === keyId) ??
                    null
                  : null;
                if (prior) {
                  const priorPem = prior?.payload?.publicKeyPem ?? prior?.payload?.newPublicKeyPem ?? null;
                  const nextPem = payload?.publicKeyPem ?? null;
                  const same = typeof priorPem === "string" && typeof nextPem === "string" && priorPem === nextPem;
                  if (!same) {
                    return sendError(res, 409, "server signer key already exists", { existingEventId: prior.id ?? null, keyId }, { code: "GOVERNANCE_KEY_CONFLICT" });
                  }
                  return await respondAlreadyExists(prior);
                }
              }

              if (type === "SERVER_SIGNER_KEY_ROTATED") {
                const oldKeyId = typeof payload?.oldKeyId === "string" ? String(payload.oldKeyId) : null;
                const newKeyId = typeof payload?.newKeyId === "string" ? String(payload.newKeyId) : null;
                const prior = oldKeyId ? stream.find((e) => e?.type === "SERVER_SIGNER_KEY_ROTATED" && String(e?.payload?.oldKeyId ?? "") === oldKeyId) ?? null : null;
                if (prior) {
                  const same =
                    String(prior?.payload?.newKeyId ?? "") === String(newKeyId ?? "") &&
                    String(prior?.payload?.rotatedAt ?? "") === String(payload?.rotatedAt ?? "") &&
                    String(prior?.payload?.newPublicKeyPem ?? "") === String(payload?.newPublicKeyPem ?? "");
                  if (!same) {
                    return sendError(res, 409, "server signer key rotation conflict", { existingEventId: prior.id ?? null, oldKeyId }, { code: "GOVERNANCE_KEY_CONFLICT" });
                  }
                  return await respondAlreadyExists(prior);
                }
              }

              if (type === "SERVER_SIGNER_KEY_REVOKED") {
                const keyId = typeof payload?.keyId === "string" ? String(payload.keyId) : null;
                const prior = keyId ? stream.find((e) => e?.type === "SERVER_SIGNER_KEY_REVOKED" && String(e?.payload?.keyId ?? "") === keyId) ?? null : null;
                if (prior) {
                  const same = String(prior?.payload?.revokedAt ?? "") === String(payload?.revokedAt ?? "");
                  if (!same) {
                    return sendError(res, 409, "server signer key revocation conflict", { existingEventId: prior.id ?? null, keyId }, { code: "GOVERNANCE_KEY_CONFLICT" });
                  }
                  return await respondAlreadyExists(prior);
                }
              }

              // Fallback: preserve the original typed append conflict semantics.
              if (code === "PREV_CHAIN_HASH_MISMATCH") {
                return sendError(res, 409, "event append conflict", {
                  expectedPrevChainHash: err.expectedPrevChainHash ?? null,
                  gotPrevChainHash: err.gotPrevChainHash ?? null
                });
              }
            }

            throw err;
          }
        }

        if (parts[1] === "insurer-reimbursements" && parts.length === 2 && req.method === "POST") {
          if (!requireScope(auth.scopes, OPS_SCOPES.FINANCE_WRITE)) return sendError(res, 403, "forbidden");
          const body = await readJsonBody(req);

          let idemStoreKey = null;
          let idemRequestHash = null;
          try {
            ({ idemStoreKey, idemRequestHash } = readIdempotency({ method: "POST", requestPath: path, expectedPrevChainHash: null, body }));
          } catch (err) {
            return sendError(res, 400, "invalid idempotency key", { message: err?.message });
          }
          if (idemStoreKey) {
            const existingIdem = store.idempotency.get(idemStoreKey);
            if (existingIdem) {
              if (existingIdem.requestHash !== idemRequestHash) {
                return sendError(res, 409, "idempotency key conflict", "request differs from initial use of this key");
              }
              return sendJson(res, existingIdem.statusCode, existingIdem.body);
            }
          }

          const insurerId = body?.insurerId ? String(body.insurerId) : null;
          const month = body?.month ? String(body.month) : null;
          const amountCents = body?.amountCents;
          const reference = body?.reference ?? null;
          const recordedAt = body?.recordedAt ? String(body.recordedAt) : nowIso();

          const reimbursementPayload = {
            tenantId,
            reimbursementId: createId("reimb"),
            insurerId,
            amountCents,
            currency: "USD",
            month,
            recordedAt,
            reference
          };
          try {
            validateInsurerReimbursementRecordedPayload(reimbursementPayload);
          } catch (err) {
            return sendError(res, 400, "invalid reimbursement", { message: err?.message });
          }

          const financeStreamId = FINANCE_STREAM_ID;
          const existing = getMonthEvents(tenantId, financeStreamId);

          const draft = createChainedEvent({
            streamId: financeStreamId,
            type: "INSURER_REIMBURSEMENT_RECORDED",
            at: reimbursementPayload.recordedAt,
            actor: { type: "finance", id: principalId },
            payload: reimbursementPayload
          });
          const nextEvents = appendChainedEvent({ events: existing, event: draft, signer: serverSigner });
          const event = nextEvents[nextEvents.length - 1];

          try {
            enforceSignaturePolicy({ tenantId, signerKind: requiredSignerKindForEventType(event.type), event });
          } catch (err) {
            return sendError(res, 400, "signature policy rejected", { message: err?.message });
          }

          let ledgerEntries = [];
          try {
            ledgerEntries = ledgerEntriesForFinanceEvent({ event });
          } catch (err) {
            return sendError(res, 400, "ledger posting rejected", { message: err?.message });
          }

          const outboxMessages = [];
          for (const entry of ledgerEntries) {
            if (!entry) continue;
            outboxMessages.push({ type: "LEDGER_ENTRY_APPLY", tenantId, jobId: null, sourceEventId: event.id, entry });
          }

          const responseBody = { event, ledgerEntryIds: ledgerEntries.map((e) => e?.id).filter(Boolean) };

          const ops = [{ kind: "MONTH_EVENTS_APPENDED", tenantId, monthId: financeStreamId, events: [event] }];
          if (outboxMessages.length) ops.push({ kind: "OUTBOX_ENQUEUE", messages: outboxMessages });
          if (idemStoreKey) {
            ops.push({ kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode: 201, body: responseBody } });
          }

          await commitTx(ops);
          return sendJson(res, 201, responseBody);
        }

        if (parts[1] === "receivables" && parts.length === 2 && req.method === "GET") {
          if (!requireScope(auth.scopes, OPS_SCOPES.FINANCE_READ)) return sendError(res, 403, "forbidden");
          const month = url.searchParams.get("month");

          let asOf = nowIso();
          if (month) {
            try {
              const period = parseYearMonth(month);
              asOf = period.endAt;
            } catch (err) {
              return sendError(res, 400, "invalid month", { message: err?.message });
            }
          }
          const asOfMs = Date.parse(asOf);

          const byInsurer = new Map();
          const add = (insurerId, field, cents) => {
            if (!insurerId) return;
            if (!Number.isSafeInteger(cents) || cents === 0) return;
            const row = byInsurer.get(insurerId) ?? { insurerId, creditsRecoverableCents: 0, reimbursementsCents: 0, balanceCents: 0 };
            row[field] += cents;
            byInsurer.set(insurerId, row);
          };

          for (const jobSnap of listJobs({ tenantId })) {
            if (!jobSnap?.id) continue;
            const coveragePolicy = jobSnap.booking?.policySnapshot?.coveragePolicy ?? null;
            if (coveragePolicy?.creditFundingModel !== CREDIT_FUNDING_MODEL.INSURER_RECOVERABLE) continue;
            const insurerId = typeof coveragePolicy?.insurerId === "string" && coveragePolicy.insurerId.trim() !== "" ? coveragePolicy.insurerId : null;
            if (!insurerId) continue;

            const pctRaw = coveragePolicy?.recoverablePercent ?? 100;
            const recoverablePercent = Number.isSafeInteger(pctRaw) ? Math.max(0, Math.min(100, pctRaw)) : 100;

            const events = getJobEvents(tenantId, jobSnap.id);
            for (const e of events) {
              if (e?.type !== "SLA_CREDIT_ISSUED") continue;
              const t = Date.parse(e.at);
              if (Number.isFinite(asOfMs) && Number.isFinite(t) && t >= asOfMs) continue;
              const amountCents = e.payload?.amountCents ?? null;
              if (!Number.isSafeInteger(amountCents) || amountCents <= 0) continue;
              const recoverableCents = Math.floor((amountCents * recoverablePercent) / 100);
              add(insurerId, "creditsRecoverableCents", recoverableCents);
            }
          }

          const financeEvents = getMonthEvents(tenantId, FINANCE_STREAM_ID);
          for (const e of financeEvents) {
            if (e?.type !== "INSURER_REIMBURSEMENT_RECORDED") continue;
            const t = Date.parse(e.at);
            if (Number.isFinite(asOfMs) && Number.isFinite(t) && t >= asOfMs) continue;
            const insurerId = typeof e.payload?.insurerId === "string" && e.payload.insurerId.trim() !== "" ? e.payload.insurerId : null;
            const amountCents = e.payload?.amountCents ?? null;
            if (!insurerId || !Number.isSafeInteger(amountCents) || amountCents <= 0) continue;
            add(insurerId, "reimbursementsCents", amountCents);
          }

          const receivables = Array.from(byInsurer.values())
            .map((r) => ({
              ...r,
              balanceCents: r.creditsRecoverableCents - r.reimbursementsCents
            }))
            .sort((a, b) => String(a.insurerId).localeCompare(String(b.insurerId)));

          const totalBalanceCents = receivables.reduce((sum, r) => sum + (Number.isSafeInteger(r.balanceCents) ? r.balanceCents : 0), 0);

          return sendJson(res, 200, { month: month ?? null, asOf, receivables, totalBalanceCents });
        }

	        if (parts[1] === "statements" && parts.length === 2 && req.method === "GET") {
          if (!(requireScope(auth.scopes, OPS_SCOPES.OPS_READ) || requireScope(auth.scopes, OPS_SCOPES.FINANCE_READ))) {
            return sendError(res, 403, "forbidden");
          }
          const customerId = url.searchParams.get("customerId");
          const siteId = url.searchParams.get("siteId");
          const month = url.searchParams.get("month");
          if (!month) return sendError(res, 400, "month is required");
          const format = url.searchParams.get("format") ?? "json";

          let statement;
          try {
            if ((customerId === null || customerId === "") && (siteId === null || siteId === "") && store.months instanceof Map && typeof store.getArtifact === "function") {
              const monthId = makeMonthCloseStreamId({ month, basis: MONTH_CLOSE_BASIS.SETTLED_AT });
              const snap = store.months.get(monthStoreKey(tenantId, monthId)) ?? null;
              if (snap?.status === "CLOSED" && snap.statementArtifactId) {
                const art = await store.getArtifact({ tenantId, artifactId: snap.statementArtifactId });
                if (art?.statement) statement = art.statement;
              }
            }
          } catch {
            statement = null;
          }
          if (!statement) try {
            let ledgerEntries = [];
            try {
              ledgerEntries = await listAllLedgerEntriesForTenant({ tenantId });
            } catch {
              ledgerEntries = [];
            }
            statement = computeMonthlyStatement({
              tenantId,
              customerId: customerId ?? null,
              siteId: siteId ?? null,
              month,
              jobs: listJobs({ tenantId }),
              getEventsForJob: (jobId) => getJobEvents(tenantId, jobId),
              ledgerEntries,
              nowIso
            });
          } catch (err) {
            return sendError(res, 400, "invalid statement query", { message: err?.message });
          }

          if (format === "csv") {
            const csv = statementToCsv(statement);
            res.statusCode = 200;
            res.setHeader("content-type", "text/csv; charset=utf-8");
            res.end(csv);
            return;
          }

          if (format && format !== "json") return sendError(res, 400, "unsupported format");
	          return sendJson(res, 200, { statement });
	        }

		        if (parts[1] === "holds" && parts.length === 2 && req.method === "GET") {
		          if (!(requireScope(auth.scopes, OPS_SCOPES.OPS_READ) || requireScope(auth.scopes, OPS_SCOPES.FINANCE_READ))) {
		            return sendError(res, 403, "forbidden");
		          }

		          const status = (url.searchParams.get("status") ?? "HELD").toUpperCase();
		          const minAgeSeconds = url.searchParams.get("minAgeSeconds");
		          const limitRaw = url.searchParams.get("limit");
		          const offsetRaw = url.searchParams.get("offset");
		          const customerId = url.searchParams.get("customerId");
		          const siteId = url.searchParams.get("siteId");
		          const robotId = url.searchParams.get("robotId");
		          const operatorId = url.searchParams.get("operatorId");
		          const reasonCode = url.searchParams.get("reasonCode");

		          const minAge = minAgeSeconds !== null && minAgeSeconds !== "" ? Number(minAgeSeconds) : null;
		          if (minAge !== null && (!Number.isFinite(minAge) || minAge < 0)) return sendError(res, 400, "minAgeSeconds must be a non-negative number");

		          const limit = limitRaw !== null && limitRaw !== "" ? Number(limitRaw) : 200;
		          const offset = offsetRaw !== null && offsetRaw !== "" ? Number(offsetRaw) : 0;
		          if (!Number.isSafeInteger(limit) || limit <= 0) return sendError(res, 400, "limit must be a positive integer");
		          if (!Number.isSafeInteger(offset) || offset < 0) return sendError(res, 400, "offset must be a non-negative integer");
		          const safeLimit = Math.min(1000, limit);

		          const nowAt = nowIso();
		          const nowMs = Date.parse(nowAt);

		          const holds = [];
		          for (const job of listJobs({ tenantId })) {
	            if (!job?.id) continue;
	            const hold = job.settlementHold ?? null;
	            if (!hold || typeof hold !== "object") continue;
		            const holdStatus = typeof hold.status === "string" ? hold.status.toUpperCase() : "NONE";
		            if (status && status !== "ALL" && holdStatus !== status) continue;
		            if (customerId !== null && customerId !== "" && String(job.booking?.customerId ?? job.customerId ?? "") !== String(customerId)) continue;
		            if (siteId !== null && siteId !== "" && String(job.booking?.siteId ?? job.siteId ?? "") !== String(siteId)) continue;
		            if (robotId !== null && robotId !== "" && String(job.reservation?.robotId ?? job.match?.robotId ?? "") !== String(robotId)) continue;
		            if (operatorId !== null && operatorId !== "" && String(job.operatorCoverage?.operatorId ?? "") !== String(operatorId)) continue;

			            const heldAt = hold.heldAt ?? null;
			            const heldAtMs = heldAt ? Date.parse(String(heldAt)) : NaN;
			            const ageSeconds = Number.isFinite(nowMs) && Number.isFinite(heldAtMs) ? Math.max(0, Math.floor((nowMs - heldAtMs) / 1000)) : null;
			            if (minAge !== null && ageSeconds !== null && ageSeconds < minAge) continue;

			            const eventsBefore = getJobEvents(tenantId, job.id);
			            const exposure = (() => {
			              try {
			                return computeHoldExposureV1({ job, eventsBefore });
			              } catch {
			                return null;
			              }
			            })();
			            const quoteEvent =
			              [...eventsBefore].reverse().find((e) => e?.type === "QUOTE_PROPOSED" && typeof e?.id === "string" && e.id.trim()) ?? null;
			            const expectedExposure = hold?.expectedExposure ?? exposure?.expected ?? null;
			            const heldExposure = hold?.heldExposure ?? exposure?.held ?? null;
			            const holdPolicy = hold?.holdPolicy ?? exposure?.holdPolicy ?? null;
			            const currency =
			              hold?.currency ??
			              expectedExposure?.currency ??
			              heldExposure?.currency ??
			              (typeof job.quote?.currency === "string" && job.quote.currency.trim() ? job.quote.currency : "USD");
			            const pricingAnchor =
			              hold?.pricingAnchor ??
			              ({
			                quoteEventId: quoteEvent?.id ?? null,
			                quoteEventChainHash: quoteEvent?.chainHash ?? null,
			                quoteEventPayloadHash: quoteEvent?.payloadHash ?? null,
			                customerPolicyHash: hold?.triggeringProofRef?.customerPolicyHash ?? job.customerPolicyHash ?? job.booking?.policyHash ?? null,
			                operatorPolicyHash: hold?.triggeringProofRef?.operatorPolicyHash ?? job.operatorPolicyHash ?? null,
			                evaluatedAtChainHash: hold?.evaluatedAtChainHash ?? null
			              });

			            const expectedAmountCents =
			              (Number.isSafeInteger(expectedExposure?.amountGrossCents) ? expectedExposure.amountGrossCents : null) ??
			              (Number.isSafeInteger(job.quote?.amountCents) ? job.quote.amountCents : 0);
			            const expectedCoverageFeeCents =
			              (Number.isSafeInteger(expectedExposure?.coverageFeeCents) ? expectedExposure.coverageFeeCents : null) ??
			              (Number.isSafeInteger(job.quote?.breakdown?.coverageFeeCents) && job.quote.breakdown.coverageFeeCents > 0 ? job.quote.breakdown.coverageFeeCents : 0);
			            const expectedServiceAmountCents =
			              (Number.isSafeInteger(expectedExposure?.amountNetCents) ? expectedExposure.amountNetCents : null) ??
			              (Number.isSafeInteger(expectedAmountCents) && Number.isSafeInteger(expectedCoverageFeeCents)
			                ? Math.max(0, expectedAmountCents - expectedCoverageFeeCents)
			                : 0);
			            const expectedTotalCents = expectedAmountCents;

		            const reasonCodes = Array.isArray(hold.reasonCodes) ? hold.reasonCodes : [];
		            if (reasonCode !== null && reasonCode !== "" && !reasonCodes.includes(String(reasonCode))) continue;

		            const missingEvidence = Array.isArray(hold.missingEvidence) ? hold.missingEvidence : [];
		            const releaseHint =
		              holdStatus === "HELD"
		                ? missingEvidence.length
		                  ? { kind: "MISSING_EVIDENCE", missingEvidence }
		                  : { kind: "REPROOF_REQUIRED" }
		                : null;

			            holds.push({
			              tenantId,
			              jobId: job.id,
		              holdId: hold.holdId ?? null,
		              status: holdStatus,
		              heldAt,
		              lastUpdatedAt: hold.lastUpdatedAt ?? null,
		              ageSeconds,
		              agingBucket:
		                ageSeconds === null
		                  ? null
		                  : ageSeconds < 7 * 24 * 60 * 60
		                    ? "0_7d"
		                    : ageSeconds < 30 * 24 * 60 * 60
		                      ? "8_30d"
		                      : ageSeconds < 90 * 24 * 60 * 60
		                        ? "31_90d"
		                        : "90d_plus",
		              evaluatedAtChainHash: hold.evaluatedAtChainHash ?? null,
		              factsHash: hold.factsHash ?? null,
		              releasedAt: hold.releasedAt ?? null,
		              releaseReason: hold.releaseReason ?? null,
		              forfeitedAt: hold.forfeitedAt ?? null,
		              forfeitureReason: hold.forfeitureReason ?? null,
		              decisionRef: hold.decisionRef ?? null,
		              decisionEventRef: hold.decisionEventRef ?? null,
					              reasonCodes,
					              missingEvidence,
					              releaseHint,
					              currency,
					              pricingAnchor,
					              triggeringProofRef: hold.triggeringProofRef ?? null,
					              releasingProofRef: hold.releasingProofRef ?? null,
					              expectedAmountCents,
				              expectedCoverageFeeCents,
				              expectedTotalCents,
				              expectedServiceAmountCents,
			              expectedSplits: expectedExposure?.splits ?? exposure?.expected?.splits ?? null,
			              expectedExposure: expectedExposure ?? null,
			              holdPolicy: holdPolicy ?? null,
			              heldExposure: heldExposure ?? null,
			              customerId: job.booking?.customerId ?? job.customerId ?? null,
			              siteId: job.booking?.siteId ?? job.siteId ?? null,
			              templateId: job.templateId ?? null,
			              robotId: job.reservation?.robotId ?? job.match?.robotId ?? null,
		              operatorId: job.operatorCoverage?.operatorId ?? null
		            });
		          }

		          holds.sort((a, b) => (Number(b.ageSeconds) || 0) - (Number(a.ageSeconds) || 0) || String(a.jobId).localeCompare(String(b.jobId)));

		          const page = holds.slice(offset, offset + safeLimit);
		          return sendJson(res, 200, { now: nowAt, holds: page, count: holds.length, limit: safeLimit, offset });
		        }

	        if (parts[1] === "settlements" && parts[2] === "export" && parts.length === 3 && req.method === "GET") {
          if (!(requireScope(auth.scopes, OPS_SCOPES.OPS_READ) || requireScope(auth.scopes, OPS_SCOPES.FINANCE_READ))) {
            return sendError(res, 403, "forbidden");
          }
          const month = url.searchParams.get("month");
          if (!month) return sendError(res, 400, "month is required");
          const customerId = url.searchParams.get("customerId");
          const siteId = url.searchParams.get("siteId");

          let statement;
          try {
            let ledgerEntries = [];
            try {
              ledgerEntries = await listAllLedgerEntriesForTenant({ tenantId });
            } catch {
              ledgerEntries = [];
            }
            statement = computeMonthlyStatement({
              tenantId,
              customerId: customerId ?? null,
              siteId: siteId ?? null,
              month,
              jobs: listJobs({ tenantId }),
              getEventsForJob: (jobId) => getJobEvents(tenantId, jobId),
              ledgerEntries,
              nowIso
            });
          } catch (err) {
            return sendError(res, 400, "invalid statement query", { message: err?.message });
          }

          const headers = [
            "jobId",
            "customerId",
            "siteId",
            "templateId",
            "zoneId",
            "environmentTier",
            "settledAt",
            "grossAmountCents",
            "slaCreditsCents",
            "claimsPaidCents",
            "operatorCostCents",
            "netDueCents",
            "workCertificateId",
            "settlementStatementId"
          ];
          const rows = [];
          rows.push(headers.join(","));
          for (const j of statement.jobs ?? []) {
            const netDueCents = (Number.isSafeInteger(j.amountCents) ? j.amountCents : 0) - (Number.isSafeInteger(j.slaCreditsCents) ? j.slaCreditsCents : 0);

            // Best-effort artifact refs (deterministic fallback).
            const artifacts = typeof store.listArtifacts === "function" ? await store.listArtifacts({ tenantId, jobId: j.jobId, limit: 50, offset: 0 }) : [];
            const latestByType = new Map();
            for (const a of artifacts) {
              const t = a?.artifactType ?? a?.schemaVersion ?? null;
              if (!t) continue;
              const prev = latestByType.get(t);
              const at = Date.parse(a?.generatedAt ?? a?.createdAt ?? 0);
              const bt = Date.parse(prev?.generatedAt ?? prev?.createdAt ?? 0);
              if (!prev || (Number.isFinite(at) && Number.isFinite(bt) && at > bt)) latestByType.set(t, a);
            }

            const workCertId =
              latestByType.get("WorkCertificate.v1")?.artifactId ?? "";
            const settlementId =
              latestByType.get("SettlementStatement.v1")?.artifactId ?? "";

            const line = [
              j.jobId ?? "",
              j.customerId ?? "",
              j.siteId ?? "",
              j.templateId ?? "",
              j.zoneId ?? "",
              j.environmentTier ?? "",
              j.settledAt ?? "",
              j.amountCents ?? 0,
              j.slaCreditsCents ?? 0,
              j.claimsPaidCents ?? 0,
              j.operatorCostCents ?? 0,
              netDueCents,
              workCertId,
              settlementId
            ]
              .map((v) => {
                const s = v === null || v === undefined ? "" : String(v);
                if (s.includes('"') || s.includes(",") || s.includes("\n") || s.includes("\r")) {
                  return `"${s.replaceAll('"', '""')}"`;
                }
                return s;
              })
              .join(",");
            rows.push(line);
          }

          res.statusCode = 200;
          res.setHeader("content-type", "text/csv; charset=utf-8");
          res.end(rows.join("\n") + "\n");
          return;
        }

        if (parts[1] === "contracts" && parts.length === 2 && req.method === "GET") {
          if (!requireScope(auth.scopes, OPS_SCOPES.OPS_READ)) return sendError(res, 403, "forbidden");
          metricInc("ops_contracts_v1_requests_total");
          const customerId = url.searchParams.get("customerId");
          const siteId = url.searchParams.get("siteId");
          const templateId = url.searchParams.get("templateId");

          let contracts = listContracts({ tenantId });
          if (customerId) contracts = contracts.filter((c) => String(c.customerId ?? "") === customerId);
          if (siteId) contracts = contracts.filter((c) => String(c.siteId ?? "") === siteId);
          if (templateId) contracts = contracts.filter((c) => String(c.templateId ?? "") === templateId);

          return sendJson(res, 200, { contracts });
        }

        if (parts[1] === "contracts" && parts.length === 2 && req.method === "POST") {
          if (!requireScope(auth.scopes, OPS_SCOPES.OPS_WRITE)) return sendError(res, 403, "forbidden");
          const body = await readJsonBody(req);
          const nowAt = nowIso();

          metricInc("ops_contracts_v1_requests_total");
          if (body?.type === CONTRACT_DOCUMENT_TYPE_V1 && body?.v !== undefined) {
            return sendError(res, 400, "contracts-as-code documents must be sent to /ops/contracts-v2", null, { code: "SCHEMA_INVALID" });
          }

          const contractId = body?.contractId ? String(body.contractId) : createId("contract");
          const key = makeScopedKey({ tenantId, id: contractId });
          const existing = store.contracts instanceof Map ? store.contracts.get(key) : null;
          const nextContractVersion = Number.isSafeInteger(existing?.contractVersion) && existing.contractVersion > 0 ? existing.contractVersion + 1 : 1;

          const mergedPolicies = {
            slaOverridesByEnvironmentTier: {
              ...(existing?.policies?.slaOverridesByEnvironmentTier ?? {}),
              ...(body?.policies?.slaOverridesByEnvironmentTier ?? {})
            },
	            proofPolicy: (() => {
	              const defaultProofPolicy = createDefaultContract({ tenantId, nowIso })?.policies?.proofPolicy ?? {
	                gateMode: "warn",
	                zoneCoverage: { thresholdPct: 95, allowExtraZones: false, excuseIncidentTypes: ["BLOCKED_ZONE"] },
	                insufficientEvidenceBehavior: { mode: "ALLOW", holdPercent: 0 },
	                disputeWindowDays: 0,
	                allowReproofAfterSettlementWithinDisputeWindow: false
	              };
	              const prev = existing?.policies?.proofPolicy ?? defaultProofPolicy;
	              const nextRaw = body?.policies?.proofPolicy ?? null;
	              const next = nextRaw && typeof nextRaw === "object" ? nextRaw : {};
              const prevZone = prev?.zoneCoverage && typeof prev.zoneCoverage === "object" ? prev.zoneCoverage : {};
              const nextZone = next?.zoneCoverage && typeof next.zoneCoverage === "object" ? next.zoneCoverage : {};
              const prevIeb =
                prev?.insufficientEvidenceBehavior && typeof prev.insufficientEvidenceBehavior === "object" ? prev.insufficientEvidenceBehavior : {};
              const nextIeb =
                next?.insufficientEvidenceBehavior && typeof next.insufficientEvidenceBehavior === "object" ? next.insufficientEvidenceBehavior : {};

	              return {
	                gateMode: next.gateMode ?? prev.gateMode ?? defaultProofPolicy.gateMode ?? "warn",
	                zoneCoverage: { ...prevZone, ...nextZone },
	                insufficientEvidenceBehavior: { ...prevIeb, ...nextIeb },
	                disputeWindowDays: next.disputeWindowDays ?? prev.disputeWindowDays ?? defaultProofPolicy.disputeWindowDays ?? 0,
	                allowReproofAfterSettlementWithinDisputeWindow:
	                  next.allowReproofAfterSettlementWithinDisputeWindow ??
	                  prev.allowReproofAfterSettlementWithinDisputeWindow ??
	                  defaultProofPolicy.allowReproofAfterSettlementWithinDisputeWindow ??
	                  false
	              };
	            })(),
            creditPolicy: {
              ...(existing?.policies?.creditPolicy ?? { enabled: false, defaultAmountCents: 0, maxAmountCents: 0, currency: "USD" }),
              ...(body?.policies?.creditPolicy ?? {})
            },
            evidencePolicy: { ...(existing?.policies?.evidencePolicy ?? { retentionDays: 0 }), ...(body?.policies?.evidencePolicy ?? {}) },
            claimPolicy: {
              ...(existing?.policies?.claimPolicy ?? { currency: "USD", autoApproveThresholdCents: 0, maxPayoutCents: 0, reservePercent: 0 }),
              ...(body?.policies?.claimPolicy ?? {})
            },
            coveragePolicy: {
              ...(existing?.policies?.coveragePolicy ?? {
                required: false,
                coverageTierId: null,
                feeModel: COVERAGE_FEE_MODEL.PER_JOB,
                feeCentsPerJob: 0,
                creditFundingModel: CREDIT_FUNDING_MODEL.PLATFORM_EXPENSE,
                reserveFundPercent: 100,
                insurerId: null,
                recoverablePercent: 100,
                recoverableTerms: null,
                responseSlaSeconds: 0,
                includedAssistSeconds: 0,
                overageRateCentsPerMinute: 0
              }),
              ...(body?.policies?.coveragePolicy ?? {})
            }
          };

          const contract = {
            tenantId,
            contractId,
            contractVersion: nextContractVersion,
            name: body?.name ? String(body.name) : existing?.name ?? contractId,
            customerId: body?.customerId ?? existing?.customerId ?? null,
            siteId: body?.siteId ?? existing?.siteId ?? null,
            templateId: body?.templateId ?? existing?.templateId ?? null,
            isDefault: body?.isDefault ?? existing?.isDefault ?? false,
            policies: mergedPolicies,
            createdAt: existing?.createdAt ?? nowAt,
            updatedAt: nowAt
          };

          try {
            validateContract(contract);
          } catch (err) {
            return sendError(res, 400, "invalid contract", { message: err?.message });
          }

          const retentionDays = contract.policies?.evidencePolicy?.retentionDays ?? 0;
          const retentionMaxDays = Number(getTenantConfig(tenantId)?.evidenceRetentionMaxDays ?? 365);
          if (!Number.isSafeInteger(retentionMaxDays) || retentionMaxDays <= 0) {
            return sendError(res, 500, "invalid tenant evidence retention config");
          }
          if (retentionDays > 0 && retentionDays > retentionMaxDays) {
            return sendError(res, 400, "invalid contract", {
              message: `evidencePolicy.retentionDays must be <= ${retentionMaxDays} for this tenant (or 0 to retain forever)`
            });
          }

          const ops = [];

          if (contract.isDefault === true && store.contracts instanceof Map) {
            for (const c of listContracts({ tenantId })) {
              if (c?.isDefault !== true) continue;
              if (String(c.contractId) === contractId) continue;
              ops.push({
                kind: "CONTRACT_UPSERT",
                tenantId,
                contract: {
                  ...c,
                  contractVersion:
                    Number.isSafeInteger(c?.contractVersion) && c.contractVersion > 0 ? c.contractVersion + 1 : 1,
                  isDefault: false,
                  updatedAt: nowAt
                }
              });
            }
          }

          ops.push({ kind: "CONTRACT_UPSERT", tenantId, contract });
          await commitTx(ops);

          return sendJson(res, 201, { contract });
        }

        if (parts[1] === "jobs" && parts[2] && parts[3] === "timeline" && parts.length === 4 && req.method === "GET") {
          if (!(requireScope(auth.scopes, OPS_SCOPES.AUDIT_READ) || requireScope(auth.scopes, OPS_SCOPES.FINANCE_READ))) {
            return sendError(res, 403, "forbidden");
          }
          const jobId = parts[2];
          const events = getJobEvents(tenantId, jobId);
          if (!events.length) return sendError(res, 404, "job not found");
          const job = reduceJob(events);
          if (!job) return sendError(res, 404, "job not found");

          const ledger = typeof store.getLedger === "function" ? store.getLedger(tenantId) : store.ledger;
          let ledgerEntries = [];
          const memoPrefix = `job:${jobId} `;
          if (typeof store.listLedgerEntries === "function") {
            try {
              ledgerEntries = await store.listLedgerEntries({ tenantId, memoPrefix, limit: 5000, offset: 0 });
            } catch {
              ledgerEntries = [];
            }
          } else {
            ledgerEntries = (ledger?.entries ?? []).filter((e) => typeof e?.memo === "string" && e.memo.startsWith(memoPrefix));
          }
          return sendJson(res, 200, { job, events, ledgerEntries, ledgerBalances: Object.fromEntries(ledger?.balances ?? []) });
        }

        if (parts[1] === "robots" && parts[2] && parts[3] === "quarantine" && parts.length === 4 && req.method === "POST") {
          if (!requireScope(auth.scopes, OPS_SCOPES.OPS_WRITE)) return sendError(res, 403, "forbidden");
          const robotId = parts[2];
          const body = await readJsonBody(req);

          const existing = getRobotEvents(tenantId, robotId);
          if (!existing.length) return sendError(res, 404, "robot not found");

          const robotBefore = reduceRobot(existing);
          if (!robotBefore) return sendError(res, 404, "robot not found");
          if (robotBefore.status === "quarantined") return sendError(res, 409, "robot already quarantined");

          const quarantinedAt = nowIso();
          const payload = {
            robotId,
            quarantinedAt,
            reason: body?.reason ?? "MANUAL",
            manualClearRequired: body?.manualClearRequired ?? true,
            incidentId: body?.incidentId ?? null,
            jobId: body?.jobId ?? null,
            notes: body?.notes ?? null,
            until: body?.until ?? null
          };
          try {
            validateRobotQuarantinedPayload(payload);
          } catch (err) {
            return sendError(res, 400, "invalid payload", { message: err?.message });
          }

          const draft = createChainedEvent({
            streamId: robotId,
            type: "ROBOT_QUARANTINED",
            at: quarantinedAt,
            actor: { type: "ops", id: principalId },
            payload
          });
          const nextEvents = appendChainedEvent({ events: existing, event: draft, signer: serverSigner });
          const event = nextEvents[nextEvents.length - 1];

          try {
            enforceSignaturePolicy({ tenantId, signerKind: requiredSignerKindForEventType(event.type), event });
          } catch (err) {
            return sendError(res, 400, "signature policy rejected", { message: err?.message });
          }

          let robotAfter;
          try {
            robotAfter = reduceRobot(nextEvents);
          } catch (err) {
            return sendError(res, 400, "robot update rejected", { message: err?.message });
          }

          await commitTx([{ kind: "ROBOT_EVENTS_APPENDED", tenantId, robotId, events: [event] }]);
          return sendJson(res, 201, { event, robot: robotAfter });
        }

        if (parts[1] === "robots" && parts[2] && parts[3] === "quarantine" && parts[4] === "clear" && parts.length === 5 && req.method === "POST") {
          if (!requireScope(auth.scopes, OPS_SCOPES.OPS_WRITE)) return sendError(res, 403, "forbidden");
          const robotId = parts[2];
          const body = await readJsonBody(req);

          const existing = getRobotEvents(tenantId, robotId);
          if (!existing.length) return sendError(res, 404, "robot not found");

          const robotBefore = reduceRobot(existing);
          if (!robotBefore) return sendError(res, 404, "robot not found");
          if (robotBefore.status !== "quarantined") return sendError(res, 409, "robot is not quarantined");

          const clearedAt = nowIso();
          const payload = {
            robotId,
            clearedAt,
            reason: body?.reason ?? "MANUAL",
            notes: body?.notes ?? null,
            maintenanceId: body?.maintenanceId ?? null
          };
          try {
            validateRobotQuarantineClearedPayload(payload);
          } catch (err) {
            return sendError(res, 400, "invalid payload", { message: err?.message });
          }

          const draft = createChainedEvent({
            streamId: robotId,
            type: "ROBOT_QUARANTINE_CLEARED",
            at: clearedAt,
            actor: { type: "ops", id: principalId },
            payload
          });
          const nextEvents = appendChainedEvent({ events: existing, event: draft, signer: serverSigner });
          const event = nextEvents[nextEvents.length - 1];

          try {
            enforceSignaturePolicy({ tenantId, signerKind: requiredSignerKindForEventType(event.type), event });
          } catch (err) {
            return sendError(res, 400, "signature policy rejected", { message: err?.message });
          }

          let robotAfter;
          try {
            robotAfter = reduceRobot(nextEvents);
          } catch (err) {
            return sendError(res, 400, "robot update rejected", { message: err?.message });
          }

          await commitTx([{ kind: "ROBOT_EVENTS_APPENDED", tenantId, robotId, events: [event] }]);
          return sendJson(res, 201, { event, robot: robotAfter });
        }

        if (parts[1] === "jobs" && parts[2] && parts[3] === "redispatch" && parts.length === 4 && req.method === "POST") {
          if (!requireScope(auth.scopes, OPS_SCOPES.OPS_WRITE)) return sendError(res, 403, "forbidden");
          const jobId = parts[2];
          const body = await readJsonBody(req);

          let idemStoreKey = null;
          let idemRequestHash = null;
          try {
            ({ idemStoreKey, idemRequestHash } = readIdempotency({ method: "POST", requestPath: path, expectedPrevChainHash: null, body }));
          } catch (err) {
            return sendError(res, 400, "invalid idempotency key", { message: err?.message });
          }
          if (idemStoreKey) {
            const existingIdem = store.idempotency.get(idemStoreKey);
            if (existingIdem) {
              if (existingIdem.requestHash !== idemRequestHash) {
                return sendError(res, 409, "idempotency key conflict", "request differs from initial use of this key");
              }
              return sendJson(res, existingIdem.statusCode, existingIdem.body);
            }
          }

          const existing = getJobEvents(tenantId, jobId);
          if (!existing.length) return sendError(res, 404, "job not found");
          const jobBefore = reduceJob(existing);
          if (!jobBefore) return sendError(res, 404, "job not found");

          const allowed = new Set(["BOOKED", "MATCHED", "RESERVED"]);
          if (!allowed.has(jobBefore.status)) return sendError(res, 409, "job is not redispatchable");
          if (!jobBefore.booking) return sendError(res, 400, "job booking is required");

          const oldWindow = { startAt: jobBefore.booking.startAt, endAt: jobBefore.booking.endAt };
          const newWindow = { ...oldWindow };

          const rescheduledAt = nowIso();
          const reschedulePayload = {
            jobId,
            oldWindow,
            newWindow,
            reason: "OPS",
            requestedBy: principalId,
            requiresRequote: false
          };
          try {
            validateJobRescheduledPayload(reschedulePayload);
          } catch (err) {
            return sendError(res, 400, "invalid reschedule payload", { message: err?.message });
          }

          const rescheduleDraft = createChainedEvent({
            streamId: jobId,
            type: "JOB_RESCHEDULED",
            at: rescheduledAt,
            actor: { type: "ops", id: principalId },
            payload: reschedulePayload
          });
          let events = appendChainedEvent({ events: existing, event: rescheduleDraft, signer: serverSigner });
          const rescheduleEvent = events[events.length - 1];

          const dispatchAt = nowIso();
          const dispatchPayload = { jobId, requestedAt: dispatchAt, trigger: "OPS_REDISPATCH" };
          const dispatchDraft = createChainedEvent({
            streamId: jobId,
            type: "DISPATCH_REQUESTED",
            at: dispatchAt,
            actor: { type: "dispatch", id: "dispatch_v1" },
            payload: dispatchPayload
          });
          events = appendChainedEvent({ events, event: dispatchDraft, signer: serverSigner });
          const dispatchRequestedEvent = events[events.length - 1];

          try {
            validateDomainEvent({ jobBefore, event: rescheduleEvent, eventsBefore: existing });
            const jobAfterReschedule = reduceJob([...existing, rescheduleEvent]);
            validateDomainEvent({ jobBefore: jobAfterReschedule, event: dispatchRequestedEvent, eventsBefore: [...existing, rescheduleEvent] });
          } catch (err) {
            return sendError(res, 400, "event rejected", { message: err?.message });
          }

          const jobAfter = reduceJob(events);
          const outboxMessages = [{ type: "DISPATCH_REQUESTED", tenantId, jobId, sourceEventId: dispatchRequestedEvent.id, at: dispatchRequestedEvent.at }];
          if (jobBefore.status !== jobAfter.status) {
            outboxMessages.push({ type: "JOB_STATUS_CHANGED", tenantId, jobId, fromStatus: jobBefore.status, toStatus: jobAfter.status, at: rescheduleEvent.at });
          }

          const responseBody = { events: [rescheduleEvent, dispatchRequestedEvent], job: jobAfter };
          const ops = [
            { kind: "JOB_EVENTS_APPENDED", tenantId, jobId, events: [rescheduleEvent, dispatchRequestedEvent] },
            { kind: "OUTBOX_ENQUEUE", messages: outboxMessages }
          ];
          if (idemStoreKey) {
            ops.push({ kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode: 201, body: responseBody } });
          }
          await commitTx(ops);
          return sendJson(res, 201, responseBody);
        }

        if (parts[1] === "jobs" && parts[2] && parts[3] === "cancel" && parts.length === 4 && req.method === "POST") {
          if (!requireScope(auth.scopes, OPS_SCOPES.OPS_WRITE)) return sendError(res, 403, "forbidden");
          const jobId = parts[2];
          const body = await readJsonBody(req);

          let idemStoreKey = null;
          let idemRequestHash = null;
          try {
            ({ idemStoreKey, idemRequestHash } = readIdempotency({ method: "POST", requestPath: path, expectedPrevChainHash: null, body }));
          } catch (err) {
            return sendError(res, 400, "invalid idempotency key", { message: err?.message });
          }
          if (idemStoreKey) {
            const existingIdem = store.idempotency.get(idemStoreKey);
            if (existingIdem) {
              if (existingIdem.requestHash !== idemRequestHash) {
                return sendError(res, 409, "idempotency key conflict", "request differs from initial use of this key");
              }
              return sendJson(res, existingIdem.statusCode, existingIdem.body);
            }
          }

          const existing = getJobEvents(tenantId, jobId);
          if (!existing.length) return sendError(res, 404, "job not found");
          const jobBefore = reduceJob(existing);
          if (!jobBefore) return sendError(res, 404, "job not found");

          const cancelledAt = nowIso();
          const payload = {
            jobId,
            cancelledAt,
            reason: body?.reason ?? "OPS",
            requestedBy: principalId
          };
          try {
            validateJobCancelledPayload(payload);
          } catch (err) {
            return sendError(res, 400, "invalid payload", { message: err?.message });
          }

          const draft = createChainedEvent({
            streamId: jobId,
            type: "JOB_CANCELLED",
            at: cancelledAt,
            actor: { type: "ops", id: principalId },
            payload
          });
          const nextEvents = appendChainedEvent({ events: existing, event: draft, signer: serverSigner });
          const event = nextEvents[nextEvents.length - 1];

          try {
            validateDomainEvent({ jobBefore, event, eventsBefore: existing });
          } catch (err) {
            return sendError(res, 400, "event rejected", { message: err?.message });
          }

          let jobAfter;
          try {
            jobAfter = reduceJob(nextEvents);
          } catch (err) {
            return sendError(res, 400, "job transition rejected", { message: err?.message });
          }

          const outboxMessages = [];
          if (jobBefore.status !== jobAfter.status) {
            outboxMessages.push({ type: "JOB_STATUS_CHANGED", tenantId, jobId, fromStatus: jobBefore.status, toStatus: jobAfter.status, at: event.at });
          }

          const responseBody = { event, job: jobAfter };
          const ops = [{ kind: "JOB_EVENTS_APPENDED", tenantId, jobId, events: [event] }];
          if (idemStoreKey) ops.push({ kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode: 201, body: responseBody } });
          if (outboxMessages.length) ops.push({ kind: "OUTBOX_ENQUEUE", messages: outboxMessages });

          await commitTx(ops);
          return sendJson(res, 201, responseBody);
        }

        if (parts[1] === "jobs" && parts[2] && parts[3] === "abort" && parts.length === 4 && req.method === "POST") {
          const jobId = parts[2];
          const body = await readJsonBody(req);

          let idemStoreKey = null;
          let idemRequestHash = null;
          try {
            ({ idemStoreKey, idemRequestHash } = readIdempotency({ method: "POST", requestPath: path, expectedPrevChainHash: null, body }));
          } catch (err) {
            return sendError(res, 400, "invalid idempotency key", { message: err?.message });
          }
          if (idemStoreKey) {
            const existingIdem = store.idempotency.get(idemStoreKey);
            if (existingIdem) {
              if (existingIdem.requestHash !== idemRequestHash) {
                return sendError(res, 409, "idempotency key conflict", "request differs from initial use of this key");
              }
              return sendJson(res, existingIdem.statusCode, existingIdem.body);
            }
          }

          const existing = getJobEvents(tenantId, jobId);
          if (!existing.length) return sendError(res, 404, "job not found");
          const jobBefore = reduceJob(existing);
          if (!jobBefore) return sendError(res, 404, "job not found");

          const robotId = jobBefore.execution?.robotId ?? jobBefore.reservation?.robotId ?? jobBefore.match?.robotId ?? null;
          if (!robotId) return sendError(res, 409, "job has no robot to abort");

          const abortedAt = nowIso();
          const payload = {
            jobId,
            robotId,
            abortedAt,
            reason: body?.reason ?? "OPS_ABORT"
          };
          try {
            validateJobExecutionAbortedPayload(payload);
          } catch (err) {
            return sendError(res, 400, "invalid payload", { message: err?.message });
          }

          const draft = createChainedEvent({
            streamId: jobId,
            type: "JOB_EXECUTION_ABORTED",
            at: abortedAt,
            actor: { type: "ops", id: principalId },
            payload
          });
          const nextEvents = appendChainedEvent({ events: existing, event: draft, signer: serverSigner });
          const event = nextEvents[nextEvents.length - 1];

          try {
            validateDomainEvent({ jobBefore, event, eventsBefore: existing });
          } catch (err) {
            return sendError(res, 400, "event rejected", { message: err?.message });
          }

          let jobAfter;
          try {
            jobAfter = reduceJob(nextEvents);
          } catch (err) {
            return sendError(res, 400, "job transition rejected", { message: err?.message });
          }

          const outboxMessages = [];
          if (jobBefore.status !== jobAfter.status) {
            outboxMessages.push({ type: "JOB_STATUS_CHANGED", tenantId, jobId, fromStatus: jobBefore.status, toStatus: jobAfter.status, at: event.at });
          }

          const responseBody = { event, job: jobAfter };
          const ops = [{ kind: "JOB_EVENTS_APPENDED", tenantId, jobId, events: [event] }];
          if (idemStoreKey) ops.push({ kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode: 201, body: responseBody } });
          if (outboxMessages.length) ops.push({ kind: "OUTBOX_ENQUEUE", messages: outboxMessages });

          await commitTx(ops);
          return sendJson(res, 201, responseBody);
        }

        if (parts[1] === "jobs" && parts[2] && parts[3] === "sla-credit" && parts.length === 4 && req.method === "POST") {
          const jobId = parts[2];
          const body = await readJsonBody(req);

          let idemStoreKey = null;
          let idemRequestHash = null;
          try {
            ({ idemStoreKey, idemRequestHash } = readIdempotency({ method: "POST", requestPath: path, expectedPrevChainHash: null, body }));
          } catch (err) {
            return sendError(res, 400, "invalid idempotency key", { message: err?.message });
          }
          if (idemStoreKey) {
            const existingIdem = store.idempotency.get(idemStoreKey);
            if (existingIdem) {
              if (existingIdem.requestHash !== idemRequestHash) {
                return sendError(res, 409, "idempotency key conflict", "request differs from initial use of this key");
              }
              return sendJson(res, existingIdem.statusCode, existingIdem.body);
            }
          }

          const existing = getJobEvents(tenantId, jobId);
          if (!existing.length) return sendError(res, 404, "job not found");
          const jobBefore = reduceJob(existing);
          if (!jobBefore) return sendError(res, 404, "job not found");

          const settledEventId = (() => {
            for (let i = existing.length - 1; i >= 0; i -= 1) {
              const e = existing[i];
              if (e?.type === "SETTLED") return e.id ?? null;
            }
            return null;
          })();
          if (!settledEventId) return sendError(res, 409, "job is not settled");

          const policyHash = jobBefore.booking?.policyHash ?? null;

          const breachEvent = (() => {
            for (let i = existing.length - 1; i >= 0; i -= 1) {
              const e = existing[i];
              if (e?.type !== "SLA_BREACH_DETECTED") continue;
              if (e?.payload?.settledEventId !== settledEventId) continue;
              return e;
            }
            return null;
          })();

          let trigger = body?.trigger ?? null;
          if (trigger === null || trigger === undefined) {
            if (
              breachEvent &&
              breachEvent.id &&
              breachEvent.payload?.window?.startAt &&
              breachEvent.payload?.window?.endAt &&
              breachEvent.payload?.policy &&
              Array.isArray(breachEvent.payload?.breaches) &&
              breachEvent.payload.breaches.length
            ) {
              trigger = {
                type: SLA_CREDIT_TRIGGER_TYPE.SLA_BREACH,
                breachEventId: breachEvent.id,
                detectedAt: breachEvent.payload?.detectedAt ?? breachEvent.at,
                window: breachEvent.payload.window,
                policy: breachEvent.payload.policy,
                breaches: breachEvent.payload.breaches
              };
            }
          }

          const issuedAt = nowIso();
          const payload = {
            jobId,
            creditId: createId("cred"),
            issuedAt,
            amountCents: body?.amountCents,
            currency: "USD",
            reason: "SLA_BREACH",
            settledEventId,
            policyHash,
            trigger
          };
          try {
            validateSlaCreditIssuedPayload(payload);
          } catch (err) {
            return sendError(res, 400, "invalid payload", { message: err?.message });
          }

          const draft = createChainedEvent({
            streamId: jobId,
            type: "SLA_CREDIT_ISSUED",
            at: issuedAt,
            actor: { type: "ops", id: principalId },
            payload
          });
          const nextEvents = appendChainedEvent({ events: existing, event: draft, signer: serverSigner });
          const event = nextEvents[nextEvents.length - 1];

          try {
            validateDomainEvent({ jobBefore, event, eventsBefore: existing });
          } catch (err) {
            return sendError(res, 400, "event rejected", { message: err?.message });
          }

          let jobAfter;
          try {
            jobAfter = reduceJob(nextEvents);
          } catch (err) {
            return sendError(res, 400, "job transition rejected", { message: err?.message });
          }

          let ledgerEntries = [];
          try {
            ledgerEntries = ledgerEntriesForJobEvent({ jobBefore, event, eventsBefore: existing });
          } catch (err) {
            return sendError(res, 400, "ledger posting rejected", { message: err?.message });
          }

          const outboxMessages = [];
          for (const entry of ledgerEntries) {
            if (!entry) continue;
            outboxMessages.push({ type: "LEDGER_ENTRY_APPLY", tenantId, jobId, sourceEventId: event.id, entry });
          }

          const responseBody = {
            event,
            job: jobAfter,
            ledgerEntryId: ledgerEntries.length ? ledgerEntries[0]?.id ?? null : null,
            ledgerEntryIds: ledgerEntries.map((e) => e?.id).filter(Boolean)
          };
          const ops = [{ kind: "JOB_EVENTS_APPENDED", tenantId, jobId, events: [event] }];
          if (idemStoreKey) ops.push({ kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode: 201, body: responseBody } });
          if (outboxMessages.length) ops.push({ kind: "OUTBOX_ENQUEUE", messages: outboxMessages });

          await commitTx(ops);
          return sendJson(res, 201, responseBody);
        }

        return sendError(res, 404, "not found");
      }

      if (path.startsWith("/pilot")) {
        if (!requireScope(auth.scopes, OPS_SCOPES.OPS_READ)) return sendError(res, 403, "forbidden");
        if (store.kind === "pg" && typeof store.refreshFromDb === "function") {
          await store.refreshFromDb();
          if (typeof store.ensureTenant === "function") store.ensureTenant(tenantId);
        }

        const parts = path.split("/").filter(Boolean);
        if (req.method === "GET" && parts.length === 2 && parts[0] === "pilot" && parts[1] === "templates") {
          return sendJson(res, 200, { templates: listPilotTemplates() });
        }

        if (req.method === "POST" && parts.length === 2 && parts[0] === "pilot" && parts[1] === "jobs") {
          if (!requireScope(auth.scopes, OPS_SCOPES.OPS_WRITE)) return sendError(res, 403, "forbidden");
          const body = await readJsonBody(req);

          let idemStoreKey = null;
          let idemRequestHash = null;
          try {
            ({ idemStoreKey, idemRequestHash } = readIdempotency({ method: "POST", requestPath: path, expectedPrevChainHash: null, body }));
          } catch (err) {
            return sendError(res, 400, "invalid idempotency key", { message: err?.message });
          }
          if (idemStoreKey) {
            const existingIdem = store.idempotency.get(idemStoreKey);
            if (existingIdem) {
              if (existingIdem.requestHash !== idemRequestHash) {
                return sendError(res, 409, "idempotency key conflict", "request differs from initial use of this key");
              }
              return sendJson(res, existingIdem.statusCode, existingIdem.body);
            }
          }

          const cfg = getTenantConfig(tenantId) ?? {};
          const requestedLimit = cfg?.quotas?.maxOpenJobs ?? 0;
          const limit = clampQuota({ tenantLimit: Number.isSafeInteger(requestedLimit) ? requestedLimit : 0, defaultLimit: 0, maxLimit: quotaPlatformMaxOpenJobs });
          if (limit > 0) {
            const open = countOpenJobsForTenant(tenantId);
            if (isQuotaExceeded({ current: open, limit })) {
              return sendError(res, 429, "tenant quota exceeded", { kind: "open_jobs", limit, current: open }, { code: "TENANT_QUOTA_EXCEEDED" });
            }
          }

          const pilotTemplateId = body?.pilotTemplateId ?? "managed_common_area_reset_l1";
          const pilotTemplate = getPilotTemplate(pilotTemplateId);
          if (!pilotTemplate) return sendError(res, 400, "unknown pilotTemplateId");

          const startAt = body?.startAt;
          const startMs = Date.parse(startAt);
          if (!Number.isFinite(startMs)) return sendError(res, 400, "invalid startAt");
          const endAt = new Date(startMs + pilotTemplate.windowMinutes * 60_000).toISOString();

          const jobTemplateId = pilotTemplate.jobTemplateId;
          const environmentTier = pilotTemplate.environmentTier;
          const zoneId = normalizeZoneId(body?.zoneId ?? pilotTemplate.defaultZoneId);
          const requiresOperatorCoverage = pilotTemplate.requiresOperatorCoverage === true || environmentTier === ENV_TIER.ENV_IN_HOME;
          const window = { startAt, endAt };

          const activeOperators = listAvailableOperators({ tenantId, zoneId, window }).length;
          if (requiresOperatorCoverage && activeOperators <= 0) {
            return sendError(res, 409, "insufficient operator coverage");
          }

          const availableRobots = listAvailableRobots({ tenantId, zoneId, window }).length;
          if (availableRobots <= 0) return sendError(res, 409, "no available robots for window");

          const jobId = createId("job");
          const customerId = body?.customerId ?? null;
          const siteId = body?.siteId ?? null;
          const requestedContractId = body?.contractId ?? null;

          const contracts = listContracts({ tenantId });
          let contract = null;
          if (requestedContractId) {
            contract = contracts.find((c) => c?.contractId === requestedContractId) ?? null;
            if (!contract) return sendError(res, 400, "unknown contractId");
          } else {
            contract = selectBestContract(contracts, { customerId, siteId, templateId: jobTemplateId });
          }
          if (!contract) contract = createDefaultContract({ tenantId, nowIso });

          const constraints = {
            ...(body?.constraints ?? {}),
            zoneId,
            pilotTemplateId,
            allowedAccessMethods: pilotTemplate.allowedAccessMethods,
            skillBundle: pilotTemplate.skillBundle,
            environmentTier
          };

          const createdDraft = createChainedEvent({
            streamId: jobId,
            type: "JOB_CREATED",
            actor: { type: "system", id: "proxy" },
            payload: { tenantId, customerId, siteId, contractId: contract.contractId, templateId: jobTemplateId, constraints },
            at: nowIso()
          });
          let events = appendChainedEvent({ events: [], event: createdDraft, signer: serverSigner });

          const coveragePolicy = contract.policies?.coveragePolicy ?? null;
          const coverageRequired = coveragePolicy?.required === true;
          const coverageFeeModel = coveragePolicy?.feeModel ?? COVERAGE_FEE_MODEL.PER_JOB;
          const coverageFeeCentsPerJob =
            Number.isSafeInteger(coveragePolicy?.feeCentsPerJob) && coveragePolicy.feeCentsPerJob > 0 ? coveragePolicy.feeCentsPerJob : 0;
          const coverageFeeCents =
            coverageRequired && coverageFeeCentsPerJob > 0
              ? coverageFeeModel === COVERAGE_FEE_MODEL.PER_JOB
                ? coverageFeeCentsPerJob
                : 0
              : 0;

          const quote = computeQuote({
            templateId: jobTemplateId,
            currency: "USD",
            environmentTier,
            requiresOperatorCoverage,
            coverageFeeCents,
            availableRobots,
            activeOperators
          });
          const baseSla = computeSlaPolicy({ environmentTier });
          const sla = applyContractSlaOverrides({ sla: baseSla, environmentTier, contract });
          const quotePayload = {
            ...quote,
            sla,
            inputs: {
              startAt,
              endAt,
              environmentTier,
              requiresOperatorCoverage,
              zoneId,
              customerId,
              siteId,
              contractId: contract.contractId,
              contractVersion:
                Number.isSafeInteger(contract?.contractVersion) && contract.contractVersion > 0 ? contract.contractVersion : 1
            }
          };
          const quoteDraft = createChainedEvent({
            streamId: jobId,
            type: "QUOTE_PROPOSED",
            actor: { type: "pricing", id: "pricing_v0" },
            payload: quotePayload,
            at: nowIso()
          });
          events = appendChainedEvent({ events, event: quoteDraft, signer: serverSigner });

          const autoBook = body?.autoBook !== false;
          const outboxMessages = [];

          if (autoBook) {
            const contractVersion =
              Number.isSafeInteger(contract?.contractVersion) && contract.contractVersion > 0 ? contract.contractVersion : 1;
            const creditPolicy =
              contract.policies?.creditPolicy ?? { enabled: false, defaultAmountCents: 0, maxAmountCents: 0, currency: "USD" };
            const evidencePolicy = contract.policies?.evidencePolicy ?? { retentionDays: 0 };
            const claimPolicy =
              contract.policies?.claimPolicy ?? { currency: "USD", autoApproveThresholdCents: 0, maxPayoutCents: 0, reservePercent: 0 };
            const coveragePolicy =
              contract.policies?.coveragePolicy ?? {
                required: false,
                coverageTierId: null,
                feeModel: COVERAGE_FEE_MODEL.PER_JOB,
                feeCentsPerJob: 0,
                creditFundingModel: CREDIT_FUNDING_MODEL.PLATFORM_EXPENSE,
                reserveFundPercent: 100,
                insurerId: null,
                recoverablePercent: 100,
                recoverableTerms: null,
                responseSlaSeconds: 0,
                includedAssistSeconds: 0,
                overageRateCentsPerMinute: 0
              };

            const contractDoc = contractDocumentV1FromLegacyContract({ ...contract, contractVersion });
            const customerContractHash = hashContractDocumentV1(contractDoc);
            const { policySnapshot, policyHash, compilerId } = compileBookingPolicySnapshot({
              contractDoc,
              environmentTier,
              requiresOperatorCoverage,
              sla,
              creditPolicy,
              evidencePolicy,
              claimPolicy,
              coveragePolicy
            });

            const requiredZonesInput = body?.requiredZones ?? null;
            const requiredZones =
              requiredZonesInput && typeof requiredZonesInput === "object"
                ? requiredZonesInput
                : {
                    schemaVersion: "ZoneSet.v1",
                    zoneSetId: `zones_${jobId}`,
                    zones: [{ zoneId: String(zoneId), label: String(zoneId) }]
                  };
            let requiredZonesHash;
            try {
              validateZoneSetV1(requiredZones);
              requiredZonesHash = computeZoneSetHash(requiredZones);
            } catch (err) {
              return sendError(res, 400, "invalid requiredZones", { message: err?.message });
            }

            const bookingPayload = {
              paymentHoldId: body?.paymentHoldId ?? "pilot_hold",
              startAt,
              endAt,
              environmentTier,
              requiresOperatorCoverage,
              zoneId,
              requiredZones,
              requiredZonesHash,
              sla,
              customerId,
              siteId,
              contractId: contract.contractId,
              contractVersion,
              customerContractHash,
              customerCompilerId: compilerId,
              creditPolicy,
              evidencePolicy,
              policySnapshot,
              policyHash
            };
            try {
              validateBookedPayload(bookingPayload);
            } catch (err) {
              return sendError(res, 400, "invalid booking", { message: err?.message });
            }

            const bookedDraft = createChainedEvent({
              streamId: jobId,
              type: "BOOKED",
              actor: { type: "requester", id: body?.requesterId ?? "pilot_requester" },
              payload: bookingPayload,
              at: nowIso()
            });
            events = appendChainedEvent({ events, event: bookedDraft, signer: serverSigner });
            const bookedEvent = events[events.length - 1];

            let ledgerEntries = [];
            try {
              // jobBefore for BOOKED is the job after quote.
              const jobBeforeBook = reduceJob(events.slice(0, -1));
              ledgerEntries = ledgerEntriesForJobEvent({ jobBefore: jobBeforeBook, event: bookedEvent, eventsBefore: events.slice(0, -1) });
            } catch (err) {
              return sendError(res, 400, "ledger posting rejected", { message: err?.message });
            }
            for (const entry of ledgerEntries) {
              if (!entry) continue;
              outboxMessages.push({ type: "LEDGER_ENTRY_APPLY", tenantId, jobId, sourceEventId: bookedEvent.id, entry });
            }

            const requestedAt = nowIso();
            const dispatchDraft = createChainedEvent({
              streamId: jobId,
              type: "DISPATCH_REQUESTED",
              actor: { type: "dispatch", id: "dispatch_v1" },
              payload: { jobId, requestedAt, trigger: "BOOKED" },
              at: requestedAt
            });
            events = appendChainedEvent({ events, event: dispatchDraft, signer: serverSigner });
            const dispatchRequestedEvent = events[events.length - 1];
            outboxMessages.push({ type: "DISPATCH_REQUESTED", tenantId, jobId, sourceEventId: dispatchRequestedEvent.id, at: dispatchRequestedEvent.at });
          }

          let jobAfter;
          try {
            jobAfter = reduceJob(events);
          } catch (err) {
            return sendError(res, 400, "job transition rejected", { message: err?.message });
          }

          const responseBody = { job: jobAfter, events, outboxQueued: outboxMessages.length };
          const ops = [{ kind: "JOB_EVENTS_APPENDED", tenantId, jobId, events }];
          if (idemStoreKey) ops.push({ kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode: 201, body: responseBody } });
          if (outboxMessages.length) ops.push({ kind: "OUTBOX_ENQUEUE", messages: outboxMessages });

          await commitTx(ops);
          return sendJson(res, 201, responseBody);
        }

        return sendError(res, 404, "not found");
      }

      if (req.method === "GET" && path === "/jobs") {
        return sendJson(res, 200, { jobs: listJobs({ tenantId }) });
      }

      if (req.method === "POST" && path === "/jobs") {
        const body = await readJsonBody(req);
        let idemStoreKey = null;
        let idemRequestHash = null;
        try {
          ({ idemStoreKey, idemRequestHash } = readIdempotency({ method: "POST", requestPath: path, expectedPrevChainHash: null, body }));
        } catch (err) {
          return sendError(res, 400, "invalid idempotency key", { message: err?.message });
        }
        if (idemStoreKey) {
          const existing = store.idempotency.get(idemStoreKey);
          if (existing) {
            if (existing.requestHash !== idemRequestHash) {
              return sendError(res, 409, "idempotency key conflict", "request differs from initial use of this key");
            }
            return sendJson(res, existing.statusCode, existing.body);
          }
        }

        {
          const cfg = getTenantConfig(tenantId) ?? {};
          const requestedLimit = cfg?.quotas?.maxOpenJobs ?? 0;
          const limit = clampQuota({ tenantLimit: Number.isSafeInteger(requestedLimit) ? requestedLimit : 0, defaultLimit: 0, maxLimit: quotaPlatformMaxOpenJobs });
          if (limit > 0) {
            const open = countOpenJobsForTenant(tenantId);
            if (isQuotaExceeded({ current: open, limit })) {
              return sendError(res, 429, "tenant quota exceeded", { kind: "open_jobs", limit, current: open }, { code: "TENANT_QUOTA_EXCEEDED" });
            }
          }
        }

        const templateId = body?.templateId;
        if (!templateId) return sendError(res, 400, "templateId is required");

        const jobId = createId("job");

        const createdEvent = createChainedEvent({
          streamId: jobId,
          type: "JOB_CREATED",
          actor: { type: "system", id: "proxy" },
          payload: {
            tenantId,
            customerId: body?.customerId ?? null,
            siteId: body?.siteId ?? null,
            contractId: body?.contractId ?? null,
            templateId,
            constraints: body?.constraints ?? {}
          },
          at: nowIso()
        });
        const events = appendChainedEvent({ events: [], event: createdEvent, signer: serverSigner });
        const jobWithHead = reduceJob(events);

        const ops = [{ kind: "JOB_EVENTS_APPENDED", tenantId, jobId, events }];
        if (idemStoreKey) {
          const responseBody = { job: jobWithHead };
          ops.push({ kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode: 201, body: responseBody } });
        }

        const responseBody = { job: jobWithHead };
        await commitTx(ops);
        return sendJson(res, 201, responseBody);
      }

      const marketplaceParts = path.split("/").filter(Boolean);
      if (marketplaceParts[0] === "marketplace" && marketplaceParts[1] === "providers") {
        if (!(store.marketplaceProviderPublications instanceof Map)) store.marketplaceProviderPublications = new Map();

        if (req.method === "POST" && marketplaceParts.length === 4 && marketplaceParts[2] === "conformance" && marketplaceParts[3] === "run") {
          const body = await readJsonBody(req);

          let manifest = null;
          try {
            manifest = normalizePaidToolManifestV1(body?.manifest);
          } catch (err) {
            return sendError(res, 400, "invalid paid tool manifest", { message: err?.message });
          }

          const providerIdFromBody = body?.providerId === undefined || body?.providerId === null ? null : String(body.providerId).trim();
          let providerId = null;
          try {
            providerId = parseMarketplaceProviderId(providerIdFromBody ?? manifest.providerId, { fieldPath: "providerId" });
          } catch (err) {
            return sendError(res, 400, "invalid providerId", { message: err?.message });
          }
          if (providerId !== String(manifest.providerId)) {
            return sendError(res, 409, "providerId must match manifest.providerId");
          }

          const baseUrl = typeof body?.baseUrl === "string" ? body.baseUrl.trim() : "";
          if (!baseUrl) return sendError(res, 400, "baseUrl is required");
          const urlSafety = checkUrlSafetySync(baseUrl, {
            allowHttp: process.env.NODE_ENV !== "production",
            allowLoopback: process.env.NODE_ENV !== "production",
            allowPrivate: process.env.NODE_ENV !== "production"
          });
          if (!urlSafety.ok) {
            return sendError(res, 400, "unsafe baseUrl", {
              code: urlSafety.code,
              message: urlSafety.message
            });
          }

          const conformanceToolId = body?.toolId === undefined || body?.toolId === null ? null : String(body.toolId).trim();
          const providerSigningPublicKeyPem =
            typeof body?.providerSigningPublicKeyPem === "string" && body.providerSigningPublicKeyPem.trim() !== ""
              ? body.providerSigningPublicKeyPem
              : null;

          let report = null;
          try {
            report = await runProviderConformanceV1({
              providerBaseUrl: baseUrl,
              manifest,
              providerId,
              conformanceToolId,
              providerSigningPublicKeyPem,
              settldSigner: {
                keyId: store?.serverSigner?.keyId,
                publicKeyPem: store?.serverSigner?.publicKeyPem,
                privateKeyPem: store?.serverSigner?.privateKeyPem
              },
              fetchFn
            });
          } catch (err) {
            return sendError(res, 502, "provider conformance run failed", { message: err?.message });
          }
          return sendJson(res, 200, { report });
        }

        if (req.method === "POST" && marketplaceParts.length === 3 && marketplaceParts[2] === "publish") {
          const body = await readJsonBody(req);
          let idemStoreKey = null;
          let idemRequestHash = null;
          try {
            ({ idemStoreKey, idemRequestHash } = readIdempotency({ method: "POST", requestPath: path, expectedPrevChainHash: null, body }));
          } catch (err) {
            return sendError(res, 400, "invalid idempotency key", { message: err?.message });
          }
          if (idemStoreKey) {
            const existingIdem = store.idempotency.get(idemStoreKey);
            if (existingIdem) {
              if (existingIdem.requestHash !== idemRequestHash) {
                return sendError(res, 409, "idempotency key conflict", "request differs from initial use of this key");
              }
              return sendJson(res, existingIdem.statusCode, existingIdem.body);
            }
          }

          let manifest = null;
          try {
            manifest = normalizePaidToolManifestV1(body?.manifest);
          } catch (err) {
            return sendError(res, 400, "invalid paid tool manifest", { message: err?.message });
          }

          const providerIdFromBody = body?.providerId === undefined || body?.providerId === null ? null : String(body.providerId).trim();
          let providerId = null;
          try {
            providerId = parseMarketplaceProviderId(providerIdFromBody ?? manifest.providerId, { fieldPath: "providerId" });
          } catch (err) {
            return sendError(res, 400, "invalid providerId", { message: err?.message });
          }
          if (providerId !== String(manifest.providerId)) {
            return sendError(res, 409, "providerId must match manifest.providerId");
          }

          const baseUrl = typeof body?.baseUrl === "string" ? body.baseUrl.trim() : "";
          if (!baseUrl) return sendError(res, 400, "baseUrl is required");
          const urlSafety = checkUrlSafetySync(baseUrl, {
            allowHttp: process.env.NODE_ENV !== "production",
            allowLoopback: process.env.NODE_ENV !== "production",
            allowPrivate: process.env.NODE_ENV !== "production"
          });
          if (!urlSafety.ok) {
            return sendError(res, 400, "unsafe baseUrl", {
              code: urlSafety.code,
              message: urlSafety.message
            });
          }

          const runConformance = body?.runConformance !== false;
          const conformanceToolId = body?.toolId === undefined || body?.toolId === null ? null : String(body.toolId).trim();
          const providerSigningPublicKeyPem =
            typeof body?.providerSigningPublicKeyPem === "string" && body.providerSigningPublicKeyPem.trim() !== ""
              ? body.providerSigningPublicKeyPem
              : null;

          let tags = [];
          try {
            tags = body?.tags === undefined ? [] : normalizeMarketplaceCapabilityTagsInput(body.tags, { fieldPath: "tags" });
          } catch (err) {
            return sendError(res, 400, "invalid tags", { message: err?.message });
          }
          const description =
            body?.description === null || body?.description === undefined || String(body.description).trim() === ""
              ? null
              : String(body.description).trim();
          if (description && description.length > 4000) return sendError(res, 400, "description must be <= 4000 chars");
          const contactUrl =
            body?.contactUrl === null || body?.contactUrl === undefined || String(body.contactUrl).trim() === ""
              ? null
              : String(body.contactUrl).trim();
          const termsUrl =
            body?.termsUrl === null || body?.termsUrl === undefined || String(body.termsUrl).trim() === ""
              ? null
              : String(body.termsUrl).trim();

          const existing = getMarketplaceProviderPublication({ tenantId, providerId });

          let report = null;
          if (runConformance) {
            try {
              report = await runProviderConformanceV1({
                providerBaseUrl: baseUrl,
                manifest,
                providerId,
                conformanceToolId,
                providerSigningPublicKeyPem,
                settldSigner: {
                  keyId: store?.serverSigner?.keyId,
                  publicKeyPem: store?.serverSigner?.publicKeyPem,
                  privateKeyPem: store?.serverSigner?.privateKeyPem
                },
                fetchFn
              });
            } catch (err) {
              return sendError(res, 502, "provider conformance run failed", { message: err?.message });
            }
          }

          const nowAt = nowIso();
          const status = runConformance ? (report?.verdict?.ok === true ? "certified" : "conformance_failed") : "draft";
          let providerSigning = existing?.providerSigning ?? null;
          if (providerSigningPublicKeyPem) {
            try {
              providerSigning = {
                algorithm: "ed25519",
                keyId: keyIdFromPublicKeyPem(providerSigningPublicKeyPem),
                publicKeyPem: providerSigningPublicKeyPem
              };
            } catch (err) {
              return sendError(res, 400, "invalid providerSigningPublicKeyPem", { message: err?.message });
            }
          }

          const publication = {
            schemaVersion: MARKETPLACE_PROVIDER_PUBLICATION_SCHEMA_VERSION,
            publicationId: existing?.publicationId ?? createId("pub"),
            tenantId,
            providerId,
            status,
            baseUrl,
            description,
            tags,
            contactUrl,
            termsUrl,
            manifestSchemaVersion: String(manifest.schemaVersion),
            manifestHash: computePaidToolManifestHashV1(manifest),
            manifest,
            conformanceReport: report,
            providerSigning,
            certified: status === "certified",
            publishedAt: existing?.publishedAt ?? nowAt,
            certifiedAt: status === "certified" ? nowAt : null,
            updatedAt: nowAt
          };
          store.marketplaceProviderPublications.set(providerPublicationStoreKey(tenantId, providerId), publication);
          const statusCode = existing ? 200 : 201;
          const responseBody = { publication };
          if (idemStoreKey) {
            await commitTx([{ kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode, body: responseBody } }]);
          }
          return sendJson(res, statusCode, responseBody);
        }

        if (req.method === "GET" && marketplaceParts.length === 2) {
          let status = "certified";
          try {
            status = parseMarketplaceProviderPublicationStatus(url.searchParams.get("status"), {
              allowAll: true,
              defaultStatus: "certified"
            });
          } catch (err) {
            return sendError(res, 400, "invalid provider listing status", { message: err?.message });
          }
          const providerId = url.searchParams.get("providerId");
          const search = url.searchParams.get("q");
          const toolId = url.searchParams.get("toolId");
          const { limit, offset } = parsePagination({
            limitRaw: url.searchParams.get("limit"),
            offsetRaw: url.searchParams.get("offset"),
            defaultLimit: 50,
            maxLimit: 200
          });
          const rows = listMarketplaceProviderPublications({ tenantId, status, providerId, search, toolId });
          const publications = rows.slice(offset, offset + limit).map((row) => ({
            schemaVersion: row.schemaVersion,
            publicationId: row.publicationId,
            tenantId: row.tenantId,
            providerId: row.providerId,
            status: row.status,
            certified: row.certified === true,
            baseUrl: row.baseUrl,
            description: row.description ?? null,
            tags: Array.isArray(row.tags) ? row.tags : [],
            toolCount: Array.isArray(row?.manifest?.tools) ? row.manifest.tools.length : 0,
            manifestSchemaVersion: row.manifestSchemaVersion,
            manifestHash: row.manifestHash,
            conformance: row.conformanceReport
              ? {
                  schemaVersion: row.conformanceReport.schemaVersion ?? null,
                  generatedAt: row.conformanceReport.generatedAt ?? null,
                  verdict: row.conformanceReport.verdict ?? null
                }
              : null,
            certificationBadge: buildMarketplaceProviderCertificationBadge(row),
            publishedAt: row.publishedAt ?? null,
            certifiedAt: row.certifiedAt ?? null,
            updatedAt: row.updatedAt ?? null
          }));
          return sendJson(res, 200, { publications, total: rows.length, limit, offset });
        }

        if (req.method === "GET" && marketplaceParts.length === 4 && marketplaceParts[3] === "badge") {
          let providerId = null;
          try {
            providerId = parseMarketplaceProviderId(marketplaceParts[2], { fieldPath: "providerId" });
          } catch (err) {
            return sendError(res, 400, "invalid providerId", { message: err?.message });
          }
          const publication = getMarketplaceProviderPublication({ tenantId, providerId });
          if (!publication) return sendError(res, 404, "provider publication not found");
          const badge = buildMarketplaceProviderCertificationBadge(publication);
          return sendJson(res, 200, { badge });
        }

        if (req.method === "GET" && marketplaceParts.length === 3) {
          let providerId = null;
          try {
            providerId = parseMarketplaceProviderId(marketplaceParts[2], { fieldPath: "providerId" });
          } catch (err) {
            return sendError(res, 400, "invalid providerId", { message: err?.message });
          }
          const publication = getMarketplaceProviderPublication({ tenantId, providerId });
          if (!publication) return sendError(res, 404, "provider publication not found");
          return sendJson(res, 200, { publication, certificationBadge: buildMarketplaceProviderCertificationBadge(publication) });
        }

        return sendError(res, 404, "not found");
      }

      if (marketplaceParts[0] === "marketplace" && marketplaceParts[1] === "tools") {
        if (req.method === "GET" && marketplaceParts.length === 2) {
          let status = "certified";
          try {
            status = parseMarketplaceProviderPublicationStatus(url.searchParams.get("status"), {
              allowAll: true,
              defaultStatus: "certified"
            });
          } catch (err) {
            return sendError(res, 400, "invalid provider listing status", { message: err?.message });
          }
          const providerId = url.searchParams.get("providerId");
          const search = url.searchParams.get("q");
          const toolId = url.searchParams.get("toolId");
          const tags = url.searchParams.get("tags");
          const { limit, offset } = parsePagination({
            limitRaw: url.searchParams.get("limit"),
            offsetRaw: url.searchParams.get("offset"),
            defaultLimit: 50,
            maxLimit: 200
          });

          const rows = listMarketplaceToolListings({ tenantId, status, providerId, toolId, search, tags });
          const tools = rows.slice(offset, offset + limit);
          return sendJson(res, 200, { tools, total: rows.length, limit, offset });
        }
        return sendError(res, 404, "not found");
      }

      if (marketplaceParts[0] === "marketplace" && marketplaceParts[1] === "capability-listings") {
        if (!(store.marketplaceCapabilityListings instanceof Map)) store.marketplaceCapabilityListings = new Map();

        if (req.method === "POST" && (marketplaceParts.length === 2 || marketplaceParts.length === 3)) {
          const body = await readJsonBody(req);
          let idemStoreKey = null;
          let idemRequestHash = null;
          try {
            ({ idemStoreKey, idemRequestHash } = readIdempotency({ method: "POST", requestPath: path, expectedPrevChainHash: null, body }));
          } catch (err) {
            return sendError(res, 400, "invalid idempotency key", { message: err?.message });
          }
          if (idemStoreKey) {
            const existingIdem = store.idempotency.get(idemStoreKey);
            if (existingIdem) {
              if (existingIdem.requestHash !== idemRequestHash) {
                return sendError(res, 409, "idempotency key conflict", "request differs from initial use of this key");
              }
              return sendJson(res, existingIdem.statusCode, existingIdem.body);
            }
          }

          const pathListingIdRaw = marketplaceParts.length === 3 ? marketplaceParts[2] : null;
          let pathListingId = null;
          try {
            pathListingId = parseMarketplaceCapabilityListingId(pathListingIdRaw, { fieldPath: "listingId", allowNull: true });
          } catch (err) {
            return sendError(res, 400, "invalid listing id", { message: err?.message });
          }

          let requestedListingId = null;
          try {
            requestedListingId =
              pathListingId ??
              parseMarketplaceCapabilityListingId(body?.listingId, {
                fieldPath: "listingId",
                allowNull: true
              }) ??
              createId("caplst");
          } catch (err) {
            return sendError(res, 400, "invalid listing id", { message: err?.message });
          }

          if (pathListingId && body?.listingId !== undefined && String(body.listingId).trim() !== pathListingId) {
            return sendError(res, 409, "listingId in path/body must match");
          }

          const existingListing = getMarketplaceCapabilityListing({ tenantId, listingId: requestedListingId });
          if (pathListingId && !existingListing) return sendError(res, 404, "capability listing not found");

          let capability = null;
          if (body?.capability !== undefined) {
            capability = String(body.capability ?? "").trim();
            if (!capability) return sendError(res, 400, "capability is required");
            if (capability.length > 128) return sendError(res, 400, "capability must be <= 128 chars");
          } else {
            capability = String(existingListing?.capability ?? "").trim() || null;
          }
          if (!capability) return sendError(res, 400, "capability is required");

          const titleRaw = body?.title !== undefined ? body.title : existingListing?.title ?? capability;
          const title = String(titleRaw ?? "").trim() || capability;
          if (title.length > 240) return sendError(res, 400, "title must be <= 240 chars");
          const description =
            body?.description === undefined
              ? existingListing?.description ?? null
              : body.description === null || String(body.description ?? "").trim() === ""
                ? null
                : String(body.description).trim();
          if (description && description.length > 4000) return sendError(res, 400, "description must be <= 4000 chars");
          const category =
            body?.category === undefined
              ? existingListing?.category ?? null
              : body.category === null || String(body.category ?? "").trim() === ""
                ? null
                : String(body.category).trim();
          if (category && category.length > 128) return sendError(res, 400, "category must be <= 128 chars");

          let sellerAgentId = null;
          if (body?.sellerAgentId === undefined) {
            sellerAgentId = existingListing?.sellerAgentId ?? null;
          } else {
            sellerAgentId = body.sellerAgentId === null || String(body.sellerAgentId ?? "").trim() === "" ? null : String(body.sellerAgentId).trim();
          }
          if (sellerAgentId) {
            let sellerIdentity = null;
            try {
              sellerIdentity = await getAgentIdentityRecord({ tenantId, agentId: sellerAgentId });
            } catch (err) {
              return sendError(res, 400, "invalid sellerAgentId", { message: err?.message });
            }
            if (!sellerIdentity) return sendError(res, 404, "seller agent identity not found");
          }

          let status = null;
          try {
            status = parseMarketplaceCapabilityListingStatus(body?.status ?? existingListing?.status ?? "active", {
              allowAll: false,
              defaultStatus: "active"
            });
          } catch (err) {
            return sendError(res, 400, "invalid capability listing status", { message: err?.message });
          }

          let tags = null;
          try {
            tags =
              body?.tags === undefined
                ? normalizeMarketplaceCapabilityTagsInput(existingListing?.tags ?? [])
                : normalizeMarketplaceCapabilityTagsInput(body.tags);
          } catch (err) {
            return sendError(res, 400, "invalid tags", { message: err?.message });
          }

          let priceModel = null;
          try {
            priceModel =
              body?.priceModel === undefined
                ? normalizeMarketplaceCapabilityPriceModelInput(existingListing?.priceModel ?? null)
                : normalizeMarketplaceCapabilityPriceModelInput(body.priceModel);
          } catch (err) {
            return sendError(res, 400, "invalid priceModel", { message: err?.message });
          }

          let availability = null;
          if (body?.availability === undefined) {
            availability = existingListing?.availability ?? null;
          } else if (body.availability === null) {
            availability = null;
          } else if (typeof body.availability !== "object" || Array.isArray(body.availability)) {
            return sendError(res, 400, "availability must be an object or null");
          } else {
            const timezone =
              body.availability.timezone === null || body.availability.timezone === undefined || String(body.availability.timezone).trim() === ""
                ? null
                : String(body.availability.timezone).trim();
            const windows = Array.isArray(body.availability.windows) ? body.availability.windows : [];
            availability = {
              schemaVersion: "MarketplaceCapabilityAvailability.v1",
              timezone,
              windows
            };
          }

          const metadata =
            body?.metadata === undefined
              ? existingListing?.metadata ?? null
              : body.metadata === null
                ? null
                : typeof body.metadata === "object" && !Array.isArray(body.metadata)
                  ? { ...body.metadata }
                  : null;
          if (body?.metadata !== undefined && metadata === null && body.metadata !== null) {
            return sendError(res, 400, "metadata must be an object or null");
          }

          const nowAt = nowIso();
          const listing = {
            schemaVersion: "MarketplaceCapabilityListing.v1",
            listingId: requestedListingId,
            tenantId,
            capability,
            title,
            description,
            category,
            sellerAgentId,
            status,
            tags,
            priceModel,
            availability,
            metadata,
            createdAt: existingListing?.createdAt ?? nowAt,
            updatedAt: nowAt
          };
          store.marketplaceCapabilityListings.set(capabilityListingStoreKey(tenantId, requestedListingId), listing);
          const statusCode = existingListing ? 200 : 201;
          const responseBody = { listing };
          if (idemStoreKey) {
            await commitTx([{ kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode, body: responseBody } }]);
          }
          return sendJson(res, statusCode, responseBody);
        }

        if (req.method === "GET" && marketplaceParts.length === 2) {
          let status = "all";
          try {
            status = parseMarketplaceCapabilityListingStatus(url.searchParams.get("status"), {
              allowAll: true,
              defaultStatus: "all"
            });
          } catch (err) {
            return sendError(res, 400, "invalid capability listing query", { message: err?.message });
          }
          const capability = url.searchParams.get("capability");
          const sellerAgentId = url.searchParams.get("sellerAgentId");
          const search = url.searchParams.get("q");
          const { limit, offset } = parsePagination({
            limitRaw: url.searchParams.get("limit"),
            offsetRaw: url.searchParams.get("offset"),
            defaultLimit: 50,
            maxLimit: 200
          });
          const rows = listMarketplaceCapabilityListings({ tenantId, status, capability, sellerAgentId, search });
          return sendJson(res, 200, { listings: rows.slice(offset, offset + limit), total: rows.length, limit, offset });
        }

        if (req.method === "GET" && marketplaceParts.length === 3) {
          let listingId = null;
          try {
            listingId = parseMarketplaceCapabilityListingId(marketplaceParts[2], { fieldPath: "listingId" });
          } catch (err) {
            return sendError(res, 400, "invalid listing id", { message: err?.message });
          }
          const listing = getMarketplaceCapabilityListing({ tenantId, listingId });
          if (!listing) return sendError(res, 404, "capability listing not found");
          return sendJson(res, 200, { listing });
        }

        if (req.method === "DELETE" && marketplaceParts.length === 3) {
          let idemStoreKey = null;
          let idemRequestHash = null;
          const body = {};
          try {
            ({ idemStoreKey, idemRequestHash } = readIdempotency({ method: "DELETE", requestPath: path, expectedPrevChainHash: null, body }));
          } catch (err) {
            return sendError(res, 400, "invalid idempotency key", { message: err?.message });
          }
          if (idemStoreKey) {
            const existingIdem = store.idempotency.get(idemStoreKey);
            if (existingIdem) {
              if (existingIdem.requestHash !== idemRequestHash) {
                return sendError(res, 409, "idempotency key conflict", "request differs from initial use of this key");
              }
              return sendJson(res, existingIdem.statusCode, existingIdem.body);
            }
          }

          let listingId = null;
          try {
            listingId = parseMarketplaceCapabilityListingId(marketplaceParts[2], { fieldPath: "listingId" });
          } catch (err) {
            return sendError(res, 400, "invalid listing id", { message: err?.message });
          }
          const listing = getMarketplaceCapabilityListing({ tenantId, listingId });
          if (!listing) return sendError(res, 404, "capability listing not found");
          store.marketplaceCapabilityListings.delete(capabilityListingStoreKey(tenantId, listingId));
          const responseBody = { ok: true, deleted: true, listingId, listing };
          if (idemStoreKey) {
            await commitTx([{ kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode: 200, body: responseBody } }]);
          }
          return sendJson(res, 200, responseBody);
        }

        return sendError(res, 404, "not found");
      }

      if (marketplaceParts[0] === "marketplace" && marketplaceParts[1] === "settlement-policies") {
        if (!(store.tenantSettlementPolicies instanceof Map)) store.tenantSettlementPolicies = new Map();

        if (req.method === "POST" && marketplaceParts.length === 2) {
          const body = await readJsonBody(req);
          let idemStoreKey = null;
          let idemRequestHash = null;
          try {
            ({ idemStoreKey, idemRequestHash } = readIdempotency({ method: "POST", requestPath: path, expectedPrevChainHash: null, body }));
          } catch (err) {
            return sendError(res, 400, "invalid idempotency key", { message: err?.message });
          }
          if (idemStoreKey) {
            const existingIdem = store.idempotency.get(idemStoreKey);
            if (existingIdem) {
              if (existingIdem.requestHash !== idemRequestHash) {
                return sendError(res, 409, "idempotency key conflict", "request differs from initial use of this key");
              }
              return sendJson(res, existingIdem.statusCode, existingIdem.body);
            }
          }

          let policyId = null;
          try {
            policyId = parseSettlementPolicyRegistryId(body?.policyId, { fieldPath: "policyId" });
          } catch (err) {
            return sendError(res, 400, "invalid policy registry id", { message: err?.message });
          }

          let requestedVersion = null;
          try {
            requestedVersion =
              body?.policyVersion === undefined || body?.policyVersion === null || body?.policyVersion === ""
                ? null
                : parseSettlementPolicyVersion(body.policyVersion, { fieldPath: "policyVersion" });
          } catch (err) {
            return sendError(res, 400, "invalid policy version", { message: err?.message });
          }

          let verificationMethod = null;
          try {
            verificationMethod = parseVerificationMethodInput(body?.verificationMethod ?? null);
          } catch (err) {
            return sendError(res, 400, "invalid verificationMethod", { message: err?.message });
          }

          const rawPolicy = body?.policy;
          if (!rawPolicy || typeof rawPolicy !== "object" || Array.isArray(rawPolicy)) {
            return sendError(res, 400, "policy is required");
          }

          let policy = null;
          try {
            const policyInput = {
              ...rawPolicy,
              ...(requestedVersion === null ? {} : { policyVersion: requestedVersion })
            };
            policy = parseSettlementPolicyInput(policyInput);
          } catch (err) {
            return sendError(res, 400, "invalid policy", { message: err?.message });
          }

          const metadata = body?.metadata ?? null;
          if (metadata !== null && (typeof metadata !== "object" || Array.isArray(metadata))) {
            return sendError(res, 400, "metadata must be an object or null");
          }
          const description =
            body?.description === null || body?.description === undefined || String(body.description).trim() === ""
              ? null
              : String(body.description).trim();

          const policyVersion = Number(policy.policyVersion);
          const verificationMethodHash = computeVerificationMethodHash(verificationMethod);
          const existingPolicy = getTenantSettlementPolicyRecord({ tenantId, policyId, policyVersion });
          if (
            existingPolicy &&
            (String(existingPolicy.policyHash ?? "") !== String(policy.policyHash ?? "") ||
              String(existingPolicy.verificationMethodHash ?? "") !== String(verificationMethodHash))
          ) {
            return sendError(res, 409, "policy version already exists with different canonical hashes");
          }

          const nowAt = nowIso();
          const record = {
            schemaVersion: TENANT_SETTLEMENT_POLICY_SCHEMA_VERSION,
            tenantId,
            policyId,
            policyVersion,
            policyHash: String(policy.policyHash),
            verificationMethodHash: String(verificationMethodHash),
            verificationMethod,
            policy,
            description,
            metadata: metadata ? { ...metadata } : null,
            createdAt: existingPolicy?.createdAt ?? nowAt,
            updatedAt: nowAt
          };
          const statusCode = existingPolicy ? 200 : 201;
          const responseBody = { policy: record };
          const ops = [{ kind: "TENANT_SETTLEMENT_POLICY_UPSERT", tenantId, policy: record }];
          if (idemStoreKey) {
            ops.push({ kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode, body: responseBody } });
          }
          await commitTx(ops);
          return sendJson(res, statusCode, responseBody);
        }

        if (req.method === "GET" && marketplaceParts.length === 2) {
          const policyId = url.searchParams.get("policyId");
          const { limit, offset } = parsePagination({
            limitRaw: url.searchParams.get("limit"),
            offsetRaw: url.searchParams.get("offset"),
            defaultLimit: 50,
            maxLimit: 200
          });
          let policies = null;
          try {
            policies = listTenantSettlementPolicyRecords({ tenantId, policyId });
          } catch (err) {
            return sendError(res, 400, "invalid settlement policy query", { message: err?.message });
          }
          const rows = policies.slice(offset, offset + limit);
          return sendJson(res, 200, { policies: rows, total: policies.length, limit, offset });
        }

        if (req.method === "GET" && marketplaceParts.length === 4) {
          let policyId = null;
          let policyVersion = null;
          try {
            policyId = parseSettlementPolicyRegistryId(marketplaceParts[2], { fieldPath: "policyId" });
            policyVersion = parseSettlementPolicyVersion(marketplaceParts[3], { fieldPath: "policyVersion" });
          } catch (err) {
            return sendError(res, 400, "invalid settlement policy reference", { message: err?.message });
          }
          const record = getTenantSettlementPolicyRecord({ tenantId, policyId, policyVersion });
          if (!record) return sendError(res, 404, "settlement policy not found");
          return sendJson(res, 200, { policy: record });
        }

        return sendError(res, 404, "not found");
      }

      if (marketplaceParts[0] === "marketplace" && marketplaceParts[1] === "rfqs") {
        if (!(store.marketplaceRfqs instanceof Map)) store.marketplaceRfqs = new Map();
        if (!(store.marketplaceRfqBids instanceof Map)) store.marketplaceRfqBids = new Map();

        if (req.method === "POST" && marketplaceParts.length === 2) {
          const body = await readJsonBody(req);
          let idemStoreKey = null;
          let idemRequestHash = null;
          try {
            ({ idemStoreKey, idemRequestHash } = readIdempotency({ method: "POST", requestPath: path, expectedPrevChainHash: null, body }));
          } catch (err) {
            return sendError(res, 400, "invalid idempotency key", { message: err?.message });
          }
          if (idemStoreKey) {
            const existingIdem = store.idempotency.get(idemStoreKey);
            if (existingIdem) {
              if (existingIdem.requestHash !== idemRequestHash) {
                return sendError(res, 409, "idempotency key conflict", "request differs from initial use of this key");
              }
              return sendJson(res, existingIdem.statusCode, existingIdem.body);
            }
          }

          if (body?.taskId !== undefined && body?.taskId !== null) {
            return sendError(res, 400, "unsupported identifier field; use rfqId");
          }
          const rfqId = body?.rfqId && String(body.rfqId).trim() !== "" ? String(body.rfqId).trim() : createId("rfq");
          const title = body?.title && String(body.title).trim() !== "" ? String(body.title).trim() : null;
          const capability = body?.capability && String(body.capability).trim() !== "" ? String(body.capability).trim() : null;
          if (!title && !capability) return sendError(res, 400, "rfq title or capability is required");

          const posterAgentId = body?.posterAgentId && String(body.posterAgentId).trim() !== "" ? String(body.posterAgentId).trim() : null;
          if (posterAgentId) {
            let posterIdentity = null;
            try {
              posterIdentity = await getAgentIdentityRecord({ tenantId, agentId: posterAgentId });
            } catch (err) {
              return sendError(res, 400, "invalid posterAgentId", { message: err?.message });
            }
            if (!posterIdentity) return sendError(res, 404, "poster agent identity not found");
          }

          let taskDirection = null;
          try {
            taskDirection = parseInteractionDirection({ fromTypeRaw: body?.fromType, toTypeRaw: body?.toType });
          } catch (err) {
            return sendError(res, 400, "invalid interaction direction", { message: err?.message });
          }

          const existingTask = getMarketplaceRfq({ tenantId, rfqId });
          if (existingTask && !idemStoreKey) return sendError(res, 409, "marketplace rfq already exists");

          let budgetCents = null;
          if (body?.budgetCents !== undefined && body?.budgetCents !== null) {
            const parsedBudget = Number(body.budgetCents);
            if (!Number.isSafeInteger(parsedBudget) || parsedBudget <= 0) {
              return sendError(res, 400, "budgetCents must be a positive safe integer");
            }
            budgetCents = parsedBudget;
          }

          const currency = body?.currency ? String(body.currency).trim().toUpperCase() : "USD";
          if (currency === "") return sendError(res, 400, "currency must be a non-empty string");

          let deadlineAt = null;
          if (body?.deadlineAt !== undefined && body?.deadlineAt !== null) {
            if (typeof body.deadlineAt !== "string" || body.deadlineAt.trim() === "") return sendError(res, 400, "deadlineAt must be an ISO date-time");
            const deadlineMs = Date.parse(body.deadlineAt);
            if (!Number.isFinite(deadlineMs)) return sendError(res, 400, "deadlineAt must be an ISO date-time");
            deadlineAt = new Date(deadlineMs).toISOString();
          }

          const metadata = body?.metadata ?? null;
          if (metadata !== null && (typeof metadata !== "object" || Array.isArray(metadata))) {
            return sendError(res, 400, "metadata must be an object or null");
          }
          let counterOfferPolicy = null;
          try {
            counterOfferPolicy = normalizeMarketplaceCounterOfferPolicyInput(body?.counterOfferPolicy ?? null, {
              fieldPath: "counterOfferPolicy"
            });
          } catch (err) {
            return sendError(res, 400, "invalid counterOfferPolicy", { message: err?.message });
          }

          const nowAt = nowIso();
          const rfq = {
            schemaVersion: "MarketplaceRfq.v1",
            rfqId,
            tenantId,
            title: title ?? capability,
            description: body?.description && String(body.description).trim() !== "" ? String(body.description).trim() : null,
            capability,
            fromType: taskDirection.fromType,
            toType: taskDirection.toType,
            posterAgentId,
            status: "open",
            budgetCents,
            currency,
            deadlineAt,
            acceptedBidId: null,
            acceptedBidderAgentId: null,
            acceptedAt: null,
            counterOfferPolicy,
            metadata: metadata ? { ...metadata } : null,
            createdAt: nowAt,
            updatedAt: nowAt
          };

          const existingBids = listMarketplaceRfqBids({ tenantId, rfqId, status: "all" });
          const ops = [
            { kind: "MARKETPLACE_RFQ_UPSERT", tenantId, rfq },
            { kind: "MARKETPLACE_RFQ_BIDS_SET", tenantId, rfqId, bids: existingBids }
          ];
          const responseBody = { rfq: toMarketplaceRfqResponse(rfq) };
          if (idemStoreKey) {
            ops.push({ kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode: 201, body: responseBody } });
          }
          await commitTx(ops);
          return sendJson(res, 201, responseBody);
        }

        if (req.method === "GET" && marketplaceParts.length === 2) {
          let status = "all";
          try {
            status = parseMarketplaceRfqStatus(url.searchParams.get("status"), { allowAll: true, defaultStatus: "all" });
          } catch (err) {
            return sendError(res, 400, "invalid marketplace rfq query", { message: err?.message });
          }

          const capability = url.searchParams.get("capability");
          const posterAgentId = url.searchParams.get("posterAgentId");
          const { limit, offset } = parsePagination({
            limitRaw: url.searchParams.get("limit"),
            offsetRaw: url.searchParams.get("offset"),
            defaultLimit: 50,
            maxLimit: 200
          });

          const allRfqs = listMarketplaceRfqs({ tenantId, status, capability, posterAgentId });
          const rfqs = allRfqs.slice(offset, offset + limit);
          return sendJson(res, 200, { rfqs: rfqs.map((rfq) => toMarketplaceRfqResponse(rfq)), total: allRfqs.length, limit, offset });
        }

        const rfqId = marketplaceParts[2] ? String(marketplaceParts[2]) : null;
        if (!rfqId) return sendError(res, 404, "not found");

        const rfq = getMarketplaceRfq({ tenantId, rfqId });
        if (!rfq) return sendError(res, 404, "marketplace rfq not found");

        if (req.method === "GET" && marketplaceParts.length === 4 && marketplaceParts[3] === "bids") {
          let status = "all";
          try {
            status = parseMarketplaceBidStatus(url.searchParams.get("status"), { allowAll: true, defaultStatus: "all" });
          } catch (err) {
            return sendError(res, 400, "invalid marketplace bid query", { message: err?.message });
          }

          const bidderAgentId = url.searchParams.get("bidderAgentId");
          const { limit, offset } = parsePagination({
            limitRaw: url.searchParams.get("limit"),
            offsetRaw: url.searchParams.get("offset"),
            defaultLimit: 50,
            maxLimit: 200
          });

          const allBids = listMarketplaceRfqBids({ tenantId, rfqId, status, bidderAgentId });
          const bids = allBids.slice(offset, offset + limit);
          return sendJson(res, 200, { rfqId, bids: bids.map((bid) => toMarketplaceBidResponse(bid)), total: allBids.length, limit, offset });
        }

        if (req.method === "POST" && marketplaceParts.length === 4 && marketplaceParts[3] === "bids") {
          const body = await readJsonBody(req);
          let idemStoreKey = null;
          let idemRequestHash = null;
          try {
            ({ idemStoreKey, idemRequestHash } = readIdempotency({ method: "POST", requestPath: path, expectedPrevChainHash: null, body }));
          } catch (err) {
            return sendError(res, 400, "invalid idempotency key", { message: err?.message });
          }
          if (idemStoreKey) {
            const existingIdem = store.idempotency.get(idemStoreKey);
            if (existingIdem) {
              if (existingIdem.requestHash !== idemRequestHash) {
                return sendError(res, 409, "idempotency key conflict", "request differs from initial use of this key");
              }
              return sendJson(res, existingIdem.statusCode, existingIdem.body);
            }
          }

          if (String(rfq.status ?? "open").toLowerCase() !== "open") return sendError(res, 409, "marketplace rfq is not open for bidding");

          const bidderAgentId = body?.bidderAgentId && String(body.bidderAgentId).trim() !== "" ? String(body.bidderAgentId).trim() : null;
          if (!bidderAgentId) return sendError(res, 400, "bidderAgentId is required");

          let bidderIdentity = null;
          try {
            bidderIdentity = await getAgentIdentityRecord({ tenantId, agentId: bidderAgentId });
          } catch (err) {
            return sendError(res, 400, "invalid bidderAgentId", { message: err?.message });
          }
          if (!bidderIdentity) return sendError(res, 404, "bidder agent identity not found");

          let rfqDirection = null;
          let bidDirection = null;
          try {
            rfqDirection = parseInteractionDirection({ fromTypeRaw: rfq?.fromType, toTypeRaw: rfq?.toType });
            bidDirection = parseInteractionDirection({
              fromTypeRaw: body?.fromType,
              toTypeRaw: body?.toType,
              defaultFromType: rfqDirection.fromType,
              defaultToType: rfqDirection.toType
            });
          } catch (err) {
            return sendError(res, 400, "invalid interaction direction", { message: err?.message });
          }
          if (bidDirection.fromType !== rfqDirection.fromType || bidDirection.toType !== rfqDirection.toType) {
            return sendError(res, 409, "bid interaction direction must match rfq direction");
          }

          const amountCents = Number(body?.amountCents);
          if (!Number.isSafeInteger(amountCents) || amountCents <= 0) return sendError(res, 400, "amountCents must be a positive safe integer");

          const currency = body?.currency ? String(body.currency).trim().toUpperCase() : String(rfq.currency ?? "USD").toUpperCase();
          if (!currency) return sendError(res, 400, "currency must be a non-empty string");
          if (String(rfq.currency ?? "USD").toUpperCase() !== currency) {
            return sendError(res, 409, "bid currency must match rfq currency");
          }

          let etaSeconds = null;
          if (body?.etaSeconds !== undefined && body?.etaSeconds !== null) {
            const parsedEta = Number(body.etaSeconds);
            if (!Number.isSafeInteger(parsedEta) || parsedEta <= 0) return sendError(res, 400, "etaSeconds must be a positive safe integer");
            etaSeconds = parsedEta;
          }

          const metadata = body?.metadata ?? null;
          if (metadata !== null && (typeof metadata !== "object" || Array.isArray(metadata))) {
            return sendError(res, 400, "metadata must be an object or null");
          }

          let policySelection = null;
          try {
            policySelection = resolveMarketplaceSettlementPolicySelection({
              tenantId,
              policyRefInput: body?.policyRef ?? null,
              verificationMethodInput: body?.verificationMethod ?? undefined,
              settlementPolicyInput: body?.policy ?? undefined
            });
          } catch (err) {
            if (err?.code === "TENANT_SETTLEMENT_POLICY_NOT_FOUND") {
              return sendError(res, 404, "policyRef not found");
            }
            if (err?.code === "TENANT_SETTLEMENT_POLICY_REF_MISMATCH") {
              return sendError(res, 409, "policyRef does not match verificationMethod/policy", { message: err?.message });
            }
            if (err?.code === "INVALID_VERIFICATION_METHOD") {
              return sendError(res, 400, "invalid verificationMethod", { message: err?.message });
            }
            if (err?.code === "INVALID_SETTLEMENT_POLICY") {
              return sendError(res, 400, "invalid policy", { message: err?.message });
            }
            return sendError(res, 400, "invalid policy selection", { message: err?.message });
          }
          const verificationMethod = policySelection.verificationMethod;
          const policy = policySelection.policy;
          const policyRef = policySelection.policyRef;

          const bidId = body?.bidId && String(body.bidId).trim() !== "" ? String(body.bidId).trim() : createId("bid");
          const allExistingBids = listMarketplaceRfqBids({ tenantId, rfqId, status: "all" });
          const duplicate = allExistingBids.find((row) => String(row?.bidId ?? "") === bidId);
          if (duplicate && !idemStoreKey) return sendError(res, 409, "marketplace bid already exists");

          const nowAt = nowIso();
          const counterOfferPolicy = resolveMarketplaceCounterOfferPolicy({ rfq: rfq, bid: null });
          const initialProposal = buildMarketplaceBidNegotiationProposal({
            rfq: rfq,
            bidId,
            revision: 1,
            proposerAgentId: bidderAgentId,
            amountCents,
            currency,
            etaSeconds,
            note: body?.note && String(body.note).trim() !== "" ? String(body.note).trim() : null,
            verificationMethodInput: verificationMethod,
            settlementPolicyInput: policy,
            policyRefInput: policyRef,
            metadataInput: metadata,
            proposalIdInput: body?.proposalId ?? null,
            proposedAt: nowAt
          });
          const negotiation = buildMarketplaceBidNegotiation({
            bidId,
            initialProposal,
            counterOfferPolicy,
            at: nowAt
          });
          const bid = {
            schemaVersion: "MarketplaceBid.v1",
            bidId,
            rfqId,
            tenantId,
            fromType: bidDirection.fromType,
            toType: bidDirection.toType,
            bidderAgentId,
            amountCents,
            currency,
            etaSeconds,
            note: body?.note && String(body.note).trim() !== "" ? String(body.note).trim() : null,
            status: "pending",
            acceptedAt: null,
            rejectedAt: null,
            negotiation,
            counterOfferPolicy,
            verificationMethod,
            policy,
            policyRef,
            metadata: metadata ? { ...metadata } : null,
            createdAt: nowAt,
            updatedAt: nowAt
          };
          const nextBids = [...allExistingBids, bid];
          const nextRfq = { ...rfq, updatedAt: nowAt };
          const responseBody = { rfq: toMarketplaceRfqResponse(nextRfq), bid: toMarketplaceBidResponse(bid) };
          const ops = [
            { kind: "MARKETPLACE_RFQ_UPSERT", tenantId, rfq: nextRfq },
            { kind: "MARKETPLACE_RFQ_BIDS_SET", tenantId, rfqId, bids: nextBids }
          ];
          if (idemStoreKey) {
            ops.push({ kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode: 201, body: responseBody } });
          }
          await commitTx(ops);
          try {
            await emitMarketplaceLifecycleArtifact({
              tenantId,
              eventType: "proposal.submitted",
              rfqId: rfqId,
              sourceEventId: initialProposal?.proposalId ?? null,
              actorAgentId: bidderAgentId,
              details: {
                bidId,
                revision: initialProposal?.revision ?? 1,
                proposal: initialProposal,
                negotiation
              }
            });
          } catch {
            // Best-effort lifecycle delivery.
          }
          return sendJson(res, 201, responseBody);
        }

        if (req.method === "POST" && marketplaceParts.length === 6 && marketplaceParts[3] === "bids" && marketplaceParts[5] === "counter-offer") {
          const bidId = marketplaceParts[4] ? String(marketplaceParts[4]).trim() : "";
          if (!bidId) return sendError(res, 404, "marketplace bid not found");

          const body = await readJsonBody(req);
          let idemStoreKey = null;
          let idemRequestHash = null;
          try {
            ({ idemStoreKey, idemRequestHash } = readIdempotency({ method: "POST", requestPath: path, expectedPrevChainHash: null, body }));
          } catch (err) {
            return sendError(res, 400, "invalid idempotency key", { message: err?.message });
          }
          if (idemStoreKey) {
            const existingIdem = store.idempotency.get(idemStoreKey);
            if (existingIdem) {
              if (existingIdem.requestHash !== idemRequestHash) {
                return sendError(res, 409, "idempotency key conflict", "request differs from initial use of this key");
              }
              return sendJson(res, existingIdem.statusCode, existingIdem.body);
            }
          }

          if (String(rfq.status ?? "open").toLowerCase() !== "open") return sendError(res, 409, "marketplace rfq is not open for negotiation");

          const proposerAgentId = body?.proposerAgentId && String(body.proposerAgentId).trim() !== "" ? String(body.proposerAgentId).trim() : null;
          if (!proposerAgentId) return sendError(res, 400, "proposerAgentId is required");

          let proposerIdentity = null;
          try {
            proposerIdentity = await getAgentIdentityRecord({ tenantId, agentId: proposerAgentId });
          } catch (err) {
            return sendError(res, 400, "invalid proposerAgentId", { message: err?.message });
          }
          if (!proposerIdentity) return sendError(res, 404, "proposer agent identity not found");

          const allExistingBids = listMarketplaceRfqBids({ tenantId, rfqId, status: "all" });
          const selectedBid = allExistingBids.find((row) => String(row?.bidId ?? "") === bidId) ?? null;
          if (!selectedBid) return sendError(res, 404, "marketplace bid not found");
          if (String(selectedBid.status ?? "pending").toLowerCase() !== "pending") {
            return sendError(res, 409, "marketplace bid is not pending");
          }

          const proposerRole = resolveMarketplaceBidCounterOfferRole({
            rfq: rfq,
            bid: selectedBid,
            proposerAgentId
          });
          if (!proposerRole) {
            return sendError(res, 409, "counter-offer proposer must be rfq poster or bid bidder");
          }
          let counterOfferPolicy = resolveMarketplaceCounterOfferPolicy({ rfq: rfq, bid: selectedBid });
          if (proposerRole === "poster" && counterOfferPolicy.allowPosterCounterOffers !== true) {
            return sendError(res, 409, "counter-offer proposer role blocked by counterOfferPolicy");
          }
          if (proposerRole === "bidder" && counterOfferPolicy.allowBidderCounterOffers !== true) {
            return sendError(res, 409, "counter-offer proposer role blocked by counterOfferPolicy");
          }

          let negotiation =
            selectedBid?.negotiation && typeof selectedBid.negotiation === "object" && !Array.isArray(selectedBid.negotiation)
              ? selectedBid.negotiation
              : null;
          const nowAt = nowIso();
          if (!negotiation) {
            try {
              negotiation = bootstrapMarketplaceBidNegotiation({
                rfq: rfq,
                bid: selectedBid,
                counterOfferPolicy,
                at: nowAt
              });
            } catch (err) {
              return sendError(res, 409, "unable to bootstrap bid negotiation", { message: err?.message });
            }
          }
          const policyApplied = applyMarketplaceBidNegotiationPolicy({
            negotiation,
            counterOfferPolicy,
            at: nowAt,
            expireIfTimedOut: true
          });
          negotiation = policyApplied.negotiation;
          counterOfferPolicy = policyApplied.counterOfferPolicy;
          if (policyApplied.justExpired) {
            const latestExpiredProposal = getLatestMarketplaceBidProposal(negotiation);
            const expiredBid = {
              ...selectedBid,
              negotiation,
              counterOfferPolicy,
              updatedAt: nowAt
            };
            const expiredBids = allExistingBids.map((candidate) => {
              if (!candidate || typeof candidate !== "object") return candidate;
              if (String(candidate.bidId ?? "") !== bidId) return candidate;
              return expiredBid;
            });
            const expiredRfq = {
              ...rfq,
              updatedAt: nowAt
            };
            await commitTx([
              { kind: "MARKETPLACE_RFQ_UPSERT", tenantId, rfq: expiredRfq },
              { kind: "MARKETPLACE_RFQ_BIDS_SET", tenantId, rfqId, bids: expiredBids }
            ]);
            try {
              await emitMarketplaceLifecycleArtifact({
                tenantId,
                eventType: "proposal.expired",
                rfqId: rfqId,
                sourceEventId: latestExpiredProposal?.proposalId ?? null,
                actorAgentId: proposerAgentId,
                details: {
                  bidId,
                  expiresAt: policyApplied.expiresAt ?? null,
                  negotiation
                }
              });
            } catch {
              // Best-effort lifecycle delivery.
            }
            return sendError(res, 409, "marketplace bid negotiation expired", {
              expiresAt: policyApplied.expiresAt ?? null
            });
          }
          const negotiationState = String(negotiation?.state ?? "open").toLowerCase();
          if (negotiationState === "expired") {
            return sendError(res, 409, "marketplace bid negotiation expired", {
              expiresAt: policyApplied.expiresAt ?? negotiation?.expiresAt ?? null
            });
          }
          if (negotiationState !== "open") {
            return sendError(res, 409, "marketplace bid negotiation is not open");
          }
          const latestProposal = getLatestMarketplaceBidProposal(negotiation);
          if (!latestProposal) return sendError(res, 409, "marketplace bid negotiation has no baseline proposal");

          const hasAmountCents = Object.prototype.hasOwnProperty.call(body, "amountCents");
          const hasCurrency = Object.prototype.hasOwnProperty.call(body, "currency");
          const hasEtaSeconds = Object.prototype.hasOwnProperty.call(body, "etaSeconds");
          const hasNote = Object.prototype.hasOwnProperty.call(body, "note");
          const hasVerificationMethod = Object.prototype.hasOwnProperty.call(body, "verificationMethod");
          const hasPolicy = Object.prototype.hasOwnProperty.call(body, "policy");
          const hasPolicyRef = Object.prototype.hasOwnProperty.call(body, "policyRef");
          const hasMetadata = Object.prototype.hasOwnProperty.call(body, "metadata");
          if (!hasAmountCents && !hasCurrency && !hasEtaSeconds && !hasNote && !hasVerificationMethod && !hasPolicy && !hasPolicyRef && !hasMetadata) {
            return sendError(res, 400, "counter-offer must include at least one mutable field");
          }

          const latestRevision = Number(negotiation?.latestRevision);
          const nextRevision = Number.isSafeInteger(latestRevision) && latestRevision > 0 ? latestRevision + 1 : 2;
          if (nextRevision > Number(counterOfferPolicy?.maxRevisions ?? 0)) {
            return sendError(res, 409, "counter-offer max revisions reached", {
              maxRevisions: counterOfferPolicy?.maxRevisions ?? null,
              latestRevision
            });
          }

          let policySelection = null;
          try {
            policySelection = resolveMarketplaceSettlementPolicySelection({
              tenantId,
              policyRefInput: hasPolicyRef ? body?.policyRef ?? null : latestProposal?.policyRef ?? null,
              verificationMethodInput: hasVerificationMethod ? body?.verificationMethod : latestProposal?.verificationMethod,
              settlementPolicyInput: hasPolicy ? body?.policy : latestProposal?.policy
            });
          } catch (err) {
            if (err?.code === "TENANT_SETTLEMENT_POLICY_NOT_FOUND") {
              return sendError(res, 404, "policyRef not found");
            }
            if (err?.code === "TENANT_SETTLEMENT_POLICY_REF_MISMATCH") {
              return sendError(res, 409, "policyRef does not match verificationMethod/policy", { message: err?.message });
            }
            if (err?.code === "INVALID_VERIFICATION_METHOD") {
              return sendError(res, 400, "invalid verificationMethod", { message: err?.message });
            }
            if (err?.code === "INVALID_SETTLEMENT_POLICY") {
              return sendError(res, 400, "invalid policy", { message: err?.message });
            }
            return sendError(res, 400, "invalid counter-offer policy selection", { message: err?.message });
          }

          let proposal = null;
          try {
            proposal = buildMarketplaceBidNegotiationProposal({
              rfq: rfq,
              bidId,
              revision: nextRevision,
              proposerAgentId,
              amountCents: hasAmountCents ? body?.amountCents : latestProposal?.amountCents,
              currency: hasCurrency ? body?.currency : latestProposal?.currency,
              etaSeconds: hasEtaSeconds ? body?.etaSeconds : latestProposal?.etaSeconds,
              note: hasNote ? body?.note : latestProposal?.note,
              verificationMethodInput: policySelection.verificationMethod,
              settlementPolicyInput: policySelection.policy,
              policyRefInput: policySelection.policyRef,
              prevProposalHashInput: deriveMarketplaceProposalHash(latestProposal),
              metadataInput: hasMetadata ? body?.metadata : latestProposal?.metadata,
              proposalIdInput: body?.proposalId ?? null,
              proposedAt: nowAt
            });
          } catch (err) {
            return sendError(res, 400, "invalid counter-offer", { message: err?.message });
          }

          const nextNegotiation = appendMarketplaceBidNegotiationProposal({ negotiation, proposal, at: nowAt });
          const nextBid = {
            ...selectedBid,
            amountCents: proposal.amountCents,
            currency: proposal.currency,
            etaSeconds: proposal.etaSeconds ?? null,
            note: proposal.note ?? null,
            verificationMethod: proposal.verificationMethod,
            policy: proposal.policy,
            policyRef: proposal.policyRef ?? null,
            metadata: proposal.metadata ?? null,
            negotiation: nextNegotiation,
            counterOfferPolicy,
            updatedAt: nowAt
          };
          const nextBids = allExistingBids.map((candidate) => {
            if (!candidate || typeof candidate !== "object") return candidate;
            if (String(candidate.bidId ?? "") !== bidId) return candidate;
            return nextBid;
          });
          const nextRfq = {
            ...rfq,
            updatedAt: nowAt
          };

          const responseBody = {
            rfq: toMarketplaceRfqResponse(nextRfq),
            bid: toMarketplaceBidResponse(nextBid),
            negotiation: nextNegotiation,
            proposal
          };
          const ops = [
            { kind: "MARKETPLACE_RFQ_UPSERT", tenantId, rfq: nextRfq },
            { kind: "MARKETPLACE_RFQ_BIDS_SET", tenantId, rfqId, bids: nextBids }
          ];
          if (idemStoreKey) {
            ops.push({ kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode: 200, body: responseBody } });
          }
          await commitTx(ops);
          try {
            await emitMarketplaceLifecycleArtifact({
              tenantId,
              eventType: "proposal.submitted",
              rfqId: rfqId,
              sourceEventId: proposal?.proposalId ?? null,
              actorAgentId: proposerAgentId,
              details: {
                bidId,
                revision: proposal?.revision ?? null,
                proposal,
                negotiation: nextNegotiation
              }
            });
          } catch {
            // Best-effort lifecycle delivery.
          }
          try {
            await emitMarketplaceLifecycleArtifact({
              tenantId,
              eventType: "marketplace.bid.counter_offer_applied",
              rfqId: rfqId,
              sourceEventId: proposal?.proposalId ?? null,
              actorAgentId: proposerAgentId,
              details: {
                bidId,
                negotiation: nextNegotiation,
                proposal
              }
            });
          } catch {
            // Best-effort lifecycle delivery.
          }
          return sendJson(res, 200, responseBody);
        }

        if (req.method === "POST" && marketplaceParts.length === 4 && marketplaceParts[3] === "accept") {
          const body = await readJsonBody(req);
          let idemStoreKey = null;
          let idemRequestHash = null;
          try {
            ({ idemStoreKey, idemRequestHash } = readIdempotency({ method: "POST", requestPath: path, expectedPrevChainHash: null, body }));
          } catch (err) {
            return sendError(res, 400, "invalid idempotency key", { message: err?.message });
          }
          if (idemStoreKey) {
            const existingIdem = store.idempotency.get(idemStoreKey);
            if (existingIdem) {
              if (existingIdem.requestHash !== idemRequestHash) {
                return sendError(res, 409, "idempotency key conflict", "request differs from initial use of this key");
              }
              return sendJson(res, existingIdem.statusCode, existingIdem.body);
            }
          }

          if (String(rfq.status ?? "open").toLowerCase() !== "open") return sendError(res, 409, "marketplace rfq is not open");

          const bidId = body?.bidId && String(body.bidId).trim() !== "" ? String(body.bidId).trim() : null;
          if (!bidId) return sendError(res, 400, "bidId is required");

          const acceptedByAgentId = body?.acceptedByAgentId && String(body.acceptedByAgentId).trim() !== "" ? String(body.acceptedByAgentId).trim() : null;
          const acceptanceSignatureInput =
            body?.acceptanceSignature && typeof body.acceptanceSignature === "object" && !Array.isArray(body.acceptanceSignature)
              ? body.acceptanceSignature
              : null;
          if (body?.acceptanceSignature !== undefined && acceptanceSignatureInput === null) {
            return sendError(res, 400, "acceptanceSignature must be an object");
          }
          if (acceptanceSignatureInput && !acceptedByAgentId) {
            return sendError(res, 400, "acceptedByAgentId is required when acceptanceSignature is provided");
          }
          let acceptedByIdentity = null;
          if (acceptedByAgentId) {
            try {
              acceptedByIdentity = await getAgentIdentityRecord({ tenantId, agentId: acceptedByAgentId });
            } catch (err) {
              return sendError(res, 400, "invalid acceptedByAgentId", { message: err?.message });
            }
            if (!acceptedByIdentity) return sendError(res, 404, "accepting agent identity not found");
          }

          const existingBids = listMarketplaceRfqBids({ tenantId, rfqId, status: "all" });
          const selectedBid = existingBids.find((candidate) => String(candidate?.bidId ?? "") === bidId) ?? null;
          if (!selectedBid) return sendError(res, 404, "marketplace bid not found");
          if (String(selectedBid.status ?? "pending").toLowerCase() !== "pending") return sendError(res, 409, "marketplace bid is not pending");

          let rfqDirection = null;
          let bidDirection = null;
          try {
            rfqDirection = parseInteractionDirection({ fromTypeRaw: rfq?.fromType, toTypeRaw: rfq?.toType });
            bidDirection = parseInteractionDirection({
              fromTypeRaw: selectedBid?.fromType,
              toTypeRaw: selectedBid?.toType,
              defaultFromType: rfqDirection.fromType,
              defaultToType: rfqDirection.toType
            });
          } catch (err) {
            return sendError(res, 400, "invalid interaction direction", { message: err?.message });
          }
          if (bidDirection.fromType !== rfqDirection.fromType || bidDirection.toType !== rfqDirection.toType) {
            return sendError(res, 409, "accepted bid interaction direction must match rfq direction");
          }

          const payeeAgentId = selectedBid?.bidderAgentId ? String(selectedBid.bidderAgentId) : null;
          if (!payeeAgentId) return sendError(res, 409, "selected bid is missing bidderAgentId");
          let payeeIdentity = null;
          try {
            payeeIdentity = await getAgentIdentityRecord({ tenantId, agentId: payeeAgentId });
          } catch (err) {
            return sendError(res, 400, "invalid bidderAgentId", { message: err?.message });
          }
          if (!payeeIdentity) return sendError(res, 404, "bidder agent identity not found");

          const settlementInput = body?.settlement && typeof body.settlement === "object" ? body.settlement : {};
          let acceptDirection = null;
          try {
            acceptDirection = parseInteractionDirection({
              fromTypeRaw: body?.fromType ?? settlementInput?.fromType,
              toTypeRaw: body?.toType ?? settlementInput?.toType,
              defaultFromType: rfqDirection.fromType,
              defaultToType: rfqDirection.toType
            });
          } catch (err) {
            return sendError(res, 400, "invalid interaction direction", { message: err?.message });
          }
          if (acceptDirection.fromType !== rfqDirection.fromType || acceptDirection.toType !== rfqDirection.toType) {
            return sendError(res, 409, "settlement interaction direction must match rfq direction");
          }
          const payerAgentIdRaw =
            settlementInput.payerAgentId ??
            body?.payerAgentId ??
            rfq?.posterAgentId ??
            null;
          if (typeof payerAgentIdRaw !== "string" || payerAgentIdRaw.trim() === "") {
            return sendError(res, 400, "payerAgentId is required (rfq poster or settlement.payerAgentId)");
          }
          const acceptedAt = nowIso();
          let counterOfferPolicy = resolveMarketplaceCounterOfferPolicy({ rfq: rfq, bid: selectedBid });
          let selectedBidNegotiation =
            selectedBid?.negotiation && typeof selectedBid.negotiation === "object" && !Array.isArray(selectedBid.negotiation)
              ? selectedBid.negotiation
              : null;
          if (!selectedBidNegotiation) {
            try {
              selectedBidNegotiation = bootstrapMarketplaceBidNegotiation({
                rfq: rfq,
                bid: selectedBid,
                counterOfferPolicy,
                at: acceptedAt
              });
            } catch (err) {
              return sendError(res, 409, "unable to bootstrap bid negotiation", { message: err?.message });
            }
          }
          const selectedPolicyApplied = applyMarketplaceBidNegotiationPolicy({
            negotiation: selectedBidNegotiation,
            counterOfferPolicy,
            at: acceptedAt,
            expireIfTimedOut: true
          });
          selectedBidNegotiation = selectedPolicyApplied.negotiation;
          counterOfferPolicy = selectedPolicyApplied.counterOfferPolicy;
          if (selectedPolicyApplied.justExpired) {
            const latestExpiredProposal = getLatestMarketplaceBidProposal(selectedBidNegotiation);
            const expiredBid = {
              ...selectedBid,
              negotiation: selectedBidNegotiation,
              counterOfferPolicy,
              updatedAt: acceptedAt
            };
            const expiredBids = existingBids.map((candidate) => {
              if (!candidate || typeof candidate !== "object") return candidate;
              if (String(candidate.bidId ?? "") !== bidId) return candidate;
              return expiredBid;
            });
            const expiredRfq = {
              ...rfq,
              updatedAt: acceptedAt
            };
            await commitTx([
              { kind: "MARKETPLACE_RFQ_UPSERT", tenantId, rfq: expiredRfq },
              { kind: "MARKETPLACE_RFQ_BIDS_SET", tenantId, rfqId, bids: expiredBids }
            ]);
            try {
              await emitMarketplaceLifecycleArtifact({
                tenantId,
                eventType: "proposal.expired",
                rfqId: rfqId,
                sourceEventId: latestExpiredProposal?.proposalId ?? null,
                actorAgentId: acceptedByAgentId ?? String(payerAgentIdRaw).trim(),
                details: {
                  bidId,
                  expiresAt: selectedPolicyApplied.expiresAt ?? null,
                  negotiation: selectedBidNegotiation
                }
              });
            } catch {
              // Best-effort lifecycle delivery.
            }
            return sendError(res, 409, "marketplace bid negotiation expired", {
              expiresAt: selectedPolicyApplied.expiresAt ?? null
            });
          }
          const selectedNegotiationState = String(selectedBidNegotiation?.state ?? "open").toLowerCase();
          if (selectedNegotiationState === "expired") {
            return sendError(res, 409, "marketplace bid negotiation expired", {
              expiresAt: selectedPolicyApplied.expiresAt ?? selectedBidNegotiation?.expiresAt ?? null
            });
          }
          if (selectedNegotiationState !== "open") {
            return sendError(res, 409, "marketplace bid negotiation is not open");
          }
          const selectedLatestProposal = getLatestMarketplaceBidProposal(selectedBidNegotiation);
          if (!selectedLatestProposal) return sendError(res, 409, "marketplace bid negotiation has no proposals");
          selectedBidNegotiation = updateMarketplaceBidNegotiationState({
            negotiation: selectedBidNegotiation,
            state: "accepted",
            at: acceptedAt,
            acceptedByAgentId: acceptedByAgentId ?? null,
            acceptedProposalId: selectedLatestProposal?.proposalId ?? null,
            acceptedRevision: selectedLatestProposal?.revision ?? null
          });
          const selectedBidAccepted = {
            ...selectedBid,
            amountCents: selectedLatestProposal?.amountCents ?? selectedBid?.amountCents,
            currency: selectedLatestProposal?.currency ?? selectedBid?.currency,
            etaSeconds: selectedLatestProposal?.etaSeconds ?? null,
            note: selectedLatestProposal?.note ?? null,
            verificationMethod: selectedLatestProposal?.verificationMethod ?? selectedBid?.verificationMethod ?? null,
            policy: selectedLatestProposal?.policy ?? selectedBid?.policy ?? null,
            policyRef: selectedLatestProposal?.policyRef ?? selectedBid?.policyRef ?? null,
            policyRefHash: selectedLatestProposal?.policyRefHash ?? null,
            metadata: selectedLatestProposal?.metadata ?? null,
            negotiation: selectedBidNegotiation,
            counterOfferPolicy,
            status: "accepted",
            acceptedAt,
            rejectedAt: null,
            updatedAt: acceptedAt
          };
          const defaultAmountCents = Number(selectedBidAccepted?.amountCents);
          const fallbackCurrency =
            typeof selectedBidAccepted?.currency === "string" && selectedBidAccepted.currency.trim() !== ""
              ? selectedBidAccepted.currency
              : rfq?.currency ?? "USD";
          let settlementRequest = null;
          try {
            settlementRequest = validateAgentRunSettlementRequest({
              payerAgentId: String(payerAgentIdRaw).trim(),
              amountCents: settlementInput.amountCents ?? defaultAmountCents,
              currency: settlementInput.currency ?? fallbackCurrency
            });
          } catch (err) {
            return sendError(res, 400, "invalid settlement payload", { message: err?.message });
          }

          let payerIdentity = null;
          try {
            payerIdentity = await getAgentIdentityRecord({ tenantId, agentId: settlementRequest.payerAgentId });
          } catch (err) {
            return sendError(res, 400, "invalid payerAgentId", { message: err?.message });
          }
	          if (!payerIdentity) return sendError(res, 404, "payer agent identity not found");
	          try {
	            await assertSettlementWithinWalletPolicy({
	              tenantId,
	              agentIdentity: payerIdentity,
	              amountCents: settlementRequest.amountCents,
	              at: acceptedAt
	            });
	          } catch (err) {
	            return sendError(res, 409, "wallet policy blocked settlement", { message: err?.message, code: err?.code ?? null });
	          }

          const runId = body?.runId && String(body.runId).trim() !== "" ? String(body.runId).trim() : `run_${rfqId}_${bidId}`;
          if (typeof runId !== "string" || runId.trim() === "") return sendError(res, 400, "runId must be a non-empty string");
          let existingRun = null;
          if (typeof store.getAgentRun === "function") {
            existingRun = await store.getAgentRun({ tenantId, runId });
          } else if (store.agentRuns instanceof Map) {
            existingRun = store.agentRuns.get(runStoreKey(tenantId, runId)) ?? null;
          } else {
            return sendError(res, 501, "agent runs not supported for this store");
          }
          if (existingRun && !idemStoreKey) return sendError(res, 409, "run already exists");

          const runCreatedPayload = {
            runId,
            agentId: payeeAgentId,
            tenantId,
            taskType:
              body?.taskType && String(body.taskType).trim() !== ""
                ? String(body.taskType).trim()
                : rfq?.capability ?? rfq?.title ?? "marketplace-rfq",
            inputRef:
              body?.inputRef && String(body.inputRef).trim() !== ""
                ? String(body.inputRef).trim()
                : `marketplace://rfqs/${encodeURIComponent(rfqId)}`
          };
          try {
            validateRunCreatedPayload(runCreatedPayload);
          } catch (err) {
            return sendError(res, 400, "invalid run payload", { message: err?.message });
          }
          const createdEvent = createChainedEvent({
            streamId: runId,
            type: AGENT_RUN_EVENT_TYPE.RUN_CREATED,
            actor: { type: "agent", id: payeeAgentId },
            payload: runCreatedPayload,
            at: acceptedAt
          });
          const runEvents = normalizeAgentRunEventRecords(appendChainedEvent({ events: [], event: createdEvent, signer: serverSigner }));
          let run = null;
          try {
            run = reduceAgentRun(runEvents);
          } catch (err) {
            return sendError(res, 400, "run creation rejected", { message: err?.message });
          }

          let payerWallet = null;
          try {
            const existingPayerWallet = await getAgentWalletRecord({ tenantId, agentId: settlementRequest.payerAgentId });
            const basePayerWallet = ensureAgentWallet({
              wallet: existingPayerWallet,
              tenantId,
              agentId: settlementRequest.payerAgentId,
              currency: settlementRequest.currency,
              at: acceptedAt
            });
            payerWallet = lockAgentWalletEscrow({ wallet: basePayerWallet, amountCents: settlementRequest.amountCents, at: acceptedAt });
            projectEscrowLedgerOperation({
              tenantId,
              settlement: {
                payerAgentId: settlementRequest.payerAgentId,
                agentId: payeeAgentId,
                currency: settlementRequest.currency
              },
              operationId: `escrow_hold_${runId}`,
              type: ESCROW_OPERATION_TYPE.HOLD,
              amountCents: settlementRequest.amountCents,
              at: acceptedAt,
              payerWalletBefore: basePayerWallet,
              payerWalletAfter: payerWallet,
              memo: `run:${runId}:hold`
            });
          } catch (err) {
            return sendError(res, 409, "unable to lock settlement escrow", { message: err?.message, code: err?.code ?? null });
          }

          const disputeWindowDaysRaw = body?.disputeWindowDays ?? settlementInput?.disputeWindowDays ?? 3;
          const disputeWindowDays =
            Number.isSafeInteger(Number(disputeWindowDaysRaw)) && Number(disputeWindowDaysRaw) >= 0 ? Number(disputeWindowDaysRaw) : 3;
          let policySelection = null;
          try {
            policySelection = resolveMarketplaceSettlementPolicySelection({
              tenantId,
              policyRefInput: body?.policyRef ?? settlementInput?.policyRef ?? selectedBidAccepted?.policyRef ?? null,
              verificationMethodInput:
                body?.verificationMethod ?? settlementInput?.verificationMethod ?? selectedBidAccepted?.verificationMethod ?? undefined,
              settlementPolicyInput: body?.policy ?? settlementInput?.policy ?? selectedBidAccepted?.policy ?? undefined
            });
          } catch (err) {
            if (err?.code === "TENANT_SETTLEMENT_POLICY_NOT_FOUND") {
              return sendError(res, 404, "policyRef not found");
            }
            if (err?.code === "TENANT_SETTLEMENT_POLICY_REF_MISMATCH") {
              return sendError(res, 409, "policyRef does not match verificationMethod/policy", { message: err?.message });
            }
            if (err?.code === "INVALID_VERIFICATION_METHOD") {
              return sendError(res, 400, "invalid verificationMethod", { message: err?.message });
            }
            if (err?.code === "INVALID_SETTLEMENT_POLICY") {
              return sendError(res, 400, "invalid policy", { message: err?.message });
            }
            return sendError(res, 400, "invalid agreement policy selection", { message: err?.message });
          }

          const verificationMethodInput = policySelection.verificationMethod;
          const settlementPolicyInput = policySelection.policy;
          const policyRefInput = policySelection.policyRef;
          const agreementTermsInput = body?.agreementTerms ?? settlementInput?.agreementTerms ?? null;
          let agreement = null;
          try {
            agreement = buildMarketplaceRfqAgreement({
              tenantId,
              rfq: rfq,
              bid: selectedBidAccepted,
              runId,
              acceptedAt,
              acceptedByAgentId,
              payerAgentId: settlementRequest.payerAgentId,
              fromType: acceptDirection.fromType,
              toType: acceptDirection.toType,
              disputeWindowDays,
              verificationMethodInput,
              settlementPolicyInput,
              policyRefInput,
              agreementTermsInput
            });
          } catch (err) {
            return sendError(res, 400, "invalid agreement terms", { message: err?.message });
          }
          if (acceptanceSignatureInput) {
            try {
              const acceptanceSignature = await parseSignedMarketplaceAgreementAcceptance({
                tenantId,
                agreement,
                acceptedByAgentId,
                acceptedByIdentity,
                acceptanceSignatureInput
              });
              agreement = {
                ...agreement,
                acceptanceSignature
              };
            } catch (err) {
              return sendError(res, 400, "invalid acceptance signature", { message: err?.message });
            }
          }
          let settlement = createAgentRunSettlement({
            tenantId,
            runId,
            agentId: payeeAgentId,
            payerAgentId: settlementRequest.payerAgentId,
            amountCents: settlementRequest.amountCents,
            currency: settlementRequest.currency,
            disputeWindowDays,
            at: acceptedAt
          });
          const pendingVerifierRef = resolveAgreementVerifierRef(agreement?.verificationMethod ?? null);
          const pendingKernelRefs = buildSettlementKernelRefs({
            settlement,
            run,
            agreementId: agreement?.agreementId ?? null,
            decisionStatus: AGENT_RUN_SETTLEMENT_DECISION_STATUS.PENDING,
            decisionMode: agreement?.policy?.mode ?? AGENT_RUN_SETTLEMENT_DECISION_MODE.AUTOMATIC,
            decisionReason: null,
            verificationStatus: null,
            policyHash: agreement?.policyHash ?? null,
            verificationMethodHash: agreement?.verificationMethodHash ?? null,
            verificationMethodMode: pendingVerifierRef?.modality ?? agreement?.verificationMethod?.mode ?? null,
            verifierId: pendingVerifierRef?.verifierId ?? "settld.policy-engine",
            verifierVersion: pendingVerifierRef?.verifierVersion ?? "v1",
            verifierHash: pendingVerifierRef?.verifierHash ?? null,
            finalityState: SETTLEMENT_FINALITY_STATE.PENDING,
            settledAt: null,
            createdAt: acceptedAt
          });
          settlement = updateAgentRunSettlementDecision({
            settlement,
            decisionStatus: AGENT_RUN_SETTLEMENT_DECISION_STATUS.PENDING,
            decisionMode: agreement?.policy?.mode ?? AGENT_RUN_SETTLEMENT_DECISION_MODE.AUTOMATIC,
            decisionPolicyHash: agreement?.policyHash ?? null,
            decisionReason: null,
            decisionTrace: {
              phase: "agreement.accepted",
              verificationMethod: agreement?.verificationMethod ?? null,
              policy: agreement?.policy ?? null,
              decisionRecord: pendingKernelRefs.decisionRecord,
              settlementReceipt: pendingKernelRefs.settlementReceipt
            },
            at: acceptedAt
          });
          const nextRfq = {
            ...rfq,
            fromType: rfqDirection.fromType,
            toType: rfqDirection.toType,
            status: "assigned",
            acceptedBidId: bidId,
            acceptedBidderAgentId: selectedBidAccepted.bidderAgentId ?? null,
            acceptedAt,
            acceptedByAgentId: acceptedByAgentId ?? null,
            runId,
            agreementId: agreement.agreementId,
            agreement,
            settlementId: settlement.settlementId,
            settlementDecisionStatus: settlement.decisionStatus ?? null,
            updatedAt: acceptedAt
          };
          const nextBids = existingBids.map((candidate) => {
            if (!candidate || typeof candidate !== "object") return candidate;
            if (String(candidate.bidId ?? "") === bidId) {
              return selectedBidAccepted;
            }
            const status = String(candidate.status ?? "pending").toLowerCase();
            if (status === "pending") {
              let rejectedNegotiation =
                candidate?.negotiation && typeof candidate.negotiation === "object" && !Array.isArray(candidate.negotiation)
                  ? candidate.negotiation
                  : null;
              try {
                if (rejectedNegotiation) {
                  rejectedNegotiation = updateMarketplaceBidNegotiationState({
                    negotiation: rejectedNegotiation,
                    state: "rejected",
                    at: acceptedAt
                  });
                }
              } catch {
                rejectedNegotiation = null;
              }
              return {
                ...candidate,
                status: "rejected",
                rejectedAt: acceptedAt,
                updatedAt: acceptedAt,
                negotiation: rejectedNegotiation ?? candidate?.negotiation ?? null
              };
            }
            return candidate;
          });

          const acceptedBid = nextBids.find((candidate) => String(candidate?.bidId ?? "") === bidId) ?? null;
          const responseBody = {
            rfq: toMarketplaceRfqResponse(nextRfq),
            acceptedBid: toMarketplaceBidResponse(acceptedBid),
            run,
            settlement,
            agreement,
            offer: agreement?.offer ?? null,
            offerAcceptance: agreement?.offerAcceptance ?? null,
            decisionRecord: pendingKernelRefs.decisionRecord,
            settlementReceipt: pendingKernelRefs.settlementReceipt
          };
          const ops = [
            { kind: "MARKETPLACE_RFQ_UPSERT", tenantId, rfq: nextRfq },
            { kind: "MARKETPLACE_RFQ_BIDS_SET", tenantId, rfqId, bids: nextBids },
            { kind: "AGENT_RUN_EVENTS_APPENDED", tenantId, runId, events: runEvents },
            { kind: "AGENT_WALLET_UPSERT", tenantId, wallet: payerWallet },
            { kind: "AGENT_RUN_SETTLEMENT_UPSERT", tenantId, runId, settlement }
          ];
          if (idemStoreKey) {
            ops.push({ kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode: 200, body: responseBody } });
          }
          await commitTx(ops);
          try {
            await emitMarketplaceLifecycleArtifact({
              tenantId,
              eventType: "marketplace.rfq.accepted",
              rfqId: rfqId,
              runId,
              sourceEventId: run?.lastEventId ?? null,
              actorAgentId: acceptedByAgentId ?? settlementRequest.payerAgentId,
              agreement,
              settlement,
              details: {
                bidId,
                acceptedBidderAgentId: acceptedBid?.bidderAgentId ?? null
              }
            });
          } catch {
            // Lifecycle deliveries are best-effort and retried by delivery workers when destinations are configured.
          }
          try {
            await emitMarketplaceLifecycleArtifact({
              tenantId,
              eventType: "proposal.accepted",
              rfqId: rfqId,
              runId,
              sourceEventId: selectedLatestProposal?.proposalId ?? null,
              actorAgentId: acceptedByAgentId ?? settlementRequest.payerAgentId,
              agreement,
              settlement,
              details: {
                bidId,
                proposal: selectedLatestProposal,
                negotiation: selectedBidNegotiation
              }
            });
          } catch {
            // Lifecycle deliveries are best-effort and retried by delivery workers when destinations are configured.
          }
          return sendJson(res, 200, responseBody);
        }

        return sendError(res, 404, "not found");
      }

      if (req.method === "GET" && path === "/marketplace/agents/search") {
        try {
          const result = await searchMarketplaceAgents({
            tenantId,
            capability: url.searchParams.get("capability"),
            status: url.searchParams.get("status"),
            minTrustScore: url.searchParams.get("minTrustScore"),
            riskTier: url.searchParams.get("riskTier"),
            limit: url.searchParams.get("limit") ? Number(url.searchParams.get("limit")) : 50,
            offset: url.searchParams.get("offset") ? Number(url.searchParams.get("offset")) : 0,
            includeReputation:
              url.searchParams.get("includeReputation") === null
                ? true
                : ["1", "true", "yes", "on"].includes(String(url.searchParams.get("includeReputation")).trim().toLowerCase()),
            reputationVersion: url.searchParams.get("reputationVersion") ?? "v2",
            reputationWindow: url.searchParams.get("reputationWindow") ?? AGENT_REPUTATION_WINDOW.THIRTY_DAYS,
            scoreStrategy: url.searchParams.get("scoreStrategy") ?? "balanced"
          });
          return sendJson(res, 200, result);
        } catch (err) {
          return sendError(res, 400, "invalid marketplace search query", { message: err?.message });
        }
      }

      // Agreement delegations (multi-hop composition primitive).
      {
        const parts = path.split("/").filter(Boolean);
        if (parts[0] === "agreements" && parts[1] && parts[2] === "delegations" && parts.length === 3 && req.method === "POST") {
          if (!requireProtocolHeaderForWrite(req, res)) return;

          const body = await readJsonBody(req);
          let idemStoreKey = null;
          let idemRequestHash = null;
          try {
            ({ idemStoreKey, idemRequestHash } = readIdempotency({ method: "POST", requestPath: path, expectedPrevChainHash: null, body }));
          } catch (err) {
            return sendError(res, 400, "invalid idempotency key", { message: err?.message });
          }
          if (idemStoreKey) {
            const existing = store.idempotency.get(idemStoreKey);
            if (existing) {
              if (existing.requestHash !== idemRequestHash) {
                return sendError(res, 409, "idempotency key conflict", "request differs from initial use of this key");
              }
              return sendJson(res, existing.statusCode, existing.body);
            }
          }

          let parentAgreementHash;
          try {
            parentAgreementHash = normalizeSha256HashInput(parts[1], "agreementHash", { allowNull: false });
          } catch (err) {
            return sendError(res, 400, "invalid agreementHash", { message: err?.message }, { code: "SCHEMA_INVALID" });
          }

          const nowAt = nowIso();
          const delegationId = typeof body?.delegationId === "string" && body.delegationId.trim() !== "" ? body.delegationId.trim() : createId("dlg");
          let childAgreementHash;
          try {
            childAgreementHash = normalizeSha256HashInput(body?.childAgreementHash, "childAgreementHash", { allowNull: false });
          } catch (err) {
            return sendError(res, 400, "invalid childAgreementHash", { message: err?.message }, { code: "SCHEMA_INVALID" });
          }
          const delegatorAgentId = typeof body?.delegatorAgentId === "string" && body.delegatorAgentId.trim() !== "" ? body.delegatorAgentId.trim() : null;
          const delegateeAgentId = typeof body?.delegateeAgentId === "string" && body.delegateeAgentId.trim() !== "" ? body.delegateeAgentId.trim() : null;
          if (!delegatorAgentId || !delegateeAgentId) {
            return sendError(res, 400, "delegatorAgentId and delegateeAgentId are required", null, { code: "SCHEMA_INVALID" });
          }
          const budgetCapCents = Number(body?.budgetCapCents);
          if (!Number.isSafeInteger(budgetCapCents) || budgetCapCents <= 0) {
            return sendError(res, 400, "budgetCapCents must be a positive safe integer", null, { code: "SCHEMA_INVALID" });
          }
          const currency = typeof body?.currency === "string" && body.currency.trim() !== "" ? body.currency.trim().toUpperCase() : "USD";

          const ancestorChainInput = body?.ancestorChain ?? null;
          const ancestorChain = Array.isArray(ancestorChainInput) ? ancestorChainInput : null;
          const inferredDepth = ancestorChain ? ancestorChain.length : 1;
          const delegationDepthRaw = body?.delegationDepth ?? inferredDepth;
          const maxDelegationDepthRaw = body?.maxDelegationDepth ?? delegationDepthRaw;
          let delegation;
          try {
            delegation = buildAgreementDelegationV1({
              delegationId,
              tenantId,
              parentAgreementHash,
              childAgreementHash,
              delegatorAgentId,
              delegateeAgentId,
              budgetCapCents,
              currency,
              delegationDepth: Number(delegationDepthRaw),
              maxDelegationDepth: Number(maxDelegationDepthRaw),
              ancestorChain: ancestorChain ?? undefined,
              createdAt: nowAt
            });
            validateAgreementDelegationV1(delegation);
          } catch (err) {
            return sendError(res, 400, "invalid agreement delegation", { message: err?.message }, { code: "SCHEMA_INVALID" });
          }

          const ops = [{ kind: "AGREEMENT_DELEGATION_UPSERT", tenantId, delegationId: delegation.delegationId, delegation }];
          const responseBody = { ok: true, delegation };
          if (idemStoreKey) {
            ops.push({ kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode: 201, body: responseBody } });
          }

          await store.commitTx({ at: nowAt, ops });
          return sendJson(res, 201, responseBody);
        }

        if (parts[0] === "agreements" && parts[1] && parts[2] === "delegations" && parts.length === 3 && req.method === "GET") {
          let agreementHash;
          try {
            agreementHash = normalizeSha256HashInput(parts[1], "agreementHash", { allowNull: false });
          } catch (err) {
            return sendError(res, 400, "invalid agreementHash", { message: err?.message }, { code: "SCHEMA_INVALID" });
          }
          const status = url.searchParams.get("status");
          const limitRaw = url.searchParams.get("limit");
          const offsetRaw = url.searchParams.get("offset");
          const limit = limitRaw ? Number(limitRaw) : 200;
          const offset = offsetRaw ? Number(offsetRaw) : 0;
          const safeLimit = Number.isSafeInteger(limit) && limit > 0 ? Math.min(1000, limit) : 200;
          const safeOffset = Number.isSafeInteger(offset) && offset >= 0 ? offset : 0;

          const parentRows = typeof store.listAgreementDelegations === "function"
            ? await store.listAgreementDelegations({ tenantId, parentAgreementHash: agreementHash, status, limit: 10_000, offset: 0 })
            : [];
          const childRows = typeof store.listAgreementDelegations === "function"
            ? await store.listAgreementDelegations({ tenantId, childAgreementHash: agreementHash, status, limit: 10_000, offset: 0 })
            : [];
          const byId = new Map();
          for (const row of [...parentRows, ...childRows]) {
            const id = String(row?.delegationId ?? "");
            if (!id) continue;
            if (!byId.has(id)) byId.set(id, row);
          }
          const delegations = Array.from(byId.values()).sort((a, b) => String(a.delegationId ?? "").localeCompare(String(b.delegationId ?? "")));
          const paged = delegations.slice(safeOffset, safeOffset + safeLimit);
          return sendJson(res, 200, { ok: true, agreementHash, delegations: paged, limit: safeLimit, offset: safeOffset, total: delegations.length });
        }

	        if (parts[0] === "delegations" && parts[1] && parts.length === 2 && req.method === "GET") {
	          const delegationId = parts[1];
	          const delegation = typeof store.getAgreementDelegation === "function" ? await store.getAgreementDelegation({ tenantId, delegationId }) : null;
	          if (!delegation) return sendError(res, 404, "delegation not found", null, { code: "NOT_FOUND" });
	          return sendJson(res, 200, { ok: true, delegation });
	        }
	      }

	      // x402 verification gate (HTTP middleware surface).
	      {
	        const parts = path.split("/").filter(Boolean);

        if (parts[0] === "x402" && parts[1] === "receipts" && parts[2] === "export" && parts.length === 3 && req.method === "GET") {
          if (typeof store.listX402Receipts !== "function") return sendError(res, 501, "x402 receipts are not supported for this store");
          let query;
          try {
            query = parseX402ReceiptListQuery(url);
          } catch (err) {
            return sendError(res, 400, "invalid receipt export query", { message: err?.message }, { code: "SCHEMA_INVALID" });
          }
          const exportPage =
            typeof store.listX402ReceiptsPage === "function"
              ? await store.listX402ReceiptsPage({
                  tenantId,
                  agentId: query.agentId,
                  sponsorId: query.sponsorId,
                  sponsorWalletRef: query.sponsorWalletRef,
                  toolId: query.toolId,
                  state: query.state,
                  from: query.from,
                  to: query.to,
                  cursor: query.cursor,
                  limit: Math.min(5000, query.limit),
                  offset: query.offset
                })
              : {
                  receipts: await store.listX402Receipts({
                    tenantId,
                    agentId: query.agentId,
                    sponsorId: query.sponsorId,
                    sponsorWalletRef: query.sponsorWalletRef,
                    toolId: query.toolId,
                    state: query.state,
                    from: query.from,
                    to: query.to,
                    limit: Math.min(5000, query.limit),
                    offset: query.offset
                  }),
                  nextCursor: null
                };
          const rows = Array.isArray(exportPage?.receipts) ? exportPage.receipts : [];
          const ndjson = rows.map((row) => JSON.stringify(row)).join("\n");
          res.statusCode = 200;
          res.setHeader("content-type", "application/x-ndjson; charset=utf-8");
          res.setHeader("cache-control", "no-store");
          if (typeof exportPage?.nextCursor === "string" && exportPage.nextCursor.trim() !== "") {
            res.setHeader("x-next-cursor", exportPage.nextCursor.trim());
          }
          res.end(ndjson ? `${ndjson}\n` : "");
          return;
        }

        if (parts[0] === "x402" && parts[1] === "receipts" && parts[2] && parts.length === 3 && req.method === "GET") {
          if (typeof store.getX402Receipt !== "function") return sendError(res, 501, "x402 receipts are not supported for this store");
          const receiptId = parts[2];
          const receipt = await store.getX402Receipt({ tenantId, receiptId });
          if (!receipt) return sendError(res, 404, "receipt not found", null, { code: "NOT_FOUND" });
          return sendJson(res, 200, { ok: true, receipt });
        }

        if (parts[0] === "x402" && parts[1] === "receipts" && parts.length === 2 && req.method === "GET") {
          if (typeof store.listX402Receipts !== "function") return sendError(res, 501, "x402 receipts are not supported for this store");
          let query;
          try {
            query = parseX402ReceiptListQuery(url);
          } catch (err) {
            return sendError(res, 400, "invalid receipt query", { message: err?.message }, { code: "SCHEMA_INVALID" });
          }
          const page =
            typeof store.listX402ReceiptsPage === "function"
              ? await store.listX402ReceiptsPage({
                  tenantId,
                  agentId: query.agentId,
                  sponsorId: query.sponsorId,
                  sponsorWalletRef: query.sponsorWalletRef,
                  toolId: query.toolId,
                  state: query.state,
                  from: query.from,
                  to: query.to,
                  cursor: query.cursor,
                  limit: query.limit,
                  offset: query.offset
                })
              : {
                  receipts: await store.listX402Receipts({
                    tenantId,
                    agentId: query.agentId,
                    sponsorId: query.sponsorId,
                    sponsorWalletRef: query.sponsorWalletRef,
                    toolId: query.toolId,
                    state: query.state,
                    from: query.from,
                    to: query.to,
                    limit: query.limit,
                    offset: query.offset
                  }),
                  nextCursor: null
                };
          const receipts = Array.isArray(page?.receipts) ? page.receipts : [];
          return sendJson(res, 200, { receipts, limit: query.limit, offset: query.offset, nextCursor: page?.nextCursor ?? null });
        }

        if (parts[0] === "x402" && parts[1] === "wallets" && parts.length === 2 && req.method === "POST") {
          if (!requireProtocolHeaderForWrite(req, res)) return;

          const body = await readJsonBody(req);
          let idemStoreKey = null;
          let idemRequestHash = null;
          try {
            ({ idemStoreKey, idemRequestHash } = readIdempotency({ method: "POST", requestPath: path, expectedPrevChainHash: null, body }));
          } catch (err) {
            return sendError(res, 400, "invalid idempotency key", { message: err?.message });
          }
          if (idemStoreKey) {
            const existingIdem = store.idempotency.get(idemStoreKey);
            if (existingIdem) {
              if (existingIdem.requestHash !== idemRequestHash) {
                return sendError(res, 409, "idempotency key conflict", "request differs from initial use of this key");
              }
              return sendJson(res, existingIdem.statusCode, existingIdem.body);
            }
          }

          let sponsorRef = null;
          let sponsorWalletRef = null;
          let policyRefInput = null;
          let policyVersionInput = null;
          let existingPolicy = null;
          try {
            sponsorRef = normalizeOptionalX402RefInput(body?.sponsorRef, "sponsorRef", { allowNull: false, max: 200 });
            sponsorWalletRef = normalizeOptionalX402RefInput(body?.sponsorWalletRef ?? createId("x402wallet"), "sponsorWalletRef", {
              allowNull: false,
              max: 200
            });
            const rawPolicy =
              body?.policy && typeof body.policy === "object" && !Array.isArray(body.policy) ? body.policy : body ?? {};
            policyRefInput = rawPolicy.policyRef ?? body?.policyRef ?? "default";
            policyVersionInput = rawPolicy.policyVersion ?? body?.policyVersion ?? 1;
            const normalizedPolicyRef = normalizeOptionalX402RefInput(policyRefInput, "policyRef", { allowNull: false, max: 200 });
            const normalizedPolicyVersion = normalizeOptionalX402PositiveSafeInt(policyVersionInput, "policyVersion", { allowNull: false });
            existingPolicy = await getX402WalletPolicyRecord({
              tenantId,
              sponsorWalletRef,
              policyRef: normalizedPolicyRef,
              policyVersion: normalizedPolicyVersion
            });
          } catch (err) {
            return sendError(res, 400, "invalid x402 wallet create request", { message: err?.message }, { code: "SCHEMA_INVALID" });
          }

          const policyInput =
            body?.policy && typeof body.policy === "object" && !Array.isArray(body.policy) ? body.policy : body ?? {};
          let policy = null;
          try {
            policy = normalizeX402WalletPolicyInput(
              {
                ...policyInput,
                sponsorRef,
                sponsorWalletRef,
                policyRef: policyRefInput,
                policyVersion: policyVersionInput
              },
              { fieldPath: "policy", existing: existingPolicy }
            );
          } catch (err) {
            return sendError(res, 400, "invalid x402 wallet policy", { message: err?.message }, { code: "SCHEMA_INVALID" });
          }

          const existingWalletPolicies = await listX402WalletPolicyRecords({
            tenantId,
            sponsorWalletRef,
            limit: 1,
            offset: 0
          });
          const walletCreated = !Array.isArray(existingWalletPolicies) || existingWalletPolicies.length === 0;
          const responseBody = {
            ok: true,
            created: walletCreated,
            wallet: normalizeForCanonicalJson(
              {
                schemaVersion: "X402SponsorWallet.v1",
                sponsorRef: policy.sponsorRef ?? sponsorRef,
                sponsorWalletRef: policy.sponsorWalletRef,
                activePolicyRef: policy.policyRef,
                activePolicyVersion: policy.policyVersion,
                policyFingerprint: policy.policyFingerprint,
                createdAt: policy.createdAt,
                updatedAt: policy.updatedAt
              },
              { path: "$" }
            ),
            policy
          };
          const statusCode = walletCreated ? 201 : 200;
          const ops = [{ kind: "X402_WALLET_POLICY_UPSERT", tenantId, policy }];
          if (idemStoreKey) {
            ops.push({ kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode, body: responseBody } });
          }
          await commitTx(ops, {
            audit: makeOpsAudit({
              action: "X402_WALLET_ISSUER_CREATE",
              targetType: "x402_wallet",
              targetId: policy.sponsorWalletRef,
              details: {
                sponsorRef: policy.sponsorRef ?? null,
                policyRef: policy.policyRef,
                policyVersion: policy.policyVersion
              }
            })
          });
          return sendJson(res, statusCode, responseBody);
        }

        if (parts[0] === "x402" && parts[1] === "wallets" && parts[2] && parts[3] === "policy" && parts.length === 4 && req.method === "PUT") {
          if (!requireProtocolHeaderForWrite(req, res)) return;
          let sponsorWalletRef = null;
          try {
            sponsorWalletRef = normalizeOptionalX402RefInput(decodePathPart(parts[2]), "sponsorWalletRef", { allowNull: false, max: 200 });
          } catch (err) {
            return sendError(res, 400, "invalid sponsorWalletRef", { message: err?.message }, { code: "SCHEMA_INVALID" });
          }

          const body = await readJsonBody(req);
          let idemStoreKey = null;
          let idemRequestHash = null;
          try {
            ({ idemStoreKey, idemRequestHash } = readIdempotency({ method: "PUT", requestPath: path, expectedPrevChainHash: null, body }));
          } catch (err) {
            return sendError(res, 400, "invalid idempotency key", { message: err?.message });
          }
          if (idemStoreKey) {
            const existingIdem = store.idempotency.get(idemStoreKey);
            if (existingIdem) {
              if (existingIdem.requestHash !== idemRequestHash) {
                return sendError(res, 409, "idempotency key conflict", "request differs from initial use of this key");
              }
              return sendJson(res, existingIdem.statusCode, existingIdem.body);
            }
          }

          const policyInput =
            body?.policy && typeof body.policy === "object" && !Array.isArray(body.policy) ? body.policy : body ?? {};
          const policyRefInput = policyInput.policyRef ?? body?.policyRef ?? "default";
          const policyVersionInput = policyInput.policyVersion ?? body?.policyVersion ?? 1;
          let normalizedPolicyRef = null;
          let normalizedPolicyVersion = null;
          try {
            normalizedPolicyRef = normalizeOptionalX402RefInput(policyRefInput, "policyRef", { allowNull: false, max: 200 });
            normalizedPolicyVersion = normalizeOptionalX402PositiveSafeInt(policyVersionInput, "policyVersion", { allowNull: false });
          } catch (err) {
            return sendError(res, 400, "invalid wallet policy key", { message: err?.message }, { code: "SCHEMA_INVALID" });
          }

          const existingPolicy = await getX402WalletPolicyRecord({
            tenantId,
            sponsorWalletRef,
            policyRef: normalizedPolicyRef,
            policyVersion: normalizedPolicyVersion
          });
          const sponsorRef =
            normalizeOptionalX402RefInput(
              policyInput.sponsorRef ?? body?.sponsorRef ?? existingPolicy?.sponsorRef ?? null,
              "sponsorRef",
              { allowNull: false, max: 200 }
            );

          let policy = null;
          try {
            policy = normalizeX402WalletPolicyInput(
              {
                ...policyInput,
                sponsorRef,
                sponsorWalletRef,
                policyRef: normalizedPolicyRef,
                policyVersion: normalizedPolicyVersion
              },
              { fieldPath: "policy", existing: existingPolicy }
            );
          } catch (err) {
            return sendError(res, 400, "invalid x402 wallet policy", { message: err?.message }, { code: "SCHEMA_INVALID" });
          }

          const responseBody = {
            ok: true,
            created: existingPolicy ? false : true,
            wallet: normalizeForCanonicalJson(
              {
                schemaVersion: "X402SponsorWallet.v1",
                sponsorRef: policy.sponsorRef ?? sponsorRef,
                sponsorWalletRef: policy.sponsorWalletRef,
                activePolicyRef: policy.policyRef,
                activePolicyVersion: policy.policyVersion,
                policyFingerprint: policy.policyFingerprint,
                createdAt: policy.createdAt,
                updatedAt: policy.updatedAt
              },
              { path: "$" }
            ),
            policy
          };
          const statusCode = existingPolicy ? 200 : 201;
          const ops = [{ kind: "X402_WALLET_POLICY_UPSERT", tenantId, policy }];
          if (idemStoreKey) {
            ops.push({ kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode, body: responseBody } });
          }
          await commitTx(ops, {
            audit: makeOpsAudit({
              action: "X402_WALLET_ISSUER_POLICY_UPSERT",
              targetType: "x402_wallet_policy",
              targetId: `${policy.sponsorWalletRef}::${policy.policyRef}::${policy.policyVersion}`,
              details: {
                sponsorRef: policy.sponsorRef ?? null,
                status: policy.status
              }
            })
          });
          return sendJson(res, statusCode, responseBody);
        }

        if (parts[0] === "x402" && parts[1] === "wallets" && parts[2] && parts[3] === "policy" && parts.length === 4 && req.method === "GET") {
          let sponsorWalletRef = null;
          try {
            sponsorWalletRef = normalizeOptionalX402RefInput(decodePathPart(parts[2]), "sponsorWalletRef", { allowNull: false, max: 200 });
          } catch (err) {
            return sendError(res, 400, "invalid sponsorWalletRef", { message: err?.message }, { code: "SCHEMA_INVALID" });
          }

          const policyRefRaw = url.searchParams.get("policyRef");
          const policyVersionRaw = url.searchParams.get("policyVersion");
          const statusRaw = url.searchParams.get("status");
          const limitRaw = url.searchParams.get("limit");
          const offsetRaw = url.searchParams.get("offset");
          if ((policyRefRaw && !policyVersionRaw) || (!policyRefRaw && policyVersionRaw)) {
            return sendError(res, 400, "policyRef and policyVersion must be provided together", null, { code: "SCHEMA_INVALID" });
          }
          if (policyRefRaw && policyVersionRaw) {
            let policyRef = null;
            let policyVersion = null;
            try {
              policyRef = normalizeOptionalX402RefInput(policyRefRaw, "policyRef", { allowNull: false, max: 200 });
              policyVersion = normalizeOptionalX402PositiveSafeInt(policyVersionRaw, "policyVersion", { allowNull: false });
            } catch (err) {
              return sendError(res, 400, "invalid x402 wallet policy key", { message: err?.message }, { code: "SCHEMA_INVALID" });
            }
            const policy = await getX402WalletPolicyRecord({ tenantId, sponsorWalletRef, policyRef, policyVersion });
            if (!policy) return sendError(res, 404, "x402 wallet policy not found", null, { code: "NOT_FOUND" });
            return sendJson(res, 200, { ok: true, policy });
          }
          const limit = limitRaw === null || limitRaw === "" ? 200 : Number(limitRaw);
          const offset = offsetRaw === null || offsetRaw === "" ? 0 : Number(offsetRaw);
          if (!Number.isSafeInteger(limit) || limit < 1 || limit > 2000) {
            return sendError(res, 400, "invalid list query", { message: "limit must be an integer in range 1..2000" }, { code: "SCHEMA_INVALID" });
          }
          if (!Number.isSafeInteger(offset) || offset < 0) {
            return sendError(res, 400, "invalid list query", { message: "offset must be a non-negative integer" }, { code: "SCHEMA_INVALID" });
          }
          let policies = [];
          try {
            policies = await listX402WalletPolicyRecords({
              tenantId,
              sponsorWalletRef,
              status: statusRaw,
              limit,
              offset
            });
          } catch (err) {
            return sendError(res, 400, "invalid x402 wallet policy query", { message: err?.message }, { code: "SCHEMA_INVALID" });
          }
          return sendJson(res, 200, { ok: true, sponsorWalletRef, limit, offset, policies });
        }

        if (parts[0] === "x402" && parts[1] === "wallets" && parts[2] && parts[3] === "authorize" && parts.length === 4 && req.method === "POST") {
          if (!requireProtocolHeaderForWrite(req, res)) return;
          let sponsorWalletRef = null;
          try {
            sponsorWalletRef = normalizeOptionalX402RefInput(decodePathPart(parts[2]), "sponsorWalletRef", { allowNull: false, max: 200 });
          } catch (err) {
            return sendError(res, 400, "invalid sponsorWalletRef", { message: err?.message }, { code: "SCHEMA_INVALID" });
          }

          const body = await readJsonBody(req);
          let idemStoreKey = null;
          let idemRequestHash = null;
          try {
            ({ idemStoreKey, idemRequestHash } = readIdempotency({ method: "POST", requestPath: path, expectedPrevChainHash: null, body }));
          } catch (err) {
            return sendError(res, 400, "invalid idempotency key", { message: err?.message });
          }
          if (idemStoreKey) {
            const existingIdem = store.idempotency.get(idemStoreKey);
            if (existingIdem) {
              if (existingIdem.requestHash !== idemRequestHash) {
                return sendError(res, 409, "idempotency key conflict", "request differs from initial use of this key");
              }
              return sendJson(res, existingIdem.statusCode, existingIdem.body);
            }
          }

          const gateId = typeof body?.gateId === "string" && body.gateId.trim() !== "" ? body.gateId.trim() : null;
          if (!gateId) return sendError(res, 400, "gateId is required", null, { code: "SCHEMA_INVALID" });
          const requestBindingModeRaw =
            typeof body?.requestBindingMode === "string" && body.requestBindingMode.trim() !== ""
              ? body.requestBindingMode.trim().toLowerCase()
              : null;
          if (requestBindingModeRaw !== null && requestBindingModeRaw !== "strict") {
            return sendError(res, 400, "requestBindingMode must be strict when provided", null, { code: "SCHEMA_INVALID" });
          }
          let requestBindingSha256 = null;
          try {
            requestBindingSha256 = normalizeSha256HashInput(body?.requestBindingSha256 ?? null, "requestBindingSha256", { allowNull: true });
          } catch (err) {
            return sendError(res, 400, "invalid requestBindingSha256", { message: err?.message }, { code: "SCHEMA_INVALID" });
          }
          const requestBindingMode = requestBindingModeRaw ?? (requestBindingSha256 ? "strict" : null);
          if (requestBindingMode === "strict" && !requestBindingSha256) {
            return sendError(res, 400, "requestBindingSha256 is required when requestBindingMode=strict", null, {
              code: "SCHEMA_INVALID"
            });
          }
          let requestedQuoteId = null;
          try {
            requestedQuoteId = normalizeOptionalX402RefInput(body?.quoteId ?? null, "quoteId", { allowNull: true, max: 200 });
          } catch (err) {
            return sendError(res, 400, "invalid quoteId", { message: err?.message }, { code: "SCHEMA_INVALID" });
          }
          let walletAuthorizationDecisionToken = null;
          try {
            walletAuthorizationDecisionToken = normalizeX402WalletIssuerDecisionTokenInput(
              body?.walletAuthorizationDecisionToken ?? body?.walletAuthorizationDecision ?? null,
              "walletAuthorizationDecisionToken",
              { allowNull: true }
            );
          } catch (err) {
            return sendError(res, 400, "invalid walletAuthorizationDecisionToken", { message: err?.message }, { code: "SCHEMA_INVALID" });
          }

          const gate = typeof store.getX402Gate === "function" ? await store.getX402Gate({ tenantId, gateId }) : null;
          if (!gate) return sendError(res, 404, "gate not found", null, { code: "NOT_FOUND" });
          if (String(gate.status ?? "").toLowerCase() === "resolved") {
            return sendError(res, 409, "gate is already resolved", null, { code: "X402_GATE_TERMINAL" });
          }
          const runId = String(gate.runId ?? "");
          const settlement = typeof store.getAgentRunSettlement === "function" ? await store.getAgentRunSettlement({ tenantId, runId }) : null;
          if (!settlement) return sendError(res, 404, "settlement not found for gate", null, { code: "NOT_FOUND" });
          if (String(settlement.status ?? "").toLowerCase() !== "locked") {
            return sendError(res, 409, "settlement already resolved", null, { code: "X402_GATE_TERMINAL" });
          }
          const payerAgentId = typeof gate?.payerAgentId === "string" && gate.payerAgentId.trim() !== "" ? gate.payerAgentId.trim() : null;
          if (!payerAgentId) return sendError(res, 409, "gate payer missing", null, { code: "X402_GATE_INVALID" });
          const amountCents = Number(gate?.terms?.amountCents ?? settlement?.amountCents ?? 0);
          if (!Number.isSafeInteger(amountCents) || amountCents <= 0) return sendError(res, 409, "gate amount invalid", null, { code: "X402_GATE_INVALID" });
          const currency =
            typeof gate?.terms?.currency === "string" && gate.terms.currency.trim() !== ""
              ? gate.terms.currency.trim().toUpperCase()
              : settlement?.currency ?? "USD";
          const gateAgentPassport =
            gate?.agentPassport && typeof gate.agentPassport === "object" && !Array.isArray(gate.agentPassport) ? gate.agentPassport : null;
          if (!gateAgentPassport) {
            return sendError(res, 409, "gate does not use wallet-policy issuer", null, { code: "X402_WALLET_ISSUER_NOT_APPLICABLE" });
          }
          const gateWalletRef =
            typeof gateAgentPassport.sponsorWalletRef === "string" && gateAgentPassport.sponsorWalletRef.trim() !== ""
              ? gateAgentPassport.sponsorWalletRef.trim()
              : null;
          if (!gateWalletRef || gateWalletRef !== sponsorWalletRef) {
            return sendError(res, 409, "sponsor wallet does not match gate passport", null, { code: "X402_WALLET_ISSUER_WALLET_MISMATCH" });
          }
          const walletPolicyResolution = await resolveX402WalletPolicyForPassport({
            tenantId,
            gateAgentPassport
          });
          if (walletPolicyResolution?.error) {
            return sendError(
              res,
              409,
              "x402 wallet policy reference is invalid",
              {
                message: walletPolicyResolution.error.message ?? null,
                sponsorWalletRef: walletPolicyResolution.sponsorWalletRef ?? null
              },
              { code: walletPolicyResolution.error.code ?? "X402_WALLET_POLICY_REFERENCE_INVALID" }
            );
          }
          const resolvedWalletPolicy = walletPolicyResolution?.policy ?? null;
          if (!resolvedWalletPolicy) {
            return sendError(res, 404, "x402 wallet policy not found", null, { code: "X402_WALLET_POLICY_NOT_FOUND" });
          }
          const payeeProviderId =
            typeof gate?.payeeAgentId === "string" && gate.payeeAgentId.trim() !== ""
              ? gate.payeeAgentId.trim()
              : typeof gate?.terms?.providerId === "string" && gate.terms.providerId.trim() !== ""
                ? gate.terms.providerId.trim()
                : null;
          const nowAt = nowIso();
          const nowMs = Date.parse(nowAt);
          const nowUnix = Math.floor(nowMs / 1000);
          const existingQuote =
            gate?.quote && typeof gate.quote === "object" && !Array.isArray(gate.quote) ? gate.quote : null;
          const existingQuoteExpiresAtMs = Number.isFinite(Date.parse(String(existingQuote?.expiresAt ?? "")))
            ? Date.parse(String(existingQuote.expiresAt))
            : Number.NaN;
          if (requestedQuoteId && !existingQuote) {
            return sendError(res, 409, "requested quoteId was not found on gate", null, { code: "X402_QUOTE_NOT_FOUND" });
          }
          if (requestedQuoteId && existingQuote && String(existingQuote.quoteId ?? "") !== String(requestedQuoteId)) {
            return sendError(res, 409, "requested quoteId does not match gate quote", null, { code: "X402_QUOTE_MISMATCH" });
          }
          const selectedQuote =
            existingQuote &&
            (!requestedQuoteId || String(existingQuote.quoteId ?? "") === String(requestedQuoteId)) &&
            Number.isFinite(existingQuoteExpiresAtMs) &&
            existingQuoteExpiresAtMs > nowMs
              ? existingQuote
              : null;
          if (requestedQuoteId && !selectedQuote) {
            return sendError(res, 409, "requested quote has expired", null, { code: "X402_QUOTE_EXPIRED" });
          }
          const quoteRequestBindingMode =
            selectedQuote && typeof selectedQuote.requestBindingMode === "string" && selectedQuote.requestBindingMode.trim() !== ""
              ? selectedQuote.requestBindingMode.trim().toLowerCase()
              : null;
          const quoteRequestBindingSha256 =
            selectedQuote && typeof selectedQuote.requestBindingSha256 === "string" && selectedQuote.requestBindingSha256.trim() !== ""
              ? selectedQuote.requestBindingSha256.trim().toLowerCase()
              : null;
          const effectiveRequestBindingMode = requestBindingMode ?? quoteRequestBindingMode ?? null;
          const effectiveRequestBindingSha256 = requestBindingSha256 ?? quoteRequestBindingSha256 ?? null;
          if (effectiveRequestBindingMode === "strict" && !effectiveRequestBindingSha256) {
            return sendError(res, 409, "strict request binding requires sha256 hash", null, { code: "X402_REQUEST_BINDING_REQUIRED" });
          }
          if (requestBindingMode === "strict" && quoteRequestBindingMode === "strict" && quoteRequestBindingSha256) {
            if (String(requestBindingSha256 ?? "") !== String(quoteRequestBindingSha256)) {
              return sendError(res, 409, "request binding does not match quote binding", null, { code: "X402_QUOTE_REQUEST_BINDING_MISMATCH" });
            }
          }
          const effectiveQuoteId =
            typeof selectedQuote?.quoteId === "string" && selectedQuote.quoteId.trim() !== "" ? selectedQuote.quoteId.trim() : null;
          const effectiveQuoteSha256 =
            typeof selectedQuote?.quoteSha256 === "string" && selectedQuote.quoteSha256.trim() !== ""
              ? selectedQuote.quoteSha256.trim().toLowerCase()
              : null;

          try {
            await assertX402WalletPolicyForAuthorization({
              tenantId,
              gate,
              policy: resolvedWalletPolicy,
              amountCents,
              currency,
              payeeProviderId,
              effectiveQuoteId,
              effectiveRequestBindingMode,
              effectiveRequestBindingSha256,
              nowAt
            });
          } catch (err) {
            return sendError(
              res,
              409,
              "x402 wallet policy blocked authorization",
              { message: err?.message ?? null, code: err?.code ?? null, details: err?.details ?? null },
              { code: err?.code ?? "X402_WALLET_POLICY_BLOCKED" }
            );
          }

          const sponsorRef =
            typeof resolvedWalletPolicy?.sponsorRef === "string" && resolvedWalletPolicy.sponsorRef.trim() !== ""
              ? resolvedWalletPolicy.sponsorRef.trim()
              : typeof gateAgentPassport?.sponsorRef === "string" && gateAgentPassport.sponsorRef.trim() !== ""
                ? gateAgentPassport.sponsorRef.trim()
                : payerAgentId;
          const policyRef = String(resolvedWalletPolicy.policyRef ?? "");
          const policyVersion = Number(resolvedWalletPolicy.policyVersion ?? 0);
          const policyFingerprint =
            typeof resolvedWalletPolicy.policyFingerprint === "string" && resolvedWalletPolicy.policyFingerprint.trim() !== ""
              ? resolvedWalletPolicy.policyFingerprint.trim().toLowerCase()
              : null;
          if (!policyFingerprint) {
            return sendError(res, 409, "x402 wallet policy fingerprint missing", null, { code: "X402_WALLET_POLICY_FINGERPRINT_MISSING" });
          }

          let idemHeaderValue = null;
          try {
            idemHeaderValue = extractIdempotencyKey(req.headers["x-idempotency-key"] ?? null);
          } catch {}
          const decisionPayload = buildX402WalletIssuerDecisionPayloadV1({
            decisionId: createId("x402dec"),
            gateId,
            sponsorRef,
            sponsorWalletRef,
            policyRef,
            policyVersion,
            policyFingerprint,
            amountCents,
            currency,
            payeeProviderId: String(payeeProviderId ?? ""),
            ...(effectiveQuoteId ? { quoteId: effectiveQuoteId } : {}),
            ...(effectiveQuoteSha256 ? { quoteSha256: effectiveQuoteSha256 } : {}),
            ...(effectiveRequestBindingMode ? { requestBindingMode: effectiveRequestBindingMode } : {}),
            ...(effectiveRequestBindingSha256 ? { requestBindingSha256: effectiveRequestBindingSha256 } : {}),
            idempotencyKey: idemHeaderValue ?? `x402wallet:${gateId}:${effectiveQuoteId ?? "noquote"}`,
            nonce: createId("x402nonce"),
            iat: nowUnix,
            exp: nowUnix + settldPayTokenTtlSecondsValue
          });
          const mintedDecision = mintX402WalletIssuerDecisionTokenV1({
            payload: decisionPayload,
            publicKeyPem: store.serverSigner.publicKeyPem,
            privateKeyPem: store.serverSigner.privateKeyPem
          });
          const responseBody = {
            ok: true,
            gateId,
            sponsorWalletRef,
            policyRef,
            policyVersion,
            walletAuthorizationDecisionToken: mintedDecision.token,
            tokenKid: mintedDecision.kid,
            tokenSha256: mintedDecision.tokenSha256,
            expiresAt: new Date(decisionPayload.exp * 1000).toISOString(),
            quoteId: effectiveQuoteId,
            quoteSha256: effectiveQuoteSha256,
            requestBindingMode: effectiveRequestBindingMode,
            requestBindingSha256: effectiveRequestBindingSha256
          };
          if (idemStoreKey) {
            await store.commitTx({
              at: nowAt,
              ops: [{ kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode: 200, body: responseBody } }]
            });
          }
          return sendJson(res, 200, responseBody);
        }

        if (parts[0] === "x402" && parts[1] === "wallets" && parts[2] && parts[3] === "ledger" && parts.length === 4 && req.method === "GET") {
          if (typeof store.listX402Receipts !== "function") return sendError(res, 501, "x402 receipts are not supported for this store");
          let sponsorWalletRef = null;
          try {
            sponsorWalletRef = normalizeOptionalX402RefInput(decodePathPart(parts[2]), "sponsorWalletRef", { allowNull: false, max: 200 });
          } catch (err) {
            return sendError(res, 400, "invalid sponsorWalletRef", { message: err?.message }, { code: "SCHEMA_INVALID" });
          }
          let query;
          try {
            query = parseX402ReceiptListQuery(url);
          } catch (err) {
            return sendError(res, 400, "invalid wallet ledger query", { message: err?.message }, { code: "SCHEMA_INVALID" });
          }
          const resolvedWalletPolicy = await resolveX402WalletPolicyForIssuerQuery({ tenantId, sponsorWalletRef });
          const effectiveSponsorId = query.sponsorId ?? resolvedWalletPolicy?.sponsorRef ?? null;
          const fetchReceiptPage = async ({ sponsorId, sponsorWalletRefFilter }) => {
            if (typeof store.listX402ReceiptsPage === "function") {
              return await store.listX402ReceiptsPage({
                tenantId,
                agentId: query.agentId,
                sponsorId,
                sponsorWalletRef: sponsorWalletRefFilter,
                toolId: query.toolId,
                state: query.state,
                from: query.from,
                to: query.to,
                cursor: query.cursor,
                limit: query.limit,
                offset: query.offset
              });
            }
            return {
              receipts: await store.listX402Receipts({
                tenantId,
                agentId: query.agentId,
                sponsorId,
                sponsorWalletRef: sponsorWalletRefFilter,
                toolId: query.toolId,
                state: query.state,
                from: query.from,
                to: query.to,
                limit: query.limit,
                offset: query.offset
              }),
              nextCursor: null
            };
          };

          let page = await fetchReceiptPage({ sponsorId: effectiveSponsorId, sponsorWalletRefFilter: sponsorWalletRef });
          let receipts = Array.isArray(page?.receipts) ? page.receipts : [];
          if (receipts.length === 0 && effectiveSponsorId && !query.sponsorWalletRef) {
            const fallbackPage = await fetchReceiptPage({ sponsorId: effectiveSponsorId, sponsorWalletRefFilter: null });
            const fallbackRows = Array.isArray(fallbackPage?.receipts) ? fallbackPage.receipts : [];
            const narrowed = fallbackRows.filter((row) => {
              if (!row || typeof row !== "object" || Array.isArray(row)) return false;
              const rowWalletRef =
                typeof row.sponsorWalletRef === "string" && row.sponsorWalletRef.trim() !== "" ? row.sponsorWalletRef.trim() : null;
              if (rowWalletRef) return rowWalletRef === sponsorWalletRef;
              return String(row.sponsorRef ?? "") === String(effectiveSponsorId);
            });
            page = { ...fallbackPage, receipts: narrowed };
            receipts = narrowed;
          }
          const entries = receipts.map((receipt) => toX402WalletLedgerEntry(receipt)).filter((entry) => Boolean(entry));
          const summary = summarizeX402WalletLedgerEntries(entries);
          return sendJson(res, 200, {
            ok: true,
            sponsorWalletRef,
            entries,
            summary,
            limit: query.limit,
            offset: query.offset,
            nextCursor: page?.nextCursor ?? null
          });
        }

        if (parts[0] === "x402" && parts[1] === "wallets" && parts[2] && parts[3] === "budgets" && parts.length === 4 && req.method === "GET") {
          let sponsorWalletRef = null;
          try {
            sponsorWalletRef = normalizeOptionalX402RefInput(decodePathPart(parts[2]), "sponsorWalletRef", { allowNull: false, max: 200 });
          } catch (err) {
            return sendError(res, 400, "invalid sponsorWalletRef", { message: err?.message }, { code: "SCHEMA_INVALID" });
          }
          const atRaw = url.searchParams.get("at");
          const atIso =
            atRaw === null || atRaw === undefined || String(atRaw).trim() === ""
              ? nowIso()
              : Number.isFinite(Date.parse(String(atRaw).trim()))
                ? new Date(String(atRaw).trim()).toISOString()
                : null;
          if (!atIso) {
            return sendError(res, 400, "invalid budgets query", { message: "at must be an ISO date-time when provided" }, { code: "SCHEMA_INVALID" });
          }
          let policy = null;
          try {
            policy = await resolveX402WalletPolicyForIssuerQuery({
              tenantId,
              sponsorWalletRef,
              policyRef: url.searchParams.get("policyRef"),
              policyVersion: url.searchParams.get("policyVersion")
            });
          } catch (err) {
            return sendError(res, 400, "invalid budgets policy selector", { message: err?.message }, { code: "SCHEMA_INVALID" });
          }
          if (!policy) return sendError(res, 404, "x402 wallet policy not found", null, { code: "NOT_FOUND" });

          const dayKey = atIso.slice(0, 10);
          const dailyAuthorizedExposureCents = computeX402DailyAuthorizedExposureCents({
            tenantId,
            dayKey,
            sponsorWalletRef
          });
          const maxAmountCents = Number.isSafeInteger(policy.maxAmountCents) ? policy.maxAmountCents : null;
          const maxDailyAuthorizationCents = Number.isSafeInteger(policy.maxDailyAuthorizationCents)
            ? policy.maxDailyAuthorizationCents
            : null;
          const remainingDailyAuthorizationCents =
            maxDailyAuthorizationCents === null ? null : Math.max(0, maxDailyAuthorizationCents - dailyAuthorizedExposureCents);
          const authorizationSummary = summarizeX402WalletAuthorizationState({ tenantId, sponsorWalletRef });
          return sendJson(res, 200, {
            ok: true,
            sponsorWalletRef,
            at: atIso,
            policy,
            budgets: normalizeForCanonicalJson(
              {
                schemaVersion: "X402WalletBudgetSnapshot.v1",
                dayKey,
                maxAmountCents,
                maxDailyAuthorizationCents,
                dailyAuthorizedExposureCents,
                remainingDailyAuthorizationCents,
                authorizationSummary
              },
              { path: "$" }
            )
          });
        }

        if (parts[0] === "x402" && parts[1] === "gate" && parts[2] === "create" && parts.length === 3 && req.method === "POST") {
          if (!requireProtocolHeaderForWrite(req, res)) return;

          const body = await readJsonBody(req);
          let idemStoreKey = null;
          let idemRequestHash = null;
          try {
            ({ idemStoreKey, idemRequestHash } = readIdempotency({ method: "POST", requestPath: path, expectedPrevChainHash: null, body }));
          } catch (err) {
            return sendError(res, 400, "invalid idempotency key", { message: err?.message });
          }
          if (idemStoreKey) {
            const existing = store.idempotency.get(idemStoreKey);
            if (existing) {
              if (existing.requestHash !== idemRequestHash) {
                return sendError(res, 409, "idempotency key conflict", "request differs from initial use of this key");
              }
              return sendJson(res, existing.statusCode, existing.body);
            }
          }

          const payerAgentId = typeof body?.payerAgentId === "string" && body.payerAgentId.trim() !== "" ? body.payerAgentId.trim() : null;
          const payeeAgentId = typeof body?.payeeAgentId === "string" && body.payeeAgentId.trim() !== "" ? body.payeeAgentId.trim() : null;
          if (!payerAgentId || !payeeAgentId || payerAgentId === payeeAgentId) {
            return sendError(res, 400, "payerAgentId and payeeAgentId are required and must differ", null, { code: "SCHEMA_INVALID" });
          }

          const nowAt = nowIso();
          const gateId = typeof body?.gateId === "string" && body.gateId.trim() !== "" ? body.gateId.trim() : createId("x402gate");
          const runId = `x402_${gateId}`;

          const amountCents = Number(body?.amountCents);
          if (!Number.isSafeInteger(amountCents) || amountCents <= 0) {
            return sendError(res, 400, "amountCents must be a positive safe integer", null, { code: "SCHEMA_INVALID" });
          }
          const currency = typeof body?.currency === "string" && body.currency.trim() !== "" ? body.currency.trim().toUpperCase() : "USD";
          const disputeWindowDays = body?.disputeWindowDays ?? 0;
          const disputeWindowMs = body?.disputeWindowMs ?? null;
          const holdbackBps = body?.holdbackBps ?? 0;
          let terms;
          try {
            terms = buildX402SettlementTerms({
              amountCents,
              currency,
              disputeWindowDays,
              disputeWindowMs,
              holdbackBps,
              evidenceRequirements: body?.evidenceRequirements ?? null,
              slaPolicy: body?.slaPolicy ?? null
            });
          } catch (err) {
            return sendError(res, 400, "invalid settlement terms", { message: err?.message }, { code: "SCHEMA_INVALID" });
          }

          const upstream = (() => {
            const parsed = parseX402PaymentRequired(body?.paymentRequiredHeader ?? body?.paymentRequired ?? null);
            return parsed.ok ? parsed : null;
          })();

	          let agreementHash = null;
	          try {
	            agreementHash = normalizeSha256HashInput(body?.agreementHash, "agreementHash", { allowNull: true });
	          } catch (err) {
	            return sendError(res, 400, "invalid agreementHash", { message: err?.message }, { code: "SCHEMA_INVALID" });
	          }

	          let providerKey = null;
	          const providerPublicKeyPem =
	            typeof body?.providerPublicKeyPem === "string" && body.providerPublicKeyPem.trim() !== "" ? body.providerPublicKeyPem.trim() : null;
	          if (providerPublicKeyPem) {
	            try {
	              const keyId = keyIdFromPublicKeyPem(providerPublicKeyPem);
	              providerKey = { algorithm: "ed25519", keyId, publicKeyPem: providerPublicKeyPem };
	            } catch (err) {
	              return sendError(res, 400, "invalid providerPublicKeyPem", { message: err?.message }, { code: "SCHEMA_INVALID" });
	            }
	          }
          let agentPassport = null;
          try {
            agentPassport = normalizeX402AgentPassportInput(body?.agentPassport ?? null, {
              fieldPath: "agentPassport",
              allowNull: true
            });
          } catch (err) {
            return sendError(res, 400, "invalid agentPassport", { message: err?.message }, { code: "SCHEMA_INVALID" });
          }
          let toolId = null;
          try {
            toolId = normalizeOptionalX402RefInput(body?.toolId ?? null, "toolId", { allowNull: true, max: 200 });
          } catch (err) {
            return sendError(res, 400, "invalid toolId", { message: err?.message }, { code: "SCHEMA_INVALID" });
          }

          const existingGate = typeof store.getX402Gate === "function" ? await store.getX402Gate({ tenantId, gateId }) : null;
          if (existingGate && !idemStoreKey) return sendError(res, 409, "gate already exists", null, { code: "ALREADY_EXISTS" });

          const existingSettlement = typeof store.getAgentRunSettlement === "function" ? await store.getAgentRunSettlement({ tenantId, runId }) : null;
          if (existingSettlement && !idemStoreKey) return sendError(res, 409, "gate run already exists", null, { code: "ALREADY_EXISTS" });

          const payerWalletExisting = typeof store.getAgentWallet === "function" ? await store.getAgentWallet({ tenantId, agentId: payerAgentId }) : null;
          const payeeWalletExisting = typeof store.getAgentWallet === "function" ? await store.getAgentWallet({ tenantId, agentId: payeeAgentId }) : null;

          const autoFundPayerCents = Number(body?.autoFundPayerCents ?? 0);
          if (!Number.isSafeInteger(autoFundPayerCents) || autoFundPayerCents < 0) {
            return sendError(res, 400, "autoFundPayerCents must be a non-negative safe integer", null, { code: "SCHEMA_INVALID" });
          }

	          let payerWallet = ensureAgentWallet({ wallet: payerWalletExisting, tenantId, agentId: payerAgentId, currency, at: nowAt });
	          let payeeWallet = ensureAgentWallet({ wallet: payeeWalletExisting, tenantId, agentId: payeeAgentId, currency, at: nowAt });
	          if (!payerWalletExisting && autoFundPayerCents > 0) payerWallet = creditAgentWallet({ wallet: payerWallet, amountCents: autoFundPayerCents, at: nowAt });
	          try {
	            const payerIdentity = await getAgentIdentityRecord({ tenantId, agentId: payerAgentId });
	            if (payerIdentity) {
	              await assertSettlementWithinWalletPolicy({ tenantId, agentIdentity: payerIdentity, amountCents, at: nowAt });
	            }
	          } catch (err) {
	            if (err?.code?.startsWith?.("WALLET_POLICY_")) {
	              return sendError(res, 409, "wallet policy blocked settlement", { message: err?.message, code: err?.code ?? null });
	            }
	            return sendError(res, 400, "invalid payer agent identity", { message: err?.message });
	          }
	          try {
	            payerWallet = lockAgentWalletEscrow({ wallet: payerWallet, amountCents, at: nowAt });
	          } catch (err) {
	            if (err?.code === "INSUFFICIENT_WALLET_BALANCE") {
	              return sendError(res, 409, "insufficient wallet balance", { message: err?.message }, { code: "INSUFFICIENT_FUNDS" });
            }
            throw err;
          }

          const settlement = createAgentRunSettlement({
            tenantId,
            runId,
            agentId: payeeAgentId,
            payerAgentId,
            amountCents,
            currency,
            disputeWindowDays: terms.disputeWindowDays,
            at: nowAt
          });

          const gate = normalizeForCanonicalJson(
            {
              schemaVersion: "X402GateRecord.v1",
              gateId,
              tenantId,
              runId,
	              payerAgentId,
	              payeeAgentId,
	              ...(agreementHash ? { agreementHash } : {}),
	              ...(providerKey ? { providerKey } : {}),
                ...(toolId ? { toolId } : {}),
                ...(agentPassport ? { agentPassport } : {}),
	              terms,
	              upstream,
              authorization: {
                schemaVersion: "X402GateAuthorization.v1",
                authorizationRef: `auth_${gateId}`,
                status: "pending",
                walletEscrow: {
                  status: "locked",
                  amountCents,
                  currency,
                  lockedAt: nowAt
                },
                reserve: null,
                token: null,
                updatedAt: nowAt
              },
	              status: "held",
	              createdAt: nowAt,
	              updatedAt: nowAt
            },
            { path: "$" }
          );

          const ops = [];
          if (!payerWalletExisting || payerWalletExisting.revision !== payerWallet.revision) {
            ops.push({ kind: "AGENT_WALLET_UPSERT", tenantId, wallet: payerWallet });
          }
          if (!payeeWalletExisting) {
            ops.push({ kind: "AGENT_WALLET_UPSERT", tenantId, wallet: payeeWallet });
          }
          ops.push({ kind: "AGENT_RUN_SETTLEMENT_UPSERT", tenantId, runId, settlement });
          ops.push({ kind: "X402_GATE_UPSERT", tenantId, gateId, gate });

          const responseBody = { ok: true, gate, settlement };
          if (idemStoreKey) {
            ops.push({ kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode: 201, body: responseBody } });
          }
          await store.commitTx({ at: nowAt, ops });
          return sendJson(res, 201, responseBody);
        }

        if (parts[0] === "x402" && parts[1] === "gate" && parts[2] === "quote" && parts.length === 3 && req.method === "POST") {
          if (!requireProtocolHeaderForWrite(req, res)) return;

          const body = await readJsonBody(req);
          let idemStoreKey = null;
          let idemRequestHash = null;
          try {
            ({ idemStoreKey, idemRequestHash } = readIdempotency({ method: "POST", requestPath: path, expectedPrevChainHash: null, body }));
          } catch (err) {
            return sendError(res, 400, "invalid idempotency key", { message: err?.message });
          }
          if (idemStoreKey) {
            const existing = store.idempotency.get(idemStoreKey);
            if (existing) {
              if (existing.requestHash !== idemRequestHash) {
                return sendError(res, 409, "idempotency key conflict", "request differs from initial use of this key");
              }
              return sendJson(res, existing.statusCode, existing.body);
            }
          }

          const gateId = typeof body?.gateId === "string" && body.gateId.trim() !== "" ? body.gateId.trim() : null;
          if (!gateId) return sendError(res, 400, "gateId is required", null, { code: "SCHEMA_INVALID" });
          const requestBindingModeRaw =
            typeof body?.requestBindingMode === "string" && body.requestBindingMode.trim() !== ""
              ? body.requestBindingMode.trim().toLowerCase()
              : null;
          if (requestBindingModeRaw !== null && requestBindingModeRaw !== "strict") {
            return sendError(res, 400, "requestBindingMode must be strict when provided", null, { code: "SCHEMA_INVALID" });
          }
          let requestBindingSha256 = null;
          try {
            requestBindingSha256 = normalizeSha256HashInput(body?.requestBindingSha256 ?? null, "requestBindingSha256", { allowNull: true });
          } catch (err) {
            return sendError(res, 400, "invalid requestBindingSha256", { message: err?.message }, { code: "SCHEMA_INVALID" });
          }
          const requestBindingMode = requestBindingModeRaw ?? (requestBindingSha256 ? "strict" : null);
          if (requestBindingMode === "strict" && !requestBindingSha256) {
            return sendError(res, 400, "requestBindingSha256 is required when requestBindingMode=strict", null, {
              code: "SCHEMA_INVALID"
            });
          }
          let requestedProviderId = null;
          let requestedToolId = null;
          let requestedQuoteId = null;
          try {
            requestedProviderId = normalizeOptionalX402RefInput(body?.providerId ?? null, "providerId", { allowNull: true, max: 200 });
            requestedToolId = normalizeOptionalX402RefInput(body?.toolId ?? null, "toolId", { allowNull: true, max: 200 });
            requestedQuoteId = normalizeOptionalX402RefInput(body?.quoteId ?? null, "quoteId", { allowNull: true, max: 200 });
          } catch (err) {
            return sendError(res, 400, "invalid quote request fields", { message: err?.message }, { code: "SCHEMA_INVALID" });
          }
          const quoteTtlSecondsRaw = body?.quoteTtlSeconds;
          let quoteTtlSeconds = x402QuoteTtlSecondsValue;
          if (!(quoteTtlSecondsRaw === null || quoteTtlSecondsRaw === undefined || String(quoteTtlSecondsRaw).trim() === "")) {
            const n = Number(quoteTtlSecondsRaw);
            if (!Number.isSafeInteger(n) || n <= 0 || n > 3600) {
              return sendError(res, 400, "quoteTtlSeconds must be an integer within 1..3600", null, { code: "SCHEMA_INVALID" });
            }
            quoteTtlSeconds = n;
          }

          const gate = typeof store.getX402Gate === "function" ? await store.getX402Gate({ tenantId, gateId }) : null;
          if (!gate) return sendError(res, 404, "gate not found", null, { code: "NOT_FOUND" });
          if (String(gate.status ?? "").toLowerCase() === "resolved") {
            return sendError(res, 409, "gate is already resolved", null, { code: "X402_GATE_TERMINAL" });
          }
          const runId = String(gate.runId ?? "");
          const settlement = typeof store.getAgentRunSettlement === "function" ? await store.getAgentRunSettlement({ tenantId, runId }) : null;
          if (!settlement) return sendError(res, 404, "settlement not found for gate", null, { code: "NOT_FOUND" });
          const amountCents = Number(gate?.terms?.amountCents ?? settlement?.amountCents ?? 0);
          if (!Number.isSafeInteger(amountCents) || amountCents <= 0) return sendError(res, 409, "gate amount invalid", null, { code: "X402_GATE_INVALID" });
          const currency =
            typeof gate?.terms?.currency === "string" && gate.terms.currency.trim() !== ""
              ? gate.terms.currency.trim().toUpperCase()
              : settlement?.currency ?? "USD";
          const providerId =
            requestedProviderId ??
            (typeof gate?.payeeAgentId === "string" && gate.payeeAgentId.trim() !== ""
              ? gate.payeeAgentId.trim()
              : typeof gate?.terms?.providerId === "string" && gate.terms.providerId.trim() !== ""
                ? gate.terms.providerId.trim()
                : null);
          if (!providerId) return sendError(res, 409, "gate provider missing", null, { code: "X402_GATE_INVALID" });
          const toolId =
            requestedToolId ??
            (typeof gate?.toolId === "string" && gate.toolId.trim() !== "" ? gate.toolId.trim() : null) ??
            (typeof gate?.quote?.toolId === "string" && gate.quote.toolId.trim() !== "" ? gate.quote.toolId.trim() : null);

          const nowAt = nowIso();
          const nowMs = Date.parse(nowAt);
          const existingQuote =
            gate?.quote && typeof gate.quote === "object" && !Array.isArray(gate.quote) ? gate.quote : null;
          const existingQuoteExpiresAtMs = Number.isFinite(Date.parse(String(existingQuote?.expiresAt ?? "")))
            ? Date.parse(String(existingQuote.expiresAt))
            : Number.NaN;
          const existingQuoteMatches =
            !!existingQuote &&
            Number.isFinite(existingQuoteExpiresAtMs) &&
            existingQuoteExpiresAtMs > nowMs &&
            (!requestedQuoteId || String(existingQuote.quoteId ?? "") === String(requestedQuoteId)) &&
            String(existingQuote.providerId ?? "") === String(providerId) &&
            String(existingQuote.toolId ?? "") === String(toolId ?? "") &&
            (requestBindingMode
              ? String(existingQuote.requestBindingMode ?? "") === String(requestBindingMode) &&
                String(existingQuote.requestBindingSha256 ?? "") === String(requestBindingSha256 ?? "")
              : !existingQuote.requestBindingMode && !existingQuote.requestBindingSha256);
          if (existingQuoteMatches) {
            const responseBody = {
              gateId,
              quote: existingQuote
            };
            if (idemStoreKey) {
              await store.commitTx({
                at: nowAt,
                ops: [{ kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode: 200, body: responseBody } }]
              });
            }
            return sendJson(res, 200, responseBody);
          }

          const expiresAt = new Date(nowMs + quoteTtlSeconds * 1000).toISOString();
          const quote = buildX402QuoteRecord({
            gateId,
            quoteId: requestedQuoteId ?? createId("x402quote"),
            providerId,
            toolId,
            amountCents,
            currency,
            requestBindingMode,
            requestBindingSha256,
            quotedAt: nowAt,
            expiresAt
          });
          const nextGate = normalizeForCanonicalJson(
            {
              ...gate,
              ...(toolId ? { toolId } : {}),
              quote,
              updatedAt: nowAt
            },
            { path: "$" }
          );
          const responseBody = { gateId, quote };
          const ops = [{ kind: "X402_GATE_UPSERT", tenantId, gateId, gate: nextGate }];
          if (idemStoreKey) {
            ops.push({ kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode: 200, body: responseBody } });
          }
          await store.commitTx({ at: nowAt, ops });
          return sendJson(res, 200, responseBody);
        }

        if (parts[0] === "x402" && parts[1] === "gate" && parts[2] === "authorize-payment" && parts.length === 3 && req.method === "POST") {
          if (!requireProtocolHeaderForWrite(req, res)) return;

          const body = await readJsonBody(req);
          let idemStoreKey = null;
          let idemRequestHash = null;
          try {
            ({ idemStoreKey, idemRequestHash } = readIdempotency({ method: "POST", requestPath: path, expectedPrevChainHash: null, body }));
          } catch (err) {
            return sendError(res, 400, "invalid idempotency key", { message: err?.message });
          }
          if (idemStoreKey) {
            const existing = store.idempotency.get(idemStoreKey);
            if (existing) {
              if (existing.requestHash !== idemRequestHash) {
                return sendError(res, 409, "idempotency key conflict", "request differs from initial use of this key");
              }
              return sendJson(res, existing.statusCode, existing.body);
            }
          }

          const gateId = typeof body?.gateId === "string" && body.gateId.trim() !== "" ? body.gateId.trim() : null;
          if (!gateId) return sendError(res, 400, "gateId is required", null, { code: "SCHEMA_INVALID" });
          const requestBindingModeRaw =
            typeof body?.requestBindingMode === "string" && body.requestBindingMode.trim() !== ""
              ? body.requestBindingMode.trim().toLowerCase()
              : null;
          if (requestBindingModeRaw !== null && requestBindingModeRaw !== "strict") {
            return sendError(res, 400, "requestBindingMode must be strict when provided", null, { code: "SCHEMA_INVALID" });
          }
          let requestBindingSha256 = null;
          try {
            requestBindingSha256 = normalizeSha256HashInput(body?.requestBindingSha256 ?? null, "requestBindingSha256", { allowNull: true });
          } catch (err) {
            return sendError(res, 400, "invalid requestBindingSha256", { message: err?.message }, { code: "SCHEMA_INVALID" });
          }
          const requestBindingMode = requestBindingModeRaw ?? (requestBindingSha256 ? "strict" : null);
          if (requestBindingMode === "strict" && !requestBindingSha256) {
            return sendError(res, 400, "requestBindingSha256 is required when requestBindingMode=strict", null, {
              code: "SCHEMA_INVALID"
            });
          }
          let requestedQuoteId = null;
          try {
            requestedQuoteId = normalizeOptionalX402RefInput(body?.quoteId ?? null, "quoteId", { allowNull: true, max: 200 });
          } catch (err) {
            return sendError(res, 400, "invalid quoteId", { message: err?.message }, { code: "SCHEMA_INVALID" });
          }
          let walletAuthorizationDecisionToken = null;
          try {
            walletAuthorizationDecisionToken = normalizeX402WalletIssuerDecisionTokenInput(
              body?.walletAuthorizationDecisionToken ?? body?.walletAuthorizationDecision ?? null,
              "walletAuthorizationDecisionToken",
              { allowNull: true }
            );
          } catch (err) {
            return sendError(res, 400, "invalid walletAuthorizationDecisionToken", { message: err?.message }, { code: "SCHEMA_INVALID" });
          }

          const gate = typeof store.getX402Gate === "function" ? await store.getX402Gate({ tenantId, gateId }) : null;
          if (!gate) return sendError(res, 404, "gate not found", null, { code: "NOT_FOUND" });
          if (String(gate.status ?? "").toLowerCase() === "resolved") {
            return sendError(res, 409, "gate is already resolved", null, { code: "X402_GATE_TERMINAL" });
          }

          const runId = String(gate.runId ?? "");
          const settlement = typeof store.getAgentRunSettlement === "function" ? await store.getAgentRunSettlement({ tenantId, runId }) : null;
          if (!settlement) return sendError(res, 404, "settlement not found for gate", null, { code: "NOT_FOUND" });
          if (String(settlement.status ?? "").toLowerCase() !== "locked") {
            return sendError(res, 409, "settlement already resolved", null, { code: "X402_GATE_TERMINAL" });
          }

          const payerAgentId = typeof gate?.payerAgentId === "string" && gate.payerAgentId.trim() !== "" ? gate.payerAgentId.trim() : null;
          if (!payerAgentId) return sendError(res, 409, "gate payer missing", null, { code: "X402_GATE_INVALID" });

          const amountCents = Number(gate?.terms?.amountCents ?? settlement?.amountCents ?? 0);
          if (!Number.isSafeInteger(amountCents) || amountCents <= 0) return sendError(res, 409, "gate amount invalid", null, { code: "X402_GATE_INVALID" });
          const currency =
            typeof gate?.terms?.currency === "string" && gate.terms.currency.trim() !== ""
              ? gate.terms.currency.trim().toUpperCase()
              : settlement?.currency ?? "USD";
          const gateAgentPassport =
            gate?.agentPassport && typeof gate.agentPassport === "object" && !Array.isArray(gate.agentPassport) ? gate.agentPassport : null;
          const payeeProviderId =
            typeof gate?.payeeAgentId === "string" && gate.payeeAgentId.trim() !== ""
              ? gate.payeeAgentId.trim()
              : typeof gate?.terms?.providerId === "string" && gate.terms.providerId.trim() !== ""
                ? gate.terms.providerId.trim()
                : null;

          const nowAt = nowIso();
          const nowMs = Date.parse(nowAt);
          const nowUnix = Math.floor(nowMs / 1000);
          const defaultAuthorizationRef = `auth_${gateId}`;
          const existingAuthorization =
            gate?.authorization && typeof gate.authorization === "object" && !Array.isArray(gate.authorization) ? gate.authorization : null;
          const authorizationRef =
            typeof existingAuthorization?.authorizationRef === "string" && existingAuthorization.authorizationRef.trim() !== ""
              ? existingAuthorization.authorizationRef.trim()
              : defaultAuthorizationRef;
          const existingToken =
            existingAuthorization?.token && typeof existingAuthorization.token === "object" && !Array.isArray(existingAuthorization.token)
              ? existingAuthorization.token
              : null;
          const existingReserve =
            existingAuthorization?.reserve && typeof existingAuthorization.reserve === "object" && !Array.isArray(existingAuthorization.reserve)
              ? existingAuthorization.reserve
              : null;
          const existingWalletEscrow =
            existingAuthorization?.walletEscrow && typeof existingAuthorization.walletEscrow === "object" && !Array.isArray(existingAuthorization.walletEscrow)
              ? existingAuthorization.walletEscrow
              : null;
          const tokenExpiresAtMs = Number.isFinite(Date.parse(String(existingToken?.expiresAt ?? "")))
            ? Date.parse(String(existingToken.expiresAt))
            : Number.NaN;
          const hasReservedAuthorization =
            String(existingAuthorization?.status ?? "").toLowerCase() === "reserved" &&
            String(existingReserve?.status ?? "").toLowerCase() === "reserved" &&
            typeof existingReserve?.reserveId === "string" &&
            existingReserve.reserveId.trim() !== "";
          const hasLiveToken =
            hasReservedAuthorization &&
            typeof existingToken?.value === "string" &&
            existingToken.value.trim() !== "" &&
            Number.isFinite(tokenExpiresAtMs) &&
            tokenExpiresAtMs > nowMs;
          const existingQuote =
            gate?.quote && typeof gate.quote === "object" && !Array.isArray(gate.quote) ? gate.quote : null;
          const existingQuoteExpiresAtMs = Number.isFinite(Date.parse(String(existingQuote?.expiresAt ?? "")))
            ? Date.parse(String(existingQuote.expiresAt))
            : Number.NaN;
          if (requestedQuoteId && !existingQuote) {
            return sendError(res, 409, "requested quoteId was not found on gate", null, { code: "X402_QUOTE_NOT_FOUND" });
          }
          if (requestedQuoteId && existingQuote && String(existingQuote.quoteId ?? "") !== String(requestedQuoteId)) {
            return sendError(res, 409, "requested quoteId does not match gate quote", null, { code: "X402_QUOTE_MISMATCH" });
          }
          const selectedQuote =
            existingQuote &&
            (!requestedQuoteId || String(existingQuote.quoteId ?? "") === String(requestedQuoteId)) &&
            Number.isFinite(existingQuoteExpiresAtMs) &&
            existingQuoteExpiresAtMs > nowMs
              ? existingQuote
              : null;
          if (requestedQuoteId && !selectedQuote) {
            return sendError(res, 409, "requested quote has expired", null, { code: "X402_QUOTE_EXPIRED" });
          }
          const quoteRequestBindingMode =
            selectedQuote && typeof selectedQuote.requestBindingMode === "string" && selectedQuote.requestBindingMode.trim() !== ""
              ? selectedQuote.requestBindingMode.trim().toLowerCase()
              : null;
          const quoteRequestBindingSha256 =
            selectedQuote && typeof selectedQuote.requestBindingSha256 === "string" && selectedQuote.requestBindingSha256.trim() !== ""
              ? selectedQuote.requestBindingSha256.trim().toLowerCase()
              : null;
          let effectiveRequestBindingMode = requestBindingMode ?? quoteRequestBindingMode ?? null;
          let effectiveRequestBindingSha256 = requestBindingSha256 ?? quoteRequestBindingSha256 ?? null;
          if (effectiveRequestBindingMode === "strict" && !effectiveRequestBindingSha256) {
            return sendError(res, 409, "strict request binding requires sha256 hash", null, { code: "X402_REQUEST_BINDING_REQUIRED" });
          }
          if (requestBindingMode === "strict" && quoteRequestBindingMode === "strict" && quoteRequestBindingSha256) {
            if (String(requestBindingSha256 ?? "") !== String(quoteRequestBindingSha256)) {
              return sendError(res, 409, "request binding does not match quote binding", null, { code: "X402_QUOTE_REQUEST_BINDING_MISMATCH" });
            }
          }
          const effectiveQuoteId =
            typeof selectedQuote?.quoteId === "string" && selectedQuote.quoteId.trim() !== "" ? selectedQuote.quoteId.trim() : null;
          const effectiveQuoteSha256 =
            typeof selectedQuote?.quoteSha256 === "string" && selectedQuote.quoteSha256.trim() !== ""
              ? selectedQuote.quoteSha256.trim().toLowerCase()
              : null;
          let existingTokenRequestBindingMode = null;
          let existingTokenRequestBindingSha256 = null;
          let existingTokenQuoteId = null;
          let existingTokenQuoteSha256 = null;
          if (hasLiveToken) {
            try {
              const parsedToken = parseSettldPayTokenV1(existingToken.value);
              const payload = parsedToken?.payload && typeof parsedToken.payload === "object" ? parsedToken.payload : {};
              existingTokenRequestBindingMode =
                typeof payload.requestBindingMode === "string" && payload.requestBindingMode.trim() !== ""
                  ? payload.requestBindingMode.trim().toLowerCase()
                  : null;
              existingTokenRequestBindingSha256 =
                typeof payload.requestBindingSha256 === "string" && payload.requestBindingSha256.trim() !== ""
                  ? payload.requestBindingSha256.trim().toLowerCase()
                  : null;
              existingTokenQuoteId =
                typeof payload.quoteId === "string" && payload.quoteId.trim() !== "" ? payload.quoteId.trim() : null;
              existingTokenQuoteSha256 =
                typeof payload.quoteSha256 === "string" && payload.quoteSha256.trim() !== ""
                  ? payload.quoteSha256.trim().toLowerCase()
                  : null;
            } catch {}
          }
          const requestBindingMatchesLiveToken =
            !effectiveRequestBindingMode
              ? !existingTokenRequestBindingMode && !existingTokenRequestBindingSha256
              : effectiveRequestBindingMode === existingTokenRequestBindingMode &&
                effectiveRequestBindingSha256 === existingTokenRequestBindingSha256;
          const quoteMatchesLiveToken =
            !effectiveQuoteId
              ? !existingTokenQuoteId && !existingTokenQuoteSha256
              : existingTokenQuoteId === effectiveQuoteId && (!effectiveQuoteSha256 || existingTokenQuoteSha256 === effectiveQuoteSha256);
          let resolvedWalletPolicy = null;
          if (gateAgentPassport) {
            const walletPolicyResolution = await resolveX402WalletPolicyForPassport({
              tenantId,
              gateAgentPassport
            });
            if (walletPolicyResolution?.error && !hasReservedAuthorization) {
              return sendError(
                res,
                409,
                "x402 wallet policy reference is invalid",
                {
                  message: walletPolicyResolution.error.message ?? null,
                  sponsorWalletRef: walletPolicyResolution.sponsorWalletRef ?? null
                },
                { code: walletPolicyResolution.error.code ?? "X402_WALLET_POLICY_REFERENCE_INVALID" }
              );
            }
            resolvedWalletPolicy = walletPolicyResolution?.policy ?? null;
          }
          let walletIssuerDecisionPayload = null;
          if (!hasReservedAuthorization && resolvedWalletPolicy) {
            if (!walletAuthorizationDecisionToken) {
              return sendError(
                res,
                409,
                "wallet issuer decision is required for wallet-bound authorization",
                {
                  gateId,
                  sponsorWalletRef:
                    typeof resolvedWalletPolicy?.sponsorWalletRef === "string" && resolvedWalletPolicy.sponsorWalletRef.trim() !== ""
                      ? resolvedWalletPolicy.sponsorWalletRef.trim()
                      : null
                },
                { code: "X402_WALLET_ISSUER_DECISION_REQUIRED" }
              );
            }
            const expectedSponsorRef =
              typeof resolvedWalletPolicy?.sponsorRef === "string" && resolvedWalletPolicy.sponsorRef.trim() !== ""
                ? resolvedWalletPolicy.sponsorRef.trim()
                : typeof gateAgentPassport?.sponsorRef === "string" && gateAgentPassport.sponsorRef.trim() !== ""
                  ? gateAgentPassport.sponsorRef.trim()
                  : payerAgentId;
            const expectedSponsorWalletRef =
              typeof resolvedWalletPolicy?.sponsorWalletRef === "string" && resolvedWalletPolicy.sponsorWalletRef.trim() !== ""
                ? resolvedWalletPolicy.sponsorWalletRef.trim()
                : null;
            const expectedPolicyRef =
              typeof resolvedWalletPolicy?.policyRef === "string" && resolvedWalletPolicy.policyRef.trim() !== ""
                ? resolvedWalletPolicy.policyRef.trim()
                : null;
            const expectedPolicyVersion =
              Number.isSafeInteger(Number(resolvedWalletPolicy?.policyVersion)) && Number(resolvedWalletPolicy.policyVersion) > 0
                ? Number(resolvedWalletPolicy.policyVersion)
                : null;
            const expectedPolicyFingerprint =
              typeof resolvedWalletPolicy?.policyFingerprint === "string" && resolvedWalletPolicy.policyFingerprint.trim() !== ""
                ? resolvedWalletPolicy.policyFingerprint.trim().toLowerCase()
                : null;
            const issuerDecisionVerify = verifyX402WalletIssuerDecisionTokenV1({
              token: walletAuthorizationDecisionToken,
              publicKeyPem: store.serverSigner.publicKeyPem,
              nowUnixSeconds: nowUnix,
              expected: {
                gateId,
                sponsorRef: expectedSponsorRef,
                sponsorWalletRef: expectedSponsorWalletRef,
                policyRef: expectedPolicyRef,
                policyVersion: expectedPolicyVersion,
                policyFingerprint: expectedPolicyFingerprint,
                amountCents,
                currency,
                payeeProviderId: String(payeeProviderId ?? ""),
                quoteId: effectiveQuoteId,
                quoteSha256: effectiveQuoteSha256,
                requestBindingMode: effectiveRequestBindingMode,
                requestBindingSha256: effectiveRequestBindingSha256
              }
            });
            if (!issuerDecisionVerify?.ok) {
              return sendError(
                res,
                409,
                "wallet issuer decision is invalid",
                {
                  message: issuerDecisionVerify?.error ?? null,
                  field: issuerDecisionVerify?.field ?? null,
                  verifyCode: issuerDecisionVerify?.code ?? null
                },
                { code: issuerDecisionVerify?.code ?? "X402_WALLET_ISSUER_DECISION_INVALID" }
              );
            }
            walletIssuerDecisionPayload = issuerDecisionVerify.payload ?? null;
          }
          if (x402PilotKillSwitchValue === true) {
            return sendError(res, 409, "x402 pilot kill switch is active", null, { code: "X402_PILOT_KILL_SWITCH_ACTIVE" });
          }
          if (!hasReservedAuthorization) {
            if (resolvedWalletPolicy) {
              try {
                await assertX402WalletPolicyForAuthorization({
                  tenantId,
                  gate,
                  policy: resolvedWalletPolicy,
                  amountCents,
                  currency,
                  payeeProviderId,
                  effectiveQuoteId,
                  effectiveRequestBindingMode,
                  effectiveRequestBindingSha256,
                  nowAt
                });
              } catch (err) {
                return sendError(
                  res,
                  409,
                  "x402 wallet policy blocked authorization",
                  { message: err?.message ?? null, code: err?.code ?? null, details: err?.details ?? null },
                  { code: err?.code ?? "X402_WALLET_POLICY_BLOCKED" }
                );
              }
            }
            if (
              Array.isArray(x402PilotAllowedProviderIdsValue) &&
              x402PilotAllowedProviderIdsValue.length > 0 &&
              !x402PilotAllowedProviderIdsValue.includes(String(payeeProviderId ?? ""))
            ) {
              return sendError(
                res,
                409,
                "x402 pilot provider is not allowed",
                {
                  gateId,
                  payeeProviderId,
                  allowedProviderIds: x402PilotAllowedProviderIdsValue
                },
                { code: "X402_PILOT_PROVIDER_NOT_ALLOWED" }
              );
            }
            if (
              Number.isSafeInteger(x402PilotMaxAmountCentsValue) &&
              x402PilotMaxAmountCentsValue > 0 &&
              amountCents > x402PilotMaxAmountCentsValue
            ) {
              return sendError(
                res,
                409,
                "x402 pilot single-call amount exceeds limit",
                {
                  gateId,
                  amountCents,
                  maxAmountCents: x402PilotMaxAmountCentsValue
                },
                { code: "X402_PILOT_AMOUNT_LIMIT_EXCEEDED" }
              );
            }
            if (Number.isSafeInteger(x402PilotDailyLimitCentsValue) && x402PilotDailyLimitCentsValue > 0) {
              const dayKey = nowAt.slice(0, 10);
              const currentExposureCents = computeX402DailyAuthorizedExposureCents({ tenantId, dayKey, excludeGateId: gateId });
              const projectedExposureCents = currentExposureCents + amountCents;
              if (projectedExposureCents > x402PilotDailyLimitCentsValue) {
                return sendError(
                  res,
                  409,
                  "x402 pilot daily authorization limit exceeded",
                  {
                    gateId,
                    dayKey,
                    amountCents,
                    currentExposureCents,
                    projectedExposureCents,
                    dailyLimitCents: x402PilotDailyLimitCentsValue
                  },
                  { code: "X402_PILOT_DAILY_LIMIT_EXCEEDED" }
                );
              }
            }
          }
          if (hasLiveToken && requestBindingMatchesLiveToken && quoteMatchesLiveToken) {
            const responseBody = {
              gateId,
              authorizationRef,
              expiresAt: new Date(tokenExpiresAtMs).toISOString(),
              token: existingToken.value,
              tokenKid: existingToken.kid ?? null,
              quoteId: effectiveQuoteId,
              quoteSha256: effectiveQuoteSha256,
              reserve: {
                amountCents,
                currency,
                mode: existingReserve.mode ?? "transfer",
                circleTransferId: existingReserve.reserveId,
                reserveId: existingReserve.reserveId,
                status: "reserved"
              }
            };
            if (idemStoreKey) {
              await store.commitTx({
                at: nowAt,
                ops: [{ kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode: 200, body: responseBody } }]
              });
            }
            return sendJson(res, 200, responseBody);
          }

          if (x402RequireExternalReserveValue && String(circleReserveAdapter?.mode ?? "").toLowerCase() === "stub") {
            return sendError(res, 503, "external reserve unavailable", null, { code: "X402_RESERVE_UNAVAILABLE" });
          }

          let payerWallet = typeof store.getAgentWallet === "function" ? await store.getAgentWallet({ tenantId, agentId: payerAgentId }) : null;
          if (!payerWallet) return sendError(res, 409, "payer wallet missing", null, { code: "WALLET_MISSING" });
          let payerWalletChanged = false;
          let walletEscrowLocked = String(existingWalletEscrow?.status ?? "").toLowerCase() === "locked";

          if (!walletEscrowLocked) {
            try {
              payerWallet = lockAgentWalletEscrow({ wallet: payerWallet, amountCents, at: nowAt });
              payerWalletChanged = true;
              walletEscrowLocked = true;
            } catch (err) {
              if (err?.code === "INSUFFICIENT_WALLET_BALANCE") {
                return sendError(res, 402, "insufficient wallet balance", { message: err?.message }, { code: "INSUFFICIENT_FUNDS" });
              }
              throw err;
            }
          }

          let reserve = existingReserve;
          if (!(reserve && String(reserve.status ?? "").toLowerCase() === "reserved" && typeof reserve.reserveId === "string" && reserve.reserveId.trim() !== "")) {
            try {
              const reserved = await circleReserveAdapter.reserve({
                tenantId,
                gateId,
                amountCents,
                currency,
                idempotencyKey: gateId,
                payerAgentId: gate?.payerAgentId ?? null,
                payeeAgentId: gate?.payeeAgentId ?? null
              });
              reserve = {
                adapter: reserved?.adapter ?? "circle",
                mode: reserved?.mode ?? "transfer",
                reserveId: String(reserved?.reserveId ?? ""),
                status: String(reserved?.status ?? "reserved"),
                reservedAt: reserved?.createdAt ?? nowAt,
                circleTransferId: String(reserved?.reserveId ?? "")
              };
              if (!reserve.reserveId) throw new TypeError("reserveId missing from reserve adapter");
            } catch (err) {
              // Hard guarantee: no reserve means no token. Roll back internal lock to avoid stranded funds.
              try {
                if (walletEscrowLocked) {
                  payerWallet = refundAgentWalletEscrow({ wallet: payerWallet, amountCents, at: nowAt });
                  payerWalletChanged = true;
                  walletEscrowLocked = false;
                }
              } catch {
                // keep original error below
              }
              const failedGate = normalizeForCanonicalJson(
                {
                  ...gate,
                  authorization: {
                    schemaVersion: "X402GateAuthorization.v1",
                    authorizationRef,
                    status: "failed",
                    walletEscrow: {
                      status: walletEscrowLocked ? "locked" : "unlocked",
                      amountCents,
                      currency,
                      lockedAt: existingWalletEscrow?.lockedAt ?? nowAt
                    },
                    reserve: null,
                    token: null,
                    lastError: {
                      code: err?.code ?? "X402_RESERVE_FAILED",
                      message: err?.message ?? String(err ?? "")
                    },
                    updatedAt: nowAt
                  },
                  updatedAt: nowAt
                },
                { path: "$" }
              );
              const ops = [];
              if (payerWalletChanged) ops.push({ kind: "AGENT_WALLET_UPSERT", tenantId, wallet: payerWallet });
              ops.push({ kind: "X402_GATE_UPSERT", tenantId, gateId, gate: failedGate });
              if (idemStoreKey) {
                ops.push({
                  kind: "IDEMPOTENCY_PUT",
                  key: idemStoreKey,
                  value: {
                    requestHash: idemRequestHash,
                    statusCode: 503,
                    body: { error: "reserve failed", code: "X402_RESERVE_FAILED", details: { message: err?.message ?? String(err ?? "") } }
                  }
                });
              }
              await store.commitTx({ at: nowAt, ops });
              return sendError(res, 503, "reserve failed", { message: err?.message ?? String(err ?? "") }, { code: "X402_RESERVE_FAILED" });
            }
          }

          const includeSpendAuthorizationClaims = Boolean(effectiveQuoteId || resolvedWalletPolicy || gateAgentPassport);
          const walletPolicyFingerprint =
            resolvedWalletPolicy &&
            typeof resolvedWalletPolicy.policyFingerprint === "string" &&
            resolvedWalletPolicy.policyFingerprint.trim() !== ""
              ? resolvedWalletPolicy.policyFingerprint.trim().toLowerCase()
              : null;
          const walletPolicyVersion =
            resolvedWalletPolicy && Number.isSafeInteger(Number(resolvedWalletPolicy.policyVersion)) && Number(resolvedWalletPolicy.policyVersion) > 0
              ? Number(resolvedWalletPolicy.policyVersion)
              : Number.isSafeInteger(Number(gateAgentPassport?.policyVersion)) && Number(gateAgentPassport.policyVersion) > 0
                ? Number(gateAgentPassport.policyVersion)
                : 1;
          const agentPassportPolicyFingerprint = buildX402AgentPassportPolicyFingerprint(gateAgentPassport);
          const fallbackPolicyFingerprint = includeSpendAuthorizationClaims
            ? sha256Hex(
                canonicalJsonStringify(
                  normalizeForCanonicalJson(
                    {
                      schemaVersion: "X402SpendPolicyFingerprintSeed.v1",
                      gateId,
                      authorizationRef,
                      payerAgentId,
                      payeeProviderId: String(payeeProviderId ?? ""),
                      quoteId: effectiveQuoteId ?? null,
                      sponsorRef:
                        (typeof resolvedWalletPolicy?.sponsorRef === "string" && resolvedWalletPolicy.sponsorRef.trim() !== ""
                          ? resolvedWalletPolicy.sponsorRef.trim()
                          : typeof gateAgentPassport?.sponsorRef === "string" && gateAgentPassport.sponsorRef.trim() !== ""
                            ? gateAgentPassport.sponsorRef.trim()
                            : payerAgentId) || null,
                      sponsorWalletRef:
                        typeof resolvedWalletPolicy?.sponsorWalletRef === "string" && resolvedWalletPolicy.sponsorWalletRef.trim() !== ""
                          ? resolvedWalletPolicy.sponsorWalletRef.trim()
                          : typeof gateAgentPassport?.sponsorWalletRef === "string" && gateAgentPassport.sponsorWalletRef.trim() !== ""
                            ? gateAgentPassport.sponsorWalletRef.trim()
                            : null
                    },
                    { path: "$" }
                  )
                )
              )
            : null;
          const payload = buildSettldPayPayloadV1({
            iss: settldPayIssuerValue,
            aud: String(gate?.payeeAgentId ?? ""),
            gateId,
            authorizationRef,
            amountCents,
            currency,
            payeeProviderId: String(payeeProviderId ?? ""),
            ...(effectiveRequestBindingMode
              ? { requestBindingMode: effectiveRequestBindingMode, requestBindingSha256: effectiveRequestBindingSha256 }
              : {}),
            ...(includeSpendAuthorizationClaims
              ? {
                  ...(effectiveQuoteId ? { quoteId: effectiveQuoteId, quoteSha256: effectiveQuoteSha256 } : {}),
                  idempotencyKey:
                    typeof walletIssuerDecisionPayload?.idempotencyKey === "string" && walletIssuerDecisionPayload.idempotencyKey.trim() !== ""
                      ? walletIssuerDecisionPayload.idempotencyKey.trim()
                      : effectiveQuoteId
                        ? `x402:${gateId}:${effectiveQuoteId}`
                        : `x402:${gateId}:${authorizationRef}`,
                  nonce:
                    typeof walletIssuerDecisionPayload?.nonce === "string" && walletIssuerDecisionPayload.nonce.trim() !== ""
                      ? walletIssuerDecisionPayload.nonce.trim()
                      : createId("x402nonce"),
                  sponsorRef:
                    (typeof walletIssuerDecisionPayload?.sponsorRef === "string" && walletIssuerDecisionPayload.sponsorRef.trim() !== ""
                      ? walletIssuerDecisionPayload.sponsorRef.trim()
                      : typeof resolvedWalletPolicy?.sponsorRef === "string" && resolvedWalletPolicy.sponsorRef.trim() !== ""
                      ? resolvedWalletPolicy.sponsorRef.trim()
                      : typeof gateAgentPassport?.sponsorRef === "string" && gateAgentPassport.sponsorRef.trim() !== ""
                        ? gateAgentPassport.sponsorRef.trim()
                      : payerAgentId) || null,
                  sponsorWalletRef:
                    typeof walletIssuerDecisionPayload?.sponsorWalletRef === "string" && walletIssuerDecisionPayload.sponsorWalletRef.trim() !== ""
                      ? walletIssuerDecisionPayload.sponsorWalletRef.trim()
                      : typeof resolvedWalletPolicy?.sponsorWalletRef === "string" && resolvedWalletPolicy.sponsorWalletRef.trim() !== ""
                      ? resolvedWalletPolicy.sponsorWalletRef.trim()
                      : typeof gateAgentPassport?.sponsorWalletRef === "string" && gateAgentPassport.sponsorWalletRef.trim() !== ""
                        ? gateAgentPassport.sponsorWalletRef.trim()
                      : null,
                  agentKeyId:
                    (typeof gateAgentPassport?.agentKeyId === "string" && gateAgentPassport.agentKeyId.trim() !== ""
                      ? gateAgentPassport.agentKeyId.trim()
                      : payerAgentId) || null,
                  delegationRef:
                    typeof gateAgentPassport?.delegationRef === "string" && gateAgentPassport.delegationRef.trim() !== ""
                      ? gateAgentPassport.delegationRef.trim()
                      : null,
                  policyVersion:
                    Number.isSafeInteger(Number(walletIssuerDecisionPayload?.policyVersion)) && Number(walletIssuerDecisionPayload.policyVersion) > 0
                      ? Number(walletIssuerDecisionPayload.policyVersion)
                      : walletPolicyVersion,
                  policyFingerprint:
                    typeof walletIssuerDecisionPayload?.policyFingerprint === "string" && walletIssuerDecisionPayload.policyFingerprint.trim() !== ""
                      ? walletIssuerDecisionPayload.policyFingerprint.trim().toLowerCase()
                      : walletPolicyFingerprint ?? agentPassportPolicyFingerprint ?? fallbackPolicyFingerprint
                }
              : {}),
            iat: nowUnix,
            exp: nowUnix + settldPayTokenTtlSecondsValue
          });
          const minted = mintSettldPayTokenV1({
            payload,
            keyId: store.serverSigner.keyId,
            publicKeyPem: store.serverSigner.publicKeyPem,
            privateKeyPem: store.serverSigner.privateKeyPem
          });
          const expiresAt = new Date(payload.exp * 1000).toISOString();

          const nextGate = normalizeForCanonicalJson(
            {
              ...gate,
              authorization: {
                schemaVersion: "X402GateAuthorization.v1",
                authorizationRef,
                status: "reserved",
                walletEscrow: {
                  status: walletEscrowLocked ? "locked" : "unlocked",
                  amountCents,
                  currency,
                  lockedAt: existingWalletEscrow?.lockedAt ?? nowAt
                },
                reserve: {
                  adapter: reserve.adapter ?? "circle",
                  mode: reserve.mode ?? "transfer",
                  reserveId: reserve.reserveId,
                  status: "reserved",
                  reservedAt: reserve.reservedAt ?? nowAt,
                  circleTransferId: reserve.circleTransferId ?? reserve.reserveId
                },
                quote:
                  selectedQuote && typeof selectedQuote === "object" && !Array.isArray(selectedQuote)
                    ? {
                        quoteId: effectiveQuoteId,
                        quoteSha256: effectiveQuoteSha256,
                        expiresAt: selectedQuote.expiresAt ?? null,
                        requestBindingMode: selectedQuote.requestBindingMode ?? null,
                        requestBindingSha256: selectedQuote.requestBindingSha256 ?? null
                      }
                    : null,
                token: {
                  value: minted.token,
                  kid: minted.kid,
                  sha256: minted.tokenSha256,
                  issuedAt: nowAt,
                  expiresAt
                },
                updatedAt: nowAt
              },
              updatedAt: nowAt
            },
            { path: "$" }
          );

          const responseBody = {
            gateId,
            authorizationRef,
            expiresAt,
            token: minted.token,
            tokenKid: minted.kid,
            quoteId: effectiveQuoteId,
            quoteSha256: effectiveQuoteSha256,
            reserve: {
              amountCents,
              currency,
              mode: reserve.mode ?? "transfer",
              circleTransferId: reserve.circleTransferId ?? reserve.reserveId,
              reserveId: reserve.reserveId,
              status: "reserved"
            }
          };

          const ops = [];
          if (payerWalletChanged) ops.push({ kind: "AGENT_WALLET_UPSERT", tenantId, wallet: payerWallet });
          ops.push({ kind: "X402_GATE_UPSERT", tenantId, gateId, gate: nextGate });
          if (idemStoreKey) {
            ops.push({ kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode: 200, body: responseBody } });
          }
          await store.commitTx({ at: nowAt, ops });
          return sendJson(res, 200, responseBody);
        }

        if (parts[0] === "x402" && parts[1] === "gate" && parts[2] === "verify" && parts.length === 3 && req.method === "POST") {
          if (!requireProtocolHeaderForWrite(req, res)) return;

          const body = await readJsonBody(req);
          let idemStoreKey = null;
          let idemRequestHash = null;
          try {
            ({ idemStoreKey, idemRequestHash } = readIdempotency({ method: "POST", requestPath: path, expectedPrevChainHash: null, body }));
          } catch (err) {
            return sendError(res, 400, "invalid idempotency key", { message: err?.message });
          }
          if (idemStoreKey) {
            const existing = store.idempotency.get(idemStoreKey);
            if (existing) {
              if (existing.requestHash !== idemRequestHash) {
                return sendError(res, 409, "idempotency key conflict", "request differs from initial use of this key");
              }
              return sendJson(res, existing.statusCode, existing.body);
            }
          }

          const gateId = typeof body?.gateId === "string" && body.gateId.trim() !== "" ? body.gateId.trim() : null;
          if (!gateId) return sendError(res, 400, "gateId is required", null, { code: "SCHEMA_INVALID" });
          const gate = typeof store.getX402Gate === "function" ? await store.getX402Gate({ tenantId, gateId }) : null;
          if (!gate) return sendError(res, 404, "gate not found", null, { code: "NOT_FOUND" });

          const runId = String(gate.runId ?? "");
          const settlement = typeof store.getAgentRunSettlement === "function" ? await store.getAgentRunSettlement({ tenantId, runId }) : null;
          if (!settlement) return sendError(res, 404, "settlement not found for gate", null, { code: "NOT_FOUND" });

          if (String(settlement.status ?? "").toLowerCase() !== "locked") {
            return sendJson(res, 200, { ok: true, gate, settlement, alreadyResolved: true });
          }

          const gateAuthorization =
            gate?.authorization && typeof gate.authorization === "object" && !Array.isArray(gate.authorization) ? gate.authorization : null;
          const authorizedForSettlement =
            String(gateAuthorization?.status ?? "").toLowerCase() === "reserved" &&
            String(gateAuthorization?.reserve?.status ?? "").toLowerCase() === "reserved" &&
            typeof gateAuthorization?.reserve?.reserveId === "string" &&
            gateAuthorization.reserve.reserveId.trim() !== "" &&
            typeof gateAuthorization?.token?.value === "string" &&
            gateAuthorization.token.value.trim() !== "";
          if (!authorizedForSettlement) {
            return sendError(res, 409, "payment not authorized", null, { code: "X402_PAYMENT_NOT_AUTHORIZED" });
          }

          // Optional: if this gate is bound to an agreementHash, enforce that the delegation graph
          // is acyclic before allowing funds to be released/refunded.
          const gateAgreementHashRaw = gate?.agreementHash ?? null;
          if (gateAgreementHashRaw) {
            let gateAgreementHash = null;
            try {
              gateAgreementHash = normalizeSha256HashInput(gateAgreementHashRaw, "gate.agreementHash", { allowNull: false });
            } catch (err) {
              return sendError(res, 409, "invalid gate agreementHash", { message: err?.message }, { code: "SCHEMA_INVALID" });
            }

            let delegations = [];
            try {
              const collected = [];
              const seen = new Set();
              let cursor = gateAgreementHash;
              for (let i = 0; i < 256; i += 1) {
                if (seen.has(cursor)) break;
                seen.add(cursor);

                const rows = typeof store.listAgreementDelegations === "function"
                  ? await store.listAgreementDelegations({ tenantId, childAgreementHash: cursor, status: null, limit: 1000, offset: 0 })
                  : [];
                const list = Array.isArray(rows) ? rows : [];
                for (const row of list) collected.push(row);
                if (list.length !== 1) break;

                const parent = list[0]?.parentAgreementHash;
                if (typeof parent !== "string" || parent.trim() === "") break;
                cursor = parent.trim().toLowerCase();
              }
              delegations = collected;
            } catch (err) {
              return sendError(res, 500, "failed to load agreement delegations", { message: err?.message }, { code: "STORE_READ_FAILED" });
            }

            try {
              cascadeSettlementCheck({ delegations, fromChildHash: gateAgreementHash });
            } catch (err) {
              const stableCode =
                typeof err?.code === "string" && err.code.trim() !== "" ? err.code : "CASCADE_SETTLEMENT_CHECK_FAILED";
              return sendError(
                res,
                409,
                "cascade settlement check failed",
                {
                  message: err?.message ?? String(err ?? ""),
                  code: err?.code ?? null,
                  agreementHash: gateAgreementHash,
                  childAgreementHash: err?.childAgreementHash ?? null,
                  cycleAgreementHash: err?.agreementHash ?? null
                },
                { code: stableCode }
              );
            }
          }

          const evidenceRefs = Array.isArray(body?.evidenceRefs) ? body.evidenceRefs.map((v) => String(v ?? "").trim()).filter(Boolean) : [];

          let verificationStatus = body?.verificationStatus ?? "amber";
          let runStatus = body?.runStatus ?? "completed";
          const extraReasonCodes = new Set();
          if (Array.isArray(body?.verificationCodes)) {
            for (const c of body.verificationCodes) {
              const code = typeof c === "string" ? c.trim() : "";
              if (code) extraReasonCodes.add(code);
            }
          }

          // Optional: enforce provider signature correctness when the caller declares this verification source.
          const verificationSourceRaw =
            body?.verificationMethod && typeof body.verificationMethod === "object" && !Array.isArray(body.verificationMethod)
              ? body.verificationMethod.source
              : null;
          const verificationSource = typeof verificationSourceRaw === "string" ? verificationSourceRaw.trim() : null;
	          if (verificationSource === "provider_signature_v1") {
	            const ps = body?.providerSignature ?? null;
	            const pinnedPublicKeyPem =
	              typeof gate?.providerKey?.publicKeyPem === "string" && gate.providerKey.publicKeyPem.trim() !== ""
	                ? gate.providerKey.publicKeyPem
	                : null;
	            const publicKeyPem = pinnedPublicKeyPem
	              ? pinnedPublicKeyPem
	              : typeof ps?.publicKeyPem === "string" && ps.publicKeyPem.trim() !== ""
	                  ? ps.publicKeyPem
	                  : null;
	            if (!ps || typeof ps !== "object" || Array.isArray(ps) || !publicKeyPem) {
	              extraReasonCodes.add("X402_PROVIDER_SIGNATURE_MISSING");
	              verificationStatus = "red";
	              runStatus = "failed";
            } else {
              // Ensure the signature binds to the response hash we claim.
              const responseHash = typeof ps.responseHash === "string" ? ps.responseHash.trim().toLowerCase() : null;
              const hasResponseRef = responseHash ? evidenceRefs.includes(`http:response_sha256:${responseHash}`) : false;
              if (responseHash && !hasResponseRef) {
                extraReasonCodes.add("X402_PROVIDER_RESPONSE_HASH_MISMATCH");
                verificationStatus = "red";
                runStatus = "failed";
              } else {
                const sig = { ...ps };
                delete sig.publicKeyPem;
                // Fill payloadHash if absent so verification doesn't depend on caller precomputing it.
                if (typeof sig.payloadHash !== "string" || sig.payloadHash.trim() === "") {
                  try {
                    sig.payloadHash = computeToolProviderSignaturePayloadHashV1({
                      responseHash: sig.responseHash,
                      nonce: sig.nonce,
                      signedAt: sig.signedAt
                    });
                  } catch {}
                }
                let ok = false;
                try {
                  ok = verifyToolProviderSignatureV1({ signature: sig, publicKeyPem });
                } catch {
                  ok = false;
                }
                if (!ok) {
                  extraReasonCodes.add("X402_PROVIDER_SIGNATURE_INVALID");
                  verificationStatus = "red";
                  runStatus = "failed";
                }
              }
            }
          }

          let policyDecision;
          try {
            policyDecision = evaluateSettlementPolicy({
              policy: body?.policy ?? {},
              verificationMethod: body?.verificationMethod ?? {},
              verificationStatus,
              runStatus,
              amountCents: Number(settlement.amountCents)
            });
          } catch (err) {
            return sendError(res, 400, "invalid verification/policy inputs", { message: err?.message }, { code: "SCHEMA_INVALID" });
          }

          const payerAgentId = String(settlement.payerAgentId ?? "");
          const payeeAgentId = String(settlement.agentId ?? "");
          const payerWalletExisting = typeof store.getAgentWallet === "function" ? await store.getAgentWallet({ tenantId, agentId: payerAgentId }) : null;
          const payeeWalletExisting = typeof store.getAgentWallet === "function" ? await store.getAgentWallet({ tenantId, agentId: payeeAgentId }) : null;
          if (!payerWalletExisting || !payeeWalletExisting) return sendError(res, 409, "missing wallets for gate settlement", null, { code: "WALLET_MISSING" });

	          let payerWallet = payerWalletExisting;
	          let payeeWallet = payeeWalletExisting;
	          const releaseAmountCents = Number(policyDecision.releaseAmountCents ?? 0);
	          const refundAmountCents = Number(policyDecision.refundAmountCents ?? 0);
	          const at = nowIso();

	          // Optional x402 holdback: implemented as a follow-on "holdback settlement" funded from the payer's wallet.
	          // The primary settlement is always fully resolved (release+refund==amount) to preserve AgentRunSettlement invariants.
	          const holdbackBpsRaw = gate?.terms?.holdbackBps ?? 0;
	          const holdbackBps = Number(holdbackBpsRaw);
	          const normalizedHoldbackBps =
	            Number.isSafeInteger(holdbackBps) && holdbackBps >= 0 ? Math.min(10_000, holdbackBps) : 0;
	          const holdbackAmountCents =
	            normalizedHoldbackBps > 0 && releaseAmountCents > 0
	              ? Math.floor((releaseAmountCents * normalizedHoldbackBps) / 10_000)
	              : 0;
	          const immediateReleaseAmountCents = releaseAmountCents - holdbackAmountCents;
	          const immediateRefundAmountCents = refundAmountCents + holdbackAmountCents;
	          const disputeWindowMsEffective = (() => {
	            const ms = gate?.terms?.disputeWindowMs;
	            if (Number.isSafeInteger(ms) && ms >= 0) return ms;
	            const days = gate?.terms?.disputeWindowDays;
	            if (Number.isSafeInteger(days) && days >= 0) return days * 86_400_000;
	            return 0;
	          })();
	          const holdbackReleaseEligibleAt =
	            holdbackAmountCents > 0 ? new Date(Date.parse(at) + disputeWindowMsEffective).toISOString() : null;
	 
	          try {
	            if (immediateReleaseAmountCents > 0) {
	              const moved = releaseAgentWalletEscrowToPayee({
	                payerWallet,
	                payeeWallet,
	                amountCents: immediateReleaseAmountCents,
	                at
	              });
	              payerWallet = moved.payerWallet;
	              payeeWallet = moved.payeeWallet;
	            }
	            if (immediateRefundAmountCents > 0) {
	              payerWallet = refundAgentWalletEscrow({ wallet: payerWallet, amountCents: immediateRefundAmountCents, at });
	            }
	          } catch (err) {
	            if (err?.code === "INSUFFICIENT_ESCROW_BALANCE") {
	              return sendError(res, 409, "insufficient escrow balance", { message: err?.message }, { code: "INSUFFICIENT_FUNDS" });
	            }
	            throw err;
	          }

	          const policyHashUsed = computeSettlementPolicyHash(policyDecision.policy);
	          const immediateReleaseRatePct =
	            Number(settlement.amountCents) > 0 ? Math.round((immediateReleaseAmountCents * 100) / Number(settlement.amountCents)) : 0;
	          const reasonCodes = (() => {
	            const out = [];
	            const push = (v) => {
	              const s = typeof v === "string" ? v.trim() : "";
	              if (s) out.push(s);
	            };
	            if (Array.isArray(policyDecision.reasonCodes)) for (const c of policyDecision.reasonCodes) push(c);
	            for (const c of extraReasonCodes) push(c);
	            // Deterministic ordering for receipts/logs.
	            return Array.from(new Set(out)).sort((a, b) => a.localeCompare(b));
	          })();
          const providerSigReasonCodes = reasonCodes.filter(
            (code) =>
              code === "X402_PROVIDER_SIGNATURE_MISSING" ||
              code === "X402_PROVIDER_SIGNATURE_INVALID" ||
              code === "X402_PROVIDER_RESPONSE_HASH_MISMATCH" ||
              code === "X402_PROVIDER_KEY_ID_MISMATCH" ||
              code === "X402_PROVIDER_KEY_ID_UNKNOWN"
          );
          const providerQuoteReasonCodes = reasonCodes.filter((code) => code.startsWith("X402_PROVIDER_QUOTE_"));
          const providerSigKeyEvidence = buildVerificationKeyEvidence(body?.providerSignature ?? null);
          const providerQuoteSigKeyEvidence = buildVerificationKeyEvidence(body?.providerQuoteSignature ?? null);
          const providerSigStatus = normalizeProviderSignatureStatus({
            providerSignatureRequired: verificationSource === "provider_signature_v1",
            providerSignature: body?.providerSignature ?? null,
            providerReasonCodes: providerSigReasonCodes
          });
          const providerQuoteSigStatus = normalizeProviderQuoteSignatureStatus({
            providerQuoteSignatureRequired: verificationSource === "provider_signature_v1",
            providerQuoteSignature: body?.providerQuoteSignature ?? null,
            providerReasonCodes: providerQuoteReasonCodes
          });
          if (providerSigKeyEvidence?.jwkThumbprintSha256) {
            providerSigStatus.keyJwkThumbprintSha256 = providerSigKeyEvidence.jwkThumbprintSha256;
          }
          if (providerQuoteSigKeyEvidence?.jwkThumbprintSha256) {
            providerQuoteSigStatus.keyJwkThumbprintSha256 = providerQuoteSigKeyEvidence.jwkThumbprintSha256;
          }
          const enrichedEvidenceRefs = Array.from(
            new Set([
              ...evidenceRefs,
              ...(providerSigKeyEvidence?.jwkThumbprintSha256
                ? [`provider:key_jwk_thumbprint_sha256:${providerSigKeyEvidence.jwkThumbprintSha256}`]
                : []),
              ...(providerQuoteSigKeyEvidence?.jwkThumbprintSha256
                ? [`provider_quote:key_jwk_thumbprint_sha256:${providerQuoteSigKeyEvidence.jwkThumbprintSha256}`]
                : [])
            ])
          ).sort((left, right) => String(left).localeCompare(String(right)));
          const requestSha256 = parseEvidenceRefSha256(enrichedEvidenceRefs, "http:request_sha256:");
          const responseSha256 = parseEvidenceRefSha256(enrichedEvidenceRefs, "http:response_sha256:");
          const verificationMethodHashUsed = computeVerificationMethodHash(policyDecision.verificationMethod ?? {});
          const policyDecisionFingerprint = buildPolicyDecisionFingerprint({
            policyInput: body?.policy ?? null,
            policyHashUsed,
            verificationMethodHashUsed,
            policyDecision
          });
          let tokenPayloadForBindings = null;
          try {
            if (typeof gateAuthorization?.token?.value === "string" && gateAuthorization.token.value.trim() !== "") {
              const parsed = parseSettldPayTokenV1(gateAuthorization.token.value);
              tokenPayloadForBindings = parsed?.payload && typeof parsed.payload === "object" && !Array.isArray(parsed.payload) ? parsed.payload : null;
            }
          } catch {}
          const tokenQuoteId =
            typeof tokenPayloadForBindings?.quoteId === "string" && tokenPayloadForBindings.quoteId.trim() !== ""
              ? tokenPayloadForBindings.quoteId.trim()
              : typeof gate?.quote?.quoteId === "string" && gate.quote.quoteId.trim() !== ""
                ? gate.quote.quoteId.trim()
                : null;
          const tokenQuoteSha256 =
            typeof tokenPayloadForBindings?.quoteSha256 === "string" && tokenPayloadForBindings.quoteSha256.trim() !== ""
              ? tokenPayloadForBindings.quoteSha256.trim().toLowerCase()
              : typeof gate?.quote?.quoteSha256 === "string" && gate.quote.quoteSha256.trim() !== ""
                ? gate.quote.quoteSha256.trim().toLowerCase()
                : null;
          const settlementBindings = {
            authorizationRef:
              typeof gateAuthorization?.authorizationRef === "string" && gateAuthorization.authorizationRef.trim() !== ""
                ? gateAuthorization.authorizationRef
                : `auth_${gateId}`,
            token: {
              kid: gateAuthorization?.token?.kid ?? null,
              sha256:
                gateAuthorization?.token?.sha256 ??
                (typeof gateAuthorization?.token?.value === "string" && gateAuthorization.token.value.trim() !== ""
                  ? computeSettldPayTokenSha256(gateAuthorization.token.value)
                  : null),
              expiresAt: gateAuthorization?.token?.expiresAt ?? null
            },
            request: {
              sha256: requestSha256 ?? null
            },
            response: {
              status:
                body?.responseStatus === null || body?.responseStatus === undefined || body?.responseStatus === ""
                  ? null
                  : Number.isSafeInteger(Number(body.responseStatus))
                    ? Number(body.responseStatus)
                    : null,
              sha256: responseSha256 ?? null
            },
            providerSig: providerSigStatus,
            providerQuoteSig: providerQuoteSigStatus,
            reserve: {
              adapter: gateAuthorization?.reserve?.adapter ?? "circle",
              mode: gateAuthorization?.reserve?.mode ?? "transfer",
              reserveId: gateAuthorization?.reserve?.reserveId ?? null,
              status: gateAuthorization?.reserve?.status ?? null
            },
            quote:
              tokenQuoteId || tokenQuoteSha256 || gateAuthorization?.quote
                ? {
                    quoteId: tokenQuoteId,
                    quoteSha256: tokenQuoteSha256,
                    expiresAt: gateAuthorization?.quote?.expiresAt ?? gate?.quote?.expiresAt ?? null,
                    requestBindingMode: gateAuthorization?.quote?.requestBindingMode ?? gate?.quote?.requestBindingMode ?? null,
                    requestBindingSha256:
                      gateAuthorization?.quote?.requestBindingSha256 ??
                      (typeof gate?.quote?.requestBindingSha256 === "string" ? gate.quote.requestBindingSha256 : null)
                  }
                : null,
            spendAuthorization:
              tokenPayloadForBindings && typeof tokenPayloadForBindings === "object"
                ? {
                    spendAuthorizationVersion:
                      typeof tokenPayloadForBindings.spendAuthorizationVersion === "string"
                        ? tokenPayloadForBindings.spendAuthorizationVersion
                        : null,
                    idempotencyKey:
                      typeof tokenPayloadForBindings.idempotencyKey === "string" ? tokenPayloadForBindings.idempotencyKey : null,
                    nonce: typeof tokenPayloadForBindings.nonce === "string" ? tokenPayloadForBindings.nonce : null,
                    sponsorRef: typeof tokenPayloadForBindings.sponsorRef === "string" ? tokenPayloadForBindings.sponsorRef : null,
                    sponsorWalletRef:
                      typeof tokenPayloadForBindings.sponsorWalletRef === "string" ? tokenPayloadForBindings.sponsorWalletRef : null,
                    agentKeyId: typeof tokenPayloadForBindings.agentKeyId === "string" ? tokenPayloadForBindings.agentKeyId : null,
                    delegationRef:
                      typeof tokenPayloadForBindings.delegationRef === "string" ? tokenPayloadForBindings.delegationRef : null,
                    policyVersion:
                      Number.isSafeInteger(Number(tokenPayloadForBindings.policyVersion)) && Number(tokenPayloadForBindings.policyVersion) > 0
                        ? Number(tokenPayloadForBindings.policyVersion)
                        : null,
                    policyFingerprint:
                      typeof tokenPayloadForBindings.policyFingerprint === "string"
                        ? tokenPayloadForBindings.policyFingerprint.toLowerCase()
                        : null
                  }
                : null,
            policyDecisionFingerprint
          };

          const settlementDecisionStatus = policyDecision.shouldAutoResolve
            ? AGENT_RUN_SETTLEMENT_DECISION_STATUS.AUTO_RESOLVED
            : AGENT_RUN_SETTLEMENT_DECISION_STATUS.MANUAL_REVIEW_REQUIRED;
          const settlementDecisionMode = policyDecision.shouldAutoResolve
            ? AGENT_RUN_SETTLEMENT_DECISION_MODE.AUTOMATIC
            : AGENT_RUN_SETTLEMENT_DECISION_MODE.MANUAL_REVIEW;
          const resolutionEventId = createId("x402res");
          const resolvedKernelRefs = buildSettlementKernelRefs({
            settlement,
            run: null,
            agreementId: gate?.agreementHash ?? null,
            decisionStatus: settlementDecisionStatus,
            decisionMode: settlementDecisionMode,
            decisionReason: reasonCodes[0] ?? null,
            verificationStatus: policyDecision.verificationStatus,
            policyHash: policyHashUsed,
            verificationMethodHash: verificationMethodHashUsed,
            verificationMethodMode: policyDecision?.verificationMethod?.mode ?? null,
            verifierId: "settld.x402",
            verifierVersion: "v1",
            verifierHash: null,
            resolutionEventId,
            status: policyDecision.settlementStatus,
            releasedAmountCents: immediateReleaseAmountCents,
            refundedAmountCents: immediateRefundAmountCents,
            releaseRatePct: immediateReleaseRatePct,
            finalityState: SETTLEMENT_FINALITY_STATE.FINAL,
            settledAt: at,
            createdAt: at,
            bindings: settlementBindings
          });
          const decisionTrace = {
            schemaVersion: "X402GateDecisionTrace.v1",
            verificationStatus: String(policyDecision.verificationStatus ?? ""),
            runStatus: String(policyDecision.runStatus ?? ""),
            shouldAutoResolve: policyDecision.shouldAutoResolve === true,
            reasonCodes,
            policyReleaseRatePct: policyDecision.releaseRatePct,
            policyReleasedAmountCents: releaseAmountCents,
            policyRefundedAmountCents: refundAmountCents,
            holdbackBps: normalizedHoldbackBps,
            holdbackAmountCents,
            holdbackReleaseEligibleAt,
            immediateReleasedAmountCents: immediateReleaseAmountCents,
            immediateRefundedAmountCents: immediateRefundAmountCents,
            releaseRatePct: immediateReleaseRatePct,
            verificationMethod: policyDecision.verificationMethod,
            bindings: settlementBindings,
            verificationContext: {
              schemaVersion: "X402GateVerificationContext.v1",
              providerSigningKey: providerSigKeyEvidence,
              providerQuoteSigningKey: providerQuoteSigKeyEvidence
            },
            decisionRecord: resolvedKernelRefs.decisionRecord,
            settlementReceipt: resolvedKernelRefs.settlementReceipt
          };

	          const resolvedSettlement = resolveAgentRunSettlement({
	            settlement,
	            status: policyDecision.settlementStatus,
	            runStatus: policyDecision.runStatus,
	            releasedAmountCents: immediateReleaseAmountCents,
	            refundedAmountCents: immediateRefundAmountCents,
	            releaseRatePct: immediateReleaseRatePct,
		            decisionStatus: settlementDecisionStatus,
		            decisionMode: settlementDecisionMode,
		            decisionPolicyHash: policyHashUsed,
		            decisionReason: reasonCodes[0] ?? null,
		            decisionTrace,
		            resolutionEventId,
		            at
		          });

	          let holdbackSettlement = null;
	          let holdbackSettlementResolved = null;
	          let holdbackRunId = null;
	          if (holdbackAmountCents > 0) {
	            holdbackRunId = `${runId}_holdback`;
	            const existingHoldback =
	              typeof store.getAgentRunSettlement === "function" ? await store.getAgentRunSettlement({ tenantId, runId: holdbackRunId }) : null;
	            if (existingHoldback && String(existingHoldback.status ?? "").toLowerCase() !== "locked") {
	              holdbackSettlementResolved = existingHoldback;
	            } else if (existingHoldback) {
	              holdbackSettlement = existingHoldback;
	            } else {
	              // Re-lock the holdback funds into escrow for the follow-on settlement.
	              try {
	                payerWallet = lockAgentWalletEscrow({ wallet: payerWallet, amountCents: holdbackAmountCents, at });
	              } catch (err) {
	                if (err?.code === "INSUFFICIENT_WALLET_BALANCE") {
	                  return sendError(res, 409, "insufficient wallet balance for holdback lock", { message: err?.message }, { code: "INSUFFICIENT_FUNDS" });
	                }
	                throw err;
	              }
	              holdbackSettlement = createAgentRunSettlement({
	                tenantId,
	                runId: holdbackRunId,
	                agentId: payeeAgentId,
	                payerAgentId,
	                amountCents: holdbackAmountCents,
	                currency: settlement.currency ?? "USD",
	                disputeWindowDays: 0,
	                at
	              });
	            }

	            // If there's no dispute window, resolve the holdback immediately.
	            if (holdbackSettlement && disputeWindowMsEffective <= 0) {
	              try {
	                const moved = releaseAgentWalletEscrowToPayee({
	                  payerWallet,
	                  payeeWallet,
	                  amountCents: holdbackAmountCents,
	                  at
	                });
	                payerWallet = moved.payerWallet;
	                payeeWallet = moved.payeeWallet;
	              } catch (err) {
	                if (err?.code === "INSUFFICIENT_ESCROW_BALANCE") {
	                  return sendError(res, 409, "insufficient escrow balance for holdback release", { message: err?.message }, { code: "INSUFFICIENT_FUNDS" });
	                }
	                throw err;
	              }

	              holdbackSettlementResolved = resolveAgentRunSettlement({
	                settlement: holdbackSettlement,
	                status: AGENT_RUN_SETTLEMENT_STATUS.RELEASED,
	                runStatus: "completed",
	                releasedAmountCents: holdbackAmountCents,
	                refundedAmountCents: 0,
	                releaseRatePct: 100,
	                decisionStatus: AGENT_RUN_SETTLEMENT_DECISION_STATUS.AUTO_RESOLVED,
	                decisionMode: AGENT_RUN_SETTLEMENT_DECISION_MODE.AUTOMATIC,
	                decisionPolicyHash: policyHashUsed,
	                decisionReason: "x402_holdback_auto_release",
	                decisionTrace: {
	                  schemaVersion: "X402HoldbackDecisionTrace.v1",
	                  gateId,
	                  policyHashUsed,
	                  releasedAmountCents: holdbackAmountCents,
	                  refundedAmountCents: 0
	                },
	                resolutionEventId: createId("x402hb"),
	                at
	              });
	              holdbackSettlement = null;
	            }
	          }

	          const nextGate = normalizeForCanonicalJson(
	            {
	              ...gate,
	              status: "resolved",
	              resolvedAt: at,
              authorization:
                gateAuthorization && typeof gateAuthorization === "object" && !Array.isArray(gateAuthorization)
                  ? {
                      ...gateAuthorization,
                      status: "settled",
                      reserve:
                        gateAuthorization.reserve && typeof gateAuthorization.reserve === "object" && !Array.isArray(gateAuthorization.reserve)
                          ? {
                              ...gateAuthorization.reserve,
                              status: policyDecision.settlementStatus === AGENT_RUN_SETTLEMENT_STATUS.REFUNDED ? "voided" : "settled",
                              settledAt: at
                            }
                          : gateAuthorization.reserve ?? null,
                      updatedAt: at
                    }
                  : null,
		              decision: {
		                policyHashUsed,
		                verificationStatus: policyDecision.verificationStatus,
		                runStatus: policyDecision.runStatus,
		                policyReleaseRatePct: policyDecision.releaseRatePct,
	                policyReleasedAmountCents: releaseAmountCents,
	                policyRefundedAmountCents: refundAmountCents,
	                holdbackBps: normalizedHoldbackBps,
	                holdbackAmountCents,
	                holdbackRunId,
	                holdbackReleaseEligibleAt,
		                releaseRatePct: immediateReleaseRatePct,
		                releasedAmountCents: immediateReleaseAmountCents,
		                refundedAmountCents: immediateRefundAmountCents,
		                reasonCodes,
                    authorizationRef: settlementBindings.authorizationRef,
                    requestSha256: settlementBindings.request?.sha256 ?? null,
                    responseSha256: settlementBindings.response?.sha256 ?? null,
                    providerSig: settlementBindings.providerSig ?? null,
                    providerQuoteSig: settlementBindings.providerQuoteSig ?? null,
                    policyDecisionFingerprint: settlementBindings.policyDecisionFingerprint ?? null
		              },
                  verificationContext: {
                    schemaVersion: "X402GateVerificationContext.v1",
                    providerSigningKey: providerSigKeyEvidence,
                    providerQuoteSigningKey: providerQuoteSigKeyEvidence
                  },
	              holdback:
	                holdbackAmountCents > 0
	                  ? {
	                      schemaVersion: "X402GateHoldback.v1",
	                      runId: holdbackRunId,
	                      amountCents: holdbackAmountCents,
	                      bps: normalizedHoldbackBps,
	                      releaseEligibleAt: holdbackReleaseEligibleAt,
	                      status: holdbackSettlementResolved ? "released" : "held",
	                      releasedAt: holdbackSettlementResolved ? at : null
	                    }
	                  : null,
		              evidenceRefs: enrichedEvidenceRefs,
		              providerSignature: body?.providerSignature ?? null,
                  providerQuoteSignature: body?.providerQuoteSignature ?? null,
                  providerQuotePayload: body?.providerQuotePayload ?? null,
		              updatedAt: at
		            },
	            { path: "$" }
	          );

	          const ops = [
	            { kind: "AGENT_WALLET_UPSERT", tenantId, wallet: payerWallet },
	            { kind: "AGENT_WALLET_UPSERT", tenantId, wallet: payeeWallet },
	            { kind: "AGENT_RUN_SETTLEMENT_UPSERT", tenantId, runId, settlement: resolvedSettlement },
	            ...(holdbackSettlement
	              ? [{ kind: "AGENT_RUN_SETTLEMENT_UPSERT", tenantId, runId: holdbackRunId, settlement: holdbackSettlement }]
	              : []),
	            ...(holdbackSettlementResolved
	              ? [{ kind: "AGENT_RUN_SETTLEMENT_UPSERT", tenantId, runId: holdbackRunId, settlement: holdbackSettlementResolved }]
	              : []),
	            { kind: "X402_GATE_UPSERT", tenantId, gateId, gate: nextGate }
	          ];
          const derivedReceiptRecord =
            typeof store.deriveX402ReceiptRecord === "function"
              ? store.deriveX402ReceiptRecord({ tenantId, gate: nextGate, settlement: resolvedSettlement, includeReversalContext: false })
              : null;
          if (derivedReceiptRecord && typeof derivedReceiptRecord.receiptId === "string" && derivedReceiptRecord.receiptId.trim() !== "") {
            ops.push({
              kind: "X402_RECEIPT_PUT",
              tenantId,
              receiptId: derivedReceiptRecord.receiptId,
              receipt: derivedReceiptRecord
            });
          }
	          const responseBody = {
	            ok: true,
	            gate: nextGate,
	            settlement: resolvedSettlement,
	            holdbackSettlement: holdbackSettlementResolved ?? holdbackSettlement ?? null,
	            decision: policyDecision,
            decisionRecord: resolvedKernelRefs.decisionRecord,
            settlementReceipt: resolvedKernelRefs.settlementReceipt
	          };
          if (idemStoreKey) {
            ops.push({ kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode: 200, body: responseBody } });
          }
          await store.commitTx({ at, ops });
          return sendJson(res, 200, responseBody);
        }

        if (parts[0] === "x402" && parts[1] === "gate" && parts[2] === "reversal" && parts.length === 3 && req.method === "POST") {
          if (!requireProtocolHeaderForWrite(req, res)) return;

          const body = await readJsonBody(req);
          let idemStoreKey = null;
          let idemRequestHash = null;
          try {
            ({ idemStoreKey, idemRequestHash } = readIdempotency({ method: "POST", requestPath: path, expectedPrevChainHash: null, body }));
          } catch (err) {
            return sendError(res, 400, "invalid idempotency key", { message: err?.message });
          }
          if (idemStoreKey) {
            const existing = store.idempotency.get(idemStoreKey);
            if (existing) {
              if (existing.requestHash !== idemRequestHash) {
                return sendError(res, 409, "idempotency key conflict", "request differs from initial use of this key");
              }
              return sendJson(res, existing.statusCode, existing.body);
            }
          }

          const gateId = typeof body?.gateId === "string" && body.gateId.trim() !== "" ? body.gateId.trim() : null;
          if (!gateId) return sendError(res, 400, "gateId is required", null, { code: "SCHEMA_INVALID" });
          let action = null;
          let providerDecision = null;
          let reason = null;
          let reversalEvidenceRefs = [];
          let commandEnvelope = null;
          let providerDecisionArtifact = null;
          try {
            action = normalizeX402ReversalActionInput(body?.action);
            providerDecision = normalizeX402ReversalDecisionInput(body?.providerDecision ?? null);
            reason = normalizeX402ReversalReasonInput(body?.reason ?? null);
            reversalEvidenceRefs = normalizeX402ReversalEvidenceRefsInput(body?.evidenceRefs ?? null);
            commandEnvelope = normalizeX402ReversalCommandInput(body?.command);
            providerDecisionArtifact = normalizeX402ProviderRefundDecisionEnvelopeInput(body?.providerDecisionArtifact ?? null);
          } catch (err) {
            return sendError(res, 400, "invalid reversal request", { message: err?.message }, { code: "SCHEMA_INVALID" });
          }

          const gate = typeof store.getX402Gate === "function" ? await store.getX402Gate({ tenantId, gateId }) : null;
          if (!gate) return sendError(res, 404, "gate not found", null, { code: "NOT_FOUND" });
          const runId = String(gate.runId ?? "");
          const settlement = typeof store.getAgentRunSettlement === "function" ? await store.getAgentRunSettlement({ tenantId, runId }) : null;
          if (!settlement) return sendError(res, 404, "settlement not found for gate", null, { code: "NOT_FOUND" });

          const amountCents = Number(settlement.amountCents ?? gate?.terms?.amountCents ?? 0);
          if (!Number.isSafeInteger(amountCents) || amountCents <= 0) {
            return sendError(res, 409, "gate amount invalid", null, { code: "X402_GATE_INVALID" });
          }
          const currency =
            typeof settlement.currency === "string" && settlement.currency.trim() !== ""
              ? settlement.currency.trim().toUpperCase()
              : typeof gate?.terms?.currency === "string" && gate.terms.currency.trim() !== ""
                ? gate.terms.currency.trim().toUpperCase()
                : "USD";
          const payerAgentId = typeof gate?.payerAgentId === "string" && gate.payerAgentId.trim() !== "" ? gate.payerAgentId.trim() : null;
          const payeeAgentId = typeof gate?.payeeAgentId === "string" && gate.payeeAgentId.trim() !== "" ? gate.payeeAgentId.trim() : null;
          if (!payerAgentId || !payeeAgentId) return sendError(res, 409, "gate actors missing", null, { code: "X402_GATE_INVALID" });

          const settlementReceiptId = x402SettlementReceiptIdFromSettlement(settlement);
          const authorizationRef =
            gate?.authorization &&
            typeof gate.authorization === "object" &&
            !Array.isArray(gate.authorization) &&
            typeof gate.authorization.authorizationRef === "string" &&
            gate.authorization.authorizationRef.trim() !== ""
              ? gate.authorization.authorizationRef.trim()
              : null;
          const reversalReceiptId =
            settlementReceiptId ??
            (action === "void_authorization" ? authorizationRef ?? `auth_${gateId}` : null);
          if (!reversalReceiptId) {
            return sendError(res, 409, "receipt is not available for gate reversal", null, { code: "X402_REVERSAL_RECEIPT_MISSING" });
          }

          const payerIdentity = await getAgentIdentityRecord({ tenantId, agentId: payerAgentId });
          const payeeIdentity = await getAgentIdentityRecord({ tenantId, agentId: payeeAgentId });
          if (!payerIdentity || !payeeIdentity) return sendError(res, 409, "agent identities missing for reversal", null, { code: "X402_GATE_INVALID" });
          const payerKeyId =
            payerIdentity?.keys && typeof payerIdentity.keys === "object" && !Array.isArray(payerIdentity.keys)
              ? String(payerIdentity.keys.keyId ?? "").trim()
              : "";
          const payerPublicKeyPem =
            payerIdentity?.keys && typeof payerIdentity.keys === "object" && !Array.isArray(payerIdentity.keys)
              ? String(payerIdentity.keys.publicKeyPem ?? "")
              : "";
          if (!payerKeyId || !payerPublicKeyPem.trim()) {
            return sendError(res, 409, "payer signature key is not configured", null, { code: "X402_REVERSAL_COMMAND_KEY_MISSING" });
          }

          const payeeKeyId =
            payeeIdentity?.keys && typeof payeeIdentity.keys === "object" && !Array.isArray(payeeIdentity.keys)
              ? String(payeeIdentity.keys.keyId ?? "").trim()
              : "";
          const payeePublicKeyPem =
            payeeIdentity?.keys && typeof payeeIdentity.keys === "object" && !Array.isArray(payeeIdentity.keys)
              ? String(payeeIdentity.keys.publicKeyPem ?? "")
              : "";
          if (!payeeKeyId || !payeePublicKeyPem.trim()) {
            return sendError(res, 409, "provider signature key is not configured", null, { code: "X402_PROVIDER_DECISION_KEY_MISSING" });
          }

          const quoteBinding = resolveX402GateQuoteBinding({ gate, settlement });
          const gateAgentPassport =
            gate?.agentPassport && typeof gate.agentPassport === "object" && !Array.isArray(gate.agentPassport) ? gate.agentPassport : null;
          let resolvedWalletPolicy = null;
          if (gateAgentPassport) {
            const walletPolicyResolution = await resolveX402WalletPolicyForPassport({
              tenantId,
              gateAgentPassport
            });
            if (walletPolicyResolution?.error) {
              return sendError(
                res,
                409,
                "x402 wallet policy reference is invalid",
                {
                  message: walletPolicyResolution.error.message ?? null,
                  sponsorWalletRef: walletPolicyResolution.sponsorWalletRef ?? null
                },
                { code: walletPolicyResolution.error.code ?? "X402_WALLET_POLICY_REFERENCE_INVALID" }
              );
            }
            resolvedWalletPolicy = walletPolicyResolution?.policy ?? null;
          }
          if (resolvedWalletPolicy) {
            const policyStatus = String(resolvedWalletPolicy.status ?? "active").toLowerCase();
            if (policyStatus !== "active") {
              return sendError(
                res,
                409,
                "x402 wallet policy blocked reversal",
                { code: "X402_WALLET_POLICY_DISABLED" },
                { code: "X402_WALLET_POLICY_DISABLED" }
              );
            }
            if (
              Array.isArray(resolvedWalletPolicy.allowedReversalActions) &&
              resolvedWalletPolicy.allowedReversalActions.length > 0 &&
              !resolvedWalletPolicy.allowedReversalActions.includes(action)
            ) {
              return sendError(
                res,
                409,
                "x402 wallet policy blocked reversal action",
                {
                  action,
                  allowedReversalActions: resolvedWalletPolicy.allowedReversalActions
                },
                { code: "X402_WALLET_POLICY_REVERSAL_ACTION_NOT_ALLOWED" }
              );
            }
          }
          const expectedSponsorRef = quoteBinding.sponsorRef ?? payerAgentId;
          const commandSignatureKeyId =
            commandEnvelope?.signature && typeof commandEnvelope.signature === "object" && !Array.isArray(commandEnvelope.signature)
              ? String(commandEnvelope.signature.keyId ?? "").trim()
              : "";
          if (!commandSignatureKeyId) {
            return sendError(res, 400, "command.signature.keyId is required", null, { code: "SCHEMA_INVALID" });
          }
          if (commandSignatureKeyId !== payerKeyId) {
            return sendError(res, 409, "command signer key does not match payer key", null, { code: "X402_REVERSAL_COMMAND_SIGNER_MISMATCH" });
          }

          const nowAt = nowIso();
          const commandVerification = verifyX402ReversalCommandV1({
            command: commandEnvelope,
            publicKeyPem: payerPublicKeyPem,
            nowAt,
            expectedAction: action,
            expectedSponsorRef: expectedSponsorRef,
            expectedGateId: gateId,
            expectedReceiptId: reversalReceiptId,
            expectedQuoteId: quoteBinding.quoteId,
            expectedRequestSha256: quoteBinding.requestSha256
          });
          if (commandVerification.ok !== true) {
            const statusCode = String(commandVerification.code ?? "").endsWith("_SCHEMA_INVALID") ? 400 : 409;
            return sendError(
              res,
              statusCode,
              "reversal command verification failed",
              { message: commandVerification.error ?? null, code: commandVerification.code ?? null },
              { code: commandVerification.code ?? "X402_REVERSAL_COMMAND_INVALID" }
            );
          }
          const commandPayload = commandVerification.payload;

          const existingCommandUsage =
            typeof store.getX402ReversalCommandUsage === "function"
              ? await store.getX402ReversalCommandUsage({ tenantId, commandId: commandPayload.commandId })
              : store.x402ReversalCommandUsage instanceof Map
                ? store.x402ReversalCommandUsage.get(makeScopedKey({ tenantId, id: commandPayload.commandId })) ?? null
                : null;
          if (existingCommandUsage) {
            return sendError(res, 409, "reversal command already used", null, { code: "X402_REVERSAL_COMMAND_REPLAY" });
          }
          const existingNonceUsage =
            typeof store.getX402ReversalNonceUsage === "function"
              ? await store.getX402ReversalNonceUsage({ tenantId, sponsorRef: commandPayload.sponsorRef, nonce: commandPayload.nonce })
              : store.x402ReversalNonceUsage instanceof Map
                ? store.x402ReversalNonceUsage.get(`${normalizeTenantId(tenantId)}\n${commandPayload.sponsorRef}\n${commandPayload.nonce}`) ?? null
                : null;
          if (existingNonceUsage) {
            return sendError(res, 409, "reversal command nonce already used", null, { code: "X402_REVERSAL_NONCE_REPLAY" });
          }

          let priorReversalEvents = [];
          if (typeof store.listX402ReversalEvents === "function") {
            priorReversalEvents = await store.listX402ReversalEvents({ tenantId, gateId, limit: 1000, offset: 0 });
          } else if (store.x402ReversalEvents instanceof Map) {
            for (const row of store.x402ReversalEvents.values()) {
              if (!row || typeof row !== "object" || Array.isArray(row)) continue;
              if (normalizeTenantId(row.tenantId ?? DEFAULT_TENANT_ID) !== normalizeTenantId(tenantId)) continue;
              if (String(row.gateId ?? "") !== gateId) continue;
              priorReversalEvents.push(row);
            }
          }
          priorReversalEvents.sort((left, right) => {
            const leftMs = Number.isFinite(Date.parse(String(left?.occurredAt ?? ""))) ? Date.parse(String(left.occurredAt)) : Number.NaN;
            const rightMs = Number.isFinite(Date.parse(String(right?.occurredAt ?? ""))) ? Date.parse(String(right.occurredAt)) : Number.NaN;
            if (Number.isFinite(leftMs) && Number.isFinite(rightMs) && leftMs !== rightMs) return leftMs - rightMs;
            return String(left?.eventId ?? "").localeCompare(String(right?.eventId ?? ""));
          });
          const previousReversalEvent = priorReversalEvents.length > 0 ? priorReversalEvents[priorReversalEvents.length - 1] : null;
          const previousEventHash =
            typeof previousReversalEvent?.eventHash === "string" && previousReversalEvent.eventHash.trim() !== ""
              ? previousReversalEvent.eventHash.trim()
              : null;

          const commandArtifact = normalizeForCanonicalJson(
            {
              schemaVersion: "X402ReversalCommand.v1",
              commandId: commandPayload.commandId,
              sponsorRef: commandPayload.sponsorRef,
              ...(commandPayload.agentKeyId ? { agentKeyId: commandPayload.agentKeyId } : {}),
              target: commandPayload.target,
              action: commandPayload.action,
              nonce: commandPayload.nonce,
              idempotencyKey: commandPayload.idempotencyKey,
              exp: commandPayload.exp,
              signature:
                commandEnvelope?.signature && typeof commandEnvelope.signature === "object" && !Array.isArray(commandEnvelope.signature)
                  ? commandEnvelope.signature
                  : null
            },
            { path: "$" }
          );
          const commandVerificationRecord = normalizeForCanonicalJson(
            {
              schemaVersion: "X402ReversalCommandVerification.v1",
              verified: true,
              keyId: commandSignatureKeyId,
              publicKeyPem: payerPublicKeyPem,
              payloadHash: commandVerification.payloadHash,
              checkedAt: nowAt,
              code: null,
              error: null
            },
            { path: "$" }
          );

          const existingReversal =
            gate?.reversal && typeof gate.reversal === "object" && !Array.isArray(gate.reversal) ? gate.reversal : null;
          const baseBindings =
            settlement?.decisionTrace?.bindings && typeof settlement.decisionTrace.bindings === "object" && !Array.isArray(settlement.decisionTrace.bindings)
              ? settlement.decisionTrace.bindings
              : null;

          let decisionArtifactVerification = null;
          if (action === "resolve_refund") {
            if (!providerDecisionArtifact) {
              return sendError(res, 400, "providerDecisionArtifact is required for resolve_refund", null, { code: "SCHEMA_INVALID" });
            }
            decisionArtifactVerification = verifyX402ProviderRefundDecisionV1({
              decision: providerDecisionArtifact,
              publicKeyPem: payeePublicKeyPem,
              expectedReceiptId: reversalReceiptId,
              expectedGateId: gateId,
              expectedQuoteId: quoteBinding.quoteId,
              expectedRequestSha256: quoteBinding.requestSha256,
              expectedDecision: providerDecision
            });
            if (decisionArtifactVerification.ok !== true) {
              const statusCode = String(decisionArtifactVerification.code ?? "").endsWith("_SCHEMA_INVALID") ? 400 : 409;
              return sendError(
                res,
                statusCode,
                "provider refund decision verification failed",
                { message: decisionArtifactVerification.error ?? null, code: decisionArtifactVerification.code ?? null },
                { code: decisionArtifactVerification.code ?? "X402_PROVIDER_DECISION_INVALID" }
              );
            }
            providerDecision = decisionArtifactVerification.payload?.decision ?? providerDecision;
          }

          let nextGate = gate;
          let nextSettlement = settlement;
          let payerWallet = null;
          let payeeWallet = null;
          let reversalEventRecord = null;
          const ops = [];
          let responseStatusCode = 200;
          let kernelRefs = null;
          const reversalEventId = createId("x402rev");
          const settlementStatusBefore = String(settlement.status ?? "").toLowerCase();

          if (action === "void_authorization") {
            if (settlementStatusBefore !== AGENT_RUN_SETTLEMENT_STATUS.LOCKED) {
              return sendError(res, 409, "void is only allowed while settlement is locked", null, { code: "X402_REVERSAL_INVALID_STATE" });
            }
            const existingAuthorization =
              gate?.authorization && typeof gate.authorization === "object" && !Array.isArray(gate.authorization) ? gate.authorization : null;
            if (!existingAuthorization) return sendError(res, 409, "gate authorization missing", null, { code: "X402_GATE_INVALID" });

            const payerWalletExisting = typeof store.getAgentWallet === "function" ? await store.getAgentWallet({ tenantId, agentId: payerAgentId }) : null;
            if (!payerWalletExisting) return sendError(res, 409, "payer wallet missing", null, { code: "WALLET_MISSING" });
            try {
              payerWallet = refundAgentWalletEscrow({ wallet: payerWalletExisting, amountCents, at: nowAt });
            } catch (err) {
              if (err?.code === "INSUFFICIENT_ESCROW_BALANCE") {
                return sendError(res, 409, "insufficient escrow balance", { message: err?.message }, { code: "INSUFFICIENT_FUNDS" });
              }
              throw err;
            }

            let reserveOutcome = null;
            const reserveStatus = String(existingAuthorization?.reserve?.status ?? "").toLowerCase();
            const reserveId = typeof existingAuthorization?.reserve?.reserveId === "string" ? existingAuthorization.reserve.reserveId.trim() : "";
            if (reserveId && (reserveStatus === "reserved" || reserveStatus === "settled")) {
              try {
                reserveOutcome = await circleReserveAdapter.void({
                  reserveId,
                  amountCents,
                  currency,
                  idempotencyKey: `${gateId}:void_authorization`
                });
              } catch (err) {
                return sendError(
                  res,
                  503,
                  "failed to void external reserve",
                  { message: err?.message ?? String(err ?? ""), code: err?.code ?? null },
                  { code: "X402_RESERVE_VOID_FAILED" }
                );
              }
            }

            const reasonCodes = ["X402_AUTHORIZATION_VOIDED"];
            kernelRefs = buildSettlementKernelRefs({
              settlement,
              agreementId: gate?.agreementHash ?? null,
              decisionStatus: AGENT_RUN_SETTLEMENT_DECISION_STATUS.MANUAL_RESOLVED,
              decisionMode: AGENT_RUN_SETTLEMENT_DECISION_MODE.MANUAL_REVIEW,
              decisionReason: "x402_authorization_voided",
              verificationStatus: "red",
              policyHash: null,
              verificationMethodHash: null,
              verificationMethodMode: "manual",
              verifierId: "settld.x402.reversal",
              verifierVersion: "v1",
              verifierHash: null,
              resolutionEventId: reversalEventId,
              status: AGENT_RUN_SETTLEMENT_STATUS.REFUNDED,
              releasedAmountCents: 0,
              refundedAmountCents: amountCents,
              releaseRatePct: 0,
              finalityState: SETTLEMENT_FINALITY_STATE.FINAL,
              settledAt: nowAt,
              createdAt: nowAt,
              bindings: baseBindings
            });
            reversalEventRecord = buildX402ReversalEventRecord({
              tenantId,
              gateId,
              receiptId: reversalReceiptId,
              action,
              eventType: "authorization_voided",
              occurredAt: nowAt,
              reason,
              providerDecision: "accepted",
              evidenceRefs: reversalEvidenceRefs,
              command: commandArtifact,
              commandVerification: commandVerificationRecord,
              settlementStatusBefore,
              settlementStatusAfter: AGENT_RUN_SETTLEMENT_STATUS.REFUNDED,
              previousEventHash,
              eventId: reversalEventId
            });
            const reversalWithEvent = appendX402GateReversalTimeline({
              gate,
              eventType: "authorization_voided",
              at: nowAt,
              reason,
              providerDecision: "accepted",
              evidenceRefs: reversalEvidenceRefs,
              action,
              eventId: reversalEventRecord.eventId,
              eventHash: reversalEventRecord.eventHash,
              prevEventHash: reversalEventRecord.prevEventHash ?? null,
              commandId: commandPayload.commandId
            });
            const reversal = normalizeForCanonicalJson(
              {
                ...reversalWithEvent,
                status: "voided",
                requestedAt: existingReversal?.requestedAt ?? nowAt,
                resolvedAt: nowAt,
                providerDecision: "accepted",
                reason: reason ?? existingReversal?.reason ?? null,
                evidenceRefs: reversalEvidenceRefs.length > 0 ? reversalEvidenceRefs : existingReversal?.evidenceRefs ?? []
              },
              { path: "$" }
            );
            const decisionTrace = normalizeForCanonicalJson(
              {
                schemaVersion: "X402GateDecisionTrace.v1",
                verificationStatus: "red",
                runStatus: "cancelled",
                shouldAutoResolve: true,
                reasonCodes,
                policyReleaseRatePct: 0,
                policyReleasedAmountCents: 0,
                policyRefundedAmountCents: amountCents,
                holdbackBps: 0,
                holdbackAmountCents: 0,
                holdbackReleaseEligibleAt: null,
                immediateReleasedAmountCents: 0,
                immediateRefundedAmountCents: amountCents,
                releaseRatePct: 0,
                verificationMethod: { mode: "manual", source: "x402_reversal_v1" },
                bindings: baseBindings,
                reversal,
                decisionRecord: kernelRefs?.decisionRecord ?? null,
                settlementReceipt: kernelRefs?.settlementReceipt ?? null
              },
              { path: "$" }
            );

            nextSettlement = resolveAgentRunSettlement({
              settlement,
              status: AGENT_RUN_SETTLEMENT_STATUS.REFUNDED,
              runStatus: "cancelled",
              releasedAmountCents: 0,
              refundedAmountCents: amountCents,
              releaseRatePct: 0,
              decisionStatus: AGENT_RUN_SETTLEMENT_DECISION_STATUS.MANUAL_RESOLVED,
              decisionMode: AGENT_RUN_SETTLEMENT_DECISION_MODE.MANUAL_REVIEW,
              decisionReason: "x402_authorization_voided",
              decisionTrace,
              resolutionEventId: reversalEventId,
              at: nowAt
            });

            const updatedAuthorization = normalizeForCanonicalJson(
              {
                ...existingAuthorization,
                status: "voided",
                walletEscrow:
                  existingAuthorization.walletEscrow &&
                  typeof existingAuthorization.walletEscrow === "object" &&
                  !Array.isArray(existingAuthorization.walletEscrow)
                    ? {
                        ...existingAuthorization.walletEscrow,
                        status: "unlocked",
                        unlockedAt: nowAt
                      }
                    : existingAuthorization.walletEscrow ?? null,
                reserve:
                  existingAuthorization.reserve &&
                  typeof existingAuthorization.reserve === "object" &&
                  !Array.isArray(existingAuthorization.reserve)
                    ? {
                        ...existingAuthorization.reserve,
                        status: reserveOutcome?.status ?? "voided",
                        voidedAt: nowAt,
                        ...(reserveOutcome?.compensationReserveId ? { compensationReserveId: reserveOutcome.compensationReserveId } : {})
                      }
                    : existingAuthorization.reserve ?? null,
                updatedAt: nowAt
              },
              { path: "$" }
            );
            nextGate = normalizeForCanonicalJson(
              {
                ...gate,
                status: "resolved",
                resolvedAt: nowAt,
                authorization: updatedAuthorization,
                reversal,
                updatedAt: nowAt
              },
              { path: "$" }
            );
            ops.push({ kind: "AGENT_WALLET_UPSERT", tenantId, wallet: payerWallet });
            ops.push({ kind: "AGENT_RUN_SETTLEMENT_UPSERT", tenantId, runId, settlement: nextSettlement });
            ops.push({ kind: "X402_GATE_UPSERT", tenantId, gateId, gate: nextGate });
          } else if (action === "request_refund") {
            if (settlementStatusBefore !== AGENT_RUN_SETTLEMENT_STATUS.RELEASED) {
              return sendError(res, 409, "refund request is only allowed after settlement release", null, {
                code: "X402_REVERSAL_INVALID_STATE"
              });
            }
            if (String(existingReversal?.status ?? "").toLowerCase() === "refunded") {
              return sendError(res, 409, "gate is already refunded", null, { code: "X402_REVERSAL_INVALID_STATE" });
            }
            reversalEventRecord = buildX402ReversalEventRecord({
              tenantId,
              gateId,
              receiptId: reversalReceiptId,
              action,
              eventType: "refund_requested",
              occurredAt: nowAt,
              reason,
              providerDecision: null,
              evidenceRefs: reversalEvidenceRefs,
              command: commandArtifact,
              commandVerification: commandVerificationRecord,
              settlementStatusBefore,
              settlementStatusAfter: AGENT_RUN_SETTLEMENT_STATUS.RELEASED,
              previousEventHash,
              eventId: reversalEventId
            });
            const reversalWithEvent = appendX402GateReversalTimeline({
              gate,
              eventType: "refund_requested",
              at: nowAt,
              reason,
              providerDecision: null,
              evidenceRefs: reversalEvidenceRefs,
              action,
              eventId: reversalEventRecord.eventId,
              eventHash: reversalEventRecord.eventHash,
              prevEventHash: reversalEventRecord.prevEventHash ?? null,
              commandId: commandPayload.commandId
            });
            const reversal = normalizeForCanonicalJson(
              {
                ...reversalWithEvent,
                status: "refund_pending",
                requestedAt: nowAt,
                resolvedAt: null,
                providerDecision: null,
                reason: reason ?? existingReversal?.reason ?? null,
                evidenceRefs: reversalEvidenceRefs.length > 0 ? reversalEvidenceRefs : existingReversal?.evidenceRefs ?? []
              },
              { path: "$" }
            );
            nextGate = normalizeForCanonicalJson(
              {
                ...gate,
                reversal,
                updatedAt: nowAt
              },
              { path: "$" }
            );
            responseStatusCode = 202;
            ops.push({ kind: "X402_GATE_UPSERT", tenantId, gateId, gate: nextGate });
          } else if (action === "resolve_refund") {
            if (String(existingReversal?.status ?? "").toLowerCase() !== "refund_pending") {
              return sendError(res, 409, "no pending refund request exists for gate", null, { code: "X402_REVERSAL_INVALID_STATE" });
            }
            if (!providerDecision) {
              return sendError(res, 400, "providerDecision is required for resolve_refund", null, { code: "SCHEMA_INVALID" });
            }
            const providerDecisionVerificationRecord = decisionArtifactVerification
              ? normalizeForCanonicalJson(
                  {
                    schemaVersion: "X402ProviderRefundDecisionVerification.v1",
                    verified: true,
                    keyId: payeeKeyId,
                    publicKeyPem: payeePublicKeyPem,
                    payloadHash: decisionArtifactVerification.payloadHash,
                    checkedAt: nowAt,
                    code: null,
                    error: null
                  },
                  { path: "$" }
                )
              : null;
            if (providerDecision === "denied") {
              reversalEventRecord = buildX402ReversalEventRecord({
                tenantId,
                gateId,
                receiptId: reversalReceiptId,
                action,
                eventType: "refund_resolved",
                occurredAt: nowAt,
                reason,
                providerDecision: "denied",
                evidenceRefs: reversalEvidenceRefs,
                command: commandArtifact,
                commandVerification: commandVerificationRecord,
                providerDecisionArtifact,
                providerDecisionVerification: providerDecisionVerificationRecord,
                settlementStatusBefore,
                settlementStatusAfter: AGENT_RUN_SETTLEMENT_STATUS.RELEASED,
                previousEventHash,
                eventId: reversalEventId
              });
              const reversalWithEvent = appendX402GateReversalTimeline({
                gate,
                eventType: "refund_resolved",
                at: nowAt,
                reason,
                providerDecision: "denied",
                evidenceRefs: reversalEvidenceRefs,
                action,
                eventId: reversalEventRecord.eventId,
                eventHash: reversalEventRecord.eventHash,
                prevEventHash: reversalEventRecord.prevEventHash ?? null,
                commandId: commandPayload.commandId
              });
              const reversal = normalizeForCanonicalJson(
                {
                  ...reversalWithEvent,
                  status: "refund_denied",
                  requestedAt: existingReversal?.requestedAt ?? nowAt,
                  resolvedAt: nowAt,
                  providerDecision: "denied",
                  reason: reason ?? existingReversal?.reason ?? null,
                  evidenceRefs: reversalEvidenceRefs.length > 0 ? reversalEvidenceRefs : existingReversal?.evidenceRefs ?? []
                },
                { path: "$" }
              );
              nextGate = normalizeForCanonicalJson(
                {
                  ...gate,
                  reversal,
                  updatedAt: nowAt
                },
                { path: "$" }
              );
              ops.push({ kind: "X402_GATE_UPSERT", tenantId, gateId, gate: nextGate });
            } else {
              if (settlementStatusBefore !== AGENT_RUN_SETTLEMENT_STATUS.RELEASED) {
                return sendError(res, 409, "refund resolution requires released settlement", null, {
                  code: "X402_REVERSAL_INVALID_STATE"
                });
              }
              const refundAmountCents = Number(settlement.releasedAmountCents ?? 0);
              if (!Number.isSafeInteger(refundAmountCents) || refundAmountCents <= 0) {
                return sendError(res, 409, "no releasable amount remains to refund", null, { code: "X402_REVERSAL_INVALID_STATE" });
              }
              const payerWalletExisting = typeof store.getAgentWallet === "function" ? await store.getAgentWallet({ tenantId, agentId: payerAgentId }) : null;
              const payeeWalletExisting = typeof store.getAgentWallet === "function" ? await store.getAgentWallet({ tenantId, agentId: payeeAgentId }) : null;
              if (!payerWalletExisting || !payeeWalletExisting) return sendError(res, 409, "missing wallets for refund resolution", null, { code: "WALLET_MISSING" });
              try {
                const transferred = transferAgentWalletAvailable({
                  fromWallet: payeeWalletExisting,
                  toWallet: payerWalletExisting,
                  amountCents: refundAmountCents,
                  at: nowAt
                });
                payeeWallet = transferred.fromWallet;
                payerWallet = transferred.toWallet;
              } catch (err) {
                if (err?.code === "INSUFFICIENT_WALLET_BALANCE") {
                  return sendError(res, 409, "provider wallet balance insufficient for refund", { message: err?.message }, { code: "INSUFFICIENT_FUNDS" });
                }
                throw err;
              }
              reversalEventRecord = buildX402ReversalEventRecord({
                tenantId,
                gateId,
                receiptId: reversalReceiptId,
                action,
                eventType: "refund_resolved",
                occurredAt: nowAt,
                reason,
                providerDecision: "accepted",
                evidenceRefs: reversalEvidenceRefs,
                command: commandArtifact,
                commandVerification: commandVerificationRecord,
                providerDecisionArtifact,
                providerDecisionVerification: providerDecisionVerificationRecord,
                settlementStatusBefore,
                settlementStatusAfter: AGENT_RUN_SETTLEMENT_STATUS.REFUNDED,
                previousEventHash,
                eventId: reversalEventId
              });
              const reversalWithEvent = appendX402GateReversalTimeline({
                gate,
                eventType: "refund_resolved",
                at: nowAt,
                reason,
                providerDecision: "accepted",
                evidenceRefs: reversalEvidenceRefs,
                action,
                eventId: reversalEventRecord.eventId,
                eventHash: reversalEventRecord.eventHash,
                prevEventHash: reversalEventRecord.prevEventHash ?? null,
                commandId: commandPayload.commandId
              });
              const reversal = normalizeForCanonicalJson(
                {
                  ...reversalWithEvent,
                  status: "refunded",
                  requestedAt: existingReversal?.requestedAt ?? nowAt,
                  resolvedAt: nowAt,
                  providerDecision: "accepted",
                  reason: reason ?? existingReversal?.reason ?? null,
                  evidenceRefs: reversalEvidenceRefs.length > 0 ? reversalEvidenceRefs : existingReversal?.evidenceRefs ?? []
                },
                { path: "$" }
              );
              kernelRefs = buildSettlementKernelRefs({
                settlement,
                agreementId: gate?.agreementHash ?? null,
                decisionStatus: AGENT_RUN_SETTLEMENT_DECISION_STATUS.MANUAL_RESOLVED,
                decisionMode: AGENT_RUN_SETTLEMENT_DECISION_MODE.MANUAL_REVIEW,
                decisionReason: "x402_refund_accepted",
                verificationStatus: "amber",
                policyHash: null,
                verificationMethodHash: null,
                verificationMethodMode: "manual",
                verifierId: "settld.x402.reversal",
                verifierVersion: "v1",
                verifierHash: null,
                resolutionEventId: reversalEventId,
                status: AGENT_RUN_SETTLEMENT_STATUS.REFUNDED,
                releasedAmountCents: 0,
                refundedAmountCents: amountCents,
                releaseRatePct: 0,
                finalityState: SETTLEMENT_FINALITY_STATE.FINAL,
                settledAt: nowAt,
                createdAt: nowAt,
                bindings: baseBindings
              });
              const decisionTrace = normalizeForCanonicalJson(
                {
                  ...(settlement?.decisionTrace && typeof settlement.decisionTrace === "object" && !Array.isArray(settlement.decisionTrace)
                    ? settlement.decisionTrace
                    : {}),
                  schemaVersion: "X402GateDecisionTrace.v1",
                  reversal,
                  reasonCodes: Array.from(
                    new Set([
                      ...(Array.isArray(settlement?.decisionTrace?.reasonCodes) ? settlement.decisionTrace.reasonCodes : []),
                      "X402_REFUND_ACCEPTED"
                    ])
                  ),
                  decisionRecord: kernelRefs?.decisionRecord ?? null,
                  settlementReceipt: kernelRefs?.settlementReceipt ?? null
                },
                { path: "$" }
              );
              nextSettlement = refundReleasedAgentRunSettlement({
                settlement,
                runStatus: "refunded",
                decisionStatus: AGENT_RUN_SETTLEMENT_DECISION_STATUS.MANUAL_RESOLVED,
                decisionMode: AGENT_RUN_SETTLEMENT_DECISION_MODE.MANUAL_REVIEW,
                decisionReason: "x402_refund_accepted",
                decisionTrace,
                resolutionEventId: reversalEventId,
                at: nowAt
              });
              nextGate = normalizeForCanonicalJson(
                {
                  ...gate,
                  reversal,
                  decision: {
                    ...(gate?.decision && typeof gate.decision === "object" && !Array.isArray(gate.decision) ? gate.decision : {}),
                    releaseRatePct: 0,
                    releasedAmountCents: 0,
                    refundedAmountCents: amountCents,
                    reasonCodes: Array.from(
                      new Set([
                        ...(Array.isArray(gate?.decision?.reasonCodes) ? gate.decision.reasonCodes : []),
                        "X402_REFUND_ACCEPTED"
                      ])
                    ),
                    policyDecisionFingerprint:
                      settlement?.decisionTrace?.bindings?.policyDecisionFingerprint ??
                      gate?.decision?.policyDecisionFingerprint ??
                      null
                  },
                  updatedAt: nowAt
                },
                { path: "$" }
              );
              ops.push({ kind: "AGENT_WALLET_UPSERT", tenantId, wallet: payerWallet });
              ops.push({ kind: "AGENT_WALLET_UPSERT", tenantId, wallet: payeeWallet });
              ops.push({ kind: "AGENT_RUN_SETTLEMENT_UPSERT", tenantId, runId, settlement: nextSettlement });
              ops.push({ kind: "X402_GATE_UPSERT", tenantId, gateId, gate: nextGate });
            }
          }

          const commandUsageRecord = normalizeForCanonicalJson(
            {
              schemaVersion: "X402ReversalCommandUsage.v1",
              tenantId,
              commandId: commandPayload.commandId,
              sponsorRef: commandPayload.sponsorRef,
              nonce: commandPayload.nonce,
              action,
              gateId,
              receiptId: reversalReceiptId,
              eventId: reversalEventRecord?.eventId ?? reversalEventId,
              usedAt: nowAt
            },
            { path: "$" }
          );
          const nonceUsageRecord = normalizeForCanonicalJson(
            {
              schemaVersion: "X402ReversalNonceUsage.v1",
              tenantId,
              sponsorRef: commandPayload.sponsorRef,
              nonce: commandPayload.nonce,
              commandId: commandPayload.commandId,
              action,
              gateId,
              receiptId: reversalReceiptId,
              eventId: reversalEventRecord?.eventId ?? reversalEventId,
              usedAt: nowAt
            },
            { path: "$" }
          );
          if (reversalEventRecord) {
            ops.push({
              kind: "X402_REVERSAL_EVENT_APPEND",
              tenantId,
              gateId,
              eventId: reversalEventRecord.eventId,
              event: reversalEventRecord
            });
          }
          ops.push({
            kind: "X402_REVERSAL_COMMAND_PUT",
            tenantId,
            commandId: commandUsageRecord.commandId,
            usage: commandUsageRecord
          });
          ops.push({
            kind: "X402_REVERSAL_NONCE_PUT",
            tenantId,
            sponsorRef: nonceUsageRecord.sponsorRef,
            nonce: nonceUsageRecord.nonce,
            usage: nonceUsageRecord
          });
          const reversalDerivedReceiptRecord =
            typeof store.deriveX402ReceiptRecord === "function"
              ? store.deriveX402ReceiptRecord({ tenantId, gate: nextGate, settlement: nextSettlement, includeReversalContext: false })
              : null;
          if (
            reversalDerivedReceiptRecord &&
            typeof reversalDerivedReceiptRecord.receiptId === "string" &&
            reversalDerivedReceiptRecord.receiptId.trim() !== ""
          ) {
            ops.push({
              kind: "X402_RECEIPT_PUT",
              tenantId,
              receiptId: reversalDerivedReceiptRecord.receiptId,
              receipt: reversalDerivedReceiptRecord
            });
          }

          const responseBody = {
            ok: true,
            action,
            gate: nextGate,
            settlement: nextSettlement,
            reversal: nextGate?.reversal ?? null,
            reversalEvent: reversalEventRecord,
            ...(kernelRefs?.decisionRecord ? { decisionRecord: kernelRefs.decisionRecord } : {}),
            ...(kernelRefs?.settlementReceipt ? { settlementReceipt: kernelRefs.settlementReceipt } : {})
          };
          if (idemStoreKey) {
            ops.push({ kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode: responseStatusCode, body: responseBody } });
          }
          if (ops.length > 0) await store.commitTx({ at: nowAt, ops });
          return sendJson(res, responseStatusCode, responseBody);
        }

        if (parts[0] === "x402" && parts[1] === "reversal-events" && parts.length === 2 && req.method === "GET") {
          if (typeof store.listX402ReversalEvents !== "function") {
            return sendError(res, 501, "x402 reversal events not supported for this store");
          }
          const gateId = typeof url.searchParams.get("gateId") === "string" && url.searchParams.get("gateId").trim() !== "" ? url.searchParams.get("gateId").trim() : null;
          const receiptId =
            typeof url.searchParams.get("receiptId") === "string" && url.searchParams.get("receiptId").trim() !== ""
              ? url.searchParams.get("receiptId").trim()
              : null;
          const action = typeof url.searchParams.get("action") === "string" && url.searchParams.get("action").trim() !== "" ? url.searchParams.get("action").trim() : null;
          const from = typeof url.searchParams.get("from") === "string" && url.searchParams.get("from").trim() !== "" ? url.searchParams.get("from").trim() : null;
          const to = typeof url.searchParams.get("to") === "string" && url.searchParams.get("to").trim() !== "" ? url.searchParams.get("to").trim() : null;
          const limitRaw = url.searchParams.get("limit");
          const offsetRaw = url.searchParams.get("offset");
          const limit = limitRaw ? Number(limitRaw) : 200;
          const offset = offsetRaw ? Number(offsetRaw) : 0;
          let events = [];
          try {
            events = await store.listX402ReversalEvents({ tenantId, gateId, receiptId, action, from, to, limit, offset });
          } catch (err) {
            return sendError(res, 400, "invalid reversal event query", { message: err?.message }, { code: "SCHEMA_INVALID" });
          }
          return sendJson(res, 200, { events, limit, offset });
        }

        if (parts[0] === "x402" && parts[1] === "reversal-events" && parts[2] && parts.length === 3 && req.method === "GET") {
          if (typeof store.getX402ReversalEvent !== "function") {
            return sendError(res, 501, "x402 reversal events not supported for this store");
          }
          const eventId = parts[2];
          let event = null;
          try {
            event = await store.getX402ReversalEvent({ tenantId, eventId });
          } catch (err) {
            return sendError(res, 400, "invalid reversal event id", { message: err?.message }, { code: "SCHEMA_INVALID" });
          }
          if (!event) return sendError(res, 404, "reversal event not found", null, { code: "NOT_FOUND" });
          return sendJson(res, 200, { event });
        }

	        if (parts[0] === "x402" && parts[1] === "gate" && parts[2] && parts.length === 3 && req.method === "GET") {
	          const gateId = parts[2];
	          const gate = typeof store.getX402Gate === "function" ? await store.getX402Gate({ tenantId, gateId }) : null;
	          if (!gate) return sendError(res, 404, "gate not found", null, { code: "NOT_FOUND" });
	          const runId = String(gate.runId ?? "");
	          const settlement = runId && typeof store.getAgentRunSettlement === "function" ? await store.getAgentRunSettlement({ tenantId, runId }) : null;
	          const holdbackRunId = String(gate?.holdback?.runId ?? gate?.decision?.holdbackRunId ?? "");
	          const holdbackSettlement =
	            holdbackRunId && typeof store.getAgentRunSettlement === "function"
	              ? await store.getAgentRunSettlement({ tenantId, runId: holdbackRunId })
	              : null;
	          return sendJson(res, 200, { ok: true, gate, settlement, holdbackSettlement });
	        }
      }

      if (req.method === "GET" && path === "/agents") {
        const status = url.searchParams.get("status");
        const capabilityFilterRaw = url.searchParams.get("capability");
        const capabilityFilter = capabilityFilterRaw && capabilityFilterRaw.trim() !== "" ? capabilityFilterRaw.trim() : null;
        const minTrustScoreRaw = url.searchParams.get("minTrustScore");
        const includeReputationRaw = url.searchParams.get("includeReputation");
        const includeReputation = includeReputationRaw !== null && ["1", "true", "yes", "on"].includes(String(includeReputationRaw).trim().toLowerCase());
        const reputationVersionRaw = url.searchParams.get("reputationVersion");
        const reputationWindowRaw = url.searchParams.get("reputationWindow");
        let reputationVersion = "v1";
        let reputationWindow = AGENT_REPUTATION_WINDOW.THIRTY_DAYS;
        try {
          reputationVersion = parseReputationVersion(reputationVersionRaw);
          reputationWindow = parseReputationWindow(reputationWindowRaw);
        } catch (err) {
          return sendError(res, 400, "invalid reputation query", { message: err?.message });
        }
        let minTrustScore = null;
        if (minTrustScoreRaw !== null) {
          const parsedMinTrustScore = Number(minTrustScoreRaw);
          if (!Number.isSafeInteger(parsedMinTrustScore) || parsedMinTrustScore < 0 || parsedMinTrustScore > 100) {
            return sendError(res, 400, "minTrustScore must be an integer within 0..100");
          }
          minTrustScore = parsedMinTrustScore;
        }
        const limitRaw = url.searchParams.get("limit");
        const offsetRaw = url.searchParams.get("offset");
        const limit = limitRaw ? Number(limitRaw) : 200;
        const offset = offsetRaw ? Number(offsetRaw) : 0;
        const safeLimit = Number.isSafeInteger(limit) && limit > 0 ? Math.min(1000, limit) : 200;
        const safeOffset = Number.isSafeInteger(offset) && offset >= 0 ? offset : 0;
        const requiresPostFilter = Boolean(capabilityFilter) || minTrustScore !== null || includeReputation;

        let agents;
        if (typeof store.listAgentIdentities === "function") {
          try {
            if (requiresPostFilter) agents = await store.listAgentIdentities({ tenantId, status: status ?? null, limit: 10_000, offset: 0 });
            else agents = await store.listAgentIdentities({ tenantId, status: status ?? null, limit: safeLimit, offset: safeOffset });
          } catch (err) {
            return sendError(res, 400, "invalid agent identity query", { message: err?.message });
          }
        } else if (store.agentIdentities instanceof Map) {
          const all = listAgentIdentities({ tenantId, status: status ?? null });
          agents = requiresPostFilter ? all : all.slice(safeOffset, safeOffset + safeLimit);
        } else {
          return sendError(res, 501, "agent identities not supported for this store");
        }

        const filteredAgents = capabilityFilter
          ? agents.filter((agentIdentity) => Array.isArray(agentIdentity?.capabilities) && agentIdentity.capabilities.includes(capabilityFilter))
          : agents;

        if (!includeReputation && minTrustScore === null) {
          if (requiresPostFilter) {
            const paged = filteredAgents.slice(safeOffset, safeOffset + safeLimit);
            return sendJson(res, 200, { agents: paged, limit: safeLimit, offset: safeOffset });
          }
          return sendJson(res, 200, { agents: filteredAgents, limit: safeLimit, offset: safeOffset });
        }

        const reputations = {};
        const scopedAgents = [];
        for (const agentIdentity of filteredAgents) {
          const agentId = String(agentIdentity?.agentId ?? "");
          if (!agentId) continue;
          const reputation = await computeAgentReputationSnapshotVersioned({
            tenantId,
            agentId,
            at: nowIso(),
            reputationVersion,
            reputationWindow
          });
          if (minTrustScore !== null && Number(reputation?.trustScore ?? 0) < minTrustScore) continue;
          scopedAgents.push(agentIdentity);
          if (includeReputation) reputations[agentId] = reputation;
        }

        const pagedAgents = scopedAgents.slice(safeOffset, safeOffset + safeLimit);
        const response = { agents: pagedAgents, limit: safeLimit, offset: safeOffset };
        if (includeReputation) {
          const pagedReputations = {};
          for (const agentIdentity of pagedAgents) {
            const id = String(agentIdentity?.agentId ?? "");
            if (!id) continue;
            if (reputations[id]) pagedReputations[id] = reputations[id];
          }
          response.reputations = pagedReputations;
        }
        return sendJson(res, 200, response);
      }

      if (req.method === "POST" && path === "/agents/register") {
        if (typeof store.putAgentIdentity !== "function") return sendError(res, 501, "agent identities not supported for this store");
        const body = await readJsonBody(req);
        let idemStoreKey = null;
        let idemRequestHash = null;
        try {
          ({ idemStoreKey, idemRequestHash } = readIdempotency({ method: "POST", requestPath: path, expectedPrevChainHash: null, body }));
        } catch (err) {
          return sendError(res, 400, "invalid idempotency key", { message: err?.message });
        }
        if (idemStoreKey) {
          const existing = store.idempotency.get(idemStoreKey);
          if (existing) {
            if (existing.requestHash !== idemRequestHash) {
              return sendError(res, 409, "idempotency key conflict", "request differs from initial use of this key");
            }
            return sendJson(res, existing.statusCode, existing.body);
          }
        }

        const publicKeyPem = body?.publicKeyPem ?? null;
        if (typeof publicKeyPem !== "string" || publicKeyPem.trim() === "") {
          return sendError(res, 400, "publicKeyPem is required");
        }

        const keyId = keyIdFromPublicKeyPem(publicKeyPem);
        const agentId = body?.agentId ? String(body.agentId) : createId("agt");
        const existingIdentity = typeof store.getAgentIdentity === "function" ? await store.getAgentIdentity({ tenantId, agentId }) : null;
        if (existingIdentity && !idemStoreKey) return sendError(res, 409, "agent identity already exists");

        const ownerBody = body?.owner && typeof body.owner === "object" && !Array.isArray(body.owner) ? body.owner : {};
        const ownerTypeRaw = ownerBody.ownerType ?? body?.ownerType ?? "service";
        const ownerIdRaw = ownerBody.ownerId ?? body?.ownerId ?? `tenant:${tenantId}`;
        const ownerType = String(ownerTypeRaw ?? "").trim().toLowerCase();
        const ownerId = String(ownerIdRaw ?? "").trim();
        if (ownerType !== "human" && ownerType !== "business" && ownerType !== "service") {
          return sendError(res, 400, "owner.ownerType must be human|business|service");
        }
        if (!ownerId) return sendError(res, 400, "owner.ownerId is required");

        const status = body?.status ? String(body.status).trim().toLowerCase() : "active";
        if (status !== "active" && status !== "suspended" && status !== "revoked") {
          return sendError(res, 400, "status must be active|suspended|revoked");
        }

        const capabilitiesRaw = Array.isArray(body?.capabilities) ? body.capabilities : [];
        const capabilities = [...new Set(capabilitiesRaw.map((value) => String(value ?? "").trim()).filter(Boolean))].sort((left, right) =>
          left.localeCompare(right)
        );

        const nowAt = nowIso();
        const candidate = {
          schemaVersion: "AgentIdentity.v1",
          agentId,
          tenantId,
          displayName:
            typeof body?.displayName === "string" && body.displayName.trim() !== "" ? String(body.displayName) : String(agentId),
          description: typeof body?.description === "string" && body.description.trim() !== "" ? String(body.description) : null,
          status,
          owner: { ownerType, ownerId },
          keys: {
            keyId,
            algorithm: "ed25519",
            publicKeyPem: String(publicKeyPem)
          },
          capabilities,
          walletPolicy: body?.walletPolicy ?? null,
          metadata: body?.metadata ?? null,
          createdAt: nowAt,
          updatedAt: nowAt
        };

        let persisted;
        try {
          persisted = await store.putAgentIdentity({ tenantId, agentIdentity: candidate });
        } catch (err) {
          if (err?.code === "AGENT_IDENTITY_EXISTS") return sendError(res, 409, "agent identity already exists");
          return sendError(res, 400, "invalid agent identity", { message: err?.message });
        }

        const responseBody = { agentIdentity: persisted, keyId };
        if (idemStoreKey) {
          await commitTx([{ kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode: 201, body: responseBody } }]);
        }
        return sendJson(res, 201, responseBody);
      }

      if (req.method === "GET" && path === "/robots") {
        return sendJson(res, 200, { robots: listRobots({ tenantId }) });
      }

      if (req.method === "POST" && path === "/robots/register") {
        const body = await readJsonBody(req);
        let idemStoreKey = null;
        let idemRequestHash = null;
        try {
          ({ idemStoreKey, idemRequestHash } = readIdempotency({ method: "POST", requestPath: path, expectedPrevChainHash: null, body }));
        } catch (err) {
          return sendError(res, 400, "invalid idempotency key", { message: err?.message });
        }
        if (idemStoreKey) {
          const existing = store.idempotency.get(idemStoreKey);
          if (existing) {
            if (existing.requestHash !== idemRequestHash) {
              return sendError(res, 409, "idempotency key conflict", "request differs from initial use of this key");
            }
            return sendJson(res, existing.statusCode, existing.body);
          }
        }

        const robotId = body?.robotId ?? createId("rob");
        const publicKeyPem = body?.publicKeyPem ?? null;

        let keyId = null;
        if (publicKeyPem) {
          keyId = keyIdFromPublicKeyPem(publicKeyPem);
        }

        if (store.robots.has(robotStoreKey(tenantId, robotId)) && !idemStoreKey) {
          return sendError(res, 409, "robot already exists");
        }

        const registeredEvent = createChainedEvent({
          streamId: robotId,
          type: "ROBOT_REGISTERED",
          actor: { type: "system", id: "proxy" },
          payload: {
            robotId,
            tenantId,
            ownerId: body?.ownerId ?? null,
            name: body?.name ?? null,
            capabilities: body?.capabilities ?? {},
            trustScore: body?.trustScore ?? 0.5,
            signerKeyId: keyId,
            homeZoneId: body?.homeZoneId ?? null,
            currentZoneId: body?.currentZoneId ?? null
          },
          at: nowIso()
        });

        const robotEvents = appendChainedEvent({ events: [], event: registeredEvent, signer: serverSigner });
        const robot = reduceRobot(robotEvents);
        if (!robot) return sendError(res, 500, "failed to register robot");

        const responseBody = { robot, keyId };
        const ops = [{ kind: "ROBOT_EVENTS_APPENDED", tenantId, robotId, events: robotEvents }];
        if (keyId && publicKeyPem) {
          ops.push({ kind: "PUBLIC_KEY_PUT", keyId, publicKeyPem });
          ops.push({
            kind: "SIGNER_KEY_UPSERT",
            tenantId,
            signerKey: { keyId, publicKeyPem, purpose: SIGNER_KEY_PURPOSE.ROBOT, status: SIGNER_KEY_STATUS.ACTIVE, description: `robot:${robotId}`, createdAt: registeredEvent.at }
          });
        }
        if (idemStoreKey) ops.push({ kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode: 201, body: responseBody } });

        await commitTx(ops);

        return sendJson(res, 201, responseBody);
      }

      if (req.method === "GET" && path === "/operators") {
        return sendJson(res, 200, { operators: listOperators({ tenantId }) });
      }

      if (req.method === "POST" && path === "/operators/register") {
        const body = await readJsonBody(req);
        let idemStoreKey = null;
        let idemRequestHash = null;
        try {
          ({ idemStoreKey, idemRequestHash } = readIdempotency({ method: "POST", requestPath: path, expectedPrevChainHash: null, body }));
        } catch (err) {
          return sendError(res, 400, "invalid idempotency key", { message: err?.message });
        }
        if (idemStoreKey) {
          const existing = store.idempotency.get(idemStoreKey);
          if (existing) {
            if (existing.requestHash !== idemRequestHash) {
              return sendError(res, 409, "idempotency key conflict", "request differs from initial use of this key");
            }
            return sendJson(res, existing.statusCode, existing.body);
          }
        }

        const operatorId = body?.operatorId ?? createId("op");
        const publicKeyPem = body?.publicKeyPem ?? null;
        if (!publicKeyPem) return sendError(res, 400, "publicKeyPem is required");

        const keyId = keyIdFromPublicKeyPem(publicKeyPem);

        if (store.operators.has(operatorStoreKey(tenantId, operatorId)) && !idemStoreKey) {
          return sendError(res, 409, "operator already exists");
        }

        const registeredEvent = createChainedEvent({
          streamId: operatorId,
          type: "OPERATOR_REGISTERED",
          actor: { type: "system", id: "proxy" },
          payload: {
            operatorId,
            tenantId,
            name: body?.name ?? null,
            signerKeyId: keyId
          },
          at: nowIso()
        });

        const operatorEvents = appendChainedEvent({ events: [], event: registeredEvent, signer: serverSigner });
        const operator = reduceOperator(operatorEvents);
        if (!operator) return sendError(res, 500, "failed to register operator");

        const responseBody = { operator, keyId };
        const ops = [
          { kind: "OPERATOR_EVENTS_APPENDED", tenantId, operatorId, events: operatorEvents },
          { kind: "PUBLIC_KEY_PUT", keyId, publicKeyPem },
          {
            kind: "SIGNER_KEY_UPSERT",
            tenantId,
            signerKey: { keyId, publicKeyPem, purpose: SIGNER_KEY_PURPOSE.OPERATOR, status: SIGNER_KEY_STATUS.ACTIVE, description: `operator:${operatorId}`, createdAt: registeredEvent.at }
          }
        ];
        if (idemStoreKey) ops.push({ kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode: 201, body: responseBody } });

        await commitTx(ops);

        return sendJson(res, 201, responseBody);
      }

      const parts = path.split("/").filter(Boolean);

      if (parts[0] === "outbox" && parts.length === 1 && req.method === "GET") {
        return sendJson(res, 200, { outbox: store.outbox });
      }

      if (parts[0] === "runs" && parts[1] && parts[2] === "verification" && parts.length === 3 && req.method === "GET") {
        const runId = parts[1];
        let run = null;
        if (typeof store.getAgentRun === "function") {
          try {
            run = await store.getAgentRun({ tenantId, runId });
          } catch (err) {
            return sendError(res, 400, "invalid run id", { message: err?.message });
          }
        } else if (store.agentRuns instanceof Map) {
          run = store.agentRuns.get(runStoreKey(tenantId, runId)) ?? null;
        } else {
          return sendError(res, 501, "agent runs not supported for this store");
        }
        if (!run) return sendError(res, 404, "run not found");

        let events = [];
        if (typeof store.getAgentRunEvents === "function") {
          events = await store.getAgentRunEvents({ tenantId, runId });
        } else if (store.agentRunEvents instanceof Map) {
          events = store.agentRunEvents.get(runStoreKey(tenantId, runId)) ?? [];
        }
        events = normalizeAgentRunEventRecords(events);

        const verification = computeAgentRunVerification({ run, events });
        return sendJson(res, 200, { runId, agentId: run.agentId ?? null, runStatus: run.status ?? null, verification });
      }

      if (parts[0] === "runs" && parts[1] && parts[2] === "settlement" && parts.length === 3 && req.method === "GET") {
        const runId = parts[1];
        let settlement = null;
        try {
          settlement = await getAgentRunSettlementRecord({ tenantId, runId });
        } catch (err) {
          return sendError(res, 501, "agent run settlements not supported for this store", { message: err?.message });
        }
        if (!settlement) return sendError(res, 404, "run settlement not found");
        return sendJson(res, 200, buildSettlementResponseBody(settlement));
      }

      if (parts[0] === "runs" && parts[1] && parts[2] === "arbitration" && parts[3] === "cases" && parts.length === 4 && req.method === "GET") {
        const runId = parts[1];
        let settlement = null;
        try {
          settlement = await getAgentRunSettlementRecord({ tenantId, runId });
        } catch (err) {
          return sendError(res, 501, "agent run settlements not supported for this store", { message: err?.message });
        }
        if (!settlement) return sendError(res, 404, "run settlement not found");
        const statusFilter = url.searchParams.get("status");
        let cases = [];
        try {
          cases = await listArbitrationCaseRecords({ tenantId, runId, status: statusFilter ?? null, limit: 500, offset: 0 });
        } catch (err) {
          return sendError(res, 501, "arbitration cases not supported for this store", { message: err?.message });
        }
        return sendJson(res, 200, { runId, cases });
      }

      if (parts[0] === "runs" && parts[1] && parts[2] === "arbitration" && parts[3] === "cases" && parts[4] && parts.length === 5 && req.method === "GET") {
        const runId = parts[1];
        const caseId = parts[4];
        let arbitrationCase = null;
        try {
          arbitrationCase = await getArbitrationCaseRecord({ tenantId, caseId });
        } catch (err) {
          return sendError(res, 501, "arbitration cases not supported for this store", { message: err?.message });
        }
        if (!arbitrationCase || String(arbitrationCase.runId ?? "") !== String(runId)) {
          return sendError(res, 404, "arbitration case not found");
        }
        return sendJson(res, 200, { runId, arbitrationCase });
      }

      // Tool-call arbitration cases (holdback disputes).
      if (parts[0] === "tool-calls" && parts[1] === "arbitration" && parts[2] === "cases" && parts.length === 3 && req.method === "GET") {
        const agreementHashRaw = url.searchParams.get("agreementHash");
        let agreementHash = null;
        try {
          agreementHash = normalizeSha256HashInput(agreementHashRaw, "agreementHash", { allowNull: false });
        } catch (err) {
          return sendError(res, 400, "invalid agreementHash", { message: err?.message }, { code: "SCHEMA_INVALID" });
        }
        const runId = `tc_${agreementHash}`;
        const statusFilter = url.searchParams.get("status");
        let cases = [];
        try {
          cases = await listArbitrationCaseRecords({ tenantId, runId, status: statusFilter ?? null, limit: 500, offset: 0 });
        } catch (err) {
          return sendError(res, 501, "arbitration cases not supported for this store", { message: err?.message });
        }
        const filtered = cases.filter((row) => {
          const meta = row?.metadata && typeof row.metadata === "object" && !Array.isArray(row.metadata) ? row.metadata : null;
          if (!meta) return false;
          if (String(meta.caseType ?? "").toLowerCase() !== "tool_call") return false;
          if (String(meta.agreementHash ?? "").toLowerCase() !== agreementHash) return false;
          return true;
        });
        return sendJson(res, 200, { agreementHash, runId, cases: filtered });
      }

      if (parts[0] === "tool-calls" && parts[1] === "arbitration" && parts[2] === "cases" && parts[3] && parts.length === 4 && req.method === "GET") {
        const caseId = parts[3];
        let arbitrationCase = null;
        try {
          arbitrationCase = await getArbitrationCaseRecord({ tenantId, caseId });
        } catch (err) {
          return sendError(res, 501, "arbitration cases not supported for this store", { message: err?.message });
        }
        const meta = arbitrationCase?.metadata && typeof arbitrationCase.metadata === "object" && !Array.isArray(arbitrationCase.metadata) ? arbitrationCase.metadata : null;
        if (!arbitrationCase || !meta || String(meta.caseType ?? "").toLowerCase() !== "tool_call") {
          return sendError(res, 404, "arbitration case not found");
        }
        return sendJson(res, 200, { caseId, arbitrationCase });
      }

      if (parts[0] === "tool-calls" && parts[1] === "arbitration" && parts[2] && parts.length === 3 && req.method === "POST") {
        if (!requireProtocolHeaderForWrite(req, res)) return;
        const action = parts[2];
        if (action !== "open" && action !== "verdict") return sendError(res, 404, "not found");

        const body = await readJsonBody(req);
        let idemStoreKey = null;
        let idemRequestHash = null;
        try {
          ({ idemStoreKey, idemRequestHash } = readIdempotency({ method: "POST", requestPath: path, expectedPrevChainHash: null, body }));
        } catch (err) {
          return sendError(res, 400, "invalid idempotency key", { message: err?.message });
        }
        if (idemStoreKey) {
          const existing = store.idempotency.get(idemStoreKey);
          if (existing) {
            if (existing.requestHash !== idemRequestHash) {
              return sendError(res, 409, "idempotency key conflict", "request differs from initial use of this key");
            }
            return sendJson(res, existing.statusCode, existing.body);
          }
        }

        const nowAt = nowIso();

        if (action === "open") {
          let agreementHash = null;
          let receiptHash = null;
          let holdHash = null;
          try {
            agreementHash = normalizeSha256HashInput(body?.agreementHash, "agreementHash", { allowNull: false });
            receiptHash = normalizeSha256HashInput(body?.receiptHash, "receiptHash", { allowNull: false });
            holdHash = normalizeSha256HashInput(body?.holdHash, "holdHash", { allowNull: false });
          } catch (err) {
            return sendError(res, 400, "invalid arbitration subject", { message: err?.message }, { code: "SCHEMA_INVALID" });
          }

          const override = body?.adminOverride && typeof body.adminOverride === "object" && !Array.isArray(body.adminOverride) ? body.adminOverride : null;
          const overrideEnabled = override?.enabled === true;
          const overrideReason =
            typeof override?.reason === "string" && override.reason.trim() !== "" ? override.reason.trim() : null;
          if (overrideEnabled) {
            if (!requireScope(auth.scopes, OPS_SCOPES.OPS_WRITE)) return sendError(res, 403, "forbidden");
            if (!overrideReason) return sendError(res, 400, "adminOverride.reason is required when override is enabled");
          }

          let hold = null;
          try {
            hold = await getToolCallHoldRecord({ tenantId, holdHash });
          } catch (err) {
            return sendError(res, 501, "tool call holds not supported for this store", { message: err?.message });
          }
          if (!hold) return sendError(res, 404, "funding hold not found");
          try {
            validateFundingHoldV1(hold);
          } catch (err) {
            return sendError(res, 409, "invalid funding hold", { message: err?.message }, { code: "HOLD_INVALID" });
          }
          if (String(hold.agreementHash ?? "").toLowerCase() !== agreementHash) {
            return sendError(res, 409, "hold agreementHash mismatch", null, { code: "TOOL_CALL_DISPUTE_BINDING_MISMATCH" });
          }
          if (String(hold.receiptHash ?? "").toLowerCase() !== receiptHash) {
            return sendError(res, 409, "hold receiptHash mismatch", null, { code: "TOOL_CALL_DISPUTE_BINDING_MISMATCH" });
          }
          if (String(hold.status ?? "").toLowerCase() !== FUNDING_HOLD_STATUS.HELD) {
            return sendError(res, 409, "hold is not active", { status: hold.status ?? null }, { code: "HOLD_NOT_ACTIVE" });
          }

          const createdAtMs = Date.parse(String(hold.createdAt ?? ""));
          const windowMs = Number(hold.challengeWindowMs ?? 0);
          const nowMs = Date.parse(nowAt);
          const withinWindow = Number.isFinite(createdAtMs) && Number.isFinite(nowMs) && nowMs <= createdAtMs + windowMs;
          if (!overrideEnabled && !withinWindow) {
            return sendError(res, 409, "challenge window closed", null, { code: "DISPUTE_WINDOW_EXPIRED" });
          }

          const defaultCaseId = `arb_case_tc_${agreementHash}`;
          const caseIdRaw = body?.caseId ?? null;
          const caseId =
            caseIdRaw === null || caseIdRaw === undefined || caseIdRaw === ""
              ? defaultCaseId
              : typeof caseIdRaw === "string" && caseIdRaw.trim() !== ""
                ? caseIdRaw.trim()
                : null;
          if (!caseId) return sendError(res, 400, "invalid caseId");
          if (caseId !== defaultCaseId) {
            return sendError(res, 409, "caseId must match deterministic tool-call case id", { expectedCaseId: defaultCaseId }, { code: "CASE_ID_NOT_DETERMINISTIC" });
          }

          let existingCase = null;
          try {
            existingCase = await getArbitrationCaseRecord({ tenantId, caseId });
          } catch (err) {
            return sendError(res, 501, "arbitration cases not supported for this store", { message: err?.message });
          }
          if (existingCase) {
            const existingCaseStatus = normalizeArbitrationCaseStatus(existingCase.status ?? ARBITRATION_CASE_STATUS.OPEN, {
              fieldName: "arbitrationCase.status"
            });
            if (existingCaseStatus !== ARBITRATION_CASE_STATUS.CLOSED) {
              return sendError(
                res,
                409,
                "an active dispute case already exists for this agreement",
                { caseId, status: existingCaseStatus },
                { code: "DISPUTE_ALREADY_OPEN" }
              );
            }
            const revisionRaw = Number(existingCase?.revision ?? 1);
            const revision = Number.isSafeInteger(revisionRaw) && revisionRaw > 0 ? revisionRaw : 1;
            const caseArtifactId = revision > 1 ? `arbitration_case_${caseId}_r${revision}` : `arbitration_case_${caseId}`;
            const existingMeta =
              existingCase?.metadata && typeof existingCase.metadata === "object" && !Array.isArray(existingCase.metadata)
                ? existingCase.metadata
                : null;
            const existingEnvelopeRef =
              existingMeta?.disputeOpenEnvelopeRef &&
              typeof existingMeta.disputeOpenEnvelopeRef === "object" &&
              !Array.isArray(existingMeta.disputeOpenEnvelopeRef)
                ? existingMeta.disputeOpenEnvelopeRef
                : null;
            const responseBody = {
              arbitrationCase: existingCase,
              arbitrationCaseArtifact: { artifactId: caseArtifactId },
              disputeOpenEnvelopeArtifact: existingEnvelopeRef?.artifactId
                ? {
                    artifactId: String(existingEnvelopeRef.artifactId),
                    artifactHash:
                      typeof existingEnvelopeRef.artifactHash === "string" && existingEnvelopeRef.artifactHash.trim() !== ""
                        ? existingEnvelopeRef.artifactHash
                        : null
                  }
                : null,
              alreadyExisted: true
            };
            if (idemStoreKey) {
              await commitTx([{ kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode: 200, body: responseBody } }]);
            }
            return sendJson(res, 200, responseBody);
          }

          const runId = `tc_${agreementHash}`;
          const disputeId = `disp_tc_${agreementHash}`;
          const settlementId = `setl_tc_${agreementHash}`;

          const disputeOpenEnvelopeRaw = body?.disputeOpenEnvelope;
          if (disputeOpenEnvelopeRaw !== undefined && disputeOpenEnvelopeRaw !== null && (typeof disputeOpenEnvelopeRaw !== "object" || Array.isArray(disputeOpenEnvelopeRaw))) {
            return sendError(res, 400, "invalid disputeOpenEnvelope", { message: "disputeOpenEnvelope must be an object" }, { code: "SCHEMA_INVALID" });
          }

          let disputeOpenEnvelope = null;
          if (disputeOpenEnvelopeRaw && typeof disputeOpenEnvelopeRaw === "object" && !Array.isArray(disputeOpenEnvelopeRaw)) {
            try {
              disputeOpenEnvelope = await parseSignedDisputeOpenEnvelope({
                tenantId,
                disputeOpenEnvelopeInput: disputeOpenEnvelopeRaw,
                expectedCaseId: defaultCaseId,
                expectedAgreementHash: agreementHash,
                expectedReceiptHash: receiptHash,
                expectedHoldHash: holdHash
              });
            } catch (err) {
              const message = String(err?.message ?? "");
              const signerIssue =
                /signature|signerkeyid|openedbyagentid|unknown signerkeyid|invalid disputeopenenvelope/i.test(message) ||
                /does not match openedbyagentid key/i.test(message);
              return sendError(
                res,
                signerIssue ? 409 : 400,
                "invalid disputeOpenEnvelope",
                { message },
                { code: signerIssue ? "DISPUTE_INVALID_SIGNER" : "SCHEMA_INVALID" }
              );
            }
          }
          if (!overrideEnabled && !disputeOpenEnvelope) {
            return sendError(
              res,
              400,
              "disputeOpenEnvelope is required for non-admin opens",
              null,
              { code: "SCHEMA_INVALID" }
            );
          }

          const openedByAgentIdBody =
            typeof body?.openedByAgentId === "string" && body.openedByAgentId.trim() !== "" ? body.openedByAgentId.trim() : null;
          if (disputeOpenEnvelope && openedByAgentIdBody && openedByAgentIdBody !== String(disputeOpenEnvelope.openedByAgentId)) {
            return sendError(res, 409, "openedByAgentId must match disputeOpenEnvelope.openedByAgentId", null, {
              code: "DISPUTE_INVALID_SIGNER"
            });
          }
          const openedByAgentId = String(disputeOpenEnvelope?.openedByAgentId ?? openedByAgentIdBody ?? hold.payerAgentId ?? "");
          if (!openedByAgentId) return sendError(res, 400, "openedByAgentId is required");
          if (!overrideEnabled && openedByAgentId !== hold.payerAgentId && openedByAgentId !== hold.payeeAgentId) {
            return sendError(res, 409, "openedByAgentId must be a hold party", null, { code: "DISPUTE_INVALID_SIGNER" });
          }
          const claimantAgentId = openedByAgentId;
          const respondentAgentId =
            openedByAgentId === hold.payerAgentId ? String(hold.payeeAgentId) : String(hold.payerAgentId);
          if (!respondentAgentId || respondentAgentId === claimantAgentId) {
            return sendError(res, 409, "invalid hold counterparties");
          }

          let evidenceRefs = [];
          try {
            evidenceRefs = normalizeArbitrationCaseEvidenceRefs(Array.isArray(body?.evidenceRefs) ? body.evidenceRefs : [], { fieldName: "evidenceRefs" });
          } catch (err) {
            return sendError(res, 400, "invalid evidenceRefs", { message: err?.message }, { code: "SCHEMA_INVALID" });
          }

          let assignment = null;
          let arbiterAgentId = null;
          try {
            arbiterAgentId =
              typeof body?.arbiterAgentId === "string" && body.arbiterAgentId.trim() !== "" ? body.arbiterAgentId.trim() : null;
          } catch {}
          if (arbiterAgentId) {
            const arbiterIdentity = await getAgentIdentityRecord({ tenantId, agentId: arbiterAgentId });
            if (!arbiterIdentity) return sendError(res, 404, "arbiterAgentId not found");
          } else if (Array.isArray(body?.panelCandidateAgentIds) && body.panelCandidateAgentIds.length > 0) {
            try {
              assignment = await assignDeterministicArbiterAgentId({
                tenantId,
                runId,
                disputeId,
                panelCandidateAgentIds: body.panelCandidateAgentIds
              });
            } catch (err) {
              return sendError(res, 400, "invalid arbitration panel assignment", { message: err?.message });
            }
            arbiterAgentId = assignment.arbiterAgentId;
          }
          if (!arbiterAgentId) return sendError(res, 400, "arbiterAgentId or panelCandidateAgentIds is required");

          const summary = typeof body?.summary === "string" && body.summary.trim() !== "" ? body.summary.trim() : null;
          if (!summary) return sendError(res, 400, "summary is required");

          const arbitrationCase = normalizeForCanonicalJson(
            {
              schemaVersion: "ArbitrationCase.v1",
              caseId,
              tenantId: normalizeTenant(tenantId),
              runId,
              settlementId,
              disputeId,
              claimantAgentId,
              respondentAgentId,
              arbiterAgentId,
              priority: AGENT_RUN_SETTLEMENT_DISPUTE_PRIORITY.NORMAL,
              status: ARBITRATION_CASE_STATUS.UNDER_REVIEW,
              openedAt: nowAt,
              closedAt: null,
              summary,
              evidenceRefs,
              appealRef: null,
              metadata: {
                caseType: "tool_call",
                agreementHash,
                receiptHash,
                holdHash,
                override: overrideEnabled ? { enabled: true, reason: overrideReason, openedByPrincipalId: principalId } : { enabled: false },
                ...(disputeOpenEnvelope
                  ? {
                      disputeOpenEnvelopeRef: {
                        artifactId: String(disputeOpenEnvelope.artifactId),
                        envelopeHash: String(disputeOpenEnvelope.envelopeHash ?? ""),
                        signerKeyId: String(disputeOpenEnvelope.signerKeyId ?? ""),
                        openedByAgentId: String(disputeOpenEnvelope.openedByAgentId ?? ""),
                        openedAt: String(disputeOpenEnvelope.openedAt ?? nowAt),
                        reasonCode: String(disputeOpenEnvelope.reasonCode ?? ""),
                        nonce: String(disputeOpenEnvelope.nonce ?? "")
                      }
                    }
                  : null),
                ...(assignment
                  ? {
                      assignmentHash: assignment.assignmentHash,
                      panelCandidateAgentIds: assignment.panelCandidateAgentIds
                    }
                  : null)
              },
              revision: 1,
              createdAt: nowAt,
              updatedAt: nowAt
            },
            { path: "$" }
          );

          const responseBody = { arbitrationCase, arbitrationCaseArtifact: null, disputeOpenEnvelopeArtifact: null };
          const ops = [{ kind: "ARBITRATION_CASE_UPSERT", tenantId, caseId, arbitrationCase }];
          if (idemStoreKey) {
            ops.push({ kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode: 201, body: responseBody } });
          }
          await commitTx(ops);
          let arbitrationCaseArtifact = null;
          let disputeOpenEnvelopeArtifact = null;
          try {
            arbitrationCaseArtifact = await emitArbitrationCaseArtifact({
              tenantId,
              runId,
              settlement: { settlementId, payerAgentId: hold.payerAgentId, agentId: hold.payeeAgentId, currency: hold.currency, disputeId },
              arbitrationVerdict: null,
              arbitrationCase,
              at: nowAt
            });
          } catch {
            arbitrationCaseArtifact = null;
          }
          if (disputeOpenEnvelope) {
            try {
              disputeOpenEnvelopeArtifact = await emitDisputeOpenEnvelopeArtifact({
                tenantId,
                runId,
                settlement: { settlementId, payerAgentId: hold.payerAgentId, agentId: hold.payeeAgentId, currency: hold.currency, disputeId },
                disputeOpenEnvelope
              });
            } catch {
              disputeOpenEnvelopeArtifact = null;
            }
          }
          await emitReputationEventBestEffort(
            {
              tenantId,
              eventId: `rep_dsp_${agreementHash}`,
              occurredAt: nowAt,
              eventKind: REPUTATION_EVENT_KIND.DISPUTE_OPENED,
              subject: {
                agentId: String(hold.payeeAgentId),
                toolId: "tool_call",
                counterpartyAgentId: String(hold.payerAgentId),
                role: "payee"
              },
              sourceRef: {
                kind: "arbitration_case",
                artifactId: arbitrationCaseArtifact?.artifactId ?? `arbitration_case_${caseId}`,
                hash: arbitrationCaseArtifact?.artifactHash ?? computeArtifactHash(arbitrationCase),
                agreementHash,
                receiptHash,
                holdHash,
                runId,
                settlementId,
                disputeId,
                caseId
              },
              facts: {
                openedByAgentId,
                openedByRole:
                  openedByAgentId === String(hold.payerAgentId)
                    ? "payer"
                    : openedByAgentId === String(hold.payeeAgentId)
                      ? "payee"
                      : "admin",
                adminOverride: overrideEnabled,
                amountCents: Number(hold.amountCents ?? 0),
                heldAmountCents: Number(hold.heldAmountCents ?? 0),
                challengeWindowMs: Number(hold.challengeWindowMs ?? 0)
              }
            },
            { context: "tool_call_dispute.opened" }
          );
          return sendJson(res, 201, { ...responseBody, arbitrationCaseArtifact, disputeOpenEnvelopeArtifact });
        }

        if (action === "verdict") {
          const caseId = typeof body?.caseId === "string" && body.caseId.trim() !== "" ? body.caseId.trim() : null;
          if (!caseId) return sendError(res, 400, "caseId is required");

          let arbitrationCase = null;
          try {
            arbitrationCase = await getArbitrationCaseRecord({ tenantId, caseId });
          } catch (err) {
            return sendError(res, 501, "arbitration cases not supported for this store", { message: err?.message });
          }
          const meta = arbitrationCase?.metadata && typeof arbitrationCase.metadata === "object" && !Array.isArray(arbitrationCase.metadata) ? arbitrationCase.metadata : null;
          if (!arbitrationCase || !meta || String(meta.caseType ?? "").toLowerCase() !== "tool_call") {
            return sendError(res, 404, "arbitration case not found");
          }

          const agreementHash = normalizeSha256HashInput(meta.agreementHash, "metadata.agreementHash", { allowNull: false });
          const receiptHash = normalizeSha256HashInput(meta.receiptHash, "metadata.receiptHash", { allowNull: false });
          const holdHash = normalizeSha256HashInput(meta.holdHash, "metadata.holdHash", { allowNull: false });

          const adjustmentId = `sadj_agmt_${agreementHash}_holdback`;
          let existingAdjustment = null;
          try {
            existingAdjustment = await getSettlementAdjustmentRecord({ tenantId, adjustmentId });
          } catch (err) {
            return sendError(res, 501, "settlement adjustments not supported for this store", { message: err?.message });
          }
          if (existingAdjustment) {
            const revisionRaw = Number(arbitrationCase?.revision ?? 1);
            const revision = Number.isSafeInteger(revisionRaw) && revisionRaw > 0 ? revisionRaw : 1;
            const caseArtifactId = revision > 1 ? `arbitration_case_${caseId}_r${revision}` : `arbitration_case_${caseId}`;
            const verdictId =
              typeof arbitrationCase?.verdictId === "string" && arbitrationCase.verdictId.trim() !== ""
                ? arbitrationCase.verdictId.trim()
                : null;
            const verdictArtifactId = verdictId ? `arbitration_verdict_${verdictId}` : null;
            const responseBody = {
              arbitrationCase,
              arbitrationVerdict: null,
              settlementAdjustment: existingAdjustment,
              arbitrationCaseArtifact: { artifactId: caseArtifactId },
              arbitrationVerdictArtifact: verdictArtifactId ? { artifactId: verdictArtifactId } : null,
              alreadyExisted: true
            };
            if (idemStoreKey) {
              await commitTx([{ kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode: 200, body: responseBody } }]);
            }
            return sendJson(res, 200, responseBody);
          }

          let hold = null;
          try {
            hold = await getToolCallHoldRecord({ tenantId, holdHash });
          } catch (err) {
            return sendError(res, 501, "tool call holds not supported for this store", { message: err?.message });
          }
          if (!hold) return sendError(res, 404, "funding hold not found");
          try {
            validateFundingHoldV1(hold);
          } catch (err) {
            return sendError(res, 409, "invalid funding hold", { message: err?.message }, { code: "HOLD_INVALID" });
          }
          if (String(hold.status ?? "").toLowerCase() !== FUNDING_HOLD_STATUS.HELD) {
            return sendError(res, 409, "hold is not active", { status: hold.status ?? null }, { code: "HOLD_NOT_ACTIVE" });
          }

          const currentStatus = normalizeArbitrationCaseStatus(arbitrationCase.status);
          if (currentStatus !== ARBITRATION_CASE_STATUS.OPEN && currentStatus !== ARBITRATION_CASE_STATUS.UNDER_REVIEW) {
            return sendError(res, 409, "arbitration case cannot accept verdict in current status");
          }

          let signedArbitrationVerdict = null;
          try {
            signedArbitrationVerdict = await parseSignedArbitrationVerdict({
              tenantId,
              runId: arbitrationCase.runId,
              settlement: { settlementId: arbitrationCase.settlementId, payerAgentId: hold.payerAgentId, agentId: hold.payeeAgentId, currency: hold.currency },
              disputeId: arbitrationCase.disputeId,
              arbitrationVerdictInput: body?.arbitrationVerdict
            });
            if (String(signedArbitrationVerdict.caseId ?? "") !== String(caseId)) {
              throw new TypeError("arbitrationVerdict.caseId must match caseId");
            }
            assertArbitrationVerdictEvidenceBoundToCase({ arbitrationCase, arbitrationVerdict: signedArbitrationVerdict });
          } catch (err) {
            return sendError(res, 400, "invalid arbitration verdict", { message: err?.message });
          }
          const releaseRatePct = Number(signedArbitrationVerdict.releaseRatePct);
          if (releaseRatePct !== 0 && releaseRatePct !== 100) {
            return sendError(res, 409, "tool-call verdict must be binary (releaseRatePct 0 or 100)", null, { code: "TOOL_CALL_VERDICT_NOT_BINARY" });
          }

          const kind =
            releaseRatePct === 100 ? SETTLEMENT_ADJUSTMENT_KIND.HOLDBACK_RELEASE : SETTLEMENT_ADJUSTMENT_KIND.HOLDBACK_REFUND;
          const heldAmountCents = Number(hold.heldAmountCents ?? 0);
          if (!Number.isSafeInteger(heldAmountCents) || heldAmountCents < 0) {
            return sendError(res, 409, "invalid hold heldAmountCents", null, { code: "HOLD_INVALID" });
          }

          const adjustment = buildSettlementAdjustmentV1({
            adjustmentId,
            tenantId,
            agreementHash,
            receiptHash,
            holdHash,
            kind,
            amountCents: heldAmountCents,
            currency: hold.currency,
            createdAt: signedArbitrationVerdict.issuedAt ?? nowAt,
            verdictRef: { caseId, verdictHash: signedArbitrationVerdict.verdictHash },
            metadata: { openedByCaseId: caseId }
          });
          try {
            validateSettlementAdjustmentV1(adjustment);
          } catch (err) {
            return sendError(res, 409, "invalid settlement adjustment", { message: err?.message }, { code: "ADJUSTMENT_INVALID" });
          }

          let payerWalletExisting = null;
          let payeeWalletExisting = null;
          try {
            payerWalletExisting = await getAgentWalletRecord({ tenantId, agentId: hold.payerAgentId });
            payeeWalletExisting = await getAgentWalletRecord({ tenantId, agentId: hold.payeeAgentId });
          } catch (err) {
            return sendError(res, 400, "invalid wallet query", { message: err?.message });
          }
          const payerWallet = ensureAgentWallet({ wallet: payerWalletExisting, tenantId, agentId: hold.payerAgentId, currency: hold.currency, at: nowAt });
          const payeeWallet = ensureAgentWallet({ wallet: payeeWalletExisting, tenantId, agentId: hold.payeeAgentId, currency: hold.currency, at: nowAt });

          let nextPayerWallet = payerWallet;
          let nextPayeeWallet = payeeWallet;
          try {
            if (heldAmountCents > 0) {
              if (kind === SETTLEMENT_ADJUSTMENT_KIND.HOLDBACK_RELEASE) {
                const released = releaseAgentWalletEscrowToPayee({ payerWallet, payeeWallet, amountCents: heldAmountCents, at: nowAt });
                nextPayerWallet = released.payerWallet;
                nextPayeeWallet = released.payeeWallet;
                projectEscrowLedgerOperation({
                  tenantId,
                  settlement: { currency: hold.currency, payerAgentId: hold.payerAgentId, agentId: hold.payeeAgentId },
                  operationId: `escrow_release_${adjustmentId}`,
                  type: ESCROW_OPERATION_TYPE.RELEASE,
                  amountCents: heldAmountCents,
                  at: nowAt,
                  payerWalletBefore: payerWallet,
                  payerWalletAfter: nextPayerWallet,
                  payeeWalletBefore: payeeWallet,
                  payeeWalletAfter: nextPayeeWallet,
                  memo: `tool_call:${agreementHash}:holdback_release`
                });
              } else {
                const refunded = refundAgentWalletEscrow({ wallet: payerWallet, amountCents: heldAmountCents, at: nowAt });
                nextPayerWallet = refunded;
                projectEscrowLedgerOperation({
                  tenantId,
                  settlement: { currency: hold.currency, payerAgentId: hold.payerAgentId, agentId: hold.payeeAgentId },
                  operationId: `escrow_forfeit_${adjustmentId}`,
                  type: ESCROW_OPERATION_TYPE.FORFEIT,
                  amountCents: heldAmountCents,
                  at: nowAt,
                  payerWalletBefore: payerWallet,
                  payerWalletAfter: nextPayerWallet,
                  memo: `tool_call:${agreementHash}:holdback_refund`
                });
              }
            }
          } catch (err) {
            return sendError(res, 409, "escrow operation rejected", { message: err?.message, code: err?.code ?? null }, { code: err?.code ?? "ESCROW_OPERATION_REJECTED" });
          }

          const resolvedHold = resolveFundingHoldV1({
            hold,
            status: kind === SETTLEMENT_ADJUSTMENT_KIND.HOLDBACK_RELEASE ? FUNDING_HOLD_STATUS.RELEASED : FUNDING_HOLD_STATUS.REFUNDED,
            resolvedAt: nowAt,
            metadata: { adjustmentId, verdictHash: signedArbitrationVerdict.verdictHash, caseId }
          });

          const nextCase = normalizeForCanonicalJson(
            {
              ...arbitrationCase,
              verdictId: signedArbitrationVerdict.verdictId,
              verdictHash: signedArbitrationVerdict.verdictHash,
              status: ARBITRATION_CASE_STATUS.CLOSED,
              closedAt: nowAt,
              metadata: {
                ...(meta ?? {}),
                adjustmentId,
                verdictHash: signedArbitrationVerdict.verdictHash
              },
              revision: Number(arbitrationCase.revision ?? 0) + 1,
              updatedAt: nowAt
            },
            { path: "$" }
          );

          const ops = [
            { kind: "SETTLEMENT_ADJUSTMENT_PUT", tenantId, adjustmentId, adjustment },
            { kind: "AGENT_WALLET_UPSERT", tenantId, wallet: nextPayerWallet },
            ...(kind === SETTLEMENT_ADJUSTMENT_KIND.HOLDBACK_RELEASE ? [{ kind: "AGENT_WALLET_UPSERT", tenantId, wallet: nextPayeeWallet }] : []),
            { kind: "TOOL_CALL_HOLD_UPSERT", tenantId, holdHash: resolvedHold.holdHash, hold: resolvedHold },
            { kind: "ARBITRATION_CASE_UPSERT", tenantId, caseId, arbitrationCase: nextCase }
          ];
          const responseBody = {
            arbitrationCase: nextCase,
            arbitrationVerdict: signedArbitrationVerdict,
            settlementAdjustment: adjustment
          };
          if (idemStoreKey) {
            ops.push({ kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode: 200, body: responseBody } });
          }
          try {
            await commitTx(ops);
          } catch (err) {
            if (err?.code === "ADJUSTMENT_ALREADY_EXISTS") {
              const existing = await getSettlementAdjustmentRecord({ tenantId, adjustmentId });
              const revisionRaw = Number(nextCase?.revision ?? 1);
              const revision = Number.isSafeInteger(revisionRaw) && revisionRaw > 0 ? revisionRaw : 1;
              const caseArtifactId = revision > 1 ? `arbitration_case_${caseId}_r${revision}` : `arbitration_case_${caseId}`;
              const verdictId =
                typeof signedArbitrationVerdict?.verdictId === "string" && signedArbitrationVerdict.verdictId.trim() !== ""
                  ? signedArbitrationVerdict.verdictId.trim()
                  : null;
              const verdictArtifactId = verdictId ? `arbitration_verdict_${verdictId}` : null;
              return sendJson(res, 200, {
                arbitrationCase: nextCase,
                arbitrationVerdict: signedArbitrationVerdict,
                settlementAdjustment: existing,
                arbitrationCaseArtifact: { artifactId: caseArtifactId },
                arbitrationVerdictArtifact: verdictArtifactId ? { artifactId: verdictArtifactId } : null,
                alreadyExisted: true
              });
            }
            throw err;
          }
          let arbitrationCaseArtifact = null;
          let arbitrationVerdictArtifact = null;
          try {
            arbitrationCaseArtifact = await emitArbitrationCaseArtifact({
              tenantId,
              runId: arbitrationCase.runId,
              settlement: { settlementId: arbitrationCase.settlementId, payerAgentId: hold.payerAgentId, agentId: hold.payeeAgentId, currency: hold.currency, disputeId: arbitrationCase.disputeId },
              arbitrationVerdict: signedArbitrationVerdict,
              arbitrationCase: nextCase,
              at: nowAt
            });
          } catch {
            arbitrationCaseArtifact = null;
          }
          try {
            arbitrationVerdictArtifact = await emitArbitrationVerdictArtifact({
              tenantId,
              runId: arbitrationCase.runId,
              settlement: { settlementId: arbitrationCase.settlementId, payerAgentId: hold.payerAgentId, agentId: hold.payeeAgentId, currency: hold.currency, disputeId: arbitrationCase.disputeId },
              arbitrationVerdict: signedArbitrationVerdict
            });
          } catch {
            arbitrationVerdictArtifact = null;
          }
          const verdictOutcome =
            releaseRatePct === 100
              ? "payee_win"
              : releaseRatePct === 0
                ? "payer_win"
                : "partial";
          await emitReputationEventBestEffort(
            {
              tenantId,
              eventId: `rep_vrd_${String(signedArbitrationVerdict.verdictHash ?? "").toLowerCase()}`,
              occurredAt: String(signedArbitrationVerdict.issuedAt ?? nowAt),
              eventKind: REPUTATION_EVENT_KIND.VERDICT_ISSUED,
              subject: {
                agentId: String(hold.payeeAgentId),
                toolId: "tool_call",
                counterpartyAgentId: String(hold.payerAgentId),
                role: "payee"
              },
              sourceRef: {
                kind: "arbitration_verdict",
                artifactId: arbitrationVerdictArtifact?.artifactId ?? `arbitration_verdict_${signedArbitrationVerdict.verdictId}`,
                hash: arbitrationVerdictArtifact?.artifactHash ?? computeArtifactHash(signedArbitrationVerdict),
                verdictHash: signedArbitrationVerdict.verdictHash ?? null,
                agreementHash,
                receiptHash,
                holdHash,
                runId: arbitrationCase.runId,
                settlementId: arbitrationCase.settlementId,
                disputeId: arbitrationCase.disputeId,
                caseId
              },
              facts: {
                verdictOutcome,
                releaseRatePct,
                amountCents: heldAmountCents
              }
            },
            { context: "tool_call_dispute.verdict_issued" }
          );
          await emitReputationEventBestEffort(
            {
              tenantId,
              eventId: `rep_adj_${adjustmentId}`,
              occurredAt: nowAt,
              eventKind: REPUTATION_EVENT_KIND.ADJUSTMENT_APPLIED,
              subject: {
                agentId: String(hold.payeeAgentId),
                toolId: "tool_call",
                counterpartyAgentId: String(hold.payerAgentId),
                role: "payee"
              },
              sourceRef: {
                kind: "settlement_adjustment",
                sourceId: adjustmentId,
                hash: adjustment.adjustmentHash,
                agreementHash,
                receiptHash,
                holdHash,
                settlementId: arbitrationCase.settlementId,
                disputeId: arbitrationCase.disputeId,
                caseId,
                adjustmentId
              },
              facts: {
                adjustmentKind: kind,
                amountCents: heldAmountCents,
                amountSettledCents: kind === SETTLEMENT_ADJUSTMENT_KIND.HOLDBACK_RELEASE ? heldAmountCents : 0,
                amountRefundedCents: kind === SETTLEMENT_ADJUSTMENT_KIND.HOLDBACK_REFUND ? heldAmountCents : 0
              }
            },
            { context: "tool_call_dispute.adjustment_applied" }
          );

          return sendJson(res, 200, { ...responseBody, arbitrationCaseArtifact, arbitrationVerdictArtifact });
        }
      }

      if (parts[0] === "runs" && parts[1] && parts[2] === "agreement" && parts.length === 3 && req.method === "GET") {
        const runId = parts[1];
        const linkedTask = findMarketplaceRfqByRunId({ tenantId, runId });
        if (!linkedTask) return sendError(res, 404, "run has no linked marketplace rfq");
        const agreement = linkedTask?.agreement ?? null;
        if (!agreement || typeof agreement !== "object" || Array.isArray(agreement)) {
          return sendError(res, 404, "run has no marketplace agreement");
        }
        const agreementPolicyMaterial = resolveAgreementPolicyMaterial({ tenantId, agreement });
        const policyBindingVerification = await verifyMarketplaceAgreementPolicyBinding({ tenantId, agreement });
        const acceptanceSignatureVerification = await verifyMarketplaceAgreementAcceptanceSignature({ tenantId, agreement });
        let settlement = null;
        try {
          settlement = await getAgentRunSettlementRecord({ tenantId, runId });
        } catch {
          settlement = null;
        }
        const settlementArtifacts = settlement ? buildSettlementResponseBody(settlement) : {
          settlement: null,
          decisionRecord: null,
          settlementReceipt: null,
          kernelVerification: null
        };
        return sendJson(res, 200, {
          runId,
          rfqId: linkedTask?.rfqId ?? null,
          agreementId: agreement?.agreementId ?? null,
          agreement,
          offer: agreement?.offer ?? null,
          offerAcceptance: agreement?.offerAcceptance ?? null,
          policyRef: agreementPolicyMaterial.policyRef ?? null,
          policyHash: agreementPolicyMaterial.policyHash ?? null,
          verificationMethodHash: agreementPolicyMaterial.verificationMethodHash ?? null,
          policyBindingVerification,
          acceptanceSignatureVerification,
          settlement: settlementArtifacts.settlement,
          decisionRecord: settlementArtifacts.decisionRecord,
          settlementReceipt: settlementArtifacts.settlementReceipt,
          kernelVerification: settlementArtifacts.kernelVerification
        });
      }

      if (parts[0] === "runs" && parts[1] && parts[2] === "agreement" && parts[3] === "change-order" && parts.length === 4 && req.method === "POST") {
        if (!requireProtocolHeaderForWrite(req, res)) return;
        const runId = parts[1];
        const body = await readJsonBody(req);

        let idemStoreKey = null;
        let idemRequestHash = null;
        try {
          ({ idemStoreKey, idemRequestHash } = readIdempotency({ method: "POST", requestPath: path, expectedPrevChainHash: null, body }));
        } catch (err) {
          return sendError(res, 400, "invalid idempotency key", { message: err?.message });
        }
        if (idemStoreKey) {
          const existing = store.idempotency.get(idemStoreKey);
          if (existing) {
            if (existing.requestHash !== idemRequestHash) {
              return sendError(res, 409, "idempotency key conflict", "request differs from initial use of this key");
            }
            return sendJson(res, existing.statusCode, existing.body);
          }
        }

        const linkedTask = findMarketplaceRfqByRunId({ tenantId, runId });
        if (!linkedTask) return sendError(res, 404, "run has no linked marketplace rfq");
        const agreement = linkedTask?.agreement ?? null;
        if (!agreement || typeof agreement !== "object" || Array.isArray(agreement)) {
          return sendError(res, 404, "run has no marketplace agreement");
        }

        let run = null;
        if (typeof store.getAgentRun === "function") {
          run = await store.getAgentRun({ tenantId, runId });
        } else if (store.agentRuns instanceof Map) {
          run = store.agentRuns.get(runStoreKey(tenantId, runId)) ?? null;
        }
        if (!run) return sendError(res, 404, "run not found");
        if (run.status === "completed" || run.status === "failed") {
          return sendError(res, 409, "cannot apply change order to terminal runs");
        }

        let settlement = null;
        try {
          settlement = await getAgentRunSettlementRecord({ tenantId, runId });
        } catch (err) {
          return sendError(res, 501, "agent run settlements not supported for this store", { message: err?.message });
        }
        if (!settlement) return sendError(res, 404, "run settlement not found");
        if (settlement.status !== AGENT_RUN_SETTLEMENT_STATUS.LOCKED) {
          return sendError(res, 409, "change order can only be applied while settlement is locked");
        }

        const terms = agreement?.terms && typeof agreement.terms === "object" && !Array.isArray(agreement.terms)
          ? agreement.terms
          : {};
        const changeOrderPolicy = normalizeAgreementChangeOrderPolicyInput(terms?.changeOrderPolicy);
        if (changeOrderPolicy.enabled !== true) {
          return sendError(res, 409, "agreement does not allow change orders");
        }
        const agreementPayerAgentId =
          typeof agreement?.payerAgentId === "string" && agreement.payerAgentId.trim() !== ""
            ? agreement.payerAgentId.trim()
            : null;
        const agreementPayeeAgentId =
          typeof agreement?.payeeAgentId === "string" && agreement.payeeAgentId.trim() !== ""
            ? agreement.payeeAgentId.trim()
            : null;
        if (!agreementPayerAgentId || !agreementPayeeAgentId || agreementPayerAgentId === agreementPayeeAgentId) {
          return sendError(res, 409, "marketplace agreement counterparties are invalid");
        }

        const requestedByAgentId =
          typeof body?.requestedByAgentId === "string" && body.requestedByAgentId.trim() !== ""
            ? body.requestedByAgentId.trim()
            : null;
        if (!requestedByAgentId) return sendError(res, 400, "requestedByAgentId is required");
        if (requestedByAgentId !== agreementPayerAgentId && requestedByAgentId !== agreementPayeeAgentId) {
          return sendError(res, 409, "requestedByAgentId must be a marketplace agreement counterparty");
        }
        const acceptedByAgentId =
          typeof body?.acceptedByAgentId === "string" && body.acceptedByAgentId.trim() !== ""
            ? body.acceptedByAgentId.trim()
            : null;
        const acceptanceSignatureInput =
          body?.acceptanceSignature && typeof body.acceptanceSignature === "object" && !Array.isArray(body.acceptanceSignature)
            ? body.acceptanceSignature
            : null;
        if (body?.acceptanceSignature !== undefined && acceptanceSignatureInput === null) {
          return sendError(res, 400, "acceptanceSignature must be an object");
        }
        if (changeOrderPolicy.requireCounterpartyAcceptance === true && !acceptedByAgentId) {
          return sendError(res, 400, "acceptedByAgentId is required by agreement change order policy");
        }
        if (acceptanceSignatureInput && !acceptedByAgentId) {
          return sendError(res, 400, "acceptedByAgentId is required when acceptanceSignature is provided");
        }
        if (acceptedByAgentId) {
          if (acceptedByAgentId === requestedByAgentId) {
            return sendError(res, 409, "acceptedByAgentId must differ from requestedByAgentId");
          }
          if (acceptedByAgentId !== agreementPayerAgentId && acceptedByAgentId !== agreementPayeeAgentId) {
            return sendError(res, 409, "acceptedByAgentId must be a marketplace agreement counterparty");
          }
        }
        let requesterIdentity = null;
        try {
          requesterIdentity = await getAgentIdentityRecord({ tenantId, agentId: requestedByAgentId });
        } catch (err) {
          return sendError(res, 400, "invalid requestedByAgentId", { message: err?.message });
        }
        if (!requesterIdentity) return sendError(res, 404, "requesting agent identity not found");
        let accepterIdentity = null;
        if (acceptedByAgentId) {
          try {
            accepterIdentity = await getAgentIdentityRecord({ tenantId, agentId: acceptedByAgentId });
          } catch (err) {
            return sendError(res, 400, "invalid acceptedByAgentId", { message: err?.message });
          }
          if (!accepterIdentity) return sendError(res, 404, "accepting agent identity not found");
        }

        const reason = typeof body?.reason === "string" && body.reason.trim() !== "" ? body.reason.trim() : null;
        if (!reason) return sendError(res, 400, "reason is required");
        const changeOrderIdRaw = body?.changeOrderId ?? createId("chg");
        const changeOrderId = typeof changeOrderIdRaw === "string" && changeOrderIdRaw.trim() !== "" ? changeOrderIdRaw.trim() : null;
        if (!changeOrderId) return sendError(res, 400, "changeOrderId must be a non-empty string");

        const existingChangeOrders = Array.isArray(terms?.changeOrders)
          ? terms.changeOrders.filter((row) => row && typeof row === "object" && !Array.isArray(row))
          : [];
        if (existingChangeOrders.some((row) => String(row?.changeOrderId ?? "") === changeOrderId)) {
          return sendError(res, 409, "changeOrderId already exists");
        }
        if (existingChangeOrders.length >= changeOrderPolicy.maxChangeOrders) {
          return sendError(res, 409, "change order limit reached");
        }

        let nextMilestones = null;
        try {
          nextMilestones =
            body?.milestones === undefined
              ? normalizeAgreementMilestonesInput(terms?.milestones)
              : normalizeAgreementMilestonesInput(body?.milestones);
        } catch (err) {
          return sendError(res, 400, "invalid agreement milestones", { message: err?.message });
        }

        let nextCancellation = null;
        try {
          nextCancellation =
            body?.cancellation === undefined
              ? normalizeAgreementCancellationInput(terms?.cancellation)
              : normalizeAgreementCancellationInput(body?.cancellation);
        } catch (err) {
          return sendError(res, 400, "invalid agreement cancellation terms", { message: err?.message });
        }

        const note = typeof body?.note === "string" && body.note.trim() !== "" ? body.note.trim() : null;
        const nowAt = nowIso();
        const changeOrder = normalizeForCanonicalJson(
          {
            changeOrderId,
            requestedByAgentId,
            acceptedByAgentId: acceptedByAgentId ?? null,
            reason,
            note,
            issuedAt: nowAt,
            acceptedAt: acceptedByAgentId ? nowAt : null,
            previousTermsHash: agreement?.termsHash ?? null
          },
          { path: "$" }
        );
        let nextChangeOrder = changeOrder;
        if (acceptanceSignatureInput) {
          try {
            const acceptanceSignature = await parseSignedMarketplaceAgreementChangeOrderAcceptance({
              tenantId,
              runId,
              agreement,
              changeOrder,
              nextMilestones,
              nextCancellation,
              acceptanceSignatureInput,
              acceptedByAgentId,
              acceptedByIdentity: accepterIdentity
            });
            nextChangeOrder = normalizeForCanonicalJson(
              {
                ...changeOrder,
                acceptanceSignature
              },
              { path: "$" }
            );
          } catch (err) {
            return sendError(res, 400, "invalid acceptance signature", { message: err?.message });
          }
        }
        const nextTerms = normalizeForCanonicalJson(
          {
            ...terms,
            milestones: nextMilestones,
            cancellation: nextCancellation,
            changeOrderPolicy,
            changeOrders: [...existingChangeOrders, nextChangeOrder]
          },
          { path: "$" }
        );
        const nextAgreement = {
          ...agreement,
          terms: nextTerms,
          termsHash: sha256Hex(canonicalJsonStringify(nextTerms)),
          agreementRevision: Number(agreement?.agreementRevision ?? 1) + 1,
          updatedAt: nowAt
        };
        nextAgreement.policyBinding = buildMarketplaceAgreementPolicyBinding({
          agreement: nextAgreement,
          signedAt: nowAt,
          signer: serverSigner
        });
        const nextRfq = {
          ...linkedTask,
          agreement: nextAgreement,
          updatedAt: nowAt
        };

        const acceptanceSignatureVerification = await verifyMarketplaceAgreementChangeOrderAcceptanceSignature({
          tenantId,
          runId,
          agreement,
          changeOrder: nextChangeOrder,
          nextMilestones,
          nextCancellation
        });
        const responseBody = {
          runId,
          rfq: toMarketplaceRfqResponse(nextRfq),
          agreement: nextAgreement,
          changeOrder: nextChangeOrder,
          acceptanceSignatureVerification
        };
        const ops = [{ kind: "MARKETPLACE_RFQ_UPSERT", tenantId, rfq: nextRfq }];
        if (idemStoreKey) {
          ops.push({ kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode: 200, body: responseBody } });
        }
        await commitTx(ops);
        try {
          await emitMarketplaceLifecycleArtifact({
            tenantId,
            eventType: "marketplace.agreement.change_order_applied",
            rfqId: nextRfq?.rfqId ?? null,
            runId,
            sourceEventId: changeOrderId,
            actorAgentId: requestedByAgentId,
            agreement: nextAgreement,
            settlement,
            details: { changeOrder: nextChangeOrder, acceptanceSignatureVerification }
          });
        } catch {
          // Best-effort lifecycle delivery.
        }
        return sendJson(res, 200, responseBody);
      }

      if (parts[0] === "runs" && parts[1] && parts[2] === "agreement" && parts[3] === "cancel" && parts.length === 4 && req.method === "POST") {
        if (!requireProtocolHeaderForWrite(req, res)) return;
        const runId = parts[1];
        const body = await readJsonBody(req);

        let idemStoreKey = null;
        let idemRequestHash = null;
        try {
          ({ idemStoreKey, idemRequestHash } = readIdempotency({ method: "POST", requestPath: path, expectedPrevChainHash: null, body }));
        } catch (err) {
          return sendError(res, 400, "invalid idempotency key", { message: err?.message });
        }
        if (idemStoreKey) {
          const existing = store.idempotency.get(idemStoreKey);
          if (existing) {
            if (existing.requestHash !== idemRequestHash) {
              return sendError(res, 409, "idempotency key conflict", "request differs from initial use of this key");
            }
            return sendJson(res, existing.statusCode, existing.body);
          }
        }

        const linkedTask = findMarketplaceRfqByRunId({ tenantId, runId });
        if (!linkedTask) return sendError(res, 404, "run has no linked marketplace rfq");
        const agreement = linkedTask?.agreement ?? null;
        if (!agreement || typeof agreement !== "object" || Array.isArray(agreement)) {
          return sendError(res, 404, "run has no marketplace agreement");
        }
        if (String(linkedTask.status ?? "").toLowerCase() !== "assigned") {
          return sendError(res, 409, "agreement cancellation is only allowed for assigned tasks");
        }

        let run = null;
        if (typeof store.getAgentRun === "function") {
          run = await store.getAgentRun({ tenantId, runId });
        } else if (store.agentRuns instanceof Map) {
          run = store.agentRuns.get(runStoreKey(tenantId, runId)) ?? null;
        }
        if (!run) return sendError(res, 404, "run not found");

        let settlement = null;
        try {
          settlement = await getAgentRunSettlementRecord({ tenantId, runId });
        } catch (err) {
          return sendError(res, 501, "agent run settlements not supported for this store", { message: err?.message });
        }
        if (!settlement) return sendError(res, 404, "run settlement not found");
        if (settlement.status !== AGENT_RUN_SETTLEMENT_STATUS.LOCKED) {
          return sendError(res, 409, "run settlement is already resolved");
        }
        try {
          assertSettlementKernelBindingsForResolution({
            settlement,
            runId,
            phase: "agreement_cancel.preflight",
            allowMissingArtifacts: true
          });
        } catch (err) {
          return sendError(res, 409, "invalid settlement kernel artifacts", {
            message: err?.message,
            code: err?.code ?? null,
            errors: err?.detail?.errors ?? null
          }, { code: "SETTLEMENT_KERNEL_BINDING_INVALID" });
        }

        const cancellationPolicy = normalizeAgreementCancellationInput(agreement?.terms?.cancellation);
        if (cancellationPolicy.allowCancellationBeforeStart !== true) {
          return sendError(res, 409, "agreement does not allow cancellation before run start");
        }
        const agreementPayerAgentId =
          typeof agreement?.payerAgentId === "string" && agreement.payerAgentId.trim() !== ""
            ? agreement.payerAgentId.trim()
            : null;
        const agreementPayeeAgentId =
          typeof agreement?.payeeAgentId === "string" && agreement.payeeAgentId.trim() !== ""
            ? agreement.payeeAgentId.trim()
            : null;
        if (!agreementPayerAgentId || !agreementPayeeAgentId || agreementPayerAgentId === agreementPayeeAgentId) {
          return sendError(res, 409, "marketplace agreement counterparties are invalid");
        }
        if (String(run.status ?? "").toLowerCase() !== "created") {
          return sendError(res, 409, "agreement cancellation is only allowed before run start; use /runs/{runId}/dispute/open");
        }

        const cancelledByAgentId =
          typeof body?.cancelledByAgentId === "string" && body.cancelledByAgentId.trim() !== ""
            ? body.cancelledByAgentId.trim()
            : null;
        if (!cancelledByAgentId) return sendError(res, 400, "cancelledByAgentId is required");
        if (cancelledByAgentId !== agreementPayerAgentId && cancelledByAgentId !== agreementPayeeAgentId) {
          return sendError(res, 409, "cancelledByAgentId must be a marketplace agreement counterparty");
        }
        const acceptedByAgentId =
          typeof body?.acceptedByAgentId === "string" && body.acceptedByAgentId.trim() !== ""
            ? body.acceptedByAgentId.trim()
            : null;
        const acceptanceSignatureInput =
          body?.acceptanceSignature && typeof body.acceptanceSignature === "object" && !Array.isArray(body.acceptanceSignature)
            ? body.acceptanceSignature
            : null;
        if (body?.acceptanceSignature !== undefined && acceptanceSignatureInput === null) {
          return sendError(res, 400, "acceptanceSignature must be an object");
        }
        if (cancellationPolicy.requireCounterpartyAcceptance === true && !acceptedByAgentId) {
          return sendError(res, 400, "acceptedByAgentId is required by agreement cancellation policy");
        }
        if (acceptanceSignatureInput && !acceptedByAgentId) {
          return sendError(res, 400, "acceptedByAgentId is required when acceptanceSignature is provided");
        }
        if (acceptedByAgentId) {
          if (acceptedByAgentId === cancelledByAgentId) {
            return sendError(res, 409, "acceptedByAgentId must differ from cancelledByAgentId");
          }
          if (acceptedByAgentId !== agreementPayerAgentId && acceptedByAgentId !== agreementPayeeAgentId) {
            return sendError(res, 409, "acceptedByAgentId must be a marketplace agreement counterparty");
          }
        }
        let cancellerIdentity = null;
        try {
          cancellerIdentity = await getAgentIdentityRecord({ tenantId, agentId: cancelledByAgentId });
        } catch (err) {
          return sendError(res, 400, "invalid cancelledByAgentId", { message: err?.message });
        }
        if (!cancellerIdentity) return sendError(res, 404, "cancelling agent identity not found");
        let accepterIdentity = null;
        if (acceptedByAgentId) {
          try {
            accepterIdentity = await getAgentIdentityRecord({ tenantId, agentId: acceptedByAgentId });
          } catch (err) {
            return sendError(res, 400, "invalid acceptedByAgentId", { message: err?.message });
          }
          if (!accepterIdentity) return sendError(res, 404, "accepting agent identity not found");
        }

        const reason = typeof body?.reason === "string" && body.reason.trim() !== "" ? body.reason.trim() : null;
        if (!reason) return sendError(res, 400, "reason is required");
        const evidenceRef = typeof body?.evidenceRef === "string" && body.evidenceRef.trim() !== "" ? body.evidenceRef.trim() : null;
        if (cancellationPolicy.requireEvidenceOnCancellation === true && !evidenceRef) {
          return sendError(res, 400, "agreement cancellation requires evidenceRef");
        }

        const cancellationIdRaw = body?.cancellationId ?? body?.resolutionEventId ?? `cancel_${createId("agr")}`;
        const cancellationId =
          typeof cancellationIdRaw === "string" && cancellationIdRaw.trim() !== "" ? cancellationIdRaw.trim() : null;
        if (!cancellationId) return sendError(res, 400, "cancellationId must be a non-empty string");

        const settledAt = nowIso();
        const killFeeRatePct = Number(cancellationPolicy.killFeeRatePct ?? 0);
        const releasedAmountCents = Math.min(settlement.amountCents, Math.floor((settlement.amountCents * killFeeRatePct) / 100));
        const refundedAmountCents = settlement.amountCents - releasedAmountCents;
        const releaseRatePct = settlement.amountCents > 0 ? Math.round((releasedAmountCents * 100) / settlement.amountCents) : 0;

        let payerWallet = null;
        try {
          const existingPayerWallet = await getAgentWalletRecord({ tenantId, agentId: settlement.payerAgentId });
          payerWallet = ensureAgentWallet({
            wallet: existingPayerWallet,
            tenantId,
            agentId: settlement.payerAgentId,
            currency: settlement.currency,
            at: settledAt
          });
        } catch (err) {
          return sendError(res, 409, "unable to load payer wallet", { message: err?.message, code: err?.code ?? null });
        }

        let payeeWallet = null;
        try {
          if (releasedAmountCents > 0) {
            const existingPayeeWallet = await getAgentWalletRecord({ tenantId, agentId: settlement.agentId });
            const normalizedPayeeWallet = ensureAgentWallet({
              wallet: existingPayeeWallet,
              tenantId,
              agentId: settlement.agentId,
              currency: settlement.currency,
              at: settledAt
            });
            const released = releaseAgentWalletEscrowToPayee({
              payerWallet,
              payeeWallet: normalizedPayeeWallet,
              amountCents: releasedAmountCents,
              at: settledAt
            });
            projectEscrowLedgerOperation({
              tenantId,
              settlement,
              operationId: `escrow_release_${runId}_${cancellationId}`,
              type: ESCROW_OPERATION_TYPE.RELEASE,
              amountCents: releasedAmountCents,
              at: settledAt,
              payerWalletBefore: payerWallet,
              payerWalletAfter: released.payerWallet,
              payeeWalletBefore: normalizedPayeeWallet,
              payeeWalletAfter: released.payeeWallet,
              memo: `run:${runId}:agreement_cancel_release`
            });
            payerWallet = released.payerWallet;
            payeeWallet = released.payeeWallet;
          }
          if (refundedAmountCents > 0) {
            const payerBeforeRefund = payerWallet;
            payerWallet = refundAgentWalletEscrow({
              wallet: payerWallet,
              amountCents: refundedAmountCents,
              at: settledAt
            });
            projectEscrowLedgerOperation({
              tenantId,
              settlement,
              operationId: `escrow_forfeit_${runId}_${cancellationId}`,
              type: ESCROW_OPERATION_TYPE.FORFEIT,
              amountCents: refundedAmountCents,
              at: settledAt,
              payerWalletBefore: payerBeforeRefund,
              payerWalletAfter: payerWallet,
              memo: `run:${runId}:agreement_cancel_refund`
            });
          }
        } catch (err) {
          return sendError(res, 409, "agreement cancellation payment adjustments failed", { message: err?.message, code: err?.code ?? null });
        }

        let cancellationKernelRefs = null;
        try {
          const cancellationVerifierRef = resolveAgreementVerifierRef(agreement?.verificationMethod ?? null);
          cancellationKernelRefs = buildSettlementKernelRefs({
            settlement,
            run: null,
            agreementId: agreement?.agreementId ?? null,
            decisionStatus: AGENT_RUN_SETTLEMENT_DECISION_STATUS.MANUAL_RESOLVED,
            decisionMode: AGENT_RUN_SETTLEMENT_DECISION_MODE.MANUAL_REVIEW,
            decisionReason: reason,
            verificationStatus: "red",
            policyHash: agreement?.policyHash ?? settlement.decisionPolicyHash ?? null,
            verificationMethodHash: agreement?.verificationMethodHash ?? null,
            verificationMethodMode: cancellationVerifierRef?.modality ?? agreement?.verificationMethod?.mode ?? null,
            verifierId: cancellationVerifierRef?.verifierId ?? "settld.policy-engine",
            verifierVersion: cancellationVerifierRef?.verifierVersion ?? "v1",
            verifierHash: cancellationVerifierRef?.verifierHash ?? null,
            resolutionEventId: cancellationId,
            status: releasedAmountCents > 0 ? AGENT_RUN_SETTLEMENT_STATUS.RELEASED : AGENT_RUN_SETTLEMENT_STATUS.REFUNDED,
            releasedAmountCents,
            refundedAmountCents,
            releaseRatePct,
            finalityState: SETTLEMENT_FINALITY_STATE.FINAL,
            settledAt,
            createdAt: settledAt
          });
        } catch (err) {
          return sendError(res, 409, "agreement cancellation decision binding failed", { message: err?.message, code: err?.code ?? null });
        }
        try {
          settlement = resolveAgentRunSettlement({
            settlement,
            status: releasedAmountCents > 0 ? AGENT_RUN_SETTLEMENT_STATUS.RELEASED : AGENT_RUN_SETTLEMENT_STATUS.REFUNDED,
            runStatus: AGENT_RUN_STATUS.FAILED,
            releasedAmountCents,
            refundedAmountCents,
            releaseRatePct,
            disputeWindowDays: settlement.disputeWindowDays ?? 0,
            decisionStatus: AGENT_RUN_SETTLEMENT_DECISION_STATUS.MANUAL_RESOLVED,
            decisionMode: AGENT_RUN_SETTLEMENT_DECISION_MODE.MANUAL_REVIEW,
            decisionPolicyHash: agreement?.policyHash ?? settlement.decisionPolicyHash ?? null,
            decisionReason: reason,
            decisionTrace: {
              phase: "agreement.cancelled.before_start",
              cancellationPolicy,
              cancelledByAgentId,
              acceptedByAgentId: acceptedByAgentId ?? null,
              evidenceRef: evidenceRef ?? null,
              decisionRecord: cancellationKernelRefs.decisionRecord,
              settlementReceipt: cancellationKernelRefs.settlementReceipt
            },
            resolutionEventId: cancellationId,
            at: settledAt
          });
          assertSettlementKernelBindingsForResolution({
            settlement,
            runId,
            phase: "agreement_cancel.resolved"
          });
        } catch (err) {
          if (err?.code === "SETTLEMENT_KERNEL_BINDING_INVALID") {
            return sendError(res, 409, "invalid settlement kernel artifacts", {
              message: err?.message,
              code: err?.code ?? null,
              errors: err?.detail?.errors ?? null
            }, { code: "SETTLEMENT_KERNEL_BINDING_INVALID" });
          }
          return sendError(res, 409, "agreement cancellation settlement update failed", { message: err?.message, code: err?.code ?? null });
        }

        const existingRunEvents = await getAgentRunEvents(tenantId, runId);
        if (!Array.isArray(existingRunEvents) || existingRunEvents.length === 0) {
          return sendError(res, 404, "run events not found");
        }
        const runFailedDraft = createChainedEvent({
          streamId: runId,
          type: AGENT_RUN_EVENT_TYPE.RUN_FAILED,
          actor: { type: "agent", id: cancelledByAgentId },
          payload: {
            runId,
            code: "MARKETPLACE_AGREEMENT_CANCELLED",
            message: reason
          },
          at: settledAt
        });
        const nextRunEvents = normalizeAgentRunEventRecords(
          appendChainedEvent({ events: existingRunEvents, event: runFailedDraft, signer: serverSigner })
        );
        const runFailedEvent = nextRunEvents[nextRunEvents.length - 1];
        let runAfter = null;
        try {
          runAfter = reduceAgentRun(nextRunEvents);
        } catch (err) {
          return sendError(res, 409, "agreement cancellation run update failed", { message: err?.message });
        }
        try {
          await assertTenantVerifiedRunAllowance({
            tenantId,
            occurredAt: runFailedEvent?.at ?? settledAt,
            quantity: 1
          });
        } catch (err) {
          if (err?.code === "BILLING_PLAN_LIMIT_EXCEEDED") {
            return sendError(res, 402, "billing plan verified-run limit exceeded", err?.detail ?? null, { code: err.code });
          }
          throw err;
        }

        const cancellationDetails = normalizeForCanonicalJson(
          {
            cancellationId,
            cancelledAt: settledAt,
            cancelledByAgentId,
            acceptedByAgentId: acceptedByAgentId ?? null,
            acceptedAt: acceptedByAgentId ? settledAt : null,
            reason,
            evidenceRef: evidenceRef ?? null,
            killFeeRatePct,
            releasedAmountCents,
            refundedAmountCents
          },
          { path: "$" }
        );
        let nextCancellationDetails = cancellationDetails;
        if (acceptanceSignatureInput) {
          try {
            const acceptanceSignature = await parseSignedMarketplaceAgreementCancellationAcceptance({
              tenantId,
              runId,
              agreement,
              cancellation: cancellationDetails,
              acceptanceSignatureInput,
              acceptedByAgentId,
              acceptedByIdentity: accepterIdentity
            });
            nextCancellationDetails = normalizeForCanonicalJson(
              {
                ...cancellationDetails,
                acceptanceSignature
              },
              { path: "$" }
            );
          } catch (err) {
            return sendError(res, 400, "invalid acceptance signature", { message: err?.message });
          }
        }
        const acceptanceSignatureVerification = await verifyMarketplaceAgreementCancellationAcceptanceSignature({
          tenantId,
          runId,
          agreement,
          cancellation: nextCancellationDetails
        });
        const baseTaskMetadata =
          linkedTask?.metadata && typeof linkedTask.metadata === "object" && !Array.isArray(linkedTask.metadata)
            ? { ...linkedTask.metadata }
            : {};
        const nextRfq = {
          ...linkedTask,
          status: "cancelled",
          settlementStatus: settlement.status,
          settlementResolvedAt: settlement.resolvedAt ?? settledAt,
          settlementReleaseRatePct: settlement.releaseRatePct ?? null,
          settlementDecisionStatus: settlement.decisionStatus ?? null,
          settlementDecisionReason: settlement.decisionReason ?? null,
          metadata: { ...baseTaskMetadata, cancellation: nextCancellationDetails },
          updatedAt: settledAt
        };

        const responseBody = {
          runId,
          rfq: toMarketplaceRfqResponse(nextRfq),
          run: runAfter,
          settlement,
          agreement: nextRfq.agreement ?? null,
          cancellation: nextCancellationDetails,
          acceptanceSignatureVerification
        };

        const ops = [
          { kind: "AGENT_WALLET_UPSERT", tenantId, wallet: payerWallet },
          { kind: "AGENT_RUN_SETTLEMENT_UPSERT", tenantId, runId, settlement },
          { kind: "AGENT_RUN_EVENTS_APPENDED", tenantId, runId, events: [runFailedEvent] },
          { kind: "MARKETPLACE_RFQ_UPSERT", tenantId, rfq: nextRfq }
        ];
        if (payeeWallet) ops.push({ kind: "AGENT_WALLET_UPSERT", tenantId, wallet: payeeWallet });
        if (idemStoreKey) {
          ops.push({ kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode: 200, body: responseBody } });
        }

        await commitTx(ops);
        await emitBillableUsageEventBestEffort(
          {
            tenantId,
            eventKey: `verified_run:${runId}:${String(runFailedEvent?.id ?? cancellationId)}`,
            eventType: BILLABLE_USAGE_EVENT_TYPE.VERIFIED_RUN,
            occurredAt: runFailedEvent?.at ?? settledAt,
            quantity: 1,
            runId,
            settlementId: settlement?.settlementId ?? null,
            disputeId: settlement?.disputeId ?? null,
            sourceType: "agreement_cancellation",
            sourceId: nextRfq?.rfqId ?? runId,
            sourceEventId: runFailedEvent?.id ?? cancellationId,
            audit: {
              route: path,
              method: "POST",
              actorAgentId: cancelledByAgentId,
              runStatus: runAfter?.status ?? AGENT_RUN_STATUS.FAILED
            }
          },
          { context: "agreement_cancellation.verified_run" }
        );
        const releasedAmountCentsRawForBilling =
          settlement?.releasedAmountCents ??
          (String(settlement?.status ?? "").toLowerCase() === AGENT_RUN_SETTLEMENT_STATUS.RELEASED ? settlement?.amountCents : 0);
        const releasedAmountCentsForBilling = Number.isSafeInteger(Number(releasedAmountCentsRawForBilling))
          ? Number(releasedAmountCentsRawForBilling)
          : 0;
        await emitBillableUsageEventBestEffort(
          {
            tenantId,
            eventKey: `settled_volume:${String(settlement?.settlementId ?? runId)}:${String(settlement?.resolutionEventId ?? cancellationId)}`,
            eventType: BILLABLE_USAGE_EVENT_TYPE.SETTLED_VOLUME,
            occurredAt: settlement?.resolvedAt ?? settledAt,
            quantity: 1,
            amountCents: Math.max(0, releasedAmountCentsForBilling),
            currency: settlement?.currency ?? "USD",
            runId,
            settlementId: settlement?.settlementId ?? null,
            disputeId: settlement?.disputeId ?? null,
            sourceType: "agreement_cancellation",
            sourceId: nextRfq?.rfqId ?? runId,
            sourceEventId: settlement?.resolutionEventId ?? cancellationId,
            audit: {
              route: path,
              method: "POST",
              actorAgentId: cancelledByAgentId,
              settlementStatus: settlement?.status ?? null
            }
          },
          { context: "agreement_cancellation.settled_volume" }
        );
        try {
          await emitMarketplaceLifecycleArtifact({
            tenantId,
            eventType: "marketplace.agreement.cancelled",
            rfqId: nextRfq?.rfqId ?? null,
            runId,
            sourceEventId: cancellationId,
            actorAgentId: cancelledByAgentId,
            agreement: nextRfq?.agreement ?? null,
            settlement,
            details: { ...nextCancellationDetails, acceptanceSignatureVerification }
          });
          if (typeof nextRfq?.agreement?.acceptedProposalId === "string" && nextRfq.agreement.acceptedProposalId.trim() !== "") {
            await emitMarketplaceLifecycleArtifact({
              tenantId,
              eventType: "proposal.cancelled",
              rfqId: nextRfq?.rfqId ?? null,
              runId,
              sourceEventId: nextRfq.agreement.acceptedProposalId,
              actorAgentId: cancelledByAgentId,
              agreement: nextRfq?.agreement ?? null,
              settlement,
              details: { ...nextCancellationDetails, acceptanceSignatureVerification }
            });
          }
        } catch {
          // Best-effort lifecycle delivery.
        }
        return sendJson(res, 200, responseBody);
      }

      if (parts[0] === "runs" && parts[1] && parts[2] === "settlement" && parts[3] === "policy-replay" && parts.length === 4 && req.method === "GET") {
        const runId = parts[1];
        let settlement = null;
        try {
          settlement = await getAgentRunSettlementRecord({ tenantId, runId });
        } catch (err) {
          return sendError(res, 501, "agent run settlements not supported for this store", { message: err?.message });
        }
        if (!settlement) return sendError(res, 404, "run settlement not found");

        let run = null;
        if (typeof store.getAgentRun === "function") {
          run = await store.getAgentRun({ tenantId, runId });
        } else if (store.agentRuns instanceof Map) {
          run = store.agentRuns.get(runStoreKey(tenantId, runId)) ?? null;
        }
        if (!run) return sendError(res, 404, "run not found");

        const events = await getAgentRunEvents(tenantId, runId);
        const verification = computeAgentRunVerification({ run, events });
        const linkedTask = findMarketplaceRfqByRunId({ tenantId, runId });
        const agreement = linkedTask?.agreement ?? null;
        if (!agreement || typeof agreement !== "object") {
          return sendError(res, 404, "run has no marketplace agreement policy");
        }
        const agreementPolicyMaterial = resolveAgreementPolicyMaterial({ tenantId, agreement });
        const replayVerifierExecution = evaluateRunSettlementVerifierExecution({
          verificationMethod: agreementPolicyMaterial.verificationMethod ?? null,
          run,
          verification
        });
        const replayVerificationStatus = replayVerifierExecution.verificationStatus;
        let replayDecision = null;
        try {
          replayDecision = evaluateSettlementPolicy({
            policy: agreementPolicyMaterial.policy ?? null,
            verificationMethod: agreementPolicyMaterial.verificationMethod ?? null,
            verificationStatus: replayVerificationStatus,
            runStatus: run.status === "failed" ? "failed" : "completed",
            amountCents: settlement.amountCents
          });
        } catch (err) {
          return sendError(res, 409, "policy replay failed", { message: err?.message });
        }
        replayDecision = applyAgreementMilestoneRelease({
          policyDecision: replayDecision,
          agreement,
          run,
          verification,
          amountCents: settlement.amountCents
        }).decision;

        const expectedDecisionStatus = replayDecision.shouldAutoResolve
          ? settlement.status === AGENT_RUN_SETTLEMENT_STATUS.LOCKED
            ? AGENT_RUN_SETTLEMENT_DECISION_STATUS.PENDING
            : AGENT_RUN_SETTLEMENT_DECISION_STATUS.AUTO_RESOLVED
          : AGENT_RUN_SETTLEMENT_DECISION_STATUS.MANUAL_REVIEW_REQUIRED;
        const expectedSettlementStatus = replayDecision.shouldAutoResolve
          ? replayDecision.settlementStatus
          : AGENT_RUN_SETTLEMENT_STATUS.LOCKED;
        const matchesStoredDecision =
          String(settlement.decisionStatus ?? "").toLowerCase() === String(expectedDecisionStatus).toLowerCase() &&
          String(settlement.status ?? "").toLowerCase() === String(expectedSettlementStatus).toLowerCase();
        const policyBindingVerification = await verifyMarketplaceAgreementPolicyBinding({ tenantId, agreement });
        const acceptanceSignatureVerification = await verifyMarketplaceAgreementAcceptanceSignature({ tenantId, agreement });
        const kernelVerification = verifySettlementKernelArtifacts({ settlement, runId });

        return sendJson(res, 200, {
          runId,
          agreementId: agreement?.agreementId ?? null,
          policyVersion: agreementPolicyMaterial.policyVersion ?? null,
          policyHash: agreementPolicyMaterial.policyHash ?? null,
          verificationMethodHash: agreementPolicyMaterial.verificationMethodHash ?? null,
          policyRef: agreementPolicyMaterial.policyRef ?? null,
          verifierRef: replayVerifierExecution.verifierRef,
          verifierExecution: replayVerifierExecution.evaluation,
          policyBinding: agreement?.policyBinding ?? null,
          policyBindingVerification,
          acceptanceSignatureVerification,
          runStatus: run.status ?? null,
          verificationStatus: replayVerificationStatus,
          replay: {
            computedAt: nowIso(),
            policy: agreementPolicyMaterial.policy ?? null,
            verificationMethod: agreementPolicyMaterial.verificationMethod ?? null,
            decision: replayDecision,
            expectedDecisionStatus,
            expectedSettlementStatus
          },
          settlement,
          kernelVerification,
          matchesStoredDecision
        });
      }

      if (parts[0] === "runs" && parts[1] && parts[2] === "settlement" && parts[3] === "replay-evaluate" && parts.length === 4 && req.method === "GET") {
        const runId = parts[1];
        let settlement = null;
        try {
          settlement = await getAgentRunSettlementRecord({ tenantId, runId });
        } catch (err) {
          return sendError(res, 501, "agent run settlements not supported for this store", { message: err?.message });
        }
        if (!settlement) return sendError(res, 404, "run settlement not found");

        let run = null;
        if (typeof store.getAgentRun === "function") {
          run = await store.getAgentRun({ tenantId, runId });
        } else if (store.agentRuns instanceof Map) {
          run = store.agentRuns.get(runStoreKey(tenantId, runId)) ?? null;
        }
        if (!run) return sendError(res, 404, "run not found");

        const events = await getAgentRunEvents(tenantId, runId);
        const verification = computeAgentRunVerification({ run, events });
        const linkedTask = findMarketplaceRfqByRunId({ tenantId, runId });
        const agreement = linkedTask?.agreement ?? null;
        if (!agreement || typeof agreement !== "object") {
          return sendError(res, 404, "run has no marketplace agreement policy");
        }

        const agreementPolicyMaterial = resolveAgreementPolicyMaterial({ tenantId, agreement });
        const replayVerifierExecution = evaluateRunSettlementVerifierExecution({
          verificationMethod: agreementPolicyMaterial.verificationMethod ?? null,
          run,
          verification
        });
        const replayVerificationStatus = replayVerifierExecution.verificationStatus;

        let replayDecision = null;
        try {
          replayDecision = evaluateSettlementPolicy({
            policy: agreementPolicyMaterial.policy ?? null,
            verificationMethod: agreementPolicyMaterial.verificationMethod ?? null,
            verificationStatus: replayVerificationStatus,
            runStatus: run.status === "failed" ? "failed" : "completed",
            amountCents: settlement.amountCents
          });
        } catch (err) {
          return sendError(res, 409, "policy replay failed", { message: err?.message });
        }
        replayDecision = applyAgreementMilestoneRelease({
          policyDecision: replayDecision,
          agreement,
          run,
          verification,
          amountCents: settlement.amountCents
        }).decision;

        const expectedDecisionStatus = replayDecision.shouldAutoResolve
          ? settlement.status === AGENT_RUN_SETTLEMENT_STATUS.LOCKED
            ? AGENT_RUN_SETTLEMENT_DECISION_STATUS.PENDING
            : AGENT_RUN_SETTLEMENT_DECISION_STATUS.AUTO_RESOLVED
          : AGENT_RUN_SETTLEMENT_DECISION_STATUS.MANUAL_REVIEW_REQUIRED;
        const expectedSettlementStatus = replayDecision.shouldAutoResolve ? replayDecision.settlementStatus : AGENT_RUN_SETTLEMENT_STATUS.LOCKED;
        const matchesStoredDecision =
          String(settlement.decisionStatus ?? "").toLowerCase() === String(expectedDecisionStatus).toLowerCase() &&
          String(settlement.status ?? "").toLowerCase() === String(expectedSettlementStatus).toLowerCase();

        const normalizePolicyDecisionForCompare = (decision) => {
          if (!decision || typeof decision !== "object" || Array.isArray(decision)) return null;
          const reasons = Array.isArray(decision.reasonCodes) ? decision.reasonCodes.map((r) => String(r)).filter(Boolean) : [];
          reasons.sort();
          return normalizeForCanonicalJson(
            {
              decisionMode: decision.decisionMode ?? null,
              shouldAutoResolve: decision.shouldAutoResolve === true,
              reasonCodes: reasons,
              releaseRatePct: Number.isFinite(Number(decision.releaseRatePct)) ? Number(decision.releaseRatePct) : 0,
              releaseAmountCents: Number.isFinite(Number(decision.releaseAmountCents)) ? Number(decision.releaseAmountCents) : 0,
              refundAmountCents: Number.isFinite(Number(decision.refundAmountCents)) ? Number(decision.refundAmountCents) : 0,
              settlementStatus: decision.settlementStatus ?? null,
              verificationStatus: decision.verificationStatus ?? null,
              runStatus: decision.runStatus ?? null
            },
            { path: "$" }
          );
        };

        const storedPolicyDecisionRaw =
          settlement?.decisionTrace?.policyDecision && typeof settlement.decisionTrace.policyDecision === "object" && !Array.isArray(settlement.decisionTrace.policyDecision)
            ? settlement.decisionTrace.policyDecision
            : null;
        const computedPolicyDecision = normalizePolicyDecisionForCompare(replayDecision);
        const storedPolicyDecision = normalizePolicyDecisionForCompare(storedPolicyDecisionRaw);
        const policyDecisionMatchesStored =
          computedPolicyDecision && storedPolicyDecision
            ? canonicalJsonStringify(computedPolicyDecision) === canonicalJsonStringify(storedPolicyDecision)
            : computedPolicyDecision === null && storedPolicyDecision === null;

        const storedDecisionRecordRaw =
          settlement?.decisionTrace?.decisionRecord && typeof settlement.decisionTrace.decisionRecord === "object" && !Array.isArray(settlement.decisionTrace.decisionRecord)
            ? settlement.decisionTrace.decisionRecord
            : null;
        const storedReceiptRaw =
          settlement?.decisionTrace?.settlementReceipt &&
          typeof settlement.decisionTrace.settlementReceipt === "object" &&
          !Array.isArray(settlement.decisionTrace.settlementReceipt)
            ? settlement.decisionTrace.settlementReceipt
            : null;
        const kernelVerification = verifySettlementKernelArtifacts({ settlement, runId });

        const replayPolicyHash = agreementPolicyMaterial.policyHash ?? null;
        const replayVerificationMethodHash = agreementPolicyMaterial.verificationMethodHash ?? null;

        const replayCriticalMatchesStored =
          storedDecisionRecordRaw && String(storedDecisionRecordRaw.schemaVersion ?? "") === "SettlementDecisionRecord.v2"
            ? (typeof storedDecisionRecordRaw.policyHashUsed === "string" ? storedDecisionRecordRaw.policyHashUsed.trim().toLowerCase() : "") ===
                String(replayPolicyHash ?? "").toLowerCase() &&
              (replayVerificationMethodHash
                ? (typeof storedDecisionRecordRaw.verificationMethodHashUsed === "string"
                    ? storedDecisionRecordRaw.verificationMethodHashUsed.trim().toLowerCase()
                    : "") === String(replayVerificationMethodHash).toLowerCase()
                : true)
            : null;

        const normalizeVerifierRefForCompare = (value) => {
          if (!value || typeof value !== "object" || Array.isArray(value)) return null;
          return normalizeForCanonicalJson(
            {
              verifierId:
                value.verifierId === null || value.verifierId === undefined || String(value.verifierId).trim() === ""
                  ? null
                  : String(value.verifierId),
              verifierVersion:
                value.verifierVersion === null || value.verifierVersion === undefined || String(value.verifierVersion).trim() === ""
                  ? null
                  : String(value.verifierVersion),
              verifierHash:
                value.verifierHash === null || value.verifierHash === undefined || String(value.verifierHash).trim() === ""
                  ? null
                  : String(value.verifierHash).trim().toLowerCase(),
              modality:
                value.modality === null || value.modality === undefined || String(value.modality).trim() === ""
                  ? null
                  : String(value.modality).trim().toLowerCase()
            },
            { path: "$" }
          );
        };

        const computedVerifierRef = normalizeVerifierRefForCompare(replayVerifierExecution.verifierRef);
        const storedVerifierRef = normalizeVerifierRefForCompare(storedDecisionRecordRaw?.verifierRef ?? null);
        const verifierRefMatchesStored =
          computedVerifierRef && storedVerifierRef
            ? canonicalJsonStringify(computedVerifierRef) === canonicalJsonStringify(storedVerifierRef)
            : computedVerifierRef === null && storedVerifierRef === null;

        return sendJson(res, 200, {
          runId,
          agreementId: agreement?.agreementId ?? null,
          policyVersion: agreementPolicyMaterial.policyVersion ?? null,
          policyHash: replayPolicyHash,
          verificationMethodHash: replayVerificationMethodHash,
          policyRef: agreementPolicyMaterial.policyRef ?? null,
          verifierRef: replayVerifierExecution.verifierRef,
          verifierExecution: replayVerifierExecution.evaluation,
          runStatus: run.status ?? null,
          verificationStatus: replayVerificationStatus,
          replay: {
            computedAt: nowIso(),
            decision: replayDecision,
            expectedDecisionStatus,
            expectedSettlementStatus
          },
          stored: {
            policyDecision: storedPolicyDecisionRaw,
            decisionRecord: storedDecisionRecordRaw,
            settlementReceipt: storedReceiptRaw
          },
          kernelVerification,
          comparisons: {
            matchesStoredDecision,
            policyDecisionMatchesStored,
            decisionRecordReplayCriticalMatchesStored: replayCriticalMatchesStored,
            verifierRefMatchesStored,
            kernelBindingsValid: kernelVerification.valid === true
          }
        });
      }

      if (parts[0] === "runs" && parts[1] && parts[2] === "settlement" && parts[3] === "resolve" && parts.length === 4 && req.method === "POST") {
        if (!requireProtocolHeaderForWrite(req, res)) return;
        const runId = parts[1];
        const body = await readJsonBody(req);

        let idemStoreKey = null;
        let idemRequestHash = null;
        try {
          ({ idemStoreKey, idemRequestHash } = readIdempotency({ method: "POST", requestPath: path, expectedPrevChainHash: null, body }));
        } catch (err) {
          return sendError(res, 400, "invalid idempotency key", { message: err?.message });
        }
        if (idemStoreKey) {
          const existing = store.idempotency.get(idemStoreKey);
          if (existing) {
            if (existing.requestHash !== idemRequestHash) {
              return sendError(res, 409, "idempotency key conflict", "request differs from initial use of this key");
            }
            return sendJson(res, existing.statusCode, existing.body);
          }
        }

        let settlement = null;
        try {
          settlement = await getAgentRunSettlementRecord({ tenantId, runId });
        } catch (err) {
          return sendError(res, 501, "agent run settlements not supported for this store", { message: err?.message });
        }
        if (!settlement) return sendError(res, 404, "run settlement not found");
        if (settlement.status !== AGENT_RUN_SETTLEMENT_STATUS.LOCKED) {
          return sendError(res, 409, "run settlement is already resolved");
        }

        let run = null;
        if (typeof store.getAgentRun === "function") {
          run = await store.getAgentRun({ tenantId, runId });
        } else if (store.agentRuns instanceof Map) {
          run = store.agentRuns.get(runStoreKey(tenantId, runId)) ?? null;
        }
        if (!run) return sendError(res, 404, "run not found");
        if (run.status !== "completed" && run.status !== "failed") {
          return sendError(res, 409, "run is not in a terminal state");
        }
        try {
          assertSettlementKernelBindingsForResolution({
            settlement,
            runId,
            phase: "manual_settlement_resolve.preflight",
            allowMissingArtifacts: true
          });
        } catch (err) {
          return sendError(res, 409, "invalid settlement kernel artifacts", {
            message: err?.message,
            code: err?.code ?? null,
            errors: err?.detail?.errors ?? null
          }, { code: "SETTLEMENT_KERNEL_BINDING_INVALID" });
        }

        const statusRaw = String(body?.status ?? "").trim().toLowerCase();
        if (statusRaw !== AGENT_RUN_SETTLEMENT_STATUS.RELEASED && statusRaw !== AGENT_RUN_SETTLEMENT_STATUS.REFUNDED) {
          return sendError(res, 400, "status must be released or refunded");
        }

        const settledAt = nowIso();
        let payerWallet = null;
        try {
          const existingPayerWallet = await getAgentWalletRecord({ tenantId, agentId: settlement.payerAgentId });
          payerWallet = ensureAgentWallet({
            wallet: existingPayerWallet,
            tenantId,
            agentId: settlement.payerAgentId,
            currency: settlement.currency,
            at: settledAt
          });
        } catch (err) {
          return sendError(res, 409, "unable to load payer wallet", { message: err?.message, code: err?.code ?? null });
        }

        const releaseRatePctRaw = body?.releaseRatePct;
        const releasedAmountRaw = body?.releasedAmountCents;
        const refundedAmountRaw = body?.refundedAmountCents;
        let releaseRatePct = releaseRatePctRaw === undefined || releaseRatePctRaw === null ? null : Number(releaseRatePctRaw);
        let releasedAmountCents = releasedAmountRaw === undefined || releasedAmountRaw === null ? null : Number(releasedAmountRaw);
        let refundedAmountCents = refundedAmountRaw === undefined || refundedAmountRaw === null ? null : Number(refundedAmountRaw);

        if (releaseRatePct !== null && (!Number.isSafeInteger(releaseRatePct) || releaseRatePct < 0 || releaseRatePct > 100)) {
          return sendError(res, 400, "releaseRatePct must be an integer within 0..100");
        }
        if (releasedAmountCents !== null && (!Number.isSafeInteger(releasedAmountCents) || releasedAmountCents < 0)) {
          return sendError(res, 400, "releasedAmountCents must be a non-negative safe integer");
        }
        if (refundedAmountCents !== null && (!Number.isSafeInteger(refundedAmountCents) || refundedAmountCents < 0)) {
          return sendError(res, 400, "refundedAmountCents must be a non-negative safe integer");
        }

        if (statusRaw === AGENT_RUN_SETTLEMENT_STATUS.REFUNDED) {
          releaseRatePct = 0;
          releasedAmountCents = 0;
          refundedAmountCents = settlement.amountCents;
        } else {
          if (releaseRatePct === null && releasedAmountCents === null && refundedAmountCents === null) {
            releaseRatePct = 100;
            releasedAmountCents = settlement.amountCents;
            refundedAmountCents = 0;
          } else if (releaseRatePct !== null) {
            releasedAmountCents = Math.min(settlement.amountCents, Math.floor((settlement.amountCents * releaseRatePct) / 100));
            refundedAmountCents = settlement.amountCents - releasedAmountCents;
          } else {
            if (releasedAmountCents === null && refundedAmountCents !== null) {
              releasedAmountCents = settlement.amountCents - refundedAmountCents;
            }
            if (refundedAmountCents === null && releasedAmountCents !== null) {
              refundedAmountCents = settlement.amountCents - releasedAmountCents;
            }
            if (releasedAmountCents === null || refundedAmountCents === null) {
              return sendError(res, 400, "manual settlement amounts are incomplete");
            }
            if (releasedAmountCents + refundedAmountCents !== settlement.amountCents) {
              return sendError(res, 400, "releasedAmountCents + refundedAmountCents must equal settlement.amountCents");
            }
            releaseRatePct = settlement.amountCents > 0 ? Math.round((releasedAmountCents * 100) / settlement.amountCents) : 0;
          }
        }

        try {
          if (releasedAmountCents > 0) {
            const payeeWalletExisting = await getAgentWalletRecord({ tenantId, agentId: settlement.agentId });
            const payeeWallet = ensureAgentWallet({
              wallet: payeeWalletExisting,
              tenantId,
              agentId: settlement.agentId,
              currency: settlement.currency,
              at: settledAt
            });
            const released = releaseAgentWalletEscrowToPayee({
              payerWallet,
              payeeWallet,
              amountCents: releasedAmountCents,
              at: settledAt
            });
            projectEscrowLedgerOperation({
              tenantId,
              settlement,
              operationId: `escrow_release_${runId}_${body?.resolutionEventId ?? "manual_resolution"}`,
              type: ESCROW_OPERATION_TYPE.RELEASE,
              amountCents: releasedAmountCents,
              at: settledAt,
              payerWalletBefore: payerWallet,
              payerWalletAfter: released.payerWallet,
              payeeWalletBefore: payeeWallet,
              payeeWalletAfter: released.payeeWallet,
              memo: `run:${runId}:manual_release`
            });
            payerWallet = released.payerWallet;
            if (refundedAmountCents > 0) {
              const payerBeforeRefund = payerWallet;
              payerWallet = refundAgentWalletEscrow({
                wallet: payerWallet,
                amountCents: refundedAmountCents,
                at: settledAt
              });
              projectEscrowLedgerOperation({
                tenantId,
                settlement,
                operationId: `escrow_forfeit_${runId}_${body?.resolutionEventId ?? "manual_resolution"}`,
                type: ESCROW_OPERATION_TYPE.FORFEIT,
                amountCents: refundedAmountCents,
                at: settledAt,
                payerWalletBefore: payerBeforeRefund,
                payerWalletAfter: payerWallet,
                memo: `run:${runId}:manual_refund`
              });
            }
            const manualResolveKernelRefs = buildSettlementKernelRefs({
              settlement,
              run,
              agreementId: null,
              decisionStatus: AGENT_RUN_SETTLEMENT_DECISION_STATUS.MANUAL_RESOLVED,
              decisionMode: AGENT_RUN_SETTLEMENT_DECISION_MODE.MANUAL_REVIEW,
              decisionReason:
                typeof body?.reason === "string" && body.reason.trim() !== ""
                  ? body.reason.trim()
                  : "manual settlement resolution",
              verificationStatus: run.status === "failed" ? "red" : null,
              policyHash: settlement.decisionPolicyHash ?? null,
              verificationMethodHash: null,
              verificationMethodMode: null,
              resolutionEventId:
                typeof body?.resolutionEventId === "string" && body.resolutionEventId.trim() !== ""
                  ? body.resolutionEventId.trim()
                  : `manual_${createId("setl")}`,
              status: statusRaw,
              releasedAmountCents,
              refundedAmountCents,
              releaseRatePct,
              finalityState: SETTLEMENT_FINALITY_STATE.FINAL,
              settledAt,
              createdAt: settledAt
            });
	            settlement = resolveAgentRunSettlement({
	              settlement,
	              status: statusRaw,
	              runStatus: run.status,
	              releasedAmountCents,
	              refundedAmountCents,
	              releaseRatePct,
	              disputeWindowDays: settlement.disputeWindowDays ?? 0,
	              decisionStatus: AGENT_RUN_SETTLEMENT_DECISION_STATUS.MANUAL_RESOLVED,
	              decisionMode: AGENT_RUN_SETTLEMENT_DECISION_MODE.MANUAL_REVIEW,
	              decisionPolicyHash: settlement.decisionPolicyHash ?? null,
	              decisionReason:
	                typeof body?.reason === "string" && body.reason.trim() !== ""
	                  ? body.reason.trim()
	                  : "manual settlement resolution",
	              decisionTrace: {
	                phase: "run.settlement.manual_resolve",
	                resolvedByAgentId:
	                  typeof body?.resolvedByAgentId === "string" && body.resolvedByAgentId.trim() !== ""
	                    ? body.resolvedByAgentId.trim()
	                    : null,
	                input: {
	                  status: statusRaw,
	                  releaseRatePct,
	                  releasedAmountCents,
	                  refundedAmountCents
	                },
	                // Preserve the original policy decision trace (if any) so replay tooling can still
	                // compare "what policy would have done" even after a manual override.
	                policyDecision: settlement?.decisionTrace?.policyDecision ?? null,
	                decisionRecord: manualResolveKernelRefs.decisionRecord,
	                settlementReceipt: manualResolveKernelRefs.settlementReceipt
	              },
	              resolutionEventId: manualResolveKernelRefs.decisionRecord?.workRef?.resolutionEventId ?? null,
	              at: settledAt
	            });
            assertSettlementKernelBindingsForResolution({
              settlement,
              runId,
              phase: "manual_settlement_resolve.released"
            });

            const ops = [
              { kind: "AGENT_WALLET_UPSERT", tenantId, wallet: payerWallet },
              { kind: "AGENT_WALLET_UPSERT", tenantId, wallet: released.payeeWallet },
              { kind: "AGENT_RUN_SETTLEMENT_UPSERT", tenantId, runId, settlement }
            ];
            const linkedTask = findMarketplaceRfqByRunId({ tenantId, runId });
            if (linkedTask && String(linkedTask.status ?? "").toLowerCase() === "assigned") {
              ops.push({
                kind: "MARKETPLACE_RFQ_UPSERT",
                tenantId,
                rfq: {
                  ...linkedTask,
                  status: "closed",
                  settlementStatus: settlement.status,
                  settlementResolvedAt: settlement.resolvedAt ?? settledAt,
                  settlementReleaseRatePct: settlement.releaseRatePct ?? null,
                  settlementDecisionStatus: settlement.decisionStatus ?? null,
                  settlementDecisionReason: settlement.decisionReason ?? null,
                  updatedAt: settledAt
                }
              });
            }
            const responseBody = { settlement };
            if (idemStoreKey) {
              ops.push({
                kind: "IDEMPOTENCY_PUT",
                key: idemStoreKey,
                value: { requestHash: idemRequestHash, statusCode: 200, body: responseBody }
              });
            }
            await commitTx(ops);
            const decisionHashRaw =
              settlement?.decisionTrace?.decisionRecord && typeof settlement.decisionTrace.decisionRecord === "object"
                ? settlement.decisionTrace.decisionRecord.decisionHash
                : null;
            const decisionHash =
              typeof decisionHashRaw === "string" && /^[0-9a-f]{64}$/i.test(decisionHashRaw.trim())
                ? decisionHashRaw.trim().toLowerCase()
                : sha256Hex(
                    `${String(settlement?.settlementId ?? runId)}:${String(settlement?.resolutionEventId ?? "manual_resolution")}:${String(
                      settlement?.status ?? ""
                    )}`
                  );
            await emitReputationEventBestEffort(
              {
                tenantId,
                eventId: `rep_dec_${decisionHash}`,
                occurredAt: settlement?.resolvedAt ?? settledAt,
                eventKind:
                  Number(settlement?.releasedAmountCents ?? 0) > 0
                    ? REPUTATION_EVENT_KIND.DECISION_APPROVED
                    : REPUTATION_EVENT_KIND.DECISION_REJECTED,
                subject: {
                  agentId: String(settlement.agentId),
                  counterpartyAgentId: String(settlement.payerAgentId),
                  role: "payee"
                },
                sourceRef: {
                  kind: "settlement_decision",
                  sourceId: String(settlement?.settlementId ?? runId),
                  hash: decisionHash,
                  decisionHash,
                  runId,
                  settlementId: settlement?.settlementId ?? null
                },
                facts: {
                  decisionStatus: Number(settlement?.releasedAmountCents ?? 0) > 0 ? "approved" : "rejected",
                  releaseRatePct: Number(settlement?.releaseRatePct ?? 0),
                  amountSettledCents: Number(settlement?.releasedAmountCents ?? 0),
                  amountRefundedCents: Number(settlement?.refundedAmountCents ?? 0),
                  latencyMs: toSafeNonNegativeInt(run?.metrics?.latencyMs)
                }
              },
              { context: "manual_settlement_resolution.released" }
            );
            const releasedAmountCentsRaw =
              settlement?.releasedAmountCents ??
              (String(settlement?.status ?? "").toLowerCase() === AGENT_RUN_SETTLEMENT_STATUS.RELEASED ? settlement?.amountCents : 0);
            const settledVolumeAmountCents = Number.isSafeInteger(Number(releasedAmountCentsRaw)) ? Number(releasedAmountCentsRaw) : 0;
            await emitBillableUsageEventBestEffort(
              {
                tenantId,
                eventKey: `settled_volume:${String(settlement?.settlementId ?? runId)}:${String(settlement?.resolutionEventId ?? `manual_${runId}`)}`,
                eventType: BILLABLE_USAGE_EVENT_TYPE.SETTLED_VOLUME,
                occurredAt: settlement?.resolvedAt ?? settledAt,
                quantity: 1,
                amountCents: Math.max(0, settledVolumeAmountCents),
                currency: settlement?.currency ?? "USD",
                runId,
                settlementId: settlement?.settlementId ?? null,
                disputeId: settlement?.disputeId ?? null,
                sourceType: "manual_settlement_resolution",
                sourceId: runId,
                sourceEventId: settlement?.resolutionEventId ?? null,
                audit: {
                  route: path,
                  method: "POST",
                  actorAgentId:
                    typeof body?.resolvedByAgentId === "string" && body.resolvedByAgentId.trim() !== ""
                      ? body.resolvedByAgentId.trim()
                      : null,
                  settlementStatus: settlement?.status ?? null
                }
              },
              { context: "manual_settlement_resolution.released" }
            );
            try {
              await emitMarketplaceLifecycleArtifact({
                tenantId,
                eventType: "marketplace.settlement.manually_resolved",
                rfqId: linkedTask?.rfqId ?? null,
                runId,
                sourceEventId: settlement.resolutionEventId ?? null,
                actorAgentId:
                  typeof body?.resolvedByAgentId === "string" && body.resolvedByAgentId.trim() !== ""
                    ? body.resolvedByAgentId.trim()
                    : null,
                settlement,
                details: {
                  status: settlement.status,
                  releaseRatePct: settlement.releaseRatePct ?? null,
                  releasedAmountCents: settlement.releasedAmountCents ?? 0,
                  refundedAmountCents: settlement.refundedAmountCents ?? 0
                }
              });
            } catch {
              // Best-effort lifecycle delivery.
            }
            return sendJson(res, 200, responseBody);
          }

          const payerBeforeRefund = payerWallet;
          payerWallet = refundAgentWalletEscrow({
            wallet: payerWallet,
            amountCents: refundedAmountCents,
            at: settledAt
          });
          projectEscrowLedgerOperation({
            tenantId,
            settlement,
            operationId: `escrow_forfeit_${runId}_${body?.resolutionEventId ?? "manual_resolution"}`,
            type: ESCROW_OPERATION_TYPE.FORFEIT,
            amountCents: refundedAmountCents,
            at: settledAt,
            payerWalletBefore: payerBeforeRefund,
            payerWalletAfter: payerWallet,
            memo: `run:${runId}:manual_refund`
          });

          const manualRefundKernelRefs = buildSettlementKernelRefs({
            settlement,
            run,
            agreementId: null,
            decisionStatus: AGENT_RUN_SETTLEMENT_DECISION_STATUS.MANUAL_RESOLVED,
            decisionMode: AGENT_RUN_SETTLEMENT_DECISION_MODE.MANUAL_REVIEW,
            decisionReason:
              typeof body?.reason === "string" && body.reason.trim() !== ""
                ? body.reason.trim()
                : "manual settlement resolution",
            verificationStatus: run.status === "failed" ? "red" : null,
            policyHash: settlement.decisionPolicyHash ?? null,
            verificationMethodHash: null,
            verificationMethodMode: null,
            resolutionEventId:
              typeof body?.resolutionEventId === "string" && body.resolutionEventId.trim() !== ""
                ? body.resolutionEventId.trim()
                : `manual_${createId("setl")}`,
            status: AGENT_RUN_SETTLEMENT_STATUS.REFUNDED,
            releasedAmountCents: 0,
            refundedAmountCents: settlement.amountCents,
            releaseRatePct: 0,
            finalityState: SETTLEMENT_FINALITY_STATE.FINAL,
            settledAt,
            createdAt: settledAt
          });
	          settlement = resolveAgentRunSettlement({
	            settlement,
	            status: AGENT_RUN_SETTLEMENT_STATUS.REFUNDED,
	            runStatus: run.status,
	            releasedAmountCents: 0,
	            refundedAmountCents: settlement.amountCents,
	            releaseRatePct: 0,
	            disputeWindowDays: settlement.disputeWindowDays ?? 0,
	            decisionStatus: AGENT_RUN_SETTLEMENT_DECISION_STATUS.MANUAL_RESOLVED,
	            decisionMode: AGENT_RUN_SETTLEMENT_DECISION_MODE.MANUAL_REVIEW,
	            decisionPolicyHash: settlement.decisionPolicyHash ?? null,
	            decisionReason:
	              typeof body?.reason === "string" && body.reason.trim() !== ""
	                ? body.reason.trim()
	                : "manual settlement resolution",
	            decisionTrace: {
	              phase: "run.settlement.manual_resolve",
	              resolvedByAgentId:
	                typeof body?.resolvedByAgentId === "string" && body.resolvedByAgentId.trim() !== ""
	                  ? body.resolvedByAgentId.trim()
	                  : null,
	              input: {
	                status: AGENT_RUN_SETTLEMENT_STATUS.REFUNDED,
	                releaseRatePct: 0,
	                releasedAmountCents: 0,
	                refundedAmountCents: settlement.amountCents
	              },
	              policyDecision: settlement?.decisionTrace?.policyDecision ?? null,
	              decisionRecord: manualRefundKernelRefs.decisionRecord,
	              settlementReceipt: manualRefundKernelRefs.settlementReceipt
	            },
	            resolutionEventId: manualRefundKernelRefs.decisionRecord?.workRef?.resolutionEventId ?? null,
	            at: settledAt
	          });
          assertSettlementKernelBindingsForResolution({
            settlement,
            runId,
            phase: "manual_settlement_resolve.refunded"
          });

          const ops = [
            { kind: "AGENT_WALLET_UPSERT", tenantId, wallet: payerWallet },
            { kind: "AGENT_RUN_SETTLEMENT_UPSERT", tenantId, runId, settlement }
          ];
          const linkedTask = findMarketplaceRfqByRunId({ tenantId, runId });
          if (linkedTask && String(linkedTask.status ?? "").toLowerCase() === "assigned") {
            ops.push({
              kind: "MARKETPLACE_RFQ_UPSERT",
              tenantId,
              rfq: {
                ...linkedTask,
                status: "closed",
                settlementStatus: settlement.status,
                settlementResolvedAt: settlement.resolvedAt ?? settledAt,
                settlementReleaseRatePct: settlement.releaseRatePct ?? null,
                settlementDecisionStatus: settlement.decisionStatus ?? null,
                settlementDecisionReason: settlement.decisionReason ?? null,
                updatedAt: settledAt
              }
            });
          }
          const responseBody = { settlement };
          if (idemStoreKey) {
            ops.push({
              kind: "IDEMPOTENCY_PUT",
              key: idemStoreKey,
              value: { requestHash: idemRequestHash, statusCode: 200, body: responseBody }
            });
          }
          await commitTx(ops);
          const decisionHashRaw =
            settlement?.decisionTrace?.decisionRecord && typeof settlement.decisionTrace.decisionRecord === "object"
              ? settlement.decisionTrace.decisionRecord.decisionHash
              : null;
          const decisionHash =
            typeof decisionHashRaw === "string" && /^[0-9a-f]{64}$/i.test(decisionHashRaw.trim())
              ? decisionHashRaw.trim().toLowerCase()
              : sha256Hex(
                  `${String(settlement?.settlementId ?? runId)}:${String(settlement?.resolutionEventId ?? "manual_resolution")}:${String(
                    settlement?.status ?? ""
                  )}`
                );
          await emitReputationEventBestEffort(
            {
              tenantId,
              eventId: `rep_dec_${decisionHash}`,
              occurredAt: settlement?.resolvedAt ?? settledAt,
              eventKind: REPUTATION_EVENT_KIND.DECISION_REJECTED,
              subject: {
                agentId: String(settlement.agentId),
                counterpartyAgentId: String(settlement.payerAgentId),
                role: "payee"
              },
              sourceRef: {
                kind: "settlement_decision",
                sourceId: String(settlement?.settlementId ?? runId),
                hash: decisionHash,
                decisionHash,
                runId,
                settlementId: settlement?.settlementId ?? null
              },
              facts: {
                decisionStatus: "rejected",
                releaseRatePct: 0,
                amountSettledCents: 0,
                amountRefundedCents: Number(settlement?.refundedAmountCents ?? settlement?.amountCents ?? 0),
                latencyMs: toSafeNonNegativeInt(run?.metrics?.latencyMs)
              }
            },
            { context: "manual_settlement_resolution.refunded" }
          );
          await emitBillableUsageEventBestEffort(
            {
              tenantId,
              eventKey: `settled_volume:${String(settlement?.settlementId ?? runId)}:${String(settlement?.resolutionEventId ?? `manual_${runId}`)}`,
              eventType: BILLABLE_USAGE_EVENT_TYPE.SETTLED_VOLUME,
              occurredAt: settlement?.resolvedAt ?? settledAt,
              quantity: 1,
              amountCents: 0,
              currency: settlement?.currency ?? "USD",
              runId,
              settlementId: settlement?.settlementId ?? null,
              disputeId: settlement?.disputeId ?? null,
              sourceType: "manual_settlement_resolution",
              sourceId: runId,
              sourceEventId: settlement?.resolutionEventId ?? null,
              audit: {
                route: path,
                method: "POST",
                actorAgentId:
                  typeof body?.resolvedByAgentId === "string" && body.resolvedByAgentId.trim() !== ""
                    ? body.resolvedByAgentId.trim()
                    : null,
                settlementStatus: settlement?.status ?? null
              }
            },
            { context: "manual_settlement_resolution.refunded" }
          );
          try {
            await emitMarketplaceLifecycleArtifact({
              tenantId,
              eventType: "marketplace.settlement.manually_resolved",
              rfqId: linkedTask?.rfqId ?? null,
              runId,
              sourceEventId: settlement.resolutionEventId ?? null,
              actorAgentId:
                typeof body?.resolvedByAgentId === "string" && body.resolvedByAgentId.trim() !== ""
                  ? body.resolvedByAgentId.trim()
                  : null,
              settlement,
              details: {
                status: settlement.status,
                releaseRatePct: 0,
                releasedAmountCents: 0,
                refundedAmountCents: settlement.amountCents
              }
            });
          } catch {
            // Best-effort lifecycle delivery.
          }
          return sendJson(res, 200, responseBody);
        } catch (err) {
          if (err?.code === "SETTLEMENT_KERNEL_BINDING_INVALID") {
            return sendError(res, 409, "invalid settlement kernel artifacts", {
              message: err?.message,
              code: err?.code ?? null,
              errors: err?.detail?.errors ?? null
            }, { code: "SETTLEMENT_KERNEL_BINDING_INVALID" });
          }
          return sendError(res, 409, "manual settlement resolution failed", { message: err?.message, code: err?.code ?? null });
        }
      }

      if (parts[0] === "runs" && parts[1] && parts[2] === "arbitration" && parts.length === 4 && req.method === "POST") {
        if (!requireProtocolHeaderForWrite(req, res)) return;
        const runId = parts[1];
        const action = parts[3];
        if (action !== "open" && action !== "assign" && action !== "evidence" && action !== "verdict" && action !== "close" && action !== "appeal") {
          return sendError(res, 404, "not found");
        }

        const body = await readJsonBody(req);
        let idemStoreKey = null;
        let idemRequestHash = null;
        try {
          ({ idemStoreKey, idemRequestHash } = readIdempotency({ method: "POST", requestPath: path, expectedPrevChainHash: null, body }));
        } catch (err) {
          return sendError(res, 400, "invalid idempotency key", { message: err?.message });
        }
        if (idemStoreKey) {
          const existing = store.idempotency.get(idemStoreKey);
          if (existing) {
            if (existing.requestHash !== idemRequestHash) {
              return sendError(res, 409, "idempotency key conflict", "request differs from initial use of this key");
            }
            return sendJson(res, existing.statusCode, existing.body);
          }
        }

        let settlement = null;
        try {
          settlement = await getAgentRunSettlementRecord({ tenantId, runId });
        } catch (err) {
          return sendError(res, 501, "agent run settlements not supported for this store", { message: err?.message });
        }
        if (!settlement) return sendError(res, 404, "run settlement not found");

        const nowAt = nowIso();
        const parseOptionalNonEmptyString = (value, name) => {
          if (value === undefined || value === null) return null;
          if (typeof value !== "string" || value.trim() === "") throw new TypeError(`${name} must be a non-empty string`);
          return value.trim();
        };
        let disputeId = null;
        try {
          disputeId = parseOptionalNonEmptyString(body?.disputeId, "disputeId") ?? String(settlement?.disputeId ?? "");
        } catch (err) {
          return sendError(res, 400, "invalid disputeId", { message: err?.message });
        }
        if (!disputeId) return sendError(res, 400, "disputeId is required");
        if (String(settlement?.disputeId ?? "") && String(settlement?.disputeId ?? "") !== String(disputeId)) {
          return sendError(res, 409, "disputeId does not match settlement dispute");
        }

        const parseCaseIdFromBody = () => {
          const caseIdRaw = body?.caseId ?? null;
          if (caseIdRaw === null || caseIdRaw === undefined || caseIdRaw === "") return null;
          if (typeof caseIdRaw !== "string" || caseIdRaw.trim() === "") throw new TypeError("caseId must be a non-empty string");
          return caseIdRaw.trim();
        };

        const loadCaseOrError = async (caseId, { requireOpen = false } = {}) => {
          let arbitrationCase;
          try {
            arbitrationCase = await getArbitrationCaseRecord({ tenantId, caseId });
          } catch (err) {
            return { error: sendError(res, 501, "arbitration cases not supported for this store", { message: err?.message }) };
          }
          if (!arbitrationCase || String(arbitrationCase.runId ?? "") !== String(runId)) {
            return { error: sendError(res, 404, "arbitration case not found") };
          }
          if (requireOpen && normalizeArbitrationCaseStatus(arbitrationCase.status) === ARBITRATION_CASE_STATUS.CLOSED) {
            return { error: sendError(res, 409, "arbitration case is closed") };
          }
          return { arbitrationCase };
        };

        if (action === "open") {
          if (String(settlement?.disputeStatus ?? "").toLowerCase() !== AGENT_RUN_SETTLEMENT_DISPUTE_STATUS.OPEN) {
            return sendError(res, 409, "arbitration requires an open dispute");
          }
          let caseId = null;
          try {
            caseId = parseCaseIdFromBody() ?? createId("arb_case");
          } catch (err) {
            return sendError(res, 400, "invalid arbitration case id", { message: err?.message });
          }
          let existingCase = null;
          try {
            existingCase = await getArbitrationCaseRecord({ tenantId, caseId });
          } catch (err) {
            return sendError(res, 501, "arbitration cases not supported for this store", { message: err?.message });
          }
          if (existingCase) return sendError(res, 409, "arbitration case already exists");

          let evidenceRefs = [];
          try {
            evidenceRefs = normalizeArbitrationCaseEvidenceRefs(
              Array.isArray(body?.evidenceRefs) ? body.evidenceRefs : settlement?.disputeContext?.evidenceRefs ?? [],
              { fieldName: "evidenceRefs" }
            );
            assertArbitrationCaseEvidenceBoundToDisputeContext({ settlement, evidenceRefs });
          } catch (err) {
            return sendError(res, 400, "invalid arbitration evidence", { message: err?.message });
          }

          let arbiterAgentId = null;
          let assignment = null;
          try {
            arbiterAgentId = parseOptionalNonEmptyString(body?.arbiterAgentId, "arbiterAgentId");
          } catch (err) {
            return sendError(res, 400, "invalid arbiter assignment", { message: err?.message });
          }
          if (arbiterAgentId) {
            const arbiterIdentity = await getAgentIdentityRecord({ tenantId, agentId: arbiterAgentId });
            if (!arbiterIdentity) return sendError(res, 404, "arbiterAgentId not found");
          } else if (Array.isArray(body?.panelCandidateAgentIds) && body.panelCandidateAgentIds.length > 0) {
            try {
              assignment = await assignDeterministicArbiterAgentId({
                tenantId,
                runId,
                disputeId,
                panelCandidateAgentIds: body.panelCandidateAgentIds
              });
            } catch (err) {
              return sendError(res, 400, "invalid arbitration panel assignment", { message: err?.message });
            }
            arbiterAgentId = assignment.arbiterAgentId;
          }
          if (!arbiterAgentId) return sendError(res, 400, "arbiterAgentId or panelCandidateAgentIds is required");

          const arbitrationCase = normalizeForCanonicalJson(
            {
              schemaVersion: "ArbitrationCase.v1",
              caseId,
              tenantId: normalizeTenant(tenantId),
              runId: String(runId),
              settlementId: String(settlement?.settlementId ?? ""),
              disputeId: String(disputeId),
              claimantAgentId: String(settlement?.payerAgentId ?? settlement?.disputeContext?.openedByAgentId ?? ""),
              respondentAgentId: String(settlement?.agentId ?? ""),
              arbiterAgentId,
              priority:
                normalizeArbitrationCasePriority(settlement?.disputeContext?.priority, {
                  fieldName: "settlement.disputeContext.priority",
                  allowNull: true
                }) ?? AGENT_RUN_SETTLEMENT_DISPUTE_PRIORITY.NORMAL,
              status: ARBITRATION_CASE_STATUS.UNDER_REVIEW,
              openedAt: nowAt,
              closedAt: null,
              summary: parseOptionalNonEmptyString(body?.summary, "summary"),
              evidenceRefs,
              appealRef: null,
              metadata: assignment
                ? {
                    assignmentHash: assignment.assignmentHash,
                    panelCandidateAgentIds: assignment.panelCandidateAgentIds
                  }
                : null,
              revision: 1,
              createdAt: nowAt,
              updatedAt: nowAt
            },
            { path: "$" }
          );
          const responseBody = {
            arbitrationCase,
            arbitrationCaseArtifact: null
          };
          const ops = [{ kind: "ARBITRATION_CASE_UPSERT", tenantId, caseId, arbitrationCase }];
          if (idemStoreKey) {
            ops.push({ kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode: 201, body: responseBody } });
          }
          await commitTx(ops);
          await emitBillableUsageEventBestEffort(
            {
              tenantId,
              eventKey: `arbitration_usage:${String(caseId)}:case`,
              eventType: BILLABLE_USAGE_EVENT_TYPE.ARBITRATION_USAGE,
              occurredAt: nowAt,
              quantity: 1,
              runId,
              settlementId: settlement?.settlementId ?? null,
              disputeId: arbitrationCase?.disputeId ?? disputeId,
              arbitrationCaseId: caseId,
              sourceType: "arbitration_case",
              sourceId: caseId,
              sourceEventId: null,
              audit: {
                route: path,
                method: "POST",
                action: "open",
                arbiterAgentId: arbitrationCase?.arbiterAgentId ?? null
              }
            },
            { context: "arbitration_case.open" }
          );
          let arbitrationCaseArtifact = null;
          try {
            arbitrationCaseArtifact = await emitArbitrationCaseArtifact({ tenantId, arbitrationCase, at: nowAt });
            await emitMarketplaceLifecycleArtifact({
              tenantId,
              eventType: "marketplace.arbitration.opened",
              runId,
              sourceEventId: caseId,
              actorAgentId: arbitrationCase.arbiterAgentId ?? null,
              settlement,
              details: { arbitrationCase, arbitrationCaseArtifact }
            });
          } catch {
            arbitrationCaseArtifact = null;
          }
          return sendJson(res, 201, { ...responseBody, arbitrationCaseArtifact });
        }

        if (action === "assign") {
          let caseId = null;
          try {
            caseId = parseCaseIdFromBody();
          } catch (err) {
            return sendError(res, 400, "invalid arbitration case id", { message: err?.message });
          }
          if (!caseId) return sendError(res, 400, "caseId is required");
          const loaded = await loadCaseOrError(caseId, { requireOpen: true });
          if (loaded.error) return;
          const arbitrationCase = loaded.arbitrationCase;

          let assignment = null;
          let arbiterAgentId = null;
          try {
            arbiterAgentId = parseOptionalNonEmptyString(body?.arbiterAgentId, "arbiterAgentId");
          } catch (err) {
            return sendError(res, 400, "invalid arbiter assignment", { message: err?.message });
          }
          if (arbiterAgentId) {
            const arbiterIdentity = await getAgentIdentityRecord({ tenantId, agentId: arbiterAgentId });
            if (!arbiterIdentity) return sendError(res, 404, "arbiterAgentId not found");
          } else {
            try {
              assignment = await assignDeterministicArbiterAgentId({
                tenantId,
                runId,
                disputeId,
                panelCandidateAgentIds: body?.panelCandidateAgentIds
              });
            } catch (err) {
              return sendError(res, 400, "invalid arbitration panel assignment", { message: err?.message });
            }
            arbiterAgentId = assignment.arbiterAgentId;
          }

          let nextStatus;
          try {
            nextStatus = ensureArbitrationCaseStatusTransition({
              currentStatus: arbitrationCase.status,
              nextStatus: ARBITRATION_CASE_STATUS.UNDER_REVIEW
            });
          } catch (err) {
            return sendError(res, 409, "arbitration transition rejected", { message: err?.message });
          }
          const nextCase = normalizeForCanonicalJson(
            {
              ...arbitrationCase,
              arbiterAgentId,
              status: nextStatus,
              metadata: {
                ...(arbitrationCase?.metadata && typeof arbitrationCase.metadata === "object" ? arbitrationCase.metadata : {}),
                ...(assignment
                  ? {
                      assignmentHash: assignment.assignmentHash,
                      panelCandidateAgentIds: assignment.panelCandidateAgentIds
                    }
                  : null)
              },
              revision: Number(arbitrationCase.revision ?? 0) + 1,
              updatedAt: nowAt
            },
            { path: "$" }
          );
          const responseBody = { arbitrationCase: nextCase, arbitrationCaseArtifact: null };
          const ops = [{ kind: "ARBITRATION_CASE_UPSERT", tenantId, caseId, arbitrationCase: nextCase }];
          if (idemStoreKey) {
            ops.push({ kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode: 200, body: responseBody } });
          }
          await commitTx(ops);
          let arbitrationCaseArtifact = null;
          try {
            arbitrationCaseArtifact = await emitArbitrationCaseArtifact({ tenantId, arbitrationCase: nextCase, at: nowAt });
          } catch {
            arbitrationCaseArtifact = null;
          }
          return sendJson(res, 200, { ...responseBody, arbitrationCaseArtifact });
        }

        if (action === "evidence") {
          let caseId = null;
          try {
            caseId = parseCaseIdFromBody();
          } catch (err) {
            return sendError(res, 400, "invalid arbitration case id", { message: err?.message });
          }
          if (!caseId) return sendError(res, 400, "caseId is required");
          const loaded = await loadCaseOrError(caseId, { requireOpen: true });
          if (loaded.error) return;
          const arbitrationCase = loaded.arbitrationCase;
          const evidenceRef = typeof body?.evidenceRef === "string" && body.evidenceRef.trim() !== "" ? body.evidenceRef.trim() : null;
          if (!evidenceRef) return sendError(res, 400, "evidenceRef is required");
          const mergedEvidenceRefs = mergeUniqueStringArrays(arbitrationCase?.evidenceRefs, [evidenceRef]);
          try {
            assertArbitrationCaseEvidenceBoundToDisputeContext({ settlement, evidenceRefs: mergedEvidenceRefs });
          } catch (err) {
            return sendError(res, 400, "invalid arbitration evidence", { message: err?.message });
          }
          let nextStatus = arbitrationCase.status;
          try {
            nextStatus = ensureArbitrationCaseStatusTransition({
              currentStatus: arbitrationCase.status,
              nextStatus:
                normalizeArbitrationCaseStatus(arbitrationCase.status) === ARBITRATION_CASE_STATUS.OPEN
                  ? ARBITRATION_CASE_STATUS.UNDER_REVIEW
                  : arbitrationCase.status
            });
          } catch (err) {
            return sendError(res, 409, "arbitration transition rejected", { message: err?.message });
          }
          const nextCase = normalizeForCanonicalJson(
            {
              ...arbitrationCase,
              status: nextStatus,
              evidenceRefs: mergedEvidenceRefs,
              revision: Number(arbitrationCase.revision ?? 0) + 1,
              updatedAt: nowAt
            },
            { path: "$" }
          );
          const responseBody = {
            arbitrationCase: nextCase,
            arbitrationCaseArtifact: null
          };
          const ops = [{ kind: "ARBITRATION_CASE_UPSERT", tenantId, caseId, arbitrationCase: nextCase }];
          if (idemStoreKey) {
            ops.push({ kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode: 200, body: responseBody } });
          }
          await commitTx(ops);
          let arbitrationCaseArtifact = null;
          try {
            arbitrationCaseArtifact = await emitArbitrationCaseArtifact({ tenantId, arbitrationCase: nextCase, at: nowAt });
          } catch {
            arbitrationCaseArtifact = null;
          }
          return sendJson(res, 200, { ...responseBody, arbitrationCaseArtifact });
        }

        if (action === "verdict") {
          let caseId = null;
          try {
            caseId = parseCaseIdFromBody();
          } catch (err) {
            return sendError(res, 400, "invalid arbitration case id", { message: err?.message });
          }
          if (!caseId) return sendError(res, 400, "caseId is required");
          const loaded = await loadCaseOrError(caseId, { requireOpen: true });
          if (loaded.error) return;
          const arbitrationCase = loaded.arbitrationCase;
          const currentStatus = normalizeArbitrationCaseStatus(arbitrationCase.status);
          if (currentStatus !== ARBITRATION_CASE_STATUS.OPEN && currentStatus !== ARBITRATION_CASE_STATUS.UNDER_REVIEW) {
            return sendError(res, 409, "arbitration case cannot accept verdict in current status");
          }
          let signedArbitrationVerdict = null;
          try {
            signedArbitrationVerdict = await parseSignedArbitrationVerdict({
              tenantId,
              runId,
              settlement,
              disputeId: arbitrationCase.disputeId,
              arbitrationVerdictInput: body?.arbitrationVerdict
            });
            if (String(signedArbitrationVerdict.caseId ?? "") !== String(caseId)) {
              throw new TypeError("arbitrationVerdict.caseId must match caseId");
            }
            assertArbitrationVerdictEvidenceBoundToDisputeContext({ settlement, arbitrationVerdict: signedArbitrationVerdict });
            assertArbitrationVerdictEvidenceBoundToCase({ arbitrationCase, arbitrationVerdict: signedArbitrationVerdict });
          } catch (err) {
            return sendError(res, 400, "invalid arbitration verdict", { message: err?.message });
          }
          const nowMs = Date.parse(nowAt);
          const endsAtMs = settlementDisputeWindowEndsAtMs(settlement);
          const verdictIssuedAtMs =
            signedArbitrationVerdict?.issuedAt && Number.isFinite(Date.parse(String(signedArbitrationVerdict.issuedAt)))
              ? Date.parse(String(signedArbitrationVerdict.issuedAt))
              : Number.NaN;
          if (!Number.isFinite(endsAtMs) || !Number.isFinite(nowMs) || nowMs > endsAtMs || !Number.isFinite(verdictIssuedAtMs) || verdictIssuedAtMs > endsAtMs) {
            return sendError(res, 409, "appeal window has closed");
          }

          const nextCase = normalizeForCanonicalJson(
            {
              ...arbitrationCase,
              arbiterAgentId: signedArbitrationVerdict.arbiterAgentId ?? arbitrationCase.arbiterAgentId ?? null,
              status: ARBITRATION_CASE_STATUS.VERDICT_ISSUED,
              summary: signedArbitrationVerdict.rationale ?? arbitrationCase.summary ?? null,
              evidenceRefs: mergeUniqueStringArrays(arbitrationCase.evidenceRefs, signedArbitrationVerdict.evidenceRefs),
              verdictId: signedArbitrationVerdict.verdictId,
              verdictHash: signedArbitrationVerdict.verdictHash,
              metadata: {
                ...(arbitrationCase?.metadata && typeof arbitrationCase.metadata === "object" ? arbitrationCase.metadata : {}),
                verdictOutcome: signedArbitrationVerdict.outcome ?? null,
                verdictReleaseRatePct: signedArbitrationVerdict.releaseRatePct ?? null,
                verdictIssuedAt: signedArbitrationVerdict.issuedAt ?? nowAt,
                verdictSignerKeyId: signedArbitrationVerdict.signerKeyId ?? null
              },
              revision: Number(arbitrationCase.revision ?? 0) + 1,
              updatedAt: nowAt
            },
            { path: "$" }
          );
          const responseBody = {
            arbitrationCase: nextCase,
            arbitrationVerdict: signedArbitrationVerdict,
            arbitrationCaseArtifact: null,
            arbitrationVerdictArtifact: null
          };
          const ops = [{ kind: "ARBITRATION_CASE_UPSERT", tenantId, caseId, arbitrationCase: nextCase }];
          if (idemStoreKey) {
            ops.push({ kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode: 200, body: responseBody } });
          }
          await commitTx(ops);
          let arbitrationCaseArtifact = null;
          let arbitrationVerdictArtifact = null;
          try {
            arbitrationCaseArtifact = await emitArbitrationCaseArtifact({ tenantId, arbitrationCase: nextCase, at: nowAt });
          } catch {
            arbitrationCaseArtifact = null;
          }
          try {
            arbitrationVerdictArtifact = await emitArbitrationVerdictArtifact({
              tenantId,
              runId,
              settlement,
              arbitrationVerdict: signedArbitrationVerdict
            });
          } catch {
            arbitrationVerdictArtifact = null;
          }
          return sendJson(res, 200, { ...responseBody, arbitrationCaseArtifact, arbitrationVerdictArtifact });
        }

        if (action === "close") {
          let caseId = null;
          try {
            caseId = parseCaseIdFromBody();
          } catch (err) {
            return sendError(res, 400, "invalid arbitration case id", { message: err?.message });
          }
          if (!caseId) return sendError(res, 400, "caseId is required");
          const loaded = await loadCaseOrError(caseId, { requireOpen: true });
          if (loaded.error) return;
          const arbitrationCase = loaded.arbitrationCase;
          const currentStatus = normalizeArbitrationCaseStatus(arbitrationCase.status);
          if (currentStatus !== ARBITRATION_CASE_STATUS.VERDICT_ISSUED) {
            return sendError(res, 409, "arbitration case can only be closed after verdict_issued");
          }

          const closedSummary =
            body?.summary === undefined || body?.summary === null
              ? arbitrationCase?.summary ?? null
              : typeof body?.summary === "string" && body.summary.trim() !== ""
                ? body.summary.trim()
                : null;
          if (body?.summary !== undefined && body?.summary !== null && closedSummary === null) {
            return sendError(res, 400, "summary must be a non-empty string when provided");
          }

          let nextSettlement = settlement;
          if (String(settlement?.disputeStatus ?? "").toLowerCase() === AGENT_RUN_SETTLEMENT_DISPUTE_STATUS.OPEN) {
            const verdictOutcome = String(arbitrationCase?.metadata?.verdictOutcome ?? "").toLowerCase();
            if (verdictOutcome !== "accepted" && verdictOutcome !== "rejected" && verdictOutcome !== "partial") {
              return sendError(res, 409, "arbitration verdict outcome missing for settlement finalization");
            }
            try {
              nextSettlement = updateAgentRunSettlementDispute({
                settlement,
                action: "close",
                disputeId: arbitrationCase.disputeId,
                resolutionInput: {
                  outcome: verdictOutcome,
                  escalationLevel: AGENT_RUN_SETTLEMENT_DISPUTE_ESCALATION_LEVEL.L2_ARBITER,
                  closedByAgentId: arbitrationCase.arbiterAgentId ?? null,
                  summary: closedSummary ?? null,
                  evidenceRefs: Array.isArray(arbitrationCase.evidenceRefs) ? arbitrationCase.evidenceRefs : []
                },
                at: nowAt
              });
            } catch (err) {
              return sendError(res, 409, "settlement finality transition rejected", { message: err?.message });
            }
            nextSettlement = {
              ...nextSettlement,
              disputeVerdictId: arbitrationCase.verdictId ?? nextSettlement.disputeVerdictId ?? null,
              disputeVerdictHash: arbitrationCase.verdictHash ?? nextSettlement.disputeVerdictHash ?? null,
              disputeVerdictArtifactId:
                arbitrationCase.verdictId ? `arbitration_verdict_${String(arbitrationCase.verdictId)}` : nextSettlement.disputeVerdictArtifactId ?? null,
              disputeVerdictSignerKeyId: arbitrationCase?.metadata?.verdictSignerKeyId ?? nextSettlement.disputeVerdictSignerKeyId ?? null,
              disputeVerdictIssuedAt: arbitrationCase?.metadata?.verdictIssuedAt ?? nextSettlement.disputeVerdictIssuedAt ?? null,
              revision: Number(nextSettlement.revision ?? 0) + 1,
              updatedAt: nowAt
            };
          }

          const nextCase = normalizeForCanonicalJson(
            {
              ...arbitrationCase,
              status: ARBITRATION_CASE_STATUS.CLOSED,
              closedAt: nowAt,
              summary: closedSummary ?? null,
              revision: Number(arbitrationCase.revision ?? 0) + 1,
              updatedAt: nowAt
            },
            { path: "$" }
          );
          const responseBody = {
            arbitrationCase: nextCase,
            settlement: nextSettlement,
            arbitrationCaseArtifact: null
          };
          const ops = [{ kind: "ARBITRATION_CASE_UPSERT", tenantId, caseId, arbitrationCase: nextCase }];
          if (nextSettlement !== settlement) {
            ops.push({ kind: "AGENT_RUN_SETTLEMENT_UPSERT", tenantId, runId, settlement: nextSettlement });
          }
          if (idemStoreKey) {
            ops.push({ kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode: 200, body: responseBody } });
          }
          await commitTx(ops);
          let arbitrationCaseArtifact = null;
          try {
            arbitrationCaseArtifact = await emitArbitrationCaseArtifact({ tenantId, arbitrationCase: nextCase, at: nowAt });
          } catch {
            arbitrationCaseArtifact = null;
          }
          return sendJson(res, 200, { ...responseBody, arbitrationCaseArtifact });
        }

        if (action === "appeal") {
          const parentCaseId =
            typeof body?.parentCaseId === "string" && body.parentCaseId.trim() !== "" ? body.parentCaseId.trim() : null;
          if (!parentCaseId) return sendError(res, 400, "parentCaseId is required");
          const loadedParent = await loadCaseOrError(parentCaseId, { requireOpen: false });
          if (loadedParent.error) return;
          const parentCase = loadedParent.arbitrationCase;
          const parentStatus = normalizeArbitrationCaseStatus(parentCase.status);
          if (parentStatus !== ARBITRATION_CASE_STATUS.VERDICT_ISSUED && parentStatus !== ARBITRATION_CASE_STATUS.CLOSED) {
            return sendError(res, 409, "appeal requires parent case in verdict_issued or closed state");
          }
          if (!parentCase.verdictId || !parentCase.verdictHash) {
            return sendError(res, 409, "appeal requires parent case verdict metadata");
          }
          const nowMs = Date.parse(nowAt);
          const endsAtMs = settlementDisputeWindowEndsAtMs(settlement);
          if (!Number.isFinite(endsAtMs) || !Number.isFinite(nowMs) || nowMs > endsAtMs) {
            return sendError(res, 409, "appeal window has closed");
          }

          let caseId = null;
          try {
            caseId = parseCaseIdFromBody() ?? createId("arb_case");
          } catch (err) {
            return sendError(res, 400, "invalid arbitration case id", { message: err?.message });
          }
          let existingCase = null;
          try {
            existingCase = await getArbitrationCaseRecord({ tenantId, caseId });
          } catch (err) {
            return sendError(res, 501, "arbitration cases not supported for this store", { message: err?.message });
          }
          if (existingCase) return sendError(res, 409, "arbitration case already exists");

          let evidenceRefs = [];
          try {
            evidenceRefs = normalizeArbitrationCaseEvidenceRefs(
              Array.isArray(body?.evidenceRefs) ? body.evidenceRefs : parentCase.evidenceRefs ?? [],
              { fieldName: "evidenceRefs" }
            );
            assertArbitrationCaseEvidenceBoundToDisputeContext({ settlement, evidenceRefs });
          } catch (err) {
            return sendError(res, 400, "invalid arbitration evidence", { message: err?.message });
          }

          let arbiterAgentId = null;
          let assignment = null;
          try {
            arbiterAgentId = parseOptionalNonEmptyString(body?.arbiterAgentId, "arbiterAgentId");
          } catch (err) {
            return sendError(res, 400, "invalid arbiter assignment", { message: err?.message });
          }
          if (arbiterAgentId) {
            const arbiterIdentity = await getAgentIdentityRecord({ tenantId, agentId: arbiterAgentId });
            if (!arbiterIdentity) return sendError(res, 404, "arbiterAgentId not found");
          } else if (Array.isArray(body?.panelCandidateAgentIds) && body.panelCandidateAgentIds.length > 0) {
            try {
              assignment = await assignDeterministicArbiterAgentId({
                tenantId,
                runId,
                disputeId,
                panelCandidateAgentIds: body.panelCandidateAgentIds
              });
            } catch (err) {
              return sendError(res, 400, "invalid arbitration panel assignment", { message: err?.message });
            }
            arbiterAgentId = assignment.arbiterAgentId;
          } else {
            arbiterAgentId = parentCase.arbiterAgentId ?? null;
          }
          if (!arbiterAgentId) return sendError(res, 400, "arbiterAgentId or panelCandidateAgentIds is required");

          const appealReason =
            body?.reason === undefined || body?.reason === null
              ? null
              : typeof body?.reason === "string" && body.reason.trim() !== ""
                ? body.reason.trim()
                : null;
          if (body?.reason !== undefined && body?.reason !== null && appealReason === null) {
            return sendError(res, 400, "reason must be a non-empty string when provided");
          }
          const appealRef = {
            parentCaseId,
            parentVerdictId:
              typeof body?.parentVerdictId === "string" && body.parentVerdictId.trim() !== ""
                ? body.parentVerdictId.trim()
                : parentCase.verdictId,
            reason: appealReason
          };

          const appealCase = normalizeForCanonicalJson(
            {
              schemaVersion: "ArbitrationCase.v1",
              caseId,
              tenantId: normalizeTenant(tenantId),
              runId: String(runId),
              settlementId: String(settlement?.settlementId ?? ""),
              disputeId: String(disputeId),
              claimantAgentId: String(parentCase.claimantAgentId ?? settlement?.payerAgentId ?? ""),
              respondentAgentId: String(parentCase.respondentAgentId ?? settlement?.agentId ?? ""),
              arbiterAgentId,
              priority:
                normalizeArbitrationCasePriority(parentCase?.priority, { fieldName: "parentCase.priority", allowNull: true }) ??
                normalizeArbitrationCasePriority(settlement?.disputeContext?.priority, {
                  fieldName: "settlement.disputeContext.priority",
                  allowNull: true
                }) ??
                AGENT_RUN_SETTLEMENT_DISPUTE_PRIORITY.NORMAL,
              status: ARBITRATION_CASE_STATUS.UNDER_REVIEW,
              openedAt: nowAt,
              closedAt: null,
              summary:
                typeof body?.summary === "string" && body.summary.trim() !== ""
                  ? body.summary.trim()
                  : null,
              evidenceRefs,
              appealRef,
              metadata: assignment
                ? {
                    assignmentHash: assignment.assignmentHash,
                    panelCandidateAgentIds: assignment.panelCandidateAgentIds
                  }
                : null,
              revision: 1,
              createdAt: nowAt,
              updatedAt: nowAt
            },
            { path: "$" }
          );

          const responseBody = { arbitrationCase: appealCase, arbitrationCaseArtifact: null };
          const ops = [{ kind: "ARBITRATION_CASE_UPSERT", tenantId, caseId, arbitrationCase: appealCase }];
          if (idemStoreKey) {
            ops.push({ kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode: 201, body: responseBody } });
          }
          await commitTx(ops);
          await emitBillableUsageEventBestEffort(
            {
              tenantId,
              eventKey: `arbitration_usage:${String(caseId)}:case`,
              eventType: BILLABLE_USAGE_EVENT_TYPE.ARBITRATION_USAGE,
              occurredAt: nowAt,
              quantity: 1,
              runId,
              settlementId: settlement?.settlementId ?? null,
              disputeId: appealCase?.disputeId ?? disputeId,
              arbitrationCaseId: caseId,
              sourceType: "arbitration_case",
              sourceId: caseId,
              sourceEventId: null,
              audit: {
                route: path,
                method: "POST",
                action: "appeal",
                parentCaseId
              }
            },
            { context: "arbitration_case.appeal" }
          );
          let arbitrationCaseArtifact = null;
          try {
            arbitrationCaseArtifact = await emitArbitrationCaseArtifact({ tenantId, arbitrationCase: appealCase, at: nowAt });
          } catch {
            arbitrationCaseArtifact = null;
          }
          return sendJson(res, 201, { ...responseBody, arbitrationCaseArtifact });
        }
      }

      if (parts[0] === "runs" && parts[1] && parts[2] === "dispute" && parts.length === 4 && req.method === "POST") {
        if (!requireProtocolHeaderForWrite(req, res)) return;
        const runId = parts[1];
        const action = parts[3];
        if (action !== "open" && action !== "close" && action !== "evidence" && action !== "escalate") return sendError(res, 404, "not found");

        const body = await readJsonBody(req);
        let idemStoreKey = null;
        let idemRequestHash = null;
        try {
          ({ idemStoreKey, idemRequestHash } = readIdempotency({ method: "POST", requestPath: path, expectedPrevChainHash: null, body }));
        } catch (err) {
          return sendError(res, 400, "invalid idempotency key", { message: err?.message });
        }
        if (idemStoreKey) {
          const existing = store.idempotency.get(idemStoreKey);
          if (existing) {
            if (existing.requestHash !== idemRequestHash) {
              return sendError(res, 409, "idempotency key conflict", "request differs from initial use of this key");
            }
            return sendJson(res, existing.statusCode, existing.body);
          }
        }

        let settlement = null;
        try {
          settlement = await getAgentRunSettlementRecord({ tenantId, runId });
        } catch (err) {
          return sendError(res, 501, "agent run settlements not supported for this store", { message: err?.message });
        }
        if (!settlement) return sendError(res, 404, "run settlement not found");
        if (settlement.status === AGENT_RUN_SETTLEMENT_STATUS.LOCKED) {
          return sendError(res, 409, "cannot dispute settlement before resolution");
        }

        const nowAt = nowIso();
        if (action === "open") {
          const endsAt = settlementDisputeWindowEndsAtMs(settlement);
          const nowMs = Date.parse(nowAt);
          if (!Number.isFinite(endsAt) || !Number.isFinite(nowMs) || nowMs > endsAt) {
            return sendError(res, 409, "dispute window has closed");
          }
        }

        let signedVerdict = null;
        let signedArbitrationVerdict = null;
        if (action === "close" && body?.verdict !== undefined && body?.verdict !== null) {
          try {
            signedVerdict = await parseSignedDisputeVerdict({
              tenantId,
              runId,
              settlement,
              disputeId: body?.disputeId ?? settlement?.disputeId ?? null,
              verdictInput: body?.verdict
            });
          } catch (err) {
            return sendError(res, 400, "invalid dispute verdict", { message: err?.message });
          }
        }
        if (action === "close" && body?.arbitrationVerdict !== undefined && body?.arbitrationVerdict !== null) {
          try {
            signedArbitrationVerdict = await parseSignedArbitrationVerdict({
              tenantId,
              runId,
              settlement,
              disputeId: body?.disputeId ?? settlement?.disputeId ?? null,
              arbitrationVerdictInput: body?.arbitrationVerdict
            });
            assertArbitrationVerdictEvidenceBoundToDisputeContext({
              settlement,
              arbitrationVerdict: signedArbitrationVerdict
            });
          } catch (err) {
            return sendError(res, 400, "invalid arbitration verdict", { message: err?.message });
          }
        }

        let disputeEvidence = null;
        let disputeEscalation = null;
        const disputeContextInput =
          action === "open"
            ? {
                type: body?.disputeType ?? body?.type,
                priority: body?.disputePriority ?? body?.priority,
                openedByAgentId: body?.openedByAgentId ?? null,
                reason: body?.reason ?? null,
                evidenceRefs: body?.evidenceRefs,
                channel: body?.disputeChannel ?? body?.channel,
                escalationLevel: body?.escalationLevel
              }
            : null;
        let resolutionInput = null;
        if (action === "close") {
          const resolution = body?.resolution;
          if (resolution !== undefined && resolution !== null && (typeof resolution !== "object" || Array.isArray(resolution))) {
            return sendError(res, 400, "resolution must be an object or null");
          }
          const mergedResolution = resolution && typeof resolution === "object" && !Array.isArray(resolution) ? { ...resolution } : {};
          if (body?.resolutionOutcome !== undefined) mergedResolution.outcome = body.resolutionOutcome;
          if (body?.closedByAgentId !== undefined) mergedResolution.closedByAgentId = body.closedByAgentId;
          if (body?.resolutionSummary !== undefined) mergedResolution.summary = body.resolutionSummary;
          if (body?.resolutionEscalationLevel !== undefined) mergedResolution.escalationLevel = body.resolutionEscalationLevel;
          if (body?.resolutionEvidenceRefs !== undefined) mergedResolution.evidenceRefs = body.resolutionEvidenceRefs;
          resolutionInput = mergedResolution;
        }
        if (action === "close" && (signedVerdict || signedArbitrationVerdict)) {
          const nowMs = Date.parse(nowAt);
          const endsAtMs = settlementDisputeWindowEndsAtMs(settlement);
          const verdictIssuedAtMs =
            signedVerdict?.issuedAt && Number.isFinite(Date.parse(String(signedVerdict.issuedAt)))
              ? Date.parse(String(signedVerdict.issuedAt))
              : Number.NaN;
          const arbitrationVerdictIssuedAtMs =
            signedArbitrationVerdict?.issuedAt && Number.isFinite(Date.parse(String(signedArbitrationVerdict.issuedAt)))
              ? Date.parse(String(signedArbitrationVerdict.issuedAt))
              : Number.NaN;
          if (
            !Number.isFinite(endsAtMs) ||
            !Number.isFinite(nowMs) ||
            nowMs > endsAtMs ||
            (signedVerdict && (!Number.isFinite(verdictIssuedAtMs) || verdictIssuedAtMs > endsAtMs)) ||
            (signedArbitrationVerdict &&
              (!Number.isFinite(arbitrationVerdictIssuedAtMs) || arbitrationVerdictIssuedAtMs > endsAtMs))
          ) {
            return sendError(res, 409, "appeal window has closed");
          }
          if (!resolutionInput || typeof resolutionInput !== "object" || Array.isArray(resolutionInput)) resolutionInput = {};
          if (
            (resolutionInput.outcome === undefined || resolutionInput.outcome === null || String(resolutionInput.outcome).trim() === "") &&
            signedVerdict
          ) {
            resolutionInput.outcome = signedVerdict.outcome;
          }
          if (
            (resolutionInput.outcome === undefined || resolutionInput.outcome === null || String(resolutionInput.outcome).trim() === "") &&
            signedArbitrationVerdict
          ) {
            resolutionInput.outcome = signedArbitrationVerdict.outcome;
          }
          if (
            (resolutionInput.summary === undefined || resolutionInput.summary === null || String(resolutionInput.summary).trim() === "") &&
            signedVerdict
          ) {
            resolutionInput.summary = signedVerdict.rationale ?? null;
          }
          if (
            (resolutionInput.summary === undefined || resolutionInput.summary === null || String(resolutionInput.summary).trim() === "") &&
            signedArbitrationVerdict
          ) {
            resolutionInput.summary = signedArbitrationVerdict.rationale ?? null;
          }
          if ((resolutionInput.closedByAgentId === undefined || resolutionInput.closedByAgentId === null) && signedVerdict) {
            resolutionInput.closedByAgentId = signedVerdict.arbiterAgentId ?? null;
          }
          if ((resolutionInput.closedByAgentId === undefined || resolutionInput.closedByAgentId === null) && signedArbitrationVerdict) {
            resolutionInput.closedByAgentId = signedArbitrationVerdict.arbiterAgentId ?? null;
          }
        }

        if (action === "open" || action === "close") {
          try {
            settlement = updateAgentRunSettlementDispute({
              settlement,
              action,
              disputeId: body?.disputeId ?? null,
              contextInput: disputeContextInput,
              resolutionInput,
              at: nowAt
            });
          } catch (err) {
            return sendError(res, 409, "dispute transition rejected", { message: err?.message });
          }
        } else if (action === "evidence") {
          const evidenceRef = typeof body?.evidenceRef === "string" && body.evidenceRef.trim() !== "" ? body.evidenceRef.trim() : null;
          if (!evidenceRef) return sendError(res, 400, "evidenceRef is required");
          const submittedByAgentId =
            body?.submittedByAgentId === undefined || body?.submittedByAgentId === null
              ? null
              : typeof body?.submittedByAgentId === "string" && body.submittedByAgentId.trim() !== ""
                ? body.submittedByAgentId.trim()
                : null;
          if (body?.submittedByAgentId !== undefined && submittedByAgentId === null) {
            return sendError(res, 400, "submittedByAgentId must be a non-empty string when provided");
          }
          const reason =
            body?.reason === undefined || body?.reason === null
              ? null
              : typeof body?.reason === "string" && body.reason.trim() !== ""
                ? body.reason.trim()
                : null;
          if (body?.reason !== undefined && reason === null) {
            return sendError(res, 400, "reason must be a non-empty string when provided");
          }
          try {
            settlement = patchAgentRunSettlementDisputeContext({
              settlement,
              contextPatch: {
                openedByAgentId: submittedByAgentId ?? undefined,
                reason: reason ?? undefined
              },
              appendEvidenceRefs: [evidenceRef],
              at: nowAt
            });
          } catch (err) {
            return sendError(res, 409, "dispute evidence rejected", { message: err?.message });
          }
          disputeEvidence = {
            evidenceRef,
            submittedAt: nowAt,
            submittedByAgentId: submittedByAgentId ?? null
          };
        } else if (action === "escalate") {
          const requestedEscalationLevel =
            typeof body?.escalationLevel === "string" && body.escalationLevel.trim() !== "" ? body.escalationLevel.trim().toLowerCase() : null;
          if (!requestedEscalationLevel) return sendError(res, 400, "escalationLevel is required");
          if (!Object.values(AGENT_RUN_SETTLEMENT_DISPUTE_ESCALATION_LEVEL).includes(requestedEscalationLevel)) {
            return sendError(res, 400, "invalid escalationLevel");
          }
          const currentEscalationLevel = String(
            settlement?.disputeContext?.escalationLevel ?? AGENT_RUN_SETTLEMENT_DISPUTE_ESCALATION_LEVEL.L1_COUNTERPARTY
          ).toLowerCase();
          const escalationRank = new Map([
            [AGENT_RUN_SETTLEMENT_DISPUTE_ESCALATION_LEVEL.L1_COUNTERPARTY, 1],
            [AGENT_RUN_SETTLEMENT_DISPUTE_ESCALATION_LEVEL.L2_ARBITER, 2],
            [AGENT_RUN_SETTLEMENT_DISPUTE_ESCALATION_LEVEL.L3_EXTERNAL, 3]
          ]);
          const currentRank = escalationRank.get(currentEscalationLevel) ?? 1;
          const requestedRank = escalationRank.get(requestedEscalationLevel) ?? 0;
          if (requestedRank < currentRank) {
            return sendError(res, 409, "escalationLevel cannot downgrade an active dispute");
          }
          const channelByEscalationLevel = new Map([
            [AGENT_RUN_SETTLEMENT_DISPUTE_ESCALATION_LEVEL.L1_COUNTERPARTY, AGENT_RUN_SETTLEMENT_DISPUTE_CHANNEL.COUNTERPARTY],
            [AGENT_RUN_SETTLEMENT_DISPUTE_ESCALATION_LEVEL.L2_ARBITER, AGENT_RUN_SETTLEMENT_DISPUTE_CHANNEL.ARBITER],
            [AGENT_RUN_SETTLEMENT_DISPUTE_ESCALATION_LEVEL.L3_EXTERNAL, AGENT_RUN_SETTLEMENT_DISPUTE_CHANNEL.EXTERNAL]
          ]);
          const requestedChannel = body?.channel;
          const channelInput =
            typeof requestedChannel === "string" && requestedChannel.trim() !== ""
              ? requestedChannel.trim().toLowerCase()
              : channelByEscalationLevel.get(requestedEscalationLevel) ?? AGENT_RUN_SETTLEMENT_DISPUTE_CHANNEL.COUNTERPARTY;
          if (!Object.values(AGENT_RUN_SETTLEMENT_DISPUTE_CHANNEL).includes(channelInput)) {
            return sendError(res, 400, "invalid channel");
          }
          const reason =
            body?.reason === undefined || body?.reason === null
              ? undefined
              : typeof body?.reason === "string" && body.reason.trim() !== ""
                ? body.reason.trim()
                : null;
          if (body?.reason !== undefined && reason === null) {
            return sendError(res, 400, "reason must be a non-empty string when provided");
          }
          const escalatedByAgentId =
            body?.escalatedByAgentId === undefined || body?.escalatedByAgentId === null
              ? null
              : typeof body?.escalatedByAgentId === "string" && body.escalatedByAgentId.trim() !== ""
                ? body.escalatedByAgentId.trim()
                : null;
          if (body?.escalatedByAgentId !== undefined && escalatedByAgentId === null) {
            return sendError(res, 400, "escalatedByAgentId must be a non-empty string when provided");
          }
          try {
            settlement = patchAgentRunSettlementDisputeContext({
              settlement,
              contextPatch: {
                escalationLevel: requestedEscalationLevel,
                channel: channelInput,
                reason
              },
              at: nowAt
            });
          } catch (err) {
            return sendError(res, 409, "dispute escalation rejected", { message: err?.message });
          }
          disputeEscalation = {
            previousEscalationLevel: currentEscalationLevel,
            escalationLevel: requestedEscalationLevel,
            channel: channelInput,
            escalatedAt: nowAt,
            escalatedByAgentId: escalatedByAgentId ?? null
          };
        }

        if (action === "close" && signedVerdict) {
          settlement = {
            ...settlement,
            disputeVerdictId: signedVerdict.verdictId,
            disputeVerdictHash: signedVerdict.verdictHash,
            disputeVerdictArtifactId: `dispute_verdict_${String(signedVerdict.verdictId)}`,
            disputeVerdictSignerKeyId: signedVerdict.signerKeyId ?? null,
            disputeVerdictIssuedAt: signedVerdict.issuedAt ?? nowAt,
            revision: Number(settlement.revision ?? 0) + 1,
            updatedAt: nowAt
          };
        }

        const responseBody = {
          settlement,
          disputeEvidence: disputeEvidence ?? null,
          disputeEscalation: disputeEscalation ?? null
        };
        const finalResponseBody = {
          ...responseBody,
          verdict: signedVerdict,
          verdictArtifact: null,
          arbitrationVerdict: signedArbitrationVerdict,
          arbitrationCaseArtifact: null,
          arbitrationVerdictArtifact: null
        };
        const ops = [{ kind: "AGENT_RUN_SETTLEMENT_UPSERT", tenantId, runId, settlement }];
        if (idemStoreKey) {
          ops.push({ kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode: 200, body: finalResponseBody } });
        }
        await commitTx(ops);
        if (action === "close" && signedArbitrationVerdict) {
          await emitBillableUsageEventBestEffort(
            {
              tenantId,
              eventKey: `arbitration_usage:${String(signedArbitrationVerdict.caseId ?? settlement?.disputeId ?? runId)}:case`,
              eventType: BILLABLE_USAGE_EVENT_TYPE.ARBITRATION_USAGE,
              occurredAt: signedArbitrationVerdict.issuedAt ?? nowAt,
              quantity: 1,
              runId,
              settlementId: settlement?.settlementId ?? null,
              disputeId: settlement?.disputeId ?? null,
              arbitrationCaseId: signedArbitrationVerdict.caseId ?? null,
              sourceType: "arbitration_verdict",
              sourceId: signedArbitrationVerdict.verdictId ?? null,
              sourceEventId: signedArbitrationVerdict.verdictId ?? null,
              audit: {
                route: path,
                method: "POST",
                action: "close",
                arbiterAgentId: signedArbitrationVerdict.arbiterAgentId ?? null
              }
            },
            { context: "arbitration_verdict.close" }
          );
        }
        let verdictArtifact = null;
        let arbitrationCaseArtifact = null;
        let arbitrationVerdictArtifact = null;
        if (action === "close" && signedVerdict) {
          try {
            verdictArtifact = await emitDisputeVerdictArtifact({
              tenantId,
              runId,
              settlement,
              verdict: signedVerdict
            });
          } catch {
            verdictArtifact = null;
          }
        }
        if (action === "close" && signedArbitrationVerdict) {
          try {
            arbitrationCaseArtifact = await emitArbitrationCaseArtifact({
              tenantId,
              runId,
              settlement,
              arbitrationVerdict: signedArbitrationVerdict,
              at: nowAt
            });
          } catch {
            arbitrationCaseArtifact = null;
          }
          try {
            arbitrationVerdictArtifact = await emitArbitrationVerdictArtifact({
              tenantId,
              runId,
              settlement,
              arbitrationVerdict: signedArbitrationVerdict
            });
          } catch {
            arbitrationVerdictArtifact = null;
          }
        }
        try {
          let eventType = "marketplace.dispute.updated";
          if (action === "open") eventType = "marketplace.dispute.opened";
          else if (action === "close") eventType = "marketplace.dispute.closed";
          else if (action === "evidence") eventType = "marketplace.dispute.evidence_submitted";
          else if (action === "escalate") eventType = "marketplace.dispute.escalated";
          await emitMarketplaceLifecycleArtifact({
            tenantId,
            eventType,
            runId,
            sourceEventId:
              action === "evidence"
                ? disputeEvidence?.evidenceRef ?? null
                : action === "escalate"
                  ? disputeEscalation?.escalationLevel ?? null
                  : body?.disputeId ?? null,
            settlement,
            details:
              action === "close"
                ? {
                    resolution: settlement?.disputeResolution ?? null,
                    verdict: signedVerdict ?? null,
                    verdictArtifact: verdictArtifact ?? null,
                    arbitrationVerdict: signedArbitrationVerdict ?? null,
                    arbitrationCaseArtifact: arbitrationCaseArtifact ?? null,
                    arbitrationVerdictArtifact: arbitrationVerdictArtifact ?? null
                  }
                : action === "evidence"
                  ? { context: settlement?.disputeContext ?? null, evidence: disputeEvidence ?? null }
                  : action === "escalate"
                    ? { context: settlement?.disputeContext ?? null, escalation: disputeEscalation ?? null }
                    : { context: settlement?.disputeContext ?? null }
          });
        } catch {
          // Best-effort lifecycle delivery.
        }
        return sendJson(res, 200, { ...finalResponseBody, verdictArtifact, arbitrationCaseArtifact, arbitrationVerdictArtifact });
      }

      if (parts[0] === "agents" && parts[1] && parts[1] !== "register") {
        const agentId = parts[1];
        let agentIdentity = null;
        if (typeof store.getAgentIdentity === "function") {
          try {
            agentIdentity = await store.getAgentIdentity({ tenantId, agentId });
          } catch (err) {
            return sendError(res, 400, "invalid agent id", { message: err?.message });
          }
        } else if (store.agentIdentities instanceof Map) {
          agentIdentity = store.agentIdentities.get(makeScopedKey({ tenantId, id: agentId })) ?? null;
        } else {
          return sendError(res, 501, "agent identities not supported for this store");
        }
        if (!agentIdentity) return sendError(res, 404, "agent identity not found");

        if (req.method === "GET" && parts.length === 2) {
          return sendJson(res, 200, { agentIdentity });
        }

        if (parts[2] === "reputation" && req.method === "GET" && parts.length === 3) {
          const reputationVersionRaw = url.searchParams.get("reputationVersion");
          const reputationWindowRaw = url.searchParams.get("reputationWindow");
          let reputationVersion = "v1";
          let reputationWindow = AGENT_REPUTATION_WINDOW.THIRTY_DAYS;
          try {
            reputationVersion = parseReputationVersion(reputationVersionRaw);
            reputationWindow = parseReputationWindow(reputationWindowRaw);
          } catch (err) {
            return sendError(res, 400, "invalid reputation query", { message: err?.message });
          }
          const reputation = await computeAgentReputationSnapshotVersioned({
            tenantId,
            agentId,
            at: nowIso(),
            reputationVersion,
            reputationWindow
          });
          return sendJson(res, 200, { reputation });
        }

        if (parts[2] === "wallet") {
          const hasWalletStore = typeof store.getAgentWallet === "function" || store.agentWallets instanceof Map;
          if (!hasWalletStore) return sendError(res, 501, "agent wallets not supported for this store");

          if (req.method === "GET" && parts.length === 3) {
            let wallet = null;
            try {
              wallet = await getAgentWalletRecord({ tenantId, agentId });
            } catch (err) {
              return sendError(res, 400, "invalid agent wallet query", { message: err?.message });
            }
            if (!wallet) {
              wallet = createAgentWallet({ tenantId, agentId, at: nowIso() });
            }
            return sendJson(res, 200, { wallet });
          }

          if (req.method === "POST" && parts[3] === "credit" && parts.length === 4) {
            if (!requireProtocolHeaderForWrite(req, res)) return;
            const body = await readJsonBody(req);
            let idemStoreKey = null;
            let idemRequestHash = null;
            try {
              ({ idemStoreKey, idemRequestHash } = readIdempotency({ method: "POST", requestPath: path, expectedPrevChainHash: null, body }));
            } catch (err) {
              return sendError(res, 400, "invalid idempotency key", { message: err?.message });
            }
            if (idemStoreKey) {
              const existing = store.idempotency.get(idemStoreKey);
              if (existing) {
                if (existing.requestHash !== idemRequestHash) {
                  return sendError(res, 409, "idempotency key conflict", "request differs from initial use of this key");
                }
                return sendJson(res, existing.statusCode, existing.body);
              }
            }

            const amountCents = Number(body?.amountCents);
            if (!Number.isSafeInteger(amountCents) || amountCents <= 0) return sendError(res, 400, "amountCents must be a positive safe integer");
            const currency = body?.currency ?? "USD";
            const nowAt = nowIso();

            let currentWallet = null;
            try {
              currentWallet = await getAgentWalletRecord({ tenantId, agentId });
            } catch (err) {
              return sendError(res, 400, "invalid agent wallet query", { message: err?.message });
            }
            const baseWallet = ensureAgentWallet({ wallet: currentWallet, tenantId, agentId, currency, at: nowAt });
            let wallet;
            try {
              wallet = creditAgentWallet({ wallet: baseWallet, amountCents, at: nowAt });
            } catch (err) {
              return sendError(res, 400, "wallet credit rejected", { message: err?.message, code: err?.code ?? null });
            }

            const responseBody = { wallet };
            const ops = [{ kind: "AGENT_WALLET_UPSERT", tenantId, wallet }];
            if (idemStoreKey) {
              ops.push({ kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode: 201, body: responseBody } });
            }
            await commitTx(ops);
            return sendJson(res, 201, responseBody);
          }
        }

        if (parts[2] === "runs") {
          const hasRunStore = typeof store.getAgentRun === "function" || store.agentRuns instanceof Map;
          const hasRunEventStore = typeof store.getAgentRunEvents === "function" || store.agentRunEvents instanceof Map;
          if (!hasRunStore || !hasRunEventStore) return sendError(res, 501, "agent runs not supported for this store");

          if (req.method === "GET" && parts.length === 3) {
            const status = url.searchParams.get("status");
            const limitRaw = url.searchParams.get("limit");
            const offsetRaw = url.searchParams.get("offset");
            const limit = limitRaw ? Number(limitRaw) : 200;
            const offset = offsetRaw ? Number(offsetRaw) : 0;
            const safeLimit = Number.isSafeInteger(limit) && limit > 0 ? Math.min(1000, limit) : 200;
            const safeOffset = Number.isSafeInteger(offset) && offset >= 0 ? offset : 0;

            let runs;
            if (typeof store.listAgentRuns === "function") {
              try {
                runs = await store.listAgentRuns({ tenantId, agentId, status: status ?? null, limit: safeLimit, offset: safeOffset });
              } catch (err) {
                return sendError(res, 400, "invalid agent run query", { message: err?.message });
              }
            } else {
              const all = listAgentRuns({ tenantId, agentId, status: status ?? null });
              runs = all.slice(safeOffset, safeOffset + safeLimit);
            }
            let total;
            if (typeof store.countAgentRuns === "function") {
              try {
                total = await store.countAgentRuns({ tenantId, agentId, status: status ?? null });
              } catch (err) {
                return sendError(res, 400, "invalid agent run query", { message: err?.message });
              }
            } else {
              total = listAgentRuns({ tenantId, agentId, status: status ?? null }).length;
            }
            return sendJson(res, 200, { runs, total, limit: safeLimit, offset: safeOffset });
          }

          if (req.method === "POST" && parts.length === 3) {
            if (!requireProtocolHeaderForWrite(req, res)) return;
            const body = await readJsonBody(req);
            let idemStoreKey = null;
            let idemRequestHash = null;
            try {
              ({ idemStoreKey, idemRequestHash } = readIdempotency({ method: "POST", requestPath: path, expectedPrevChainHash: null, body }));
            } catch (err) {
              return sendError(res, 400, "invalid idempotency key", { message: err?.message });
            }
            if (idemStoreKey) {
              const existing = store.idempotency.get(idemStoreKey);
              if (existing) {
                if (existing.requestHash !== idemRequestHash) {
                  return sendError(res, 409, "idempotency key conflict", "request differs from initial use of this key");
                }
                return sendJson(res, existing.statusCode, existing.body);
              }
            }

            const runId = body?.runId ? String(body.runId) : createId("run");
            let existingRun = null;
            if (typeof store.getAgentRun === "function") {
              existingRun = await store.getAgentRun({ tenantId, runId });
            } else if (store.agentRuns instanceof Map) {
              existingRun = store.agentRuns.get(runStoreKey(tenantId, runId)) ?? null;
            }
            if (existingRun && !idemStoreKey) return sendError(res, 409, "run already exists");

            let settlementRequest = null;
            if (body?.settlement !== undefined && body?.settlement !== null) {
              try {
                settlementRequest = validateAgentRunSettlementRequest(body.settlement);
              } catch (err) {
                return sendError(res, 400, "invalid run settlement payload", { message: err?.message });
              }
              const hasWalletStore = typeof store.getAgentWallet === "function" || store.agentWallets instanceof Map;
              const hasSettlementStore = typeof store.getAgentRunSettlement === "function" || store.agentRunSettlements instanceof Map;
              if (!hasWalletStore || !hasSettlementStore) {
                return sendError(res, 501, "agent wallets/settlements not supported for this store");
              }
            }

            const createdPayload = {
              runId,
              agentId,
              tenantId,
              taskType: body?.taskType ?? null,
              inputRef: body?.inputRef ?? null
            };
            try {
              validateRunCreatedPayload(createdPayload);
            } catch (err) {
              return sendError(res, 400, "invalid run payload", { message: err?.message });
            }

            const createdEvent = createChainedEvent({
              streamId: runId,
              type: AGENT_RUN_EVENT_TYPE.RUN_CREATED,
              actor: { type: "agent", id: agentId },
              payload: createdPayload,
              at: nowIso()
            });
            const events = normalizeAgentRunEventRecords(appendChainedEvent({ events: [], event: createdEvent, signer: serverSigner }));
            let run;
            try {
              run = reduceAgentRun(events);
            } catch (err) {
              return sendError(res, 400, "run creation rejected", { message: err?.message });
            }

            const nowAt = events[events.length - 1]?.at ?? nowIso();
            const ops = [{ kind: "AGENT_RUN_EVENTS_APPENDED", tenantId, runId, events }];
            let settlement = null;
            if (settlementRequest) {
              let payerIdentity = null;
              if (typeof store.getAgentIdentity === "function") {
                payerIdentity = await store.getAgentIdentity({ tenantId, agentId: settlementRequest.payerAgentId });
              } else if (store.agentIdentities instanceof Map) {
                payerIdentity = store.agentIdentities.get(makeScopedKey({ tenantId, id: settlementRequest.payerAgentId })) ?? null;
              }
	              if (!payerIdentity) return sendError(res, 404, "payer agent identity not found");
	
	              try {
	                await assertSettlementWithinWalletPolicy({
	                  tenantId,
	                  agentIdentity: payerIdentity,
	                  amountCents: settlementRequest.amountCents,
	                  at: nowAt
	                });
	              } catch (err) {
	                return sendError(res, 409, "wallet policy blocked settlement", { message: err?.message, code: err?.code ?? null });
	              }

              let payerWallet = null;
              try {
                const existingPayerWallet = await getAgentWalletRecord({ tenantId, agentId: settlementRequest.payerAgentId });
                const basePayerWallet = ensureAgentWallet({
                  wallet: existingPayerWallet,
                  tenantId,
                  agentId: settlementRequest.payerAgentId,
                  currency: settlementRequest.currency,
                  at: nowAt
                });
                payerWallet = lockAgentWalletEscrow({ wallet: basePayerWallet, amountCents: settlementRequest.amountCents, at: nowAt });
                projectEscrowLedgerOperation({
                  tenantId,
                  settlement: {
                    payerAgentId: settlementRequest.payerAgentId,
                    agentId,
                    currency: settlementRequest.currency
                  },
                  operationId: `escrow_hold_${runId}`,
                  type: ESCROW_OPERATION_TYPE.HOLD,
                  amountCents: settlementRequest.amountCents,
                  at: nowAt,
                  payerWalletBefore: basePayerWallet,
                  payerWalletAfter: payerWallet,
                  memo: `run:${runId}:hold`
                });
              } catch (err) {
                return sendError(res, 409, "unable to lock settlement escrow", { message: err?.message, code: err?.code ?? null });
              }

              settlement = createAgentRunSettlement({
                tenantId,
                runId,
                agentId,
                payerAgentId: settlementRequest.payerAgentId,
                amountCents: settlementRequest.amountCents,
                currency: settlementRequest.currency,
                disputeWindowDays: settlementRequest.disputeWindowDays ?? 0,
                at: nowAt
              });
              ops.push({ kind: "AGENT_WALLET_UPSERT", tenantId, wallet: payerWallet });
              ops.push({ kind: "AGENT_RUN_SETTLEMENT_UPSERT", tenantId, runId, settlement });
            }

            const responseBody = { run, event: events[events.length - 1], settlement };
            if (idemStoreKey) {
              ops.push({ kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode: 201, body: responseBody } });
            }
            await commitTx(ops);
            return sendJson(res, 201, responseBody);
          }

          const runId = parts[3] ?? null;
          if (runId && req.method === "GET" && parts.length === 4) {
            let run = null;
            if (typeof store.getAgentRun === "function") {
              try {
                run = await store.getAgentRun({ tenantId, runId });
              } catch (err) {
                return sendError(res, 400, "invalid run id", { message: err?.message });
              }
            } else if (store.agentRuns instanceof Map) {
              run = store.agentRuns.get(runStoreKey(tenantId, runId)) ?? null;
            } else {
              return sendError(res, 501, "agent runs not supported for this store");
            }
            if (!run || String(run.agentId ?? "") !== String(agentId)) return sendError(res, 404, "run not found");

            const events = await getAgentRunEvents(tenantId, runId);
            const verification = computeAgentRunVerification({ run, events });
            let settlement = null;
            try {
              settlement = await getAgentRunSettlementRecord({ tenantId, runId });
            } catch {
              settlement = null;
            }
            return sendJson(res, 200, { run, verification, settlement });
          }

          if (runId && parts[4] === "events" && req.method === "GET" && parts.length === 5) {
            let run = null;
            if (typeof store.getAgentRun === "function") run = await store.getAgentRun({ tenantId, runId });
            else if (store.agentRuns instanceof Map) run = store.agentRuns.get(runStoreKey(tenantId, runId)) ?? null;
            if (!run || String(run.agentId ?? "") !== String(agentId)) return sendError(res, 404, "run not found");
            return sendJson(res, 200, { events: await getAgentRunEvents(tenantId, runId) });
          }

          if (runId && parts[4] === "events" && req.method === "POST" && parts.length === 5) {
            if (!requireProtocolHeaderForWrite(req, res)) return;
            const body = await readJsonBody(req);
            {
              const schemaCheck = parseEventSchemaVersionFromBody(body);
              if (!schemaCheck.ok) return sendError(res, schemaCheck.statusCode ?? 400, schemaCheck.message, schemaCheck.details ?? null, { code: schemaCheck.code });
            }
            const type = body?.type;
            if (!type) return sendError(res, 400, "type is required");
            res.__settldEventType = type;
            const supported = new Set([
              AGENT_RUN_EVENT_TYPE.RUN_STARTED,
              AGENT_RUN_EVENT_TYPE.RUN_HEARTBEAT,
              AGENT_RUN_EVENT_TYPE.EVIDENCE_ADDED,
              AGENT_RUN_EVENT_TYPE.RUN_COMPLETED,
              AGENT_RUN_EVENT_TYPE.RUN_FAILED
            ]);
            if (!supported.has(type)) return sendError(res, 400, "unsupported run event type");

            const expectedHeader = parseExpectedPrevChainHashHeader(req);
            if (!expectedHeader.ok) return sendError(res, 428, "missing precondition", "x-proxy-expected-prev-chain-hash is required");

            let idemStoreKey = null;
            let idemRequestHash = null;
            try {
              ({ idemStoreKey, idemRequestHash } = readIdempotency({
                method: "POST",
                requestPath: path,
                expectedPrevChainHash: expectedHeader.expectedPrevChainHash,
                body
              }));
            } catch (err) {
              return sendError(res, 400, "invalid idempotency key", { message: err?.message });
            }
            if (idemStoreKey) {
              const existingIdem = store.idempotency.get(idemStoreKey);
              if (existingIdem) {
                if (existingIdem.requestHash !== idemRequestHash) {
                  return sendError(res, 409, "idempotency key conflict", "request differs from initial use of this key");
                }
                return sendJson(res, existingIdem.statusCode, existingIdem.body);
              }
            }

            const existing = await getAgentRunEvents(tenantId, runId);
            if (!existing.length) return sendError(res, 404, "run not found");
            const currentPrevChainHash = getCurrentPrevChainHash(existing);
            if (expectedHeader.expectedPrevChainHash !== currentPrevChainHash) {
              return sendError(res, 409, "event append conflict", {
                expectedPrevChainHash: currentPrevChainHash,
                gotExpectedPrevChainHash: expectedHeader.expectedPrevChainHash
              });
            }

            const payloadRaw = body?.payload ?? {};
            if (!payloadRaw || typeof payloadRaw !== "object" || Array.isArray(payloadRaw)) return sendError(res, 400, "payload must be an object");
            const payload = { ...payloadRaw, runId };
            try {
              if (type === AGENT_RUN_EVENT_TYPE.RUN_STARTED) validateRunStartedPayload(payload);
              else if (type === AGENT_RUN_EVENT_TYPE.RUN_HEARTBEAT) validateRunHeartbeatPayload(payload);
              else if (type === AGENT_RUN_EVENT_TYPE.EVIDENCE_ADDED) validateEvidenceAddedPayload(payload);
              else if (type === AGENT_RUN_EVENT_TYPE.RUN_COMPLETED) validateRunCompletedPayload(payload);
              else if (type === AGENT_RUN_EVENT_TYPE.RUN_FAILED) validateRunFailedPayload(payload);
            } catch (err) {
              return sendError(res, 400, "invalid run event payload", { message: err?.message });
            }

            const draft = createChainedEvent({
              streamId: runId,
              type,
              actor: body?.actor ?? { type: "agent", id: agentId },
              payload,
              at: nowIso()
            });
            const nextEvents = normalizeAgentRunEventRecords(appendChainedEvent({ events: existing, event: draft, signer: serverSigner }));
            const event = nextEvents[nextEvents.length - 1];

            let run;
            try {
              run = reduceAgentRun(nextEvents);
            } catch (err) {
              return sendError(res, 400, "run update rejected", { message: err?.message });
            }
            if (String(run.agentId ?? "") !== String(agentId)) return sendError(res, 400, "run agent mismatch");

            const ops = [{ kind: "AGENT_RUN_EVENTS_APPENDED", tenantId, runId, events: [event] }];
            let settlement = null;
            try {
              settlement = await getAgentRunSettlementRecord({ tenantId, runId });
            } catch {
              settlement = null;
            }

            if (settlement && settlement.status === AGENT_RUN_SETTLEMENT_STATUS.LOCKED) {
              const terminal = run.status === "completed" || run.status === "failed";
              if (terminal) {
                const settledAt = event?.at ?? nowIso();
                const settlementResolutionKey = typeof event?.id === "string" && event.id.trim() !== "" ? event.id : `run_${runId}_${settledAt}`;
                try {
                  assertSettlementKernelBindingsForResolution({
                    settlement,
                    runId,
                    phase: "run_terminal_settlement.preflight",
                    allowMissingArtifacts: true
                  });
                  const payerWalletExisting = await getAgentWalletRecord({ tenantId, agentId: settlement.payerAgentId });
                  let payerWallet = ensureAgentWallet({
                    wallet: payerWalletExisting,
                    tenantId,
                    agentId: settlement.payerAgentId,
                    currency: settlement.currency,
                    at: settledAt
                  });

                  const verification = computeAgentRunVerification({ run, events: nextEvents });
                  const linkedTask = findMarketplaceRfqByRunId({ tenantId, runId });
                  const linkedDisputeWindowDaysRaw = linkedTask?.agreement?.disputeWindowDays ?? settlement?.disputeWindowDays ?? 0;
                  const linkedDisputeWindowDays =
                    Number.isSafeInteger(Number(linkedDisputeWindowDaysRaw)) && Number(linkedDisputeWindowDaysRaw) >= 0
                      ? Number(linkedDisputeWindowDaysRaw)
                      : 0;
                  const agreementPolicyMaterial = resolveAgreementPolicyMaterial({
                    tenantId,
                    agreement: linkedTask?.agreement ?? null
                  });
                  const agreementPolicy = agreementPolicyMaterial.policy ?? null;
                  const agreementVerificationMethod = agreementPolicyMaterial.verificationMethod ?? null;
                  const verifierExecution = evaluateRunSettlementVerifierExecution({
                    verificationMethod: agreementVerificationMethod,
                    run,
                    verification
                  });
                  const effectiveVerificationStatus = verifierExecution.verificationStatus;
                  const hasMarketplaceAgreement = Boolean(linkedTask?.agreement && typeof linkedTask.agreement === "object");
                  let policyDecision = null;
                  if (!hasMarketplaceAgreement) {
                    const fallbackReleaseRatePct = run.status === "failed" ? 0 : resolveRunSettlementReleaseRatePct({ run, verification });
                    const fallbackReleaseAmountCents =
                      fallbackReleaseRatePct <= 0
                        ? 0
                        : Math.min(settlement.amountCents, Math.floor((settlement.amountCents * fallbackReleaseRatePct) / 100));
                    policyDecision = {
                      policy: null,
                      verificationMethod: null,
                      decisionMode: AGENT_RUN_SETTLEMENT_DECISION_MODE.AUTOMATIC,
                      shouldAutoResolve: true,
                      reasonCodes: [],
                      releaseRatePct: fallbackReleaseRatePct,
                      releaseAmountCents: fallbackReleaseAmountCents,
                      refundAmountCents: settlement.amountCents - fallbackReleaseAmountCents,
                      settlementStatus: fallbackReleaseAmountCents > 0 ? "released" : "refunded",
                      verificationStatus: effectiveVerificationStatus,
                      runStatus: run.status
                    };
                  } else {
                    try {
                      policyDecision = evaluateSettlementPolicy({
                        policy: agreementPolicy,
                        verificationMethod: agreementVerificationMethod,
                        verificationStatus: effectiveVerificationStatus,
                        runStatus: run.status,
                        amountCents: settlement.amountCents
                      });
                    } catch {
                      const fallbackReleaseRatePct = run.status === "failed" ? 0 : resolveRunSettlementReleaseRatePct({ run, verification });
                      const fallbackReleaseAmountCents =
                        fallbackReleaseRatePct <= 0
                          ? 0
                          : Math.min(settlement.amountCents, Math.floor((settlement.amountCents * fallbackReleaseRatePct) / 100));
                      policyDecision = {
                        policy: null,
                        verificationMethod: null,
                        decisionMode: AGENT_RUN_SETTLEMENT_DECISION_MODE.AUTOMATIC,
                        shouldAutoResolve: true,
                        reasonCodes: ["fallback_policy_decision"],
                        releaseRatePct: fallbackReleaseRatePct,
                        releaseAmountCents: fallbackReleaseAmountCents,
                        refundAmountCents: settlement.amountCents - fallbackReleaseAmountCents,
                        settlementStatus: fallbackReleaseAmountCents > 0 ? "released" : "refunded",
                        verificationStatus: effectiveVerificationStatus,
                        runStatus: run.status
                      };
                    }
                    policyDecision = applyAgreementMilestoneRelease({
                      policyDecision,
                      agreement: linkedTask?.agreement ?? null,
                      run,
                      verification,
                      amountCents: settlement.amountCents
                    }).decision;
                  }

                  if (!policyDecision.shouldAutoResolve) {
                    const manualReviewKernelRefs = buildSettlementKernelRefs({
                      settlement,
                      run,
                      agreementId: linkedTask?.agreement?.agreementId ?? null,
                      decisionStatus: AGENT_RUN_SETTLEMENT_DECISION_STATUS.MANUAL_REVIEW_REQUIRED,
                      decisionMode: AGENT_RUN_SETTLEMENT_DECISION_MODE.MANUAL_REVIEW,
                      decisionReason: policyDecision.reasonCodes?.[0] ?? "manual review required by settlement policy",
                      verificationStatus: policyDecision.verificationStatus ?? null,
                      policyHash: agreementPolicyMaterial.policyHash ?? null,
                      verificationMethodHash: agreementPolicyMaterial.verificationMethodHash ?? null,
                      verificationMethodMode: verifierExecution.verifierRef?.modality ?? agreementVerificationMethod?.mode ?? null,
                      verifierId: verifierExecution.verifierRef?.verifierId ?? "settld.policy-engine",
                      verifierVersion: verifierExecution.verifierRef?.verifierVersion ?? "v1",
                      verifierHash: verifierExecution.verifierRef?.verifierHash ?? null,
                      resolutionEventId: null,
                      finalityState: SETTLEMENT_FINALITY_STATE.PENDING,
                      settledAt: null,
                      createdAt: settledAt
                    });
                    settlement = updateAgentRunSettlementDecision({
                      settlement,
                      decisionStatus: AGENT_RUN_SETTLEMENT_DECISION_STATUS.MANUAL_REVIEW_REQUIRED,
                      decisionMode: AGENT_RUN_SETTLEMENT_DECISION_MODE.MANUAL_REVIEW,
                      decisionPolicyHash: agreementPolicyMaterial.policyHash ?? null,
                      decisionReason: policyDecision.reasonCodes?.[0] ?? "manual review required by settlement policy",
                      decisionTrace: {
                        phase: "run.terminal.awaiting_manual_resolution",
                        verifierExecution: verifierExecution.evaluation,
                        policyDecision,
                        decisionRecord: manualReviewKernelRefs.decisionRecord,
                        settlementReceipt: manualReviewKernelRefs.settlementReceipt
                      },
                      at: settledAt
                    });
                    settlement = {
                      ...settlement,
                      disputeWindowDays: linkedDisputeWindowDays,
                      revision: Number(settlement.revision ?? 0) + 1,
                      updatedAt: settledAt
                    };
                    ops.push({ kind: "AGENT_RUN_SETTLEMENT_UPSERT", tenantId, runId, settlement });
                    if (linkedTask && String(linkedTask.status ?? "").toLowerCase() === "assigned") {
                      const awaitingTask = {
                        ...linkedTask,
                        settlementDecisionStatus: settlement.decisionStatus ?? null,
                        settlementDecisionReason: settlement.decisionReason ?? null,
                        updatedAt: settledAt
                      };
                      ops.push({ kind: "MARKETPLACE_RFQ_UPSERT", tenantId, rfq: awaitingTask });
                    }
                  } else {
                    const releaseAmountCents = Number(policyDecision.releaseAmountCents ?? 0);
                    const refundAmountCents = Number(policyDecision.refundAmountCents ?? settlement.amountCents);
                    if (releaseAmountCents > 0) {
                      const payeeWalletExisting = await getAgentWalletRecord({ tenantId, agentId: settlement.agentId });
                      const payeeWallet = ensureAgentWallet({
                        wallet: payeeWalletExisting,
                        tenantId,
                        agentId: settlement.agentId,
                        currency: settlement.currency,
                        at: settledAt
                      });
                      const released = releaseAgentWalletEscrowToPayee({
                        payerWallet,
                        payeeWallet,
                        amountCents: releaseAmountCents,
                        at: settledAt
                      });
                      projectEscrowLedgerOperation({
                        tenantId,
                        settlement,
                        operationId: `escrow_release_${runId}_${settlementResolutionKey}`,
                        type: ESCROW_OPERATION_TYPE.RELEASE,
                        amountCents: releaseAmountCents,
                        at: settledAt,
                        payerWalletBefore: payerWallet,
                        payerWalletAfter: released.payerWallet,
                        payeeWalletBefore: payeeWallet,
                        payeeWalletAfter: released.payeeWallet,
                        memo: `run:${runId}:auto_release`
                      });
                      payerWallet = released.payerWallet;
                      ops.push({ kind: "AGENT_WALLET_UPSERT", tenantId, wallet: released.payeeWallet });
                    }
                    if (refundAmountCents > 0) {
                      const payerBeforeRefund = payerWallet;
                      payerWallet = refundAgentWalletEscrow({
                        wallet: payerWallet,
                        amountCents: refundAmountCents,
                        at: settledAt
                      });
                      projectEscrowLedgerOperation({
                        tenantId,
                        settlement,
                        operationId: `escrow_forfeit_${runId}_${settlementResolutionKey}`,
                        type: ESCROW_OPERATION_TYPE.FORFEIT,
                        amountCents: refundAmountCents,
                        at: settledAt,
                        payerWalletBefore: payerBeforeRefund,
                        payerWalletAfter: payerWallet,
                        memo: `run:${runId}:auto_refund`
                      });
                    }

                    const autoResolvedKernelRefs = buildSettlementKernelRefs({
                      settlement,
                      run,
                      agreementId: linkedTask?.agreement?.agreementId ?? null,
                      decisionStatus: AGENT_RUN_SETTLEMENT_DECISION_STATUS.AUTO_RESOLVED,
                      decisionMode: AGENT_RUN_SETTLEMENT_DECISION_MODE.AUTOMATIC,
                      decisionReason: policyDecision.reasonCodes?.[0] ?? null,
                      verificationStatus: policyDecision.verificationStatus ?? null,
                      policyHash: agreementPolicyMaterial.policyHash ?? null,
                      verificationMethodHash: agreementPolicyMaterial.verificationMethodHash ?? null,
                      verificationMethodMode: verifierExecution.verifierRef?.modality ?? agreementVerificationMethod?.mode ?? null,
                      verifierId: verifierExecution.verifierRef?.verifierId ?? "settld.policy-engine",
                      verifierVersion: verifierExecution.verifierRef?.verifierVersion ?? "v1",
                      verifierHash: verifierExecution.verifierRef?.verifierHash ?? null,
                      resolutionEventId: event.id,
                      status: releaseAmountCents > 0 ? AGENT_RUN_SETTLEMENT_STATUS.RELEASED : AGENT_RUN_SETTLEMENT_STATUS.REFUNDED,
                      releasedAmountCents: releaseAmountCents,
                      refundedAmountCents: refundAmountCents,
                      releaseRatePct: Number(policyDecision.releaseRatePct ?? 0),
                      finalityState: SETTLEMENT_FINALITY_STATE.FINAL,
                      settledAt,
                      createdAt: settledAt
                    });
                    settlement = resolveAgentRunSettlement({
                      settlement,
                      status: releaseAmountCents > 0 ? AGENT_RUN_SETTLEMENT_STATUS.RELEASED : AGENT_RUN_SETTLEMENT_STATUS.REFUNDED,
                      runStatus: run.status,
                      releasedAmountCents: releaseAmountCents,
                      refundedAmountCents: refundAmountCents,
                      releaseRatePct: Number(policyDecision.releaseRatePct ?? 0),
                      disputeWindowDays: linkedDisputeWindowDays,
                      decisionStatus: AGENT_RUN_SETTLEMENT_DECISION_STATUS.AUTO_RESOLVED,
                      decisionMode: AGENT_RUN_SETTLEMENT_DECISION_MODE.AUTOMATIC,
                      decisionPolicyHash: agreementPolicyMaterial.policyHash ?? null,
                      decisionReason: policyDecision.reasonCodes?.[0] ?? null,
                      decisionTrace: {
                        phase: "run.terminal.auto_resolved",
                        verifierExecution: verifierExecution.evaluation,
                        policyDecision,
                        decisionRecord: autoResolvedKernelRefs.decisionRecord,
                        settlementReceipt: autoResolvedKernelRefs.settlementReceipt
                      },
                      resolutionEventId: event.id,
                      at: settledAt
                    });
                    assertSettlementKernelBindingsForResolution({
                      settlement,
                      runId,
                      phase: "run_terminal_settlement.auto_resolved"
                    });

                    ops.push({ kind: "AGENT_WALLET_UPSERT", tenantId, wallet: payerWallet });
                    ops.push({ kind: "AGENT_RUN_SETTLEMENT_UPSERT", tenantId, runId, settlement });

                    if (linkedTask && String(linkedTask.status ?? "").toLowerCase() === "assigned") {
                      const closedTask = {
                        ...linkedTask,
                        status: "closed",
                        settlementStatus: settlement.status,
                        settlementResolvedAt: settlement.resolvedAt ?? settledAt,
                        settlementReleaseRatePct: settlement.releaseRatePct ?? null,
                        settlementDecisionStatus: settlement.decisionStatus ?? null,
                        settlementDecisionReason: settlement.decisionReason ?? null,
                        updatedAt: settledAt
                      };
                      ops.push({ kind: "MARKETPLACE_RFQ_UPSERT", tenantId, rfq: closedTask });
                    }
                  }
                } catch (err) {
                  if (err?.code === "SETTLEMENT_KERNEL_BINDING_INVALID") {
                    return sendError(res, 409, "invalid settlement kernel artifacts", {
                      message: err?.message,
                      code: err?.code ?? null,
                      errors: err?.detail?.errors ?? null
                    }, { code: "SETTLEMENT_KERNEL_BINDING_INVALID" });
                  }
                  return sendError(res, 409, "run settlement failed", { message: err?.message, code: err?.code ?? null });
                }
              }
            }

            if (run.status === "completed" || run.status === "failed") {
              try {
                await assertTenantVerifiedRunAllowance({
                  tenantId,
                  occurredAt: event?.at ?? nowIso(),
                  quantity: 1
                });
              } catch (err) {
                if (err?.code === "BILLING_PLAN_LIMIT_EXCEEDED") {
                  return sendError(res, 402, "billing plan verified-run limit exceeded", err?.detail ?? null, { code: err.code });
                }
                throw err;
              }
            }

            const settlementArtifacts = extractSettlementKernelArtifacts(settlement);
            const kernelVerification = verifySettlementKernelArtifacts({ settlement, runId });
            const responseBody = { event, run, settlement, ...settlementArtifacts, kernelVerification };
            if (idemStoreKey) {
              ops.push({ kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode: 201, body: responseBody } });
            }
            await commitTx(ops);
            if (run.status === "completed" || run.status === "failed") {
              await emitBillableUsageEventBestEffort(
                {
                  tenantId,
                  eventKey: `verified_run:${runId}:${String(event?.id ?? run?.lastEventId ?? run?.status ?? "terminal")}`,
                  eventType: BILLABLE_USAGE_EVENT_TYPE.VERIFIED_RUN,
                  occurredAt: event?.at ?? nowIso(),
                  quantity: 1,
                  runId,
                  settlementId: settlement?.settlementId ?? null,
                  disputeId: settlement?.disputeId ?? null,
                  sourceType: "agent_run_event",
                  sourceId: runId,
                  sourceEventId: event?.id ?? null,
                  audit: {
                    route: path,
                    method: "POST",
                    actorAgentId: agentId,
                    runStatus: run.status,
                    verificationStatus: computeAgentRunVerification({ run, events: nextEvents }).verificationStatus
                  }
                },
                { context: "agent_run_event.verified_run" }
              );
            }
            if (settlement && settlement.status !== AGENT_RUN_SETTLEMENT_STATUS.LOCKED) {
              const decisionHashRaw =
                settlement?.decisionTrace?.decisionRecord && typeof settlement.decisionTrace.decisionRecord === "object"
                  ? settlement.decisionTrace.decisionRecord.decisionHash
                  : null;
              const decisionHash =
                typeof decisionHashRaw === "string" && /^[0-9a-f]{64}$/i.test(decisionHashRaw.trim())
                  ? decisionHashRaw.trim().toLowerCase()
                  : sha256Hex(
                      `${String(settlement?.settlementId ?? runId)}:${String(settlement?.resolutionEventId ?? event?.id ?? "auto_resolution")}:${String(
                        settlement?.status ?? ""
                      )}`
                    );
              await emitReputationEventBestEffort(
                {
                  tenantId,
                  eventId: `rep_dec_${decisionHash}`,
                  occurredAt: settlement?.resolvedAt ?? event?.at ?? nowIso(),
                  eventKind:
                    Number(settlement?.releasedAmountCents ?? 0) > 0
                      ? REPUTATION_EVENT_KIND.DECISION_APPROVED
                      : REPUTATION_EVENT_KIND.DECISION_REJECTED,
                  subject: {
                    agentId: String(settlement.agentId),
                    counterpartyAgentId: String(settlement.payerAgentId),
                    role: "payee"
                  },
                  sourceRef: {
                    kind: "settlement_decision",
                    sourceId: String(settlement?.settlementId ?? runId),
                    hash: decisionHash,
                    decisionHash,
                    runId,
                    settlementId: settlement?.settlementId ?? null
                  },
                  facts: {
                    decisionStatus: Number(settlement?.releasedAmountCents ?? 0) > 0 ? "approved" : "rejected",
                    releaseRatePct: Number(settlement?.releaseRatePct ?? 0),
                    amountSettledCents: Number(settlement?.releasedAmountCents ?? 0),
                    amountRefundedCents: Number(settlement?.refundedAmountCents ?? 0),
                    latencyMs: toSafeNonNegativeInt(run?.metrics?.latencyMs)
                  }
                },
                { context: "agent_run_event.settlement_decision" }
              );
              const releasedAmountCentsRaw =
                settlement?.releasedAmountCents ??
                (String(settlement.status ?? "").toLowerCase() === AGENT_RUN_SETTLEMENT_STATUS.RELEASED ? settlement?.amountCents : 0);
              const releasedAmountCents = Number.isSafeInteger(Number(releasedAmountCentsRaw)) ? Number(releasedAmountCentsRaw) : 0;
              await emitBillableUsageEventBestEffort(
                {
                  tenantId,
                  eventKey: `settled_volume:${String(settlement?.settlementId ?? runId)}:${String(settlement?.resolutionEventId ?? event?.id ?? settlement?.status ?? "resolved")}`,
                  eventType: BILLABLE_USAGE_EVENT_TYPE.SETTLED_VOLUME,
                  occurredAt: settlement?.resolvedAt ?? event?.at ?? nowIso(),
                  quantity: 1,
                  amountCents: Math.max(0, releasedAmountCents),
                  currency: settlement?.currency ?? "USD",
                  runId,
                  settlementId: settlement?.settlementId ?? null,
                  disputeId: settlement?.disputeId ?? null,
                  sourceType: "agent_run_settlement",
                  sourceId: settlement?.settlementId ?? runId,
                  sourceEventId: settlement?.resolutionEventId ?? event?.id ?? null,
                  audit: {
                    route: path,
                    method: "POST",
                    actorAgentId: agentId,
                    settlementStatus: settlement?.status ?? null
                  }
                },
                { context: "agent_run_event.settled_volume" }
              );
            }
            if (settlement && settlement.status !== AGENT_RUN_SETTLEMENT_STATUS.LOCKED) {
              try {
                await emitMarketplaceLifecycleArtifact({
                  tenantId,
                  eventType: "marketplace.settlement.resolved",
                  rfqId: findMarketplaceRfqByRunId({ tenantId, runId })?.rfqId ?? null,
                  runId,
                  sourceEventId: event.id,
                  actorAgentId: agentId,
                  settlement,
                  details: {
                    runStatus: run.status,
                    verificationStatus: computeAgentRunVerification({ run, events: nextEvents }).verificationStatus
                  }
                });
              } catch {
                // Best-effort lifecycle delivery.
              }
            } else if (settlement && settlement.decisionStatus === AGENT_RUN_SETTLEMENT_DECISION_STATUS.MANUAL_REVIEW_REQUIRED) {
              try {
                await emitMarketplaceLifecycleArtifact({
                  tenantId,
                  eventType: "marketplace.settlement.manual_review_required",
                  rfqId: findMarketplaceRfqByRunId({ tenantId, runId })?.rfqId ?? null,
                  runId,
                  sourceEventId: event.id,
                  actorAgentId: agentId,
                  settlement,
                  details: {
                    runStatus: run.status,
                    verificationStatus: computeAgentRunVerification({ run, events: nextEvents }).verificationStatus,
                    decisionReason: settlement.decisionReason ?? null
                  }
                });
              } catch {
                // Best-effort lifecycle delivery.
              }
            }
            return sendJson(res, 201, responseBody);
          }
        }
      }

      if (parts[0] === "robots" && parts[1] && parts[1] !== "register") {
        const robotId = parts[1];
        const robot = store.robots.get(robotStoreKey(tenantId, robotId));
        if (!robot) return sendError(res, 404, "robot not found");

        if (req.method === "GET" && parts.length === 2) {
          return sendJson(res, 200, { robot });
        }

        if (parts[2] === "events") {
          if (req.method === "GET" && parts.length === 3) {
            return sendJson(res, 200, { events: getRobotEvents(tenantId, robotId) });
          }

          if (req.method === "POST" && parts.length === 3) {
            if (!requireProtocolHeaderForWrite(req, res)) return;
            const body = await readJsonBody(req);
	            {
	              const schemaCheck = parseEventSchemaVersionFromBody(body);
	              if (!schemaCheck.ok) return sendError(res, schemaCheck.statusCode ?? 400, schemaCheck.message, schemaCheck.details ?? null, { code: schemaCheck.code });
	            }
	            const type = body?.type;
	            if (!type) return sendError(res, 400, "type is required");
	            res.__settldEventType = type;
            const supported = new Set([
              "ROBOT_HEARTBEAT",
              "ROBOT_UNHEALTHY",
              "ROBOT_QUARANTINED",
              "ROBOT_QUARANTINE_CLEARED",
              "MAINTENANCE_REQUESTED",
              "MAINTENANCE_COMPLETED"
            ]);
            if (!supported.has(type)) return sendError(res, 400, "unsupported robot event type");

            const signerKind = requiredSignerKindForEventType(type);
            const existing = getRobotEvents(tenantId, robotId);
            const currentPrevChainHash = getCurrentPrevChainHash(existing);

            const isClientFinalized = Boolean(body?.payloadHash || body?.chainHash || body?.signature || body?.signerKeyId || body?.prevChainHash);

            // Client-finalized events are used for robot-signed types.
            if (isClientFinalized) {
              const event = {
                v: body?.v ?? 1,
                id: body?.id,
                at: body?.at,
                streamId: body?.streamId,
                type,
                actor: body?.actor ?? null,
                payload: body?.payload ?? null,
                payloadHash: body?.payloadHash ?? null,
                prevChainHash: body?.prevChainHash ?? null,
                chainHash: body?.chainHash ?? null,
                signature: body?.signature ?? null,
                signerKeyId: body?.signerKeyId ?? null
              };

              try {
                if (event.v !== 1) throw new TypeError("event.v must be 1");
                assertNonEmptyString(event.id, "event.id");
                assertIsoDate(event.at, "event.at");
                assertNonEmptyString(event.streamId, "event.streamId");
                if (event.streamId !== robotId) throw new TypeError("event.streamId must match robotId");
                assertActor(event.actor);
                if (event.actor.type !== "robot") throw new TypeError("robot client-finalized events require actor.type=robot");
                if (event.actor.id !== robotId) throw new TypeError("event.actor.id must match robotId");
                assertNonEmptyString(event.payloadHash, "event.payloadHash");
                assertNonEmptyString(event.chainHash, "event.chainHash");
              } catch (err) {
                return sendError(res, 400, "invalid event envelope", { message: err?.message });
              }

              {
                const atMs = Date.parse(event.at);
                const nowMs = Date.parse(nowIso());
                const maxSkewMs = 5 * 60_000;
                if (Number.isFinite(atMs) && Number.isFinite(nowMs) && atMs > nowMs + maxSkewMs) {
                  return sendError(res, 400, "event.at is too far in the future");
                }
              }

              if (event.prevChainHash !== currentPrevChainHash) {
                return sendError(res, 409, "event append conflict", {
                  expectedPrevChainHash: currentPrevChainHash,
                  gotPrevChainHash: event.prevChainHash
                });
              }

              await ensureSignerContextFresh({ tenantId, event });
              const nextEvents = [...existing, event];
              const verify = verifyChainedEvents(nextEvents, { publicKeyByKeyId: store.publicKeyByKeyId });
              if (!verify.ok) return sendError(res, 400, "event chain verification failed", verify.error);

              try {
                enforceSignaturePolicy({ tenantId, signerKind, event });
              } catch (err) {
                return sendError(res, 400, "signature policy rejected", { message: err?.message });
              }

              let robotAfter;
              try {
                robotAfter = reduceRobot(nextEvents);
              } catch (err) {
                return sendError(res, 400, "robot update rejected", { message: err?.message });
              }

              const responseBody = { event, robot: robotAfter };
              await commitTx([{ kind: "ROBOT_EVENTS_APPENDED", tenantId, robotId, events: [event] }]);
              return sendJson(res, 201, responseBody);
            }

            // Server-driven robot events (e.g., quarantine/maintenance) require precondition header.
            const expectedHeader = parseExpectedPrevChainHashHeader(req);
            if (!expectedHeader.ok) return sendError(res, 428, "missing precondition", "x-proxy-expected-prev-chain-hash is required");
            if (expectedHeader.expectedPrevChainHash !== currentPrevChainHash) {
              return sendError(res, 409, "event append conflict", {
                expectedPrevChainHash: currentPrevChainHash,
                gotExpectedPrevChainHash: expectedHeader.expectedPrevChainHash
              });
            }

            if (body?.actor?.type === "robot" || body?.actor?.type === "operator") {
              return sendError(res, 400, "robot/operator actors must use signer-enforced event types");
            }

            // Basic payload shape validation for server-created robot events.
            try {
              const p = body?.payload ?? null;
              if (type === "ROBOT_UNHEALTHY") validateRobotUnhealthyPayload(p ?? {});
              if (type === "ROBOT_QUARANTINED") validateRobotQuarantinedPayload(p ?? {});
              if (type === "ROBOT_QUARANTINE_CLEARED") validateRobotQuarantineClearedPayload(p ?? {});
              if (type === "MAINTENANCE_REQUESTED") validateMaintenanceRequestedPayload(p ?? {});
              if (type === "MAINTENANCE_COMPLETED") validateMaintenanceCompletedPayload(p ?? {});
            } catch (err) {
              return sendError(res, 400, "invalid payload", { message: err?.message });
            }

            const draft = createChainedEvent({
              streamId: robotId,
              type,
              actor: body?.actor ?? { type: "system", id: "proxy" },
              payload: body?.payload ?? null,
              at: nowIso()
            });
            const nextEvents = appendChainedEvent({ events: existing, event: draft, signer: serverSigner });
            const event = nextEvents[nextEvents.length - 1];

            try {
              enforceSignaturePolicy({ tenantId, signerKind, event });
            } catch (err) {
              return sendError(res, 400, "signature policy rejected", { message: err?.message });
            }

            let robotAfter;
            try {
              robotAfter = reduceRobot(nextEvents);
            } catch (err) {
              return sendError(res, 400, "robot update rejected", { message: err?.message });
	            }
	
	            const responseBody = { event, robot: robotAfter };
	            await commitTx([{ kind: "ROBOT_EVENTS_APPENDED", tenantId, robotId, events: [event] }]);
	            return sendJson(res, 201, responseBody);
	          }
	        }

        if (req.method === "POST" && parts[2] === "availability" && parts.length === 3) {
	          const body = await readJsonBody(req);
	          const expectedHeader = parseExpectedPrevChainHashHeader(req);
	          if (!expectedHeader.ok) return sendError(res, 428, "missing precondition", "x-proxy-expected-prev-chain-hash is required");

	          let idemStoreKey = null;
	          let idemRequestHash = null;
	          try {
	            ({ idemStoreKey, idemRequestHash } = readIdempotency({
	              method: "POST",
	              requestPath: path,
	              expectedPrevChainHash: expectedHeader.expectedPrevChainHash,
	              body
	            }));
	          } catch (err) {
	            return sendError(res, 400, "invalid idempotency key", { message: err?.message });
	          }
	          if (idemStoreKey) {
	            const existingIdem = store.idempotency.get(idemStoreKey);
	            if (existingIdem) {
	              if (existingIdem.requestHash !== idemRequestHash) {
	                return sendError(res, 409, "idempotency key conflict", "request differs from initial use of this key");
	              }
	              return sendJson(res, existingIdem.statusCode, existingIdem.body);
	            }
	          }

          const payload = { robotId, availability: body?.availability, timezone: body?.timezone };
          try {
            validateRobotAvailabilitySetPayload(payload);
          } catch (err) {
            return sendError(res, 400, "invalid payload", { message: err?.message });
          }

	          let existing = getRobotEvents(tenantId, robotId);
	          if (!existing.length && typeof store.listAggregateEvents === "function") {
	            try {
	              existing = await store.listAggregateEvents({ tenantId, aggregateType: "robot", aggregateId: robotId });
	            } catch {
	              existing = [];
	            }
	          }
	          const currentPrevChainHash = getCurrentPrevChainHash(existing);
	          if (expectedHeader.expectedPrevChainHash !== currentPrevChainHash) {
	            return sendError(res, 409, "event append conflict", {
	              expectedPrevChainHash: currentPrevChainHash,
	              gotExpectedPrevChainHash: expectedHeader.expectedPrevChainHash
	            });
	          }

          const draft = createChainedEvent({ streamId: robotId, type: "ROBOT_AVAILABILITY_SET", actor: { type: "system", id: "proxy" }, payload, at: nowIso() });
          const nextEvents = appendChainedEvent({ events: existing, event: draft, signer: serverSigner });
          const event = nextEvents[nextEvents.length - 1];

          let robotAfter;
          try {
            robotAfter = reduceRobot(nextEvents);
          } catch (err) {
            return sendError(res, 400, "robot update rejected", { message: err?.message });
          }

          const responseBody = { event, robot: robotAfter };
          const ops = [{ kind: "ROBOT_EVENTS_APPENDED", tenantId, robotId, events: [event] }];
          if (idemStoreKey) ops.push({ kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode: 201, body: responseBody } });
          await commitTx(ops);

          return sendJson(res, 201, responseBody);
        }

        if (req.method === "POST" && parts[2] === "status" && parts.length === 3) {
          const body = await readJsonBody(req);
          const expectedHeader = parseExpectedPrevChainHashHeader(req);
          if (!expectedHeader.ok) return sendError(res, 428, "missing precondition", "x-proxy-expected-prev-chain-hash is required");

          const payload = { robotId, status: body?.status, reason: body?.reason };
          try {
            validateRobotStatusChangedPayload(payload);
          } catch (err) {
            return sendError(res, 400, "invalid payload", { message: err?.message });
          }

	          let existing = getRobotEvents(tenantId, robotId);
	          if (!existing.length && typeof store.listAggregateEvents === "function") {
	            try {
	              existing = await store.listAggregateEvents({ tenantId, aggregateType: "robot", aggregateId: robotId });
	            } catch {
	              existing = [];
	            }
	          }
	          const currentPrevChainHash = getCurrentPrevChainHash(existing);
	          if (expectedHeader.expectedPrevChainHash !== currentPrevChainHash) {
	            return sendError(res, 409, "event append conflict", {
	              expectedPrevChainHash: currentPrevChainHash,
	              gotExpectedPrevChainHash: expectedHeader.expectedPrevChainHash
	            });
	          }

          const draft = createChainedEvent({ streamId: robotId, type: "ROBOT_STATUS_CHANGED", actor: { type: "system", id: "proxy" }, payload, at: nowIso() });
          const nextEvents = appendChainedEvent({ events: existing, event: draft, signer: serverSigner });
          const event = nextEvents[nextEvents.length - 1];

          let robotAfter;
          try {
            robotAfter = reduceRobot(nextEvents);
          } catch (err) {
            return sendError(res, 400, "robot update rejected", { message: err?.message });
          }

          const responseBody = { event, robot: robotAfter };
          await commitTx([{ kind: "ROBOT_EVENTS_APPENDED", tenantId, robotId, events: [event] }]);
          return sendJson(res, 201, responseBody);
        }
      }

      if (parts[0] === "operators" && parts[1] && parts[1] !== "register") {
        const operatorId = parts[1];
        const operator = store.operators.get(operatorStoreKey(tenantId, operatorId));
        if (!operator) return sendError(res, 404, "operator not found");

        if (req.method === "GET" && parts.length === 2) {
          return sendJson(res, 200, { operator });
        }

        if (parts[2] === "events") {
          if (req.method === "GET" && parts.length === 3) {
            return sendJson(res, 200, { events: getOperatorEvents(tenantId, operatorId) });
          }

          if (req.method === "POST" && parts.length === 3) {
            if (!requireProtocolHeaderForWrite(req, res)) return;
            const body = await readJsonBody(req);
            {
              const schemaCheck = parseEventSchemaVersionFromBody(body);
              if (!schemaCheck.ok) return sendError(res, schemaCheck.statusCode ?? 400, schemaCheck.message, schemaCheck.details ?? null, { code: schemaCheck.code });
            }
            const type = body?.type;
            if (!type) return sendError(res, 400, "type is required");
            if (type !== "OPERATOR_SHIFT_OPENED" && type !== "OPERATOR_SHIFT_CLOSED") {
              return sendError(res, 400, "unsupported operator event type");
            }

            const signerKind = requiredSignerKindForEventType(type);
            const existing = getOperatorEvents(tenantId, operatorId);
            const currentPrevChainHash = getCurrentPrevChainHash(existing);
            const isClientFinalized = Boolean(body?.payloadHash || body?.chainHash || body?.signature || body?.signerKeyId || body?.prevChainHash);
            if (!isClientFinalized) return sendError(res, 400, "event must be client-finalized and signed for this type");

            const event = {
              v: body?.v ?? 1,
              id: body?.id,
              at: body?.at,
              streamId: body?.streamId,
              type,
              actor: body?.actor ?? null,
              payload: body?.payload ?? null,
              payloadHash: body?.payloadHash ?? null,
              prevChainHash: body?.prevChainHash ?? null,
              chainHash: body?.chainHash ?? null,
              signature: body?.signature ?? null,
              signerKeyId: body?.signerKeyId ?? null
            };

            try {
              if (event.v !== 1) throw new TypeError("event.v must be 1");
              assertNonEmptyString(event.id, "event.id");
              assertIsoDate(event.at, "event.at");
              assertNonEmptyString(event.streamId, "event.streamId");
              if (event.streamId !== operatorId) throw new TypeError("event.streamId must match operatorId");
              assertActor(event.actor);
              if (event.actor.type !== "operator") throw new TypeError("operator events require actor.type=operator");
              if (event.actor.id !== operatorId) throw new TypeError("event.actor.id must match operatorId");
              assertNonEmptyString(event.payloadHash, "event.payloadHash");
              assertNonEmptyString(event.chainHash, "event.chainHash");
            } catch (err) {
              return sendError(res, 400, "invalid event envelope", { message: err?.message });
            }

            {
              const atMs = Date.parse(event.at);
              const nowMs = Date.parse(nowIso());
              const maxSkewMs = 5 * 60_000;
              if (Number.isFinite(atMs) && Number.isFinite(nowMs) && atMs > nowMs + maxSkewMs) {
                return sendError(res, 400, "event.at is too far in the future");
              }
            }

            if (event.prevChainHash !== currentPrevChainHash) {
              return sendError(res, 409, "event append conflict", {
                expectedPrevChainHash: currentPrevChainHash,
                gotPrevChainHash: event.prevChainHash
              });
            }

            if (type === "OPERATOR_SHIFT_OPENED") {
              try {
                validateOperatorShiftOpenedPayload(event.payload ?? {});
                if (event.payload?.operatorId !== operatorId) throw new TypeError("payload.operatorId must match operatorId");
              } catch (err) {
                return sendError(res, 400, "invalid payload", { message: err?.message });
              }
            }
            if (type === "OPERATOR_SHIFT_CLOSED") {
              try {
                validateOperatorShiftClosedPayload(event.payload ?? {});
                if (event.payload?.operatorId !== operatorId) throw new TypeError("payload.operatorId must match operatorId");
              } catch (err) {
                return sendError(res, 400, "invalid payload", { message: err?.message });
              }
            }

            await ensureSignerContextFresh({ tenantId, event });
            const nextEvents = [...existing, event];
            const verify = verifyChainedEvents(nextEvents, { publicKeyByKeyId: store.publicKeyByKeyId });
            if (!verify.ok) return sendError(res, 400, "event chain verification failed", verify.error);

            try {
              enforceSignaturePolicy({ tenantId, signerKind, event });
            } catch (err) {
              return sendError(res, 400, "signature policy rejected", { message: err?.message });
            }

            let operatorAfter;
            try {
              operatorAfter = reduceOperator(nextEvents);
            } catch (err) {
              return sendError(res, 400, "operator update rejected", { message: err?.message });
            }

            const responseBody = { event, operator: operatorAfter };
            await commitTx([{ kind: "OPERATOR_EVENTS_APPENDED", tenantId, operatorId, events: [event] }]);
            return sendJson(res, 201, responseBody);
          }
        }
      }

      if (parts[0] === "artifacts" && parts[1] && parts[2] === "status" && parts.length === 3 && req.method === "GET") {
        if (
          !(
            requireScope(auth.scopes, OPS_SCOPES.OPS_READ) ||
            requireScope(auth.scopes, OPS_SCOPES.AUDIT_READ) ||
            requireScope(auth.scopes, OPS_SCOPES.FINANCE_READ)
          )
        ) {
          return sendError(res, 403, "forbidden");
        }
        if (typeof store.getArtifact !== "function") return sendError(res, 501, "artifacts not supported for this store");

        const artifactId = String(parts[1]);
        let artifact = null;
        try {
          artifact = await store.getArtifact({ tenantId, artifactId });
        } catch (err) {
          return sendError(res, 400, "invalid artifact id", { message: err?.message });
        }
        if (!artifact) return sendError(res, 404, "artifact not found");

        let job = null;
        const artifactJobId = typeof artifact.jobId === "string" && artifact.jobId.trim() !== "" ? String(artifact.jobId) : null;
        if (artifactJobId) {
          const events = getJobEvents(tenantId, artifactJobId);
          if (events.length) {
            try {
              job = reduceJob(events);
            } catch {
              job = null;
            }
          }
        }

        let verification;
        try {
          verification = computeArtifactVerificationStatus({ artifact, job });
        } catch (err) {
          return sendError(res, 500, "artifact verification status unavailable", { message: err?.message });
        }

        return sendJson(res, 200, {
          artifactId: artifact.artifactId ?? artifactId,
          artifactType: artifact.artifactType ?? artifact.schemaVersion ?? null,
          artifactHash: artifact.artifactHash ?? null,
          sourceEventId: artifact.sourceEventId ?? null,
          jobId: artifactJobId,
          verification
        });
      }

      if (parts[0] === "artifacts" && parts[1] && parts.length === 2 && req.method === "GET") {
        if (
          !(
            requireScope(auth.scopes, OPS_SCOPES.OPS_READ) ||
            requireScope(auth.scopes, OPS_SCOPES.AUDIT_READ) ||
            requireScope(auth.scopes, OPS_SCOPES.FINANCE_READ)
          )
        ) {
          return sendError(res, 403, "forbidden");
        }
        if (typeof store.getArtifact !== "function") return sendError(res, 501, "artifacts not supported for this store");

        const artifactId = String(parts[1]);
        let artifact = null;
        try {
          artifact = await store.getArtifact({ tenantId, artifactId });
        } catch (err) {
          return sendError(res, 400, "invalid artifact id", { message: err?.message });
        }
        if (!artifact) return sendError(res, 404, "artifact not found");

        return sendJson(res, 200, { artifact });
      }

      if (parts[0] === "jobs" && parts[1]) {
        const jobId = parts[1];
        const needsFreshForExport =
          req.method === "GET" && (parts[2] === "audit" || parts[2] === "evidence") && store.kind === "pg" && typeof store.refreshFromDb === "function";
        if (needsFreshForExport) await store.refreshFromDb();

        const events = await getJobEventsFresh(tenantId, jobId, { force: req.method !== "GET" });
        const job = reduceJob(events);
        if (!job) return sendError(res, 404, "job not found");
        if (normalizeTenant(job.tenantId ?? DEFAULT_TENANT_ID) !== normalizeTenant(tenantId)) return sendError(res, 404, "job not found");

        if (req.method === "GET" && parts.length === 2) {
          return sendJson(res, 200, { job });
        }

        if (req.method === "GET" && parts[2] === "audit" && parts.length === 3) {
          if (!requireScope(auth.scopes, OPS_SCOPES.AUDIT_READ)) return sendError(res, 403, "forbidden");
          const audit = buildAuditExport({ job, events });
          return sendJson(res, 200, { audit });
        }

	        if (req.method === "GET" && parts[2] === "evidence" && parts.length === 3) {
	          if (!requireScope(auth.scopes, OPS_SCOPES.AUDIT_READ)) return sendError(res, 403, "forbidden");
	          const evidenceExport = buildEvidenceExport({ job });

          const at = nowIso();
          const nowMs = Date.parse(at);
          const ttlMs = 5 * 60_000;
          const expiresAt = new Date((Number.isFinite(nowMs) ? nowMs : Date.now()) + ttlMs).toISOString();

          const evidence = Array.isArray(evidenceExport.evidence) ? evidenceExport.evidence : [];
          const withUrls = evidence.map((e) => {
            const evidenceId = e?.evidenceId ?? null;
            const evidenceRef = e?.evidenceRef ?? null;
            if (e?.expiredAt) return e;
            if (typeof evidenceId !== "string" || !evidenceId) return e;
            if (typeof evidenceRef !== "string" || !evidenceRef.startsWith("obj://")) return e;
            const downloadUrl = buildEvidenceDownloadUrl({
              tenantId,
              jobId,
              evidenceId,
              evidenceRef,
              expiresAt,
              secret: evidenceSigningSecret
            });
            return { ...e, downloadUrl, downloadExpiresAt: expiresAt };
          });

	          return sendJson(res, 200, { evidence: { ...evidenceExport, evidence: withUrls } });
	        }

	        if (req.method === "GET" && parts[2] === "artifacts" && parts[3] === "effective" && parts.length === 4) {
	          if (!(requireScope(auth.scopes, OPS_SCOPES.AUDIT_READ) || requireScope(auth.scopes, OPS_SCOPES.FINANCE_READ))) {
	            return sendError(res, 403, "forbidden");
	          }
	          if (typeof store.listArtifacts !== "function") return sendError(res, 501, "artifacts not supported for this store");

	          const artifactType = url.searchParams.get("type");
	          if (!artifactType || String(artifactType).trim() === "") return sendError(res, 400, "type is required");

	          const settledEventId = job?.settlement?.settledEventId ?? null;
	          if (typeof settledEventId === "string" && settledEventId.trim() !== "") {
	            const artifacts = await store.listArtifacts({
	              tenantId,
	              jobId,
	              artifactType: String(artifactType),
	              sourceEventId: String(settledEventId),
	              limit: 10,
	              offset: 0
	            });
	            if (!artifacts.length) return sendError(res, 404, "effective artifact not found", { settledEventId });
	            if (artifacts.length > 1) {
	              return sendError(res, 500, "multiple settlement-backed artifacts found", { settledEventId, count: artifacts.length });
	            }
	            return sendJson(res, 200, {
	              artifact: artifacts[0],
	              selection: { kind: "SETTLED_EVENT", sourceEventId: settledEventId }
	            });
	          }

	          // Unsettled jobs: choose an anchor based on the current proof for the latest completion anchor.
	          // NOTE: For WorkCertificate/SettlementStatement/ProofReceipt, artifacts are anchored to PROOF_EVALUATED.
	          const completionTypes = new Set(["EXECUTION_COMPLETED", "JOB_EXECUTION_COMPLETED", "EXECUTION_ABORTED", "JOB_EXECUTION_ABORTED"]);
	          const completion = [...events].reverse().find((e) => completionTypes.has(e?.type) && typeof e?.chainHash === "string" && e.chainHash.trim() !== "");
	          const completionChainHash = completion?.chainHash ?? null;
	          if (!completionChainHash) return sendError(res, 409, "job has no completion anchor yet");

	          let proofEvent = null;
	          let proofFreshness = "none";
	          let expectedFactsHash = null;
	          try {
	            const anchorIdx = events.findIndex((e) => e?.chainHash === completionChainHash);
	            const anchorSlice = anchorIdx === -1 ? null : events.slice(0, anchorIdx + 1);
	            const jobAtAnchor = anchorSlice ? reduceJob(anchorSlice) : null;
	            if (jobAtAnchor) {
	              const current = verifyZoneCoverageProofV1({
	                job: jobAtAnchor,
	                events,
	                evaluatedAtChainHash: completionChainHash,
	                customerPolicyHash: jobAtAnchor.customerPolicyHash ?? jobAtAnchor.booking?.policyHash ?? null,
	                operatorPolicyHash: jobAtAnchor.operatorPolicyHash ?? null
	              });
	              const factsHash = current?.factsHash ?? null;
	              const customerPolicyHash = current?.anchors?.customerPolicyHash ?? (jobAtAnchor.customerPolicyHash ?? jobAtAnchor.booking?.policyHash ?? null);
	              if (factsHash && customerPolicyHash) {
	                proofEvent =
	                  [...events]
	                    .reverse()
	                    .find(
	                      (e) =>
	                        e?.type === "PROOF_EVALUATED" &&
	                        e?.payload?.evaluatedAtChainHash === completionChainHash &&
	                        e?.payload?.customerPolicyHash === customerPolicyHash &&
	                        e?.payload?.factsHash === factsHash &&
	                        typeof e?.id === "string" &&
	                        e.id.trim() !== ""
	                    ) ?? null;
	                if (proofEvent) {
	                  proofFreshness = "fresh";
	                } else {
	                  proofFreshness = "stale";
	                  expectedFactsHash = factsHash;
	                  proofEvent =
	                    [...events]
	                      .reverse()
	                      .find(
	                        (e) =>
	                          e?.type === "PROOF_EVALUATED" &&
	                          e?.payload?.evaluatedAtChainHash === completionChainHash &&
	                          typeof e?.id === "string" &&
	                          e.id.trim() !== ""
	                      ) ?? null;
	                }
	              }
	            }
	          } catch {
	            // ignore, fall back below
	          }

	          if (!proofEvent) {
	            proofEvent = [...events].reverse().find((e) => e?.type === "PROOF_EVALUATED" && typeof e?.id === "string" && e.id.trim() !== "") ?? null;
	          }
	          if (!proofEvent?.id) return sendError(res, 409, "effective proof not available yet");

	          const artifacts = await store.listArtifacts({
	            tenantId,
	            jobId,
	            artifactType: String(artifactType),
	            sourceEventId: String(proofEvent.id),
	            limit: 10,
	            offset: 0
	          });
	          if (!artifacts.length) {
	            return sendError(res, 409, "effective artifact not available yet", { sourceEventId: proofEvent.id });
	          }
	          if (artifacts.length > 1) {
	            return sendError(res, 500, "multiple artifacts found for effective source event", { sourceEventId: proofEvent.id, count: artifacts.length });
	          }
	          return sendJson(res, 200, {
	            artifact: artifacts[0],
	            selection: {
	              kind: "PROOF_EVENT",
	              sourceEventId: proofEvent.id,
	              proofFreshness,
	              expectedFactsHash
	            }
	          });
	        }

	        if (req.method === "GET" && parts[2] === "artifacts" && parts.length === 3) {
	          if (!(requireScope(auth.scopes, OPS_SCOPES.AUDIT_READ) || requireScope(auth.scopes, OPS_SCOPES.FINANCE_READ))) {
	            return sendError(res, 403, "forbidden");
	          }
	          if (typeof store.listArtifacts !== "function") return sendError(res, 501, "artifacts not supported for this store");

	          const type = url.searchParams.get("type");
	          const sourceEventId = url.searchParams.get("sourceEventId");
	          const cursor = url.searchParams.get("cursor");
	          const limitRaw = url.searchParams.get("limit");
	          const offsetRaw = url.searchParams.get("offset");
	          const limit = limitRaw ? Number(limitRaw) : 200;
	          const offset = offsetRaw ? Number(offsetRaw) : 0;

	          if (cursor && String(cursor).trim() !== "" && offsetRaw && String(offsetRaw).trim() !== "") {
	            return sendError(res, 400, "invalid artifacts query", { message: "cursor and offset cannot be used together" }, { code: "INVALID_PAGINATION" });
	          }

	          if (cursor && String(cursor).trim() !== "") {
	            if (store.kind !== "pg") {
	              return sendError(res, 501, "cursor pagination not supported for this store", null, { code: "CURSOR_PAGINATION_UNSUPPORTED" });
	            }
	            const CURSOR_VERSION = 1;
	            const CURSOR_ORDER = "created_at_desc_artifact_id_desc";
	            const isCursorTimestampV1 = (s) => {
	              if (typeof s !== "string") return false;
	              // RFC3339 UTC with microseconds: 2026-01-01T00:00:00.123456Z
	              // (We require microseconds for v1 to preserve Postgres timestamptz precision.)
	              return /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{6}Z$/.test(s);
	            };
	            const decodeCursor = (raw) => {
	              try {
	                const buf = Buffer.from(String(raw), "base64url");
	                const parsed = JSON.parse(buf.toString("utf8"));
	                const vRaw = parsed?.v ?? null;
	                const v = vRaw === null || vRaw === undefined ? CURSOR_VERSION : Number(vRaw);
	                if (!Number.isFinite(v) || !Number.isSafeInteger(v)) throw new Error("cursor.v must be an integer");
	                if (v !== CURSOR_VERSION) throw new Error(`unsupported cursor version: ${v}`);

	                const order = parsed?.order ?? null;
	                if (order !== null && String(order) !== CURSOR_ORDER) throw new Error(`unsupported cursor order: ${String(order)}`);

	                const createdAt = parsed?.createdAt ?? null;
	                const artifactId = parsed?.artifactId ?? null;
	                if (typeof createdAt !== "string" || !createdAt.trim()) throw new Error("cursor.createdAt is required");
	                if (typeof artifactId !== "string" || !artifactId.trim()) throw new Error("cursor.artifactId is required");
	                if (!isCursorTimestampV1(createdAt)) throw new Error("cursor.createdAt must be an RFC3339 UTC timestamp with microseconds");
	                return { createdAt, artifactId };
	              } catch (err) {
	                const e = new Error(`invalid cursor: ${err?.message ?? "parse failed"}`);
	                e.code = "INVALID_CURSOR";
	                throw e;
	              }
	            };
	            const encodeCursor = ({ createdAt, artifactId }) => {
	              if (!isCursorTimestampV1(createdAt)) throw new Error("internal: createdAt must be RFC3339 UTC with microseconds");
	              const body = JSON.stringify({ v: CURSOR_VERSION, order: CURSOR_ORDER, createdAt, artifactId });
	              return Buffer.from(body, "utf8").toString("base64url");
	            };

	            let cur;
	            try {
	              cur = decodeCursor(cursor);
	            } catch (err) {
	              return sendError(res, 400, "invalid artifacts query", { message: err?.message }, { code: err?.code ?? "INVALID_CURSOR" });
	            }

	            const pageSize = Number.isFinite(limit) ? Math.max(1, Math.min(1000, Math.floor(limit))) : 200;
	            let rows;
	            try {
	              rows = await store.listArtifacts({
	                tenantId,
	                jobId,
	                artifactType: type && String(type).trim() !== "" ? String(type) : null,
	                sourceEventId: sourceEventId && String(sourceEventId).trim() !== "" ? String(sourceEventId) : null,
	                beforeCreatedAt: cur.createdAt,
	                beforeArtifactId: cur.artifactId,
	                includeDbMeta: true,
	                limit: pageSize + 1,
	                offset: 0
	              });
	            } catch (err) {
	              return sendError(res, 400, "invalid artifacts query", { message: err?.message });
	            }

	            const hasMore = rows.length > pageSize;
	            const page = rows.slice(0, pageSize);
	            const artifacts = page.map((r) => r?.artifact ?? null).filter(Boolean);
	            const last = page.length ? page[page.length - 1] : null;
	            const nextCursor = hasMore && last?.db?.createdAt && last?.db?.artifactId ? encodeCursor(last.db) : null;
	            return sendJson(res, 200, { artifacts, nextCursor, hasMore, limit: pageSize });
	          }

	          let artifacts;
	          try {
	            artifacts = await store.listArtifacts({
	              tenantId,
	              jobId,
	              artifactType: type && String(type).trim() !== "" ? String(type) : null,
	              sourceEventId: sourceEventId && String(sourceEventId).trim() !== "" ? String(sourceEventId) : null,
	              limit,
	              offset
	            });
	          } catch (err) {
	            return sendError(res, 400, "invalid artifacts query", { message: err?.message });
	          }
	          return sendJson(res, 200, { artifacts });
	        }

        const getWindowZoneId = (windowZoneId) => normalizeZoneId(windowZoneId ?? job.booking?.zoneId ?? job.constraints?.zoneId);

        if (req.method === "POST" && parts[2] === "quote" && parts.length === 3) {
          const body = await readJsonBody(req);

	          const expectedHeader = parseExpectedPrevChainHashHeader(req);
	          if (!expectedHeader.ok) return sendError(res, 428, "missing precondition", "x-proxy-expected-prev-chain-hash is required");

	          let idemStoreKey = null;
	          let idemRequestHash = null;
	          try {
	            ({ idemStoreKey, idemRequestHash } = readIdempotency({
	              method: "POST",
	              requestPath: path,
	              expectedPrevChainHash: expectedHeader.expectedPrevChainHash,
	              body
	            }));
	          } catch (err) {
	            return sendError(res, 400, "invalid idempotency key", { message: err?.message });
	          }
	          if (idemStoreKey) {
	            const existingIdem = store.idempotency.get(idemStoreKey);
	            if (existingIdem) {
	              if (existingIdem.requestHash !== idemRequestHash) {
	                return sendError(res, 409, "idempotency key conflict", "request differs from initial use of this key");
	              }
	              return sendJson(res, existingIdem.statusCode, existingIdem.body);
	            }
	          }

          if (job.status !== "CREATED") return sendError(res, 400, "job is not quoteable");

          const quoteCustomerId = body?.customerId ?? job.customerId ?? null;
          const quoteSiteId = body?.siteId ?? job.siteId ?? null;
          const quoteContractId = body?.contractId ?? job.contractId ?? null;

          const quoteInput = {
            startAt: body?.startAt,
            endAt: body?.endAt,
            environmentTier: body?.environmentTier,
            requiresOperatorCoverage: body?.requiresOperatorCoverage,
            customerId: quoteCustomerId,
            siteId: quoteSiteId,
            contractId: quoteContractId
          };
          try {
            validateBookingWindowInput(quoteInput);
          } catch (err) {
            return sendError(res, 400, "invalid quote input", { message: err?.message });
          }

          const zoneId = getWindowZoneId(quoteInput.zoneId);
          const window = { startAt: quoteInput.startAt, endAt: quoteInput.endAt };

          const activeOperators = listAvailableOperators({ tenantId, zoneId, window, ignoreJobId: jobId }).length;
          const requiresOperatorCoverage =
            quoteInput.requiresOperatorCoverage === true || quoteInput.environmentTier === ENV_TIER.ENV_IN_HOME;
          if (requiresOperatorCoverage && activeOperators <= 0) {
            return sendError(res, 409, "insufficient operator coverage");
          }

          const availableRobotList = listAvailableRobots({ tenantId, zoneId, window, ignoreJobId: jobId });
          const availableRobots = availableRobotList.length;
          if (availableRobots <= 0) return sendError(res, 409, "no available robots for window");
          let avgAvailableRobotTrustScoreBps = 0;
          if (availableRobots > 0) {
            let sum = 0;
            for (const r of availableRobotList) {
              const score = typeof r?.trustScore === "number" && Number.isFinite(r.trustScore) ? r.trustScore : 0;
              sum += Math.max(0, Math.min(1, score));
            }
            avgAvailableRobotTrustScoreBps = Math.max(0, Math.min(10_000, Math.round((sum / availableRobots) * 10_000)));
          }

          const contracts = listContracts({ tenantId });
          let contract = null;
          if (quoteContractId) {
            contract = contracts.find((c) => c?.contractId === quoteContractId) ?? null;
            if (!contract) return sendError(res, 400, "unknown contractId");
          } else {
            contract = selectBestContract(contracts, { customerId: quoteCustomerId, siteId: quoteSiteId, templateId: job.templateId });
          }
          if (!contract) contract = createDefaultContract({ tenantId, nowIso });

          const contractVersion =
            Number.isSafeInteger(contract?.contractVersion) && contract.contractVersion > 0 ? contract.contractVersion : 1;

          const baseSla = computeSlaPolicy({ environmentTier: quoteInput.environmentTier });
          const sla = applyContractSlaOverrides({ sla: baseSla, environmentTier: quoteInput.environmentTier, contract });
          const creditPolicy =
            contract.policies?.creditPolicy ?? { enabled: false, defaultAmountCents: 0, maxAmountCents: 0, currency: "USD" };

          const coveragePolicy = contract.policies?.coveragePolicy ?? null;
          const coverageRequired = coveragePolicy?.required === true;
          const coverageFeeModel = coveragePolicy?.feeModel ?? COVERAGE_FEE_MODEL.PER_JOB;
          const coverageFeeCentsPerJob =
            Number.isSafeInteger(coveragePolicy?.feeCentsPerJob) && coveragePolicy.feeCentsPerJob > 0 ? coveragePolicy.feeCentsPerJob : 0;
          const coverageFeeCents =
            coverageRequired && coverageFeeCentsPerJob > 0
              ? coverageFeeModel === COVERAGE_FEE_MODEL.PER_JOB
                ? coverageFeeCentsPerJob
                : 0
              : 0;

          const quote = computeQuote({
            templateId: job.templateId,
            currency: "USD",
            environmentTier: quoteInput.environmentTier,
            requiresOperatorCoverage,
            coverageFeeCents,
            availableRobots,
            activeOperators
          });
          const payload = {
            ...quote,
            sla,
            inputs: {
              ...quoteInput,
              requiresOperatorCoverage,
              zoneId,
              customerId: quoteCustomerId,
              siteId: quoteSiteId,
              contractId: contract.contractId,
              contractVersion
            }
          };
          const existing = await getJobEventsFresh(tenantId, jobId);
          const currentPrevChainHash = getCurrentPrevChainHash(existing);
          if (expectedHeader.expectedPrevChainHash !== currentPrevChainHash) {
            return sendError(res, 409, "event append conflict", {
              expectedPrevChainHash: currentPrevChainHash,
              gotExpectedPrevChainHash: expectedHeader.expectedPrevChainHash
            });
          }

          const draft = createChainedEvent({
            streamId: jobId,
            type: "QUOTE_PROPOSED",
            actor: { type: "pricing", id: "pricing_v0" },
            payload,
            at: nowIso()
          });
          const eventsAfterQuote = appendChainedEvent({ events: existing, event: draft, signer: serverSigner });
          const event = eventsAfterQuote[eventsAfterQuote.length - 1];

          let jobAfterQuote;
          try {
            jobAfterQuote = reduceJob(eventsAfterQuote);
          } catch (err) {
            return sendError(res, 400, "job transition rejected", { message: err?.message });
          }

          let riskEvent = null;
          let nextEvents = eventsAfterQuote;
          let jobAfter = jobAfterQuote;
          try {
            const scoredAt = nowIso();
            const assessment = computeRiskAssessment({
              basis: RISK_BASIS.QUOTE,
              templateId: job.templateId,
              environmentTier: quoteInput.environmentTier,
              requiresOperatorCoverage,
              zoneId,
              siteId: quoteSiteId,
              customerId: quoteCustomerId,
              availableRobots,
              activeOperators,
              avgAvailableRobotTrustScoreBps,
              creditPolicy,
              policyHash: null,
              jobs: listJobs({ tenantId }),
              getEventsForJob: (id) => getJobEvents(tenantId, id),
              nowIso
            });
            const riskPayload = {
              jobId,
              basis: RISK_BASIS.QUOTE,
              scoredAt,
              sourceEventId: event.id,
              ...assessment
            };
            const riskDraft = createChainedEvent({
              streamId: jobId,
              type: "RISK_SCORED",
              actor: { type: "risk", id: "risk_v1" },
              payload: riskPayload,
              at: scoredAt
            });
            nextEvents = appendChainedEvent({ events: eventsAfterQuote, event: riskDraft, signer: serverSigner });
            riskEvent = nextEvents[nextEvents.length - 1];
            validateDomainEvent({ jobBefore: jobAfterQuote, event: riskEvent, eventsBefore: eventsAfterQuote });
            jobAfter = reduceJob(nextEvents);
          } catch {
            // Best-effort: risk scoring should not block quoting.
            riskEvent = null;
            nextEvents = eventsAfterQuote;
            jobAfter = jobAfterQuote;
          }

          let ledgerEntries = [];
          try {
            ledgerEntries = ledgerEntriesForJobEvent({ jobBefore: job, event, eventsBefore: existing });
          } catch (err) {
            return sendError(res, 400, "ledger posting rejected", { message: err?.message });
          }

          const responseBody = {
            event,
            job: jobAfter,
            ledgerEntryId: ledgerEntries.length ? ledgerEntries[0]?.id ?? null : null,
            ledgerEntryIds: ledgerEntries.map((e) => e?.id).filter(Boolean)
          };

          const outboxMessages = [];
          for (const entry of ledgerEntries) {
            if (!entry) continue;
            outboxMessages.push({ type: "LEDGER_ENTRY_APPLY", tenantId, jobId, sourceEventId: event.id, entry });
          }
          if (job.status !== jobAfter.status) {
            outboxMessages.push({ type: "JOB_STATUS_CHANGED", tenantId, jobId, fromStatus: job.status, toStatus: jobAfter.status, at: event.at });
          }

          const appended = riskEvent ? [event, riskEvent] : [event];
          const ops = [{ kind: "JOB_EVENTS_APPENDED", tenantId, jobId, events: appended }];
          if (idemStoreKey) ops.push({ kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode: 201, body: responseBody } });
          if (outboxMessages.length) ops.push({ kind: "OUTBOX_ENQUEUE", messages: outboxMessages });
          await commitTx(ops);
          return sendJson(res, 201, responseBody);
        }

        if (req.method === "POST" && parts[2] === "book" && parts.length === 3) {
          const body = await readJsonBody(req);

	          const expectedHeader = parseExpectedPrevChainHashHeader(req);
	          if (!expectedHeader.ok) return sendError(res, 428, "missing precondition", "x-proxy-expected-prev-chain-hash is required");

	          let idemStoreKey = null;
	          let idemRequestHash = null;
	          try {
	            ({ idemStoreKey, idemRequestHash } = readIdempotency({
	              method: "POST",
	              requestPath: path,
	              expectedPrevChainHash: expectedHeader.expectedPrevChainHash,
	              body
	            }));
	          } catch (err) {
	            return sendError(res, 400, "invalid idempotency key", { message: err?.message });
	          }
	          if (idemStoreKey) {
	            const existingIdem = store.idempotency.get(idemStoreKey);
	            if (existingIdem) {
	              if (existingIdem.requestHash !== idemRequestHash) {
	                return sendError(res, 409, "idempotency key conflict", "request differs from initial use of this key");
	              }
	              return sendJson(res, existingIdem.statusCode, existingIdem.body);
	            }
	          }

          if (job.status !== "QUOTED") return sendError(res, 400, "job is not bookable");

          const bookingCustomerId = body?.customerId ?? job.customerId ?? null;
          const bookingSiteId = body?.siteId ?? job.siteId ?? null;
          const bookingContractId = body?.contractId ?? job.contractId ?? null;

          const contracts = listContracts({ tenantId });
          let contract = null;
          if (bookingContractId) {
            contract = contracts.find((c) => c?.contractId === bookingContractId) ?? null;
            if (!contract) return sendError(res, 400, "unknown contractId");
          } else {
            contract = selectBestContract(contracts, { customerId: bookingCustomerId, siteId: bookingSiteId, templateId: job.templateId });
          }
          if (!contract) contract = createDefaultContract({ tenantId, nowIso });

          const bookingInput = {
            paymentHoldId: body?.paymentHoldId,
            startAt: body?.startAt,
            endAt: body?.endAt,
            environmentTier: body?.environmentTier,
            requiresOperatorCoverage: body?.requiresOperatorCoverage,
            zoneId: body?.zoneId,
            customerId: bookingCustomerId,
            siteId: bookingSiteId,
            contractId: contract.contractId
          };
          try {
            validateBookingWindowInput(bookingInput);
          } catch (err) {
            return sendError(res, 400, "invalid booking", { message: err?.message });
          }

          const derivedRequiresOperatorCoverage =
            bookingInput.requiresOperatorCoverage === true || bookingInput.environmentTier === ENV_TIER.ENV_IN_HOME;

          const quotedInputs = job.quote?.inputs ?? null;
          const zoneId = normalizeZoneId(bookingInput.zoneId ?? quotedInputs?.zoneId ?? job.constraints?.zoneId);
          if (quotedInputs) {
            if (quotedInputs.startAt !== bookingInput.startAt || quotedInputs.endAt !== bookingInput.endAt) {
              return sendError(res, 409, "booking window differs from quoted window");
            }
            if (quotedInputs.environmentTier && quotedInputs.environmentTier !== bookingInput.environmentTier) {
              return sendError(res, 409, "booking environment tier differs from quoted tier");
            }
            if (
              typeof quotedInputs.requiresOperatorCoverage === "boolean" &&
              quotedInputs.requiresOperatorCoverage !== derivedRequiresOperatorCoverage
            ) {
              return sendError(res, 409, "booking operator coverage differs from quoted coverage");
            }
            if (quotedInputs.zoneId && normalizeZoneId(quotedInputs.zoneId) !== zoneId) {
              return sendError(res, 409, "booking zone differs from quoted zone");
            }
            if (quotedInputs.customerId !== undefined && quotedInputs.customerId !== bookingCustomerId) {
              return sendError(res, 409, "booking customer differs from quoted customer");
            }
            if (quotedInputs.siteId !== undefined && quotedInputs.siteId !== bookingSiteId) {
              return sendError(res, 409, "booking site differs from quoted site");
            }
            if (quotedInputs.contractId !== undefined && quotedInputs.contractId !== contract.contractId) {
              return sendError(res, 409, "booking contract differs from quoted contract");
            }
          }

          const contractVersion =
            Number.isSafeInteger(contract?.contractVersion) && contract.contractVersion > 0 ? contract.contractVersion : 1;
          if (quotedInputs && quotedInputs.contractVersion !== undefined && quotedInputs.contractVersion !== contractVersion) {
            return sendError(res, 409, "booking contract version differs from quoted contract version");
          }

          const baseSla = computeSlaPolicy({ environmentTier: bookingInput.environmentTier });
          const sla = applyContractSlaOverrides({ sla: baseSla, environmentTier: bookingInput.environmentTier, contract });
          const window = { startAt: bookingInput.startAt, endAt: bookingInput.endAt };

          const activeOperatorsList = listAvailableOperators({ tenantId, zoneId, window, ignoreJobId: jobId });
          const activeOperators = activeOperatorsList.length;
          if (derivedRequiresOperatorCoverage && activeOperators <= 0) {
            return sendError(res, 409, "insufficient operator coverage");
          }

          const availableRobotList = listAvailableRobots({ tenantId, zoneId, window, ignoreJobId: jobId });
          const availableRobots = availableRobotList.length;
          if (availableRobots <= 0) return sendError(res, 409, "no available robots for window");
          let avgAvailableRobotTrustScoreBps = 0;
          if (availableRobots > 0) {
            let sum = 0;
            for (const r of availableRobotList) {
              const score = typeof r?.trustScore === "number" && Number.isFinite(r.trustScore) ? r.trustScore : 0;
              sum += Math.max(0, Math.min(1, score));
            }
            avgAvailableRobotTrustScoreBps = Math.max(0, Math.min(10_000, Math.round((sum / availableRobots) * 10_000)));
          }

          const creditPolicy =
            contract.policies?.creditPolicy ?? { enabled: false, defaultAmountCents: 0, maxAmountCents: 0, currency: "USD" };
          const evidencePolicy = contract.policies?.evidencePolicy ?? { retentionDays: 0 };
          const claimPolicy = contract.policies?.claimPolicy ?? { currency: "USD", autoApproveThresholdCents: 0, maxPayoutCents: 0, reservePercent: 0 };
          const coveragePolicy =
            contract.policies?.coveragePolicy ?? {
              required: false,
              coverageTierId: null,
              feeModel: COVERAGE_FEE_MODEL.PER_JOB,
              feeCentsPerJob: 0,
              creditFundingModel: CREDIT_FUNDING_MODEL.PLATFORM_EXPENSE,
              reserveFundPercent: 100,
              insurerId: null,
              recoverablePercent: 100,
              recoverableTerms: null,
              responseSlaSeconds: 0,
              includedAssistSeconds: 0,
              overageRateCentsPerMinute: 0
            };

          const contractDoc = contractDocumentV1FromLegacyContract({ ...contract, contractVersion });
          const customerContractHash = hashContractDocumentV1(contractDoc);
          const { policySnapshot, policyHash, compilerId } = compileBookingPolicySnapshot({
            contractDoc,
            environmentTier: bookingInput.environmentTier,
            requiresOperatorCoverage: derivedRequiresOperatorCoverage,
            sla,
            creditPolicy,
            evidencePolicy,
            claimPolicy,
            coveragePolicy
          });

          const requiredZonesInput = body?.requiredZones ?? null;
          const requiredZones =
            requiredZonesInput && typeof requiredZonesInput === "object"
              ? requiredZonesInput
              : {
                  schemaVersion: "ZoneSet.v1",
                  zoneSetId: `zones_${jobId}`,
                  zones: [{ zoneId: String(zoneId), label: String(zoneId) }]
                };
          let requiredZonesHash;
          try {
            validateZoneSetV1(requiredZones);
            requiredZonesHash = computeZoneSetHash(requiredZones);
          } catch (err) {
            return sendError(res, 400, "invalid requiredZones", { message: err?.message });
          }

          const bookingPayload = {
            paymentHoldId: bookingInput.paymentHoldId,
            startAt: bookingInput.startAt,
            endAt: bookingInput.endAt,
            environmentTier: bookingInput.environmentTier,
            requiresOperatorCoverage: derivedRequiresOperatorCoverage,
            zoneId,
            requiredZones,
            requiredZonesHash,
            sla,
            customerId: bookingCustomerId,
            siteId: bookingSiteId,
            contractId: contract.contractId,
            contractVersion,
            customerContractHash,
            customerCompilerId: compilerId,
            creditPolicy,
            evidencePolicy,
            policySnapshot,
            policyHash
          };
          try {
            validateBookedPayload(bookingPayload);
          } catch (err) {
            return sendError(res, 400, "invalid booking", { message: err?.message });
          }

          const existing = await getJobEventsFresh(tenantId, jobId);
          const currentPrevChainHash = getCurrentPrevChainHash(existing);
          if (expectedHeader.expectedPrevChainHash !== currentPrevChainHash) {
            return sendError(res, 409, "event append conflict", {
              expectedPrevChainHash: currentPrevChainHash,
              gotExpectedPrevChainHash: expectedHeader.expectedPrevChainHash
            });
          }

          const draft = createChainedEvent({
            streamId: jobId,
            type: "BOOKED",
            actor: { type: "requester", id: body?.requesterId ?? "requester_demo" },
            payload: bookingPayload,
            at: nowIso()
          });
          const eventsAfterBook = appendChainedEvent({ events: existing, event: draft, signer: serverSigner });
          const bookedEvent = eventsAfterBook[eventsAfterBook.length - 1];

          try {
            validateDomainEvent({ jobBefore: job, event: bookedEvent, eventsBefore: existing });
          } catch (err) {
            return sendError(res, 400, "event rejected", { message: err?.message });
          }

          let jobAfterBook;
          try {
            jobAfterBook = reduceJob(eventsAfterBook);
          } catch (err) {
            return sendError(res, 400, "job transition rejected", { message: err?.message });
          }

          // Risk scoring is best-effort and should not block booking.
          let riskEvent = null;
          let eventsBeforeDispatch = eventsAfterBook;
          let jobBeforeDispatch = jobAfterBook;
          try {
            const scoredAt = bookedEvent.at;
            const assessment = computeRiskAssessment({
              basis: RISK_BASIS.BOOK,
              templateId: job.templateId,
              environmentTier: bookingInput.environmentTier,
              requiresOperatorCoverage: derivedRequiresOperatorCoverage,
              zoneId,
              siteId: bookingSiteId,
              customerId: bookingCustomerId,
              availableRobots,
              activeOperators,
              avgAvailableRobotTrustScoreBps,
              creditPolicy,
              policyHash,
              jobs: listJobs({ tenantId }),
              getEventsForJob: (id) => getJobEvents(tenantId, id),
              nowIso
            });
            const riskPayload = {
              jobId,
              basis: RISK_BASIS.BOOK,
              scoredAt,
              sourceEventId: bookedEvent.id,
              ...assessment
            };
            const riskDraft = createChainedEvent({
              streamId: jobId,
              type: "RISK_SCORED",
              actor: { type: "risk", id: "risk_v1" },
              payload: riskPayload,
              at: scoredAt
            });
            const eventsAfterRisk = appendChainedEvent({ events: eventsAfterBook, event: riskDraft, signer: serverSigner });
            riskEvent = eventsAfterRisk[eventsAfterRisk.length - 1];
            validateDomainEvent({ jobBefore: jobAfterBook, event: riskEvent, eventsBefore: eventsAfterBook });
            jobBeforeDispatch = reduceJob(eventsAfterRisk);
            eventsBeforeDispatch = eventsAfterRisk;
          } catch {
            riskEvent = null;
            eventsBeforeDispatch = eventsAfterBook;
            jobBeforeDispatch = jobAfterBook;
          }

          const requestedAt = nowIso();
          const dispatchRequestDraft = createChainedEvent({
            streamId: jobId,
            type: "DISPATCH_REQUESTED",
            actor: { type: "dispatch", id: "dispatch_v1" },
            payload: { jobId, requestedAt, trigger: "BOOKED" },
            at: requestedAt
          });
          const nextEvents = appendChainedEvent({ events: eventsBeforeDispatch, event: dispatchRequestDraft, signer: serverSigner });
          const dispatchRequestedEvent = nextEvents[nextEvents.length - 1];

          try {
            validateDomainEvent({ jobBefore: jobBeforeDispatch, event: dispatchRequestedEvent, eventsBefore: eventsBeforeDispatch });
          } catch (err) {
            return sendError(res, 400, "event rejected", { message: err?.message });
          }

          let jobAfter;
          try {
            jobAfter = reduceJob(nextEvents);
          } catch (err) {
            return sendError(res, 400, "job transition rejected", { message: err?.message });
          }

          let ledgerEntries = [];
          try {
            ledgerEntries = ledgerEntriesForJobEvent({ jobBefore: job, event: bookedEvent, eventsBefore: existing });
          } catch (err) {
            return sendError(res, 400, "ledger posting rejected", { message: err?.message });
          }

          const responseBody = {
            event: bookedEvent,
            job: jobAfter,
            ledgerEntryId: ledgerEntries.length ? ledgerEntries[0]?.id ?? null : null,
            ledgerEntryIds: ledgerEntries.map((e) => e?.id).filter(Boolean),
            dispatchRequestedEventId: dispatchRequestedEvent.id
          };

          const outboxMessages = [];
          for (const entry of ledgerEntries) {
            if (!entry) continue;
            outboxMessages.push({ type: "LEDGER_ENTRY_APPLY", tenantId, jobId, sourceEventId: bookedEvent.id, entry });
          }
          if (job.status !== jobAfter.status) {
            outboxMessages.push({ type: "JOB_STATUS_CHANGED", tenantId, jobId, fromStatus: job.status, toStatus: jobAfter.status, at: bookedEvent.at });
          }
          outboxMessages.push({ type: "DISPATCH_REQUESTED", tenantId, jobId, sourceEventId: dispatchRequestedEvent.id, at: dispatchRequestedEvent.at });

          const appended = riskEvent ? [bookedEvent, riskEvent, dispatchRequestedEvent] : [bookedEvent, dispatchRequestedEvent];
          const ops = [{ kind: "JOB_EVENTS_APPENDED", tenantId, jobId, events: appended }];
          if (idemStoreKey) ops.push({ kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode: 201, body: responseBody } });
          if (outboxMessages.length) ops.push({ kind: "OUTBOX_ENQUEUE", messages: outboxMessages });
          await commitTx(ops);
          return sendJson(res, 201, responseBody);
        }

        if (req.method === "POST" && parts[2] === "dispatch" && parts.length === 3) {
          const body = await readJsonBody(req);

	          const expectedHeader = parseExpectedPrevChainHashHeader(req);
	          if (!expectedHeader.ok) return sendError(res, 428, "missing precondition", "x-proxy-expected-prev-chain-hash is required");

	          let idemStoreKey = null;
	          let idemRequestHash = null;
	          try {
	            ({ idemStoreKey, idemRequestHash } = readIdempotency({
	              method: "POST",
	              requestPath: path,
	              expectedPrevChainHash: expectedHeader.expectedPrevChainHash,
	              body
	            }));
	          } catch (err) {
	            return sendError(res, 400, "invalid idempotency key", { message: err?.message });
	          }
	          if (idemStoreKey) {
	            const existingIdem = store.idempotency.get(idemStoreKey);
	            if (existingIdem) {
	              if (existingIdem.requestHash !== idemRequestHash) {
	                return sendError(res, 409, "idempotency key conflict", "request differs from initial use of this key");
	              }
	              return sendJson(res, existingIdem.statusCode, existingIdem.body);
	            }
	          }

          if (job.status !== "BOOKED") return sendError(res, 400, "job is not dispatchable");
          if (!job.booking?.startAt || !job.booking?.endAt) return sendError(res, 400, "job booking window is missing");

          const requiresOperatorCoverage =
            job.booking.requiresOperatorCoverage === true || job.booking.environmentTier === ENV_TIER.ENV_IN_HOME;

          const window = { startAt: job.booking.startAt, endAt: job.booking.endAt };
          const zoneId = getJobZoneId(job);

          const availableOperators = listAvailableOperators({ tenantId, zoneId, window, ignoreJobId: jobId });
          if (requiresOperatorCoverage && availableOperators.length <= 0) {
            return sendError(res, 409, "insufficient operator coverage");
          }

          const robotsInZone = listAvailableRobots({ tenantId, zoneId, window, ignoreJobId: jobId });
          const { selected, candidates } = selectRobotForJob({
            robots: robotsInZone,
            window,
            reservations: (robotId, win) => robotHasOverlappingReservation({ tenantId, robotId, window: win, ignoreJobId: jobId }),
            minTrustScore: 0
          });
          if (!selected) return sendError(res, 409, "no available robots for window");

          const existing = getJobEvents(tenantId, jobId);
          const currentPrevChainHash = getCurrentPrevChainHash(existing);
          if (expectedHeader.expectedPrevChainHash !== currentPrevChainHash) {
            return sendError(res, 409, "event append conflict", {
              expectedPrevChainHash: currentPrevChainHash,
              gotExpectedPrevChainHash: expectedHeader.expectedPrevChainHash
            });
          }

          const evaluatedAt = nowIso();
          const evalPayload = {
            jobId,
            evaluatedAt,
            window,
            zoneId,
            requiresOperatorCoverage,
            candidates: candidates.map((c) => ({ robotId: c.robotId, score: c.score, reasons: ["candidate"], rejected: false })).slice(0, 10),
            selected: { robotId: selected.robotId, operatorId: requiresOperatorCoverage ? availableOperators[0].id : null }
          };
          const evalDraft = createChainedEvent({
            streamId: jobId,
            type: "DISPATCH_EVALUATED",
            actor: { type: "dispatch", id: "dispatch_v1" },
            payload: evalPayload,
            at: evaluatedAt
          });
          const eventsAfterEval = appendChainedEvent({ events: existing, event: evalDraft, signer: serverSigner });
          const evalEvent = eventsAfterEval[eventsAfterEval.length - 1];

          try {
            validateDomainEvent({ jobBefore: job, event: evalEvent, eventsBefore: existing });
          } catch (err) {
            return sendError(res, 400, "event rejected", { message: err?.message });
          }

          let jobAfterEval;
          try {
            jobAfterEval = reduceJob(eventsAfterEval);
          } catch (err) {
            return sendError(res, 400, "job transition rejected", { message: err?.message });
          }

	          const matchDraft = createChainedEvent({
	            streamId: jobId,
	            type: "MATCHED",
	            actor: { type: "dispatch", id: "dispatch_v1" },
	            payload: {
	              robotId: selected.robotId,
	              score: selected.score,
	              algorithm: "trustScore_v2",
	              operatorContractHash: job.booking?.customerContractHash ?? null,
	              operatorPolicyHash: job.booking?.policyHash ?? null,
	              operatorCompilerId: job.booking?.customerCompilerId ?? null
	            },
	            at: nowIso()
	          });
          const eventsAfterMatch = appendChainedEvent({ events: eventsAfterEval, event: matchDraft, signer: serverSigner });
          const matchEvent = eventsAfterMatch[eventsAfterMatch.length - 1];

          try {
            validateDomainEvent({ jobBefore: jobAfterEval, event: matchEvent, eventsBefore: eventsAfterEval });
          } catch (err) {
            return sendError(res, 400, "event rejected", { message: err?.message });
          }

          let jobAfterMatch;
          try {
            jobAfterMatch = reduceJob(eventsAfterMatch);
          } catch (err) {
            return sendError(res, 400, "job transition rejected", { message: err?.message });
          }

          const reservationPayload = {
            robotId: selected.robotId,
            startAt: window.startAt,
            endAt: window.endAt,
            reservationId: createId("rsv"),
            reservedUntil: window.startAt
          };
          const reserveDraft = createChainedEvent({
            streamId: jobId,
            type: "RESERVED",
            actor: { type: "dispatch", id: "dispatch_v1" },
            payload: reservationPayload,
            at: nowIso()
          });
          const nextEvents = appendChainedEvent({ events: eventsAfterMatch, event: reserveDraft, signer: serverSigner });
          const reservedEvent = nextEvents[nextEvents.length - 1];

          try {
            validateDomainEvent({ jobBefore: jobAfterMatch, event: reservedEvent, eventsBefore: eventsAfterMatch });
          } catch (err) {
            return sendError(res, 400, "event rejected", { message: err?.message });
          }

          let jobAfter;
          try {
            jobAfter = reduceJob(nextEvents);
          } catch (err) {
            return sendError(res, 400, "job transition rejected", { message: err?.message });
          }

          let eventsFinal = nextEvents;
          const appendedEvents = [evalEvent, matchEvent, reservedEvent];

          if (requiresOperatorCoverage) {
            const operatorId = availableOperators[0].id;
            const coveragePayload = {
              jobId,
              operatorId,
              startAt: window.startAt,
              endAt: window.endAt,
              reservationId: createId("opcov"),
              zoneId
            };
            const coverageDraft = createChainedEvent({
              streamId: jobId,
              type: "OPERATOR_COVERAGE_RESERVED",
              actor: { type: "dispatch", id: "dispatch_v1" },
              payload: coveragePayload,
              at: nowIso()
            });
            eventsFinal = appendChainedEvent({ events: eventsFinal, event: coverageDraft, signer: serverSigner });
            const coverageEvent = eventsFinal[eventsFinal.length - 1];

            try {
              validateDomainEvent({ jobBefore: jobAfter, event: coverageEvent, eventsBefore: nextEvents });
            } catch (err) {
              return sendError(res, 400, "event rejected", { message: err?.message });
            }

            appendedEvents.push(coverageEvent);
            jobAfter = reduceJob(eventsFinal);
          }

          const confirmedAt = nowIso();
          const confirmDraft = createChainedEvent({
            streamId: jobId,
            type: "DISPATCH_CONFIRMED",
            actor: { type: "dispatch", id: "dispatch_v1" },
            payload: { jobId, confirmedAt },
            at: confirmedAt
          });
          eventsFinal = appendChainedEvent({ events: eventsFinal, event: confirmDraft, signer: serverSigner });
          const confirmEvent = eventsFinal[eventsFinal.length - 1];
          try {
            validateDomainEvent({ jobBefore: jobAfter, event: confirmEvent, eventsBefore: eventsFinal.slice(0, -1) });
          } catch (err) {
            return sendError(res, 400, "event rejected", { message: err?.message });
          }
          appendedEvents.push(confirmEvent);
          jobAfter = reduceJob(eventsFinal);

          const responseBody = { events: appendedEvents, job: jobAfter };
          const outboxMessages = [];
          if (job.status !== jobAfter.status) {
            outboxMessages.push({ type: "JOB_STATUS_CHANGED", tenantId, jobId, fromStatus: job.status, toStatus: jobAfter.status, at: confirmedAt });
          }

          const ops = [{ kind: "JOB_EVENTS_APPENDED", tenantId, jobId, events: appendedEvents }];
          if (idemStoreKey) ops.push({ kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode: 201, body: responseBody } });
          if (outboxMessages.length) ops.push({ kind: "OUTBOX_ENQUEUE", messages: outboxMessages });
          await commitTx(ops);

          return sendJson(res, 201, responseBody);
        }

	        if (req.method === "POST" && parts[2] === "reschedule" && parts.length === 3) {
          const body = await readJsonBody(req);

	          const expectedHeader = parseExpectedPrevChainHashHeader(req);
	          if (!expectedHeader.ok) return sendError(res, 428, "missing precondition", "x-proxy-expected-prev-chain-hash is required");

	          let idemStoreKey = null;
	          let idemRequestHash = null;
	          try {
	            ({ idemStoreKey, idemRequestHash } = readIdempotency({
	              method: "POST",
	              requestPath: path,
	              expectedPrevChainHash: expectedHeader.expectedPrevChainHash,
	              body
	            }));
	          } catch (err) {
	            return sendError(res, 400, "invalid idempotency key", { message: err?.message });
	          }
	          if (idemStoreKey) {
	            const existingIdem = store.idempotency.get(idemStoreKey);
	            if (existingIdem) {
	              if (existingIdem.requestHash !== idemRequestHash) {
	                return sendError(res, 409, "idempotency key conflict", "request differs from initial use of this key");
	              }
	              return sendJson(res, existingIdem.statusCode, existingIdem.body);
	            }
	          }

          if (job.status !== "BOOKED" && job.status !== "MATCHED" && job.status !== "RESERVED") {
            return sendError(res, 400, "job is not reschedulable");
          }

          const booking = job.booking;
          if (!booking) return sendError(res, 400, "job is missing booking");

          const reschedulePayload = {
            jobId,
            oldWindow: { startAt: booking.startAt, endAt: booking.endAt },
            newWindow: { startAt: body?.startAt, endAt: body?.endAt },
            reason: body?.reason ?? "CUSTOMER_REQUEST",
            requestedBy: body?.requestedBy ?? "customer",
            requiresRequote: false
          };
          try {
            validateJobRescheduledPayload(reschedulePayload);
          } catch (err) {
            return sendError(res, 400, "invalid reschedule", { message: err?.message });
          }

          const newWindow = reschedulePayload.newWindow;

          const zoneId = getJobZoneId(job);
          const requiresOperatorCoverage = booking.requiresOperatorCoverage === true;
          const availableOperators = requiresOperatorCoverage ? listAvailableOperators({ tenantId, zoneId, window: newWindow, ignoreJobId: jobId }) : [];
          if (requiresOperatorCoverage && availableOperators.length <= 0) {
            return sendError(res, 409, "insufficient operator coverage");
          }

          const robotsInZone = listAvailableRobots({ tenantId, zoneId, window: newWindow, ignoreJobId: jobId });
          if (robotsInZone.length <= 0) return sendError(res, 409, "no available robots for window");

          const existing = getJobEvents(tenantId, jobId);
          const currentPrevChainHash = getCurrentPrevChainHash(existing);
          if (expectedHeader.expectedPrevChainHash !== currentPrevChainHash) {
            return sendError(res, 409, "event append conflict", {
              expectedPrevChainHash: currentPrevChainHash,
              gotExpectedPrevChainHash: expectedHeader.expectedPrevChainHash
            });
          }

          const rescheduleDraft = createChainedEvent({
            streamId: jobId,
            type: "JOB_RESCHEDULED",
            at: nowIso(),
            actor: { type: "scheduler", id: "scheduler_v0" },
            payload: reschedulePayload
          });
          const eventsAfterReschedule = appendChainedEvent({ events: existing, event: rescheduleDraft, signer: serverSigner });
          const rescheduleEvent = eventsAfterReschedule[eventsAfterReschedule.length - 1];

          try {
            validateDomainEvent({ jobBefore: job, event: rescheduleEvent, eventsBefore: existing });
          } catch (err) {
            return sendError(res, 400, "event rejected", { message: err?.message });
          }

          let jobAfterReschedule;
          try {
            jobAfterReschedule = reduceJob(eventsAfterReschedule);
          } catch (err) {
            return sendError(res, 400, "job transition rejected", { message: err?.message });
          }

          let nextEvents = eventsAfterReschedule;
          const appendedEvents = [rescheduleEvent];
          let jobAfter = jobAfterReschedule;

          // If previously reserved, re-dispatch/reserve atomically (or fail).
          if (job.reservation) {
            const selection = selectRobotForJob({
              robots: robotsInZone,
              window: newWindow,
              reservations: (robotId, win) => robotHasOverlappingReservation({ tenantId, robotId, window: win, ignoreJobId: jobId }),
              minTrustScore: 0
            });
            const selected = selection.selected;
            if (!selected) return sendError(res, 409, "no available robots for window");

	            const matchDraft = createChainedEvent({
	              streamId: jobId,
	              type: "MATCHED",
	              at: nowIso(),
	              actor: { type: "dispatch", id: "dispatch_v1" },
	              payload: {
	                robotId: selected.robotId,
	                score: selected.score,
	                algorithm: "trustScore_v2",
	                operatorContractHash: jobAfterReschedule.booking?.customerContractHash ?? null,
	                operatorPolicyHash: jobAfterReschedule.booking?.policyHash ?? null,
	                operatorCompilerId: jobAfterReschedule.booking?.customerCompilerId ?? null
	              }
	            });
            const eventsAfterMatch = appendChainedEvent({ events: nextEvents, event: matchDraft, signer: serverSigner });
            const matchEvent = eventsAfterMatch[eventsAfterMatch.length - 1];

            try {
              validateDomainEvent({ jobBefore: jobAfterReschedule, event: matchEvent, eventsBefore: nextEvents });
            } catch (err) {
              return sendError(res, 400, "event rejected", { message: err?.message });
            }

            let jobAfterMatch;
            try {
              jobAfterMatch = reduceJob(eventsAfterMatch);
            } catch (err) {
              return sendError(res, 400, "job transition rejected", { message: err?.message });
            }

            const reservationPayload = {
              robotId: selected.robotId,
              startAt: newWindow.startAt,
              endAt: newWindow.endAt,
              reservationId: createId("rsv"),
              reservedUntil: newWindow.startAt
            };
            const reserveDraft = createChainedEvent({
              streamId: jobId,
              type: "RESERVED",
              at: nowIso(),
              actor: { type: "dispatch", id: "dispatch_v1" },
              payload: reservationPayload
            });
            const eventsAfterReserve = appendChainedEvent({ events: eventsAfterMatch, event: reserveDraft, signer: serverSigner });
            const reservedEvent = eventsAfterReserve[eventsAfterReserve.length - 1];

            try {
              validateDomainEvent({ jobBefore: jobAfterMatch, event: reservedEvent, eventsBefore: eventsAfterMatch });
            } catch (err) {
              return sendError(res, 400, "event rejected", { message: err?.message });
            }

            try {
              jobAfter = reduceJob(eventsAfterReserve);
            } catch (err) {
              return sendError(res, 400, "job transition rejected", { message: err?.message });
            }

            nextEvents = eventsAfterReserve;
            appendedEvents.push(matchEvent, reservedEvent);

            if (requiresOperatorCoverage) {
              const operatorId = availableOperators[0].id;
              const coveragePayload = {
                jobId,
                operatorId,
                startAt: newWindow.startAt,
                endAt: newWindow.endAt,
                reservationId: createId("opcov"),
                zoneId
              };
              const coverageDraft = createChainedEvent({
                streamId: jobId,
                type: "OPERATOR_COVERAGE_RESERVED",
                actor: { type: "dispatch", id: "dispatch_v1" },
                payload: coveragePayload,
                at: nowIso()
              });
              const eventsAfterCoverage = appendChainedEvent({ events: nextEvents, event: coverageDraft, signer: serverSigner });
              const coverageEvent = eventsAfterCoverage[eventsAfterCoverage.length - 1];

              try {
                validateDomainEvent({ jobBefore: jobAfter, event: coverageEvent, eventsBefore: nextEvents });
              } catch (err) {
                return sendError(res, 400, "event rejected", { message: err?.message });
              }

              try {
                jobAfter = reduceJob(eventsAfterCoverage);
              } catch (err) {
                return sendError(res, 400, "job transition rejected", { message: err?.message });
              }

              nextEvents = eventsAfterCoverage;
              appendedEvents.push(coverageEvent);
            }
          }

          const responseBody = { events: appendedEvents, job: jobAfter };
          const outboxMessages = [];
          if (job.status !== jobAfter.status) {
            outboxMessages.push({ type: "JOB_STATUS_CHANGED", tenantId, jobId, fromStatus: job.status, toStatus: jobAfter.status, at: rescheduleEvent.at });
          }

          const ops = [{ kind: "JOB_EVENTS_APPENDED", tenantId, jobId, events: appendedEvents }];
          if (idemStoreKey) ops.push({ kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode: 201, body: responseBody } });
          if (outboxMessages.length) ops.push({ kind: "OUTBOX_ENQUEUE", messages: outboxMessages });

          await commitTx(ops);

	          return sendJson(res, 201, responseBody);
	        }

	        if (req.method === "POST" && parts[2] === "dispute" && parts[3] === "open" && parts.length === 4) {
	          const body = await readJsonBody(req);
	          const expectedHeader = parseExpectedPrevChainHashHeader(req);
	          if (!expectedHeader.ok) return sendError(res, 428, "missing precondition", "x-proxy-expected-prev-chain-hash is required");

	          const ok = requireScope(auth.scopes, OPS_SCOPES.OPS_WRITE) || requireScope(auth.scopes, OPS_SCOPES.FINANCE_WRITE);
	          if (!ok) return sendError(res, 403, "forbidden");

	          let idemStoreKey = null;
	          let idemRequestHash = null;
	          try {
	            ({ idemStoreKey, idemRequestHash } = readIdempotency({
	              method: "POST",
	              requestPath: path,
	              expectedPrevChainHash: expectedHeader.expectedPrevChainHash,
	              body
	            }));
	          } catch (err) {
	            return sendError(res, 400, "invalid idempotency key", { message: err?.message });
	          }
	          if (idemStoreKey) {
	            const existingIdem = store.idempotency.get(idemStoreKey);
	            if (existingIdem) {
	              if (existingIdem.requestHash !== idemRequestHash) {
	                return sendError(res, 409, "idempotency key conflict", "request differs from initial use of this key");
	              }
	              return sendJson(res, existingIdem.statusCode, existingIdem.body);
	            }
	          }

	          const existing = getJobEvents(tenantId, jobId);
	          const currentPrevChainHash = getCurrentPrevChainHash(existing);
	          if (expectedHeader.expectedPrevChainHash !== currentPrevChainHash) {
	            return sendError(res, 409, "event append conflict", {
	              expectedPrevChainHash: currentPrevChainHash,
	              gotExpectedPrevChainHash: expectedHeader.expectedPrevChainHash
	            });
	          }

	          const disputeId = body?.disputeId ?? createId("dsp");
	          const openedAt = nowIso();
	          const payload = { jobId, disputeId, openedAt, reason: body?.reason ?? null };
	          const draft = createChainedEvent({
	            streamId: jobId,
	            type: "DISPUTE_OPENED",
	            actor: { type: "ops", id: principalId },
	            payload,
	            at: openedAt
	          });
	          const nextEvents = appendChainedEvent({ events: existing, event: draft, signer: serverSigner });
	          const event = nextEvents[nextEvents.length - 1];

	          try {
	            validateDomainEvent({ jobBefore: reduceJob(existing), event, eventsBefore: existing });
	          } catch (err) {
	            return sendError(res, 400, "event rejected", { message: err?.message }, { code: err?.code ?? null });
	          }

	          let jobAfter;
	          try {
	            jobAfter = reduceJob(nextEvents);
	          } catch (err) {
	            return sendError(res, 400, "job transition rejected", { message: err?.message });
	          }

	          const responseBody = { event, job: jobAfter };
	          const ops = [{ kind: "JOB_EVENTS_APPENDED", tenantId, jobId, events: [event] }];
	          if (idemStoreKey) ops.push({ kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode: 201, body: responseBody } });
	          await commitTx(ops);
	          return sendJson(res, 201, responseBody);
	        }

	        if (req.method === "POST" && parts[2] === "dispute" && parts[3] === "close" && parts.length === 4) {
	          const body = await readJsonBody(req);
	          const expectedHeader = parseExpectedPrevChainHashHeader(req);
	          if (!expectedHeader.ok) return sendError(res, 428, "missing precondition", "x-proxy-expected-prev-chain-hash is required");

	          const ok = requireScope(auth.scopes, OPS_SCOPES.OPS_WRITE) || requireScope(auth.scopes, OPS_SCOPES.FINANCE_WRITE);
	          if (!ok) return sendError(res, 403, "forbidden");

	          let idemStoreKey = null;
	          let idemRequestHash = null;
	          try {
	            ({ idemStoreKey, idemRequestHash } = readIdempotency({
	              method: "POST",
	              requestPath: path,
	              expectedPrevChainHash: expectedHeader.expectedPrevChainHash,
	              body
	            }));
	          } catch (err) {
	            return sendError(res, 400, "invalid idempotency key", { message: err?.message });
	          }
	          if (idemStoreKey) {
	            const existingIdem = store.idempotency.get(idemStoreKey);
	            if (existingIdem) {
	              if (existingIdem.requestHash !== idemRequestHash) {
	                return sendError(res, 409, "idempotency key conflict", "request differs from initial use of this key");
	              }
	              return sendJson(res, existingIdem.statusCode, existingIdem.body);
	            }
	          }

	          const existing = getJobEvents(tenantId, jobId);
	          const currentPrevChainHash = getCurrentPrevChainHash(existing);
	          if (expectedHeader.expectedPrevChainHash !== currentPrevChainHash) {
	            return sendError(res, 409, "event append conflict", {
	              expectedPrevChainHash: currentPrevChainHash,
	              gotExpectedPrevChainHash: expectedHeader.expectedPrevChainHash
	            });
	          }

	          const disputeId = body?.disputeId ?? null;
	          if (typeof disputeId !== "string" || disputeId.trim() === "") return sendError(res, 400, "disputeId is required");

	          const closedAt = nowIso();
	          const payload = { jobId, disputeId, closedAt, resolution: body?.resolution ?? null };
	          const draft = createChainedEvent({
	            streamId: jobId,
	            type: "DISPUTE_CLOSED",
	            actor: { type: "ops", id: principalId },
	            payload,
	            at: closedAt
	          });
	          const nextEvents = appendChainedEvent({ events: existing, event: draft, signer: serverSigner });
	          const event = nextEvents[nextEvents.length - 1];

	          try {
	            validateDomainEvent({ jobBefore: reduceJob(existing), event, eventsBefore: existing });
	          } catch (err) {
	            return sendError(res, 400, "event rejected", { message: err?.message }, { code: err?.code ?? null });
	          }

	          let jobAfter;
	          try {
	            jobAfter = reduceJob(nextEvents);
	          } catch (err) {
	            return sendError(res, 400, "job transition rejected", { message: err?.message });
	          }

	          const responseBody = { event, job: jobAfter };
	          const ops = [{ kind: "JOB_EVENTS_APPENDED", tenantId, jobId, events: [event] }];
	          if (idemStoreKey) ops.push({ kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode: 201, body: responseBody } });
	          await commitTx(ops);
	          return sendJson(res, 201, responseBody);
	        }

	        if (parts[2] === "events") {
	          if (req.method === "GET" && parts.length === 3) {
	            return sendJson(res, 200, { events: await getJobEventsFresh(tenantId, jobId, { force: true }) });
	          }

          if (req.method === "POST" && parts.length === 3) {
            if (!requireProtocolHeaderForWrite(req, res)) return;
            const body = await readJsonBody(req);
            {
              const schemaCheck = parseEventSchemaVersionFromBody(body);
              if (!schemaCheck.ok) return sendError(res, schemaCheck.statusCode ?? 400, schemaCheck.message, schemaCheck.details ?? null, { code: schemaCheck.code });
            }
	            const type = body?.type;
	            if (!type) return sendError(res, 400, "type is required");

	            {
	              const financeOnly = new Set(["SETTLED", "SETTLEMENT_FORFEITED", "DECISION_RECORDED"]);
	              const dispute = new Set(["DISPUTE_OPENED", "DISPUTE_CLOSED"]);
	              if (financeOnly.has(type)) {
	                if (!requireScope(auth.scopes, OPS_SCOPES.FINANCE_WRITE)) return sendError(res, 403, "forbidden");
	              } else if (dispute.has(type)) {
	                const ok = requireScope(auth.scopes, OPS_SCOPES.OPS_WRITE) || requireScope(auth.scopes, OPS_SCOPES.FINANCE_WRITE);
	                if (!ok) return sendError(res, 403, "forbidden");
	              } else {
	                if (!requireScope(auth.scopes, OPS_SCOPES.OPS_WRITE)) return sendError(res, 403, "forbidden");
	              }
	            }

	            const signerKind = requiredSignerKindForEventType(type);
	            const existing = await getJobEventsFresh(tenantId, jobId, { force: true });
	            const jobBefore = reduceJob(existing);
		            if (!jobBefore) return sendError(res, 404, "job not found");
	            const currentPrevChainHash = getCurrentPrevChainHash(existing);

	            const expectedHeader = parseExpectedPrevChainHashHeader(req);
	            let idemStoreKey = null;
	            let idemRequestHash = null;
	            try {
	              ({ idemStoreKey, idemRequestHash } = readIdempotency({
	                method: "POST",
	                requestPath: path,
	                expectedPrevChainHash: expectedHeader.ok ? expectedHeader.expectedPrevChainHash : null,
	                body
	              }));
	            } catch (err) {
	              return sendError(res, 400, "invalid idempotency key", { message: err?.message });
	            }
	            if (idemStoreKey) {
	              const existingIdem = store.idempotency.get(idemStoreKey);
	              if (existingIdem) {
	                if (existingIdem.requestHash !== idemRequestHash) {
	                  return sendError(res, 409, "idempotency key conflict", "request differs from initial use of this key");
                }
                return sendJson(res, existingIdem.statusCode, existingIdem.body);
              }
            }

            // If a client supplies hash/signature, treat it as a finalized (agent-signed) event.
            const isClientFinalized = Boolean(body?.payloadHash || body?.chainHash || body?.signature || body?.signerKeyId || body?.prevChainHash);

            let nextEvents;
            let event;

            if (isClientFinalized) {
              event = {
                v: body?.v ?? 1,
                id: body?.id,
                at: body?.at,
                streamId: body?.streamId,
                type,
                actor: body?.actor ?? null,
                payload: body?.payload ?? null,
                payloadHash: body?.payloadHash ?? null,
                prevChainHash: body?.prevChainHash ?? null,
                chainHash: body?.chainHash ?? null,
                signature: body?.signature ?? null,
                signerKeyId: body?.signerKeyId ?? null
              };

              try {
                if (event.v !== 1) throw new TypeError("event.v must be 1");
                assertNonEmptyString(event.id, "event.id");
                assertIsoDate(event.at, "event.at");
                assertNonEmptyString(event.streamId, "event.streamId");
                if (event.streamId !== jobId) throw new TypeError("event.streamId must match jobId");
                assertActor(event.actor);
                assertNonEmptyString(event.type, "event.type");
                assertNonEmptyString(event.payloadHash, "event.payloadHash");
                assertNonEmptyString(event.chainHash, "event.chainHash");
              } catch (err) {
                return sendError(res, 400, "invalid event envelope", { message: err?.message });
              }

              {
                const atMs = Date.parse(event.at);
                const nowMs = Date.parse(nowIso());
                const maxSkewMs = 5 * 60_000;
                if (Number.isFinite(atMs) && Number.isFinite(nowMs) && atMs > nowMs + maxSkewMs) {
                  return sendError(res, 400, "event.at is too far in the future");
                }
              }

              if (event.prevChainHash !== currentPrevChainHash) {
                return sendError(res, 409, "event append conflict", {
                  expectedPrevChainHash: currentPrevChainHash,
                  gotPrevChainHash: event.prevChainHash
                });
              }

              await ensureSignerContextFresh({ tenantId, event });
              nextEvents = [...existing, event];
              const verify = verifyChainedEvents(nextEvents, { publicKeyByKeyId: store.publicKeyByKeyId });
              if (!verify.ok) return sendError(res, 400, "event chain verification failed", verify.error);

              try {
                enforceSignaturePolicy({ tenantId, signerKind, event });
              } catch (err) {
                return sendError(res, 400, "signature policy rejected", { message: err?.message });
              }
            } else {
              try {
                assertActor(body?.actor);
              } catch (err) {
                return sendError(res, 400, "invalid actor", { message: err?.message });
              }

              if (
                signerKind === SIGNER_KIND.ROBOT ||
                signerKind === SIGNER_KIND.OPERATOR ||
                signerKind === SIGNER_KIND.ROBOT_OR_OPERATOR
              ) {
                return sendError(res, 400, "event must be client-finalized and signed for this type");
              }
              if (body.actor.type === "robot" || body.actor.type === "operator") {
                return sendError(res, 400, "robot/operator actors must use signer-enforced event types");
              }

              if (!expectedHeader.ok) {
                return sendError(res, 428, "missing precondition", "x-proxy-expected-prev-chain-hash is required");
              }
              if (expectedHeader.expectedPrevChainHash !== currentPrevChainHash) {
                return sendError(res, 409, "event append conflict", {
                  expectedPrevChainHash: currentPrevChainHash,
                  gotExpectedPrevChainHash: expectedHeader.expectedPrevChainHash
                });
              }

	              let serverPayload = body?.payload ?? null;
	              if (type === "DECISION_RECORDED") {
	                const base = serverPayload && typeof serverPayload === "object" && !Array.isArray(serverPayload) ? serverPayload : {};
	                const decisionId = typeof base.decisionId === "string" && base.decisionId.trim() ? base.decisionId : createId("dec");
	                const kind = typeof base.kind === "string" && base.kind.trim() ? base.kind : "SETTLEMENT_FORFEIT";

	                // Best-effort: infer holdId from the current active hold if omitted.
	                let holdId = typeof base.holdId === "string" && base.holdId.trim() ? base.holdId : null;
	                if (!holdId) {
	                  for (let i = existing.length - 1; i >= 0; i -= 1) {
	                    const e = existing[i];
	                    if (e?.type !== "SETTLEMENT_HELD") continue;
	                    const hp = e.payload ?? null;
	                    if (!hp || typeof hp !== "object") continue;
	                    if (typeof hp.holdId === "string" && hp.holdId.trim()) {
	                      holdId = hp.holdId;
	                      break;
	                    }
	                  }
	                }

	                serverPayload = {
	                  jobId,
	                  decisionId,
	                  decidedAt: nowIso(),
	                  kind,
	                  holdId,
	                  forfeitureReason: base.forfeitureReason ?? base.reason ?? null,
	                  reasonCodes: Array.isArray(base.reasonCodes) ? base.reasonCodes : [],
	                  evidenceRefs: Array.isArray(base.evidenceRefs) ? base.evidenceRefs : [],
	                  policyHash: base.policyHash ?? jobBefore?.booking?.policyHash ?? jobBefore?.customerPolicyHash ?? null
	                };
	              }
	              if (type === "SETTLED") {
                const proofPolicy = jobBefore.booking?.policySnapshot?.proofPolicy ?? null;
                const gateModeRaw = typeof proofPolicy?.gateMode === "string" ? proofPolicy.gateMode : "warn";
                const gateMode = gateModeRaw === "strict" || gateModeRaw === "holdback" ? gateModeRaw : "warn";

                if (jobBefore.status === "COMPLETED" && gateMode !== "warn") {
                  let completionChainHash = null;
                  for (let i = existing.length - 1; i >= 0; i -= 1) {
                    const e = existing[i];
                    if (e?.type !== "EXECUTION_COMPLETED" && e?.type !== "JOB_EXECUTION_COMPLETED") continue;
                    const ch = typeof e?.chainHash === "string" ? e.chainHash.trim() : "";
                    if (!ch) continue;
                    completionChainHash = ch;
                    break;
                  }

                  const anchorIdx = completionChainHash ? existing.findIndex((e) => e?.chainHash === completionChainHash) : -1;
                  const anchorSlice = anchorIdx === -1 ? null : existing.slice(0, anchorIdx + 1);
                  const jobAtAnchor = anchorSlice ? reduceJob(anchorSlice) : null;
                  const current =
                    jobAtAnchor && completionChainHash
                      ? verifyZoneCoverageProofV1({
                          job: jobAtAnchor,
                          events: existing,
                          evaluatedAtChainHash: completionChainHash,
                          customerPolicyHash: jobAtAnchor.customerPolicyHash ?? jobAtAnchor.booking?.policyHash ?? null,
                          operatorPolicyHash: jobAtAnchor.operatorPolicyHash ?? null
                        })
                      : null;
                  const expectedFactsHash = current?.factsHash ?? null;
                  const expectedCustomerPolicyHash = current?.anchors?.customerPolicyHash ?? (jobAtAnchor?.customerPolicyHash ?? jobAtAnchor?.booking?.policyHash ?? null);

                  let proofEvent = null;
                  if (completionChainHash && expectedFactsHash) {
                    for (let i = existing.length - 1; i >= 0; i -= 1) {
                      const e = existing[i];
                      if (e?.type !== "PROOF_EVALUATED") continue;
                      const p = e.payload ?? null;
                      if (!p || typeof p !== "object") continue;
                      if (p.evaluatedAtChainHash !== completionChainHash) continue;
                      if (p.factsHash !== expectedFactsHash) continue;
                      if (expectedCustomerPolicyHash && p.customerPolicyHash !== expectedCustomerPolicyHash) continue;
                      proofEvent = e;
                      break;
                    }
                  }

	                  if (proofEvent) {
	                    const p = proofEvent.payload ?? {};
	                    const proofStatus = p.status === null || p.status === undefined ? null : String(p.status).trim();
	
	                    let forfeit = null;
	                    if (proofStatus === "INSUFFICIENT_EVIDENCE") {
	                      let holdId = null;
	                      for (let i = existing.length - 1; i >= 0; i -= 1) {
	                        const e = existing[i];
	                        if (e?.type !== "SETTLEMENT_HELD") continue;
	                        const hp = e.payload ?? null;
	                        if (!hp || typeof hp !== "object") continue;
	                        if (hp.evaluatedAtChainHash !== completionChainHash) continue;
	                        if (hp.factsHash !== expectedFactsHash) continue;
	                        if (typeof hp.holdId === "string" && hp.holdId.trim()) {
	                          holdId = hp.holdId;
	                          break;
	                        }
	                      }
	
	                      const forfeitEvent =
	                        holdId &&
	                        existing
	                          .slice()
	                          .reverse()
	                          .find((e) => e?.type === "SETTLEMENT_FORFEITED" && e?.payload?.holdId === holdId && e?.payload?.factsHash === expectedFactsHash);
	                      if (forfeitEvent) {
	                        const fp = forfeitEvent.payload ?? null;
	                        forfeit = {
	                          holdId,
	                          forfeitureReason: fp?.forfeitureReason ?? null,
	                          forfeitEventId: forfeitEvent.id ?? null,
	                          forfeitEventChainHash: forfeitEvent.chainHash ?? null,
	                          forfeitEventPayloadHash: forfeitEvent.payloadHash ?? null
	                        };
	                      }
	                    }
	
	                    if (proofStatus !== "INSUFFICIENT_EVIDENCE" || forfeit) {
	                      const settlementProofRef = {
	                        proofEventId: proofEvent.id ?? null,
	                        proofEventAt: p.evaluatedAt ?? proofEvent.at ?? null,
	                        proofEventChainHash: proofEvent.chainHash ?? null,
	                        proofEventPayloadHash: proofEvent.payloadHash ?? null,
	                        proofEventSignerKeyId: proofEvent.signerKeyId ?? null,
	                        proofEventSignature: proofEvent.signature ?? null,
	                        evaluationId: p.evaluationId ?? null,
	                        evaluatedAtChainHash: p.evaluatedAtChainHash ?? null,
	                        status: forfeit ? "FAIL" : proofStatus,
	                        reasonCodes: Array.isArray(p.reasonCodes) ? p.reasonCodes : [],
	                        requiredZonesHash: p.requiredZonesHash ?? null,
	                        customerPolicyHash: p.customerPolicyHash ?? null,
	                        operatorPolicyHash: p.operatorPolicyHash ?? null,
	                        factsHash: p.factsHash ?? null,
	                        metrics: p.metrics ?? null,
	                        ...(forfeit ? { forfeit } : null)
	                      };

	                      const base = serverPayload && typeof serverPayload === "object" && !Array.isArray(serverPayload) ? serverPayload : {};
	                      serverPayload = { ...base, settlementProofRef };
	                    }
	                  }
	                }
	              }

	              if (type === "SETTLEMENT_FORFEITED") {
	                const base = serverPayload && typeof serverPayload === "object" && !Array.isArray(serverPayload) ? serverPayload : {};
	                let completionChainHash = null;
	                for (let i = existing.length - 1; i >= 0; i -= 1) {
	                  const e = existing[i];
	                  if (e?.type !== "EXECUTION_COMPLETED" && e?.type !== "JOB_EXECUTION_COMPLETED") continue;
	                  const ch = typeof e?.chainHash === "string" ? e.chainHash.trim() : "";
	                  if (!ch) continue;
	                  completionChainHash = ch;
	                  break;
	                }
	
	                const anchorIdx = completionChainHash ? existing.findIndex((e) => e?.chainHash === completionChainHash) : -1;
	                const anchorSlice = anchorIdx === -1 ? null : existing.slice(0, anchorIdx + 1);
	                const jobAtAnchor = anchorSlice ? reduceJob(anchorSlice) : null;
	                const current =
	                  jobAtAnchor && completionChainHash
	                    ? verifyZoneCoverageProofV1({
	                        job: jobAtAnchor,
	                        events: existing,
	                        evaluatedAtChainHash: completionChainHash,
	                        customerPolicyHash: jobAtAnchor.customerPolicyHash ?? jobAtAnchor.booking?.policyHash ?? null,
	                        operatorPolicyHash: jobAtAnchor.operatorPolicyHash ?? null
	                      })
	                    : null;
	                const expectedFactsHash = current?.factsHash ?? null;
	
	                let holdId = typeof base.holdId === "string" && base.holdId.trim() ? base.holdId : null;
	                if (!holdId && completionChainHash && expectedFactsHash) {
	                  for (let i = existing.length - 1; i >= 0; i -= 1) {
	                    const e = existing[i];
	                    if (e?.type !== "SETTLEMENT_HELD") continue;
	                    const hp = e.payload ?? null;
	                    if (!hp || typeof hp !== "object") continue;
	                    if (hp.evaluatedAtChainHash !== completionChainHash) continue;
	                    if (hp.factsHash !== expectedFactsHash) continue;
	                    if (typeof hp.holdId === "string" && hp.holdId.trim()) {
	                      holdId = hp.holdId;
	                      break;
	                    }
	                  }
	                }
	
	                serverPayload = {
	                  ...base,
	                  jobId,
	                  holdId,
	                  forfeitedAt: nowIso(),
	                  forfeitureReason: base.forfeitureReason ?? base.reason ?? "MANUAL",
	                  decisionRef: base.decisionRef ?? null,
	                  evaluatedAtChainHash: completionChainHash,
	                  factsHash: expectedFactsHash
	                };

	                // Prefer a verifiable, signed decision event reference when present.
	                let decisionEvent = null;
	                const decisionEventIdRaw = typeof base.decisionEventId === "string" && base.decisionEventId.trim() ? base.decisionEventId : null;
	                const decisionIdRaw = typeof base.decisionId === "string" && base.decisionId.trim() ? base.decisionId : null;

	                if (decisionEventIdRaw) {
	                  decisionEvent = existing.find((e) => e?.id === decisionEventIdRaw) ?? null;
	                } else if (decisionIdRaw) {
	                  decisionEvent =
	                    existing
	                      .slice()
	                      .reverse()
	                      .find((e) => e?.type === "DECISION_RECORDED" && e?.payload?.decisionId === decisionIdRaw) ?? null;
	                } else {
	                  decisionEvent =
	                    existing
	                      .slice()
	                      .reverse()
	                      .find(
	                        (e) =>
	                          e?.type === "DECISION_RECORDED" &&
	                          e?.payload?.kind === "SETTLEMENT_FORFEIT" &&
	                          e?.payload?.holdId === holdId &&
	                          e?.payload?.forfeitureReason === (serverPayload.forfeitureReason ?? null)
	                      ) ?? null;
	                }

	                if (decisionEvent && decisionEvent.type === "DECISION_RECORDED") {
	                  const p = decisionEvent.payload ?? null;
	                  serverPayload = {
	                    ...serverPayload,
	                    decisionEventRef: {
	                      decisionEventId: decisionEvent.id ?? null,
	                      decisionEventAt: p?.decidedAt ?? decisionEvent.at ?? null,
	                      decisionEventChainHash: decisionEvent.chainHash ?? null,
	                      decisionEventPayloadHash: decisionEvent.payloadHash ?? null,
	                      decisionEventSignerKeyId: decisionEvent.signerKeyId ?? null,
	                      decisionEventSignature: decisionEvent.signature ?? null,
	                      decisionId: p?.decisionId ?? null,
	                      kind: p?.kind ?? null,
	                      holdId: p?.holdId ?? null,
	                      forfeitureReason: p?.forfeitureReason ?? null,
	                      reasonCodes: Array.isArray(p?.reasonCodes) ? p.reasonCodes : [],
	                      evidenceRefs: Array.isArray(p?.evidenceRefs) ? p.evidenceRefs : [],
	                      policyHash: p?.policyHash ?? null
	                    }
	                  };
	                }
	              }

	              event = createChainedEvent({
	                streamId: jobId,
	                type,
                actor: body?.actor,
                payload: serverPayload,
                at: nowIso()
              });
              nextEvents = appendChainedEvent({ events: existing, event, signer: serverSigner });
              event = nextEvents[nextEvents.length - 1];
            }

            try {
              validateDomainEvent({ jobBefore, event, eventsBefore: existing });
            } catch (err) {
              if (err?.code === "TENANT_QUOTA_EXCEEDED") {
                return sendError(res, 429, "tenant quota exceeded", err?.quota ?? { message: err?.message }, { code: "TENANT_QUOTA_EXCEEDED" });
              }
              return sendError(res, 400, "event rejected", { message: err?.message }, { code: err?.code ?? null });
            }

            let jobAfter;
            try {
              jobAfter = reduceJob(nextEvents);
            } catch (err) {
              return sendError(res, 400, "job transition rejected", {
                name: err?.name,
                message: err?.message,
                fromStatus: err?.fromStatus,
                eventType: err?.eventType
              });
            }

            let ledgerEntries = [];
            try {
              ledgerEntries = ledgerEntriesForJobEvent({ jobBefore, event, eventsBefore: existing });
            } catch (err) {
              return sendError(res, 400, "ledger posting rejected", { message: err?.message });
            }

            const responseBody = {
              event,
              job: jobAfter,
              ledgerEntryId: ledgerEntries.length ? ledgerEntries[0]?.id ?? null : null,
              ledgerEntryIds: ledgerEntries.map((e) => e?.id).filter(Boolean)
            };

            const outboxMessages = [];
            for (const entry of ledgerEntries) {
              if (!entry) continue;
              outboxMessages.push({ type: "LEDGER_ENTRY_APPLY", tenantId, jobId, sourceEventId: event.id, entry });
            }
            if (jobBefore?.status !== jobAfter?.status) {
              outboxMessages.push({
                type: "JOB_STATUS_CHANGED",
                tenantId,
                jobId,
                fromStatus: jobBefore.status,
                toStatus: jobAfter.status,
                at: event.at
              });
            }
            if (event.type === "SETTLED") {
              outboxMessages.push({ type: "JOB_SETTLED", tenantId, jobId, settledEventId: event.id, at: event.at, sourceEventId: event.id });
            }
            if (event.type === "INCIDENT_DETECTED" || event.type === "INCIDENT_REPORTED") {
              const robotId = jobAfter.execution?.robotId ?? jobAfter.reservation?.robotId ?? jobAfter.match?.robotId ?? null;
              if (robotId) {
                outboxMessages.push({
                  type: "INCIDENT_RECORDED",
                  tenantId,
                  jobId,
                  robotId,
                  incidentId: event.payload?.incidentId ?? null,
                  incidentType: event.payload?.type ?? null,
                  severity: event.payload?.severity ?? null,
                  at: event.at,
                  sourceEventId: event.id
                });
              }
            }

	            // Proof re-evaluation: if evidence that affects proof arrives after completion, enqueue a re-eval for the completion anchor.
	            if (event.type === "ZONE_COVERAGE_REPORTED" || event.type === "INCIDENT_DETECTED" || event.type === "INCIDENT_REPORTED") {
	              if (jobAfter?.status === "COMPLETED") {
	                let completionChainHash = null;
                for (let i = nextEvents.length - 1; i >= 0; i -= 1) {
                  const e = nextEvents[i];
                  if (e?.type !== "EXECUTION_COMPLETED" && e?.type !== "JOB_EXECUTION_COMPLETED") continue;
                  if (typeof e.chainHash === "string" && e.chainHash.trim()) {
                    completionChainHash = e.chainHash;
                    break;
                  }
                }
	                if (completionChainHash) {
	                  outboxMessages.push({
	                    type: "PROOF_EVAL_ENQUEUE",
	                    tenantId,
	                    jobId,
	                    sourceEventId: event.id,
	                    evaluatedAtChainHash: completionChainHash,
	                    sourceAt: event.at ?? null
	                  });
	                }
	              }

	              // Post-settlement proof re-evaluation is governed: only allow if a dispute is open,
	              // or within the configured dispute window (if explicitly enabled).
	              if (jobAfter?.status === "SETTLED") {
	                const disputeOpen = jobAfter?.dispute?.status === "OPEN";
	                const proofPolicy = jobAfter?.booking?.policySnapshot?.proofPolicy ?? null;
	                const disputeWindowDays = Number.isSafeInteger(proofPolicy?.disputeWindowDays) ? proofPolicy.disputeWindowDays : 0;
	                const allowWindow = proofPolicy?.allowReproofAfterSettlementWithinDisputeWindow === true && disputeWindowDays > 0;
	                const settledAtMs = jobAfter?.settlement?.settledAt ? Date.parse(String(jobAfter.settlement.settledAt)) : NaN;
	                const atMs = event.at ? Date.parse(String(event.at)) : NaN;
	                const withinWindow = allowWindow && Number.isFinite(settledAtMs) && Number.isFinite(atMs) && atMs <= settledAtMs + disputeWindowDays * 24 * 60 * 60_000;

	                if (disputeOpen || withinWindow) {
	                  let completionChainHash = null;
	                  for (let i = nextEvents.length - 1; i >= 0; i -= 1) {
	                    const e = nextEvents[i];
	                    if (e?.type !== "EXECUTION_COMPLETED" && e?.type !== "JOB_EXECUTION_COMPLETED") continue;
	                    if (typeof e.chainHash === "string" && e.chainHash.trim()) {
	                      completionChainHash = e.chainHash;
	                      break;
	                    }
	                  }
	                  if (completionChainHash) {
	                    outboxMessages.push({
	                      type: "PROOF_EVAL_ENQUEUE",
	                      tenantId,
	                      jobId,
	                      sourceEventId: event.id,
	                      evaluatedAtChainHash: completionChainHash,
	                      sourceAt: event.at ?? null
	                    });
	                  }
	                } else {
	                  try {
	                    store.metrics?.incCounter?.("proof_reeval_skipped_total", { reason: "job_settled" }, 1);
	                  } catch {}
	                }
	              }
	            }

	            if (event.type === "DISPUTE_OPENED") {
	              let completionChainHash = null;
	              for (let i = nextEvents.length - 1; i >= 0; i -= 1) {
	                const e = nextEvents[i];
	                if (e?.type !== "EXECUTION_COMPLETED" && e?.type !== "JOB_EXECUTION_COMPLETED") continue;
	                if (typeof e.chainHash === "string" && e.chainHash.trim()) {
	                  completionChainHash = e.chainHash;
	                  break;
	                }
	              }
	              if (completionChainHash) {
	                outboxMessages.push({
	                  type: "PROOF_EVAL_ENQUEUE",
	                  tenantId,
	                  jobId,
	                  sourceEventId: event.id,
	                  evaluatedAtChainHash: completionChainHash,
	                  sourceAt: event.at ?? null
	                });
	              }
	            }

            const ops = [{ kind: "JOB_EVENTS_APPENDED", tenantId, jobId, events: [event] }];
            if (idemStoreKey) ops.push({ kind: "IDEMPOTENCY_PUT", key: idemStoreKey, value: { requestHash: idemRequestHash, statusCode: 201, body: responseBody } });
            if (outboxMessages.length) ops.push({ kind: "OUTBOX_ENQUEUE", messages: outboxMessages });

            await commitTx(ops);

            return sendJson(res, 201, responseBody);
          }
        }
      }

      return sendError(res, 404, "not found");
    } catch (err) {
      const statusCode = Number(err?.statusCode);
      if (Number.isInteger(statusCode) && statusCode >= 400 && statusCode < 500) {
        return sendError(res, statusCode, err?.message ?? "bad request");
      }
      return sendError(res, 500, "internal error", { message: err?.message });
    } finally {
      const statusCode = Number(res?.statusCode ?? 0);
      const durationMs = Date.now() - startedMs;
      metricInc("http_requests_total", { route, method: String(req.method ?? ""), status: String(statusCode) }, 1);

	      if (
	        req.method === "POST" &&
	        (route === "/jobs/:jobId/events" || route === "/robots/:robotId/events" || route === "/operators/:operatorId/events") &&
	        statusCode >= 400
	      ) {
	        const reason = typeof res?.__settldErrorCode === "string" && res.__settldErrorCode.trim() ? res.__settldErrorCode : "UNKNOWN";
	        metricInc("append_rejected_total", { reason }, 1);
	      }

	      if (req.method === "POST" && route === "/jobs/:jobId/events") {
	        const eventType = typeof res?.__settldEventType === "string" ? res.__settldEventType : null;
	        const reason = typeof res?.__settldErrorCode === "string" && res.__settldErrorCode.trim() ? res.__settldErrorCode : "UNKNOWN";
	        if (eventType === "SETTLED" && statusCode >= 400) metricInc("settlement_rejected_total", { reason }, 1);
	        if (eventType === "SETTLEMENT_HELD" && statusCode === 201) metricInc("settlement_held_total", {}, 1);
	        if (eventType === "SETTLEMENT_RELEASED" && statusCode === 201) metricInc("settlement_released_total", {}, 1);
	      }

      const level = logLevelForStatus(statusCode);
      logger[level]("http.request", {
        tenantId,
        principalId,
        requestId,
        route,
        method: req.method,
        path,
        statusCode,
        durationMs,
        code: res?.__settldErrorCode ?? null
      });
    }
    });
  }

  const { tickArtifacts } = createArtifactWorker({
    store,
    nowIso,
    getJobEvents,
    listDestinationsForTenant
  });
  const { tickProof } = createProofWorker({
    store,
    nowIso,
    getJobEvents,
    serverSigner,
    validateDomainEvent,
    commitTx
  });
  const { tickDeliveries } = createDeliveryWorker({
    store,
    nowIso,
    listDestinationsForTenant,
    maxAttempts: deliveryMaxAttempts,
    backoffBaseMs: deliveryBackoffBaseMs,
    backoffMaxMs: deliveryBackoffMaxMs,
    random: deliveryRandom,
    fetchFn
  });

  async function tickX402Holdbacks({ maxMessages = 100 } = {}) {
    if (!Number.isSafeInteger(maxMessages) || maxMessages <= 0) throw new TypeError("maxMessages must be a positive safe integer");
    if (!(store?.x402Gates instanceof Map)) return { ok: true, processed: 0, skipped: true, reason: "x402 gates unsupported" };
    if (typeof store.getAgentRunSettlement !== "function" || typeof store.getAgentWallet !== "function") {
      return { ok: true, processed: 0, skipped: true, reason: "store missing settlement/wallet support" };
    }

    const at = nowIso();
    const nowMs = Date.parse(at);
    const due = [];
    for (const gate of store.x402Gates.values()) {
      if (!gate || typeof gate !== "object") continue;
      const holdback = gate?.holdback;
      if (!holdback || typeof holdback !== "object") continue;
      if (String(holdback.status ?? "").toLowerCase() !== "held") continue;
      const eligibleAt = typeof holdback.releaseEligibleAt === "string" ? holdback.releaseEligibleAt : null;
      if (!eligibleAt) continue;
      const eligibleMs = Date.parse(eligibleAt);
      if (!Number.isFinite(eligibleMs)) continue;
      if (eligibleMs > nowMs) continue;
      due.push(gate);
    }
    due.sort((a, b) => String(a?.holdback?.releaseEligibleAt ?? "").localeCompare(String(b?.holdback?.releaseEligibleAt ?? "")));

    let processed = 0;
    for (const gate of due.slice(0, maxMessages)) {
      const tenantId = normalizeTenantId(gate.tenantId ?? DEFAULT_TENANT_ID);
      const gateId = String(gate.gateId ?? "");
      const holdback = gate.holdback;
      const holdbackRunId = String(holdback.runId ?? "");
      const amountCents = Number(holdback.amountCents ?? 0);
      if (!gateId || !holdbackRunId || !Number.isSafeInteger(amountCents) || amountCents <= 0) continue;

      const settlement = await store.getAgentRunSettlement({ tenantId, runId: holdbackRunId });
      if (!settlement) continue;
      if (String(settlement.status ?? "").toLowerCase() !== "locked") {
        // Ensure the gate reflects final state even if something else resolved it.
        if (String(holdback.status ?? "").toLowerCase() !== "released") {
          const nextGate = normalizeForCanonicalJson(
            {
              ...gate,
              holdback: { ...holdback, status: "released", releasedAt: settlement.resolvedAt ?? at },
              updatedAt: at
            },
            { path: "$" }
          );
          await store.commitTx({ at, ops: [{ kind: "X402_GATE_UPSERT", tenantId, gateId, gate: nextGate }] });
        }
        processed += 1;
        continue;
      }

      const payerAgentId = String(settlement.payerAgentId ?? gate.payerAgentId ?? "");
      const payeeAgentId = String(settlement.agentId ?? gate.payeeAgentId ?? "");
      if (!payerAgentId || !payeeAgentId) continue;

      const payerWalletExisting = await store.getAgentWallet({ tenantId, agentId: payerAgentId });
      const payeeWalletExisting = await store.getAgentWallet({ tenantId, agentId: payeeAgentId });
      if (!payerWalletExisting || !payeeWalletExisting) continue;

      let payerWallet = payerWalletExisting;
      let payeeWallet = payeeWalletExisting;
      try {
        const moved = releaseAgentWalletEscrowToPayee({ payerWallet, payeeWallet, amountCents, at });
        payerWallet = moved.payerWallet;
        payeeWallet = moved.payeeWallet;
      } catch (err) {
        if (err?.code === "INSUFFICIENT_ESCROW_BALANCE") continue;
        logger.error("tickX402Holdbacks.release_failed", { err, tenantId, gateId, holdbackRunId });
        continue;
      }

      const resolvedHoldbackSettlement = resolveAgentRunSettlement({
        settlement,
        status: AGENT_RUN_SETTLEMENT_STATUS.RELEASED,
        runStatus: "completed",
        releasedAmountCents: amountCents,
        refundedAmountCents: 0,
        releaseRatePct: 100,
        decisionStatus: AGENT_RUN_SETTLEMENT_DECISION_STATUS.AUTO_RESOLVED,
        decisionMode: AGENT_RUN_SETTLEMENT_DECISION_MODE.AUTOMATIC,
        decisionPolicyHash: settlement.decisionPolicyHash ?? null,
        decisionReason: "x402_holdback_auto_release",
        decisionTrace: {
          schemaVersion: "X402HoldbackDecisionTrace.v1",
          gateId,
          releasedAmountCents: amountCents,
          refundedAmountCents: 0
        },
        resolutionEventId: createId("x402hb"),
        at
      });

      const nextGate = normalizeForCanonicalJson(
        {
          ...gate,
          holdback: { ...holdback, status: "released", releasedAt: at },
          updatedAt: at
        },
        { path: "$" }
      );

      await store.commitTx({
        at,
        ops: [
          { kind: "AGENT_WALLET_UPSERT", tenantId, wallet: payerWallet },
          { kind: "AGENT_WALLET_UPSERT", tenantId, wallet: payeeWallet },
          { kind: "AGENT_RUN_SETTLEMENT_UPSERT", tenantId, runId: holdbackRunId, settlement: resolvedHoldbackSettlement },
          { kind: "X402_GATE_UPSERT", tenantId, gateId, gate: nextGate }
        ]
      });
      processed += 1;
    }

    return { ok: true, processed };
  }

  return {
    store,
    handle,
    tickLiveness,
    tickMonthClose,
    tickDispatch,
    tickOperatorQueue,
    tickRobotHealth,
    tickJobAccounting,
    tickEvidenceRetention,
    tickRetentionCleanup,
    tickFinanceReconciliation,
    tickMoneyRailReconciliation,
    tickX402Holdbacks,
    tickBillingStripeSync,
    tickProof,
    tickArtifacts,
    tickDeliveries
  };
}
